// @bun
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toCommonJS = (from) => {
  const moduleCache = __toCommonJS.moduleCache ??= new WeakMap;
  var cached = moduleCache.get(from);
  if (cached)
    return cached;
  var to = __defProp({}, "__esModule", { value: true });
  var desc = { enumerable: false };
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key))
        __defProp(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
  }
  moduleCache.set(from, to);
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = (id) => {
  return import.meta.require(id);
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// node_modules/clean-css/lib/optimizer/level-0/optimize.js
var require_optimize = __commonJS((exports, module) => {
  var level0Optimize = function(tokens) {
    return tokens;
  };
  module.exports = level0Optimize;
});

// node_modules/clean-css/lib/optimizer/level-1/shorten-hex.js
var require_shorten_hex = __commonJS((exports, module) => {
  var hexConverter = function(match, prefix, colorValue, suffix) {
    return prefix + toHex[colorValue.toLowerCase()] + suffix;
  };
  var nameConverter = function(match, colorValue, suffix) {
    return toName[colorValue.toLowerCase()] + suffix;
  };
  var shortenHex = function(value) {
    var hasHex = value.indexOf("#") > -1;
    var shortened = value.replace(toHexPattern, hexConverter);
    if (shortened != value) {
      shortened = shortened.replace(toHexPattern, hexConverter);
    }
    return hasHex ? shortened.replace(toNamePattern, nameConverter) : shortened;
  };
  var COLORS = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#0ff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000",
    blanchedalmond: "#ffebcd",
    blue: "#00f",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#0ff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#f0f",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#0f0",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#f00",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#fff",
    whitesmoke: "#f5f5f5",
    yellow: "#ff0",
    yellowgreen: "#9acd32"
  };
  var toHex = {};
  var toName = {};
  for (name in COLORS) {
    hex = COLORS[name];
    if (name.length < hex.length) {
      toName[hex] = name;
    } else {
      toHex[name] = hex;
    }
  }
  var hex;
  var name;
  var toHexPattern = new RegExp("(^| |,|\\))(" + Object.keys(toHex).join("|") + ")( |,|\\)|$)", "ig");
  var toNamePattern = new RegExp("(" + Object.keys(toName).join("|") + ")([^a-f0-9]|$)", "ig");
  module.exports = shortenHex;
});

// node_modules/clean-css/lib/optimizer/level-1/shorten-hsl.js
var require_shorten_hsl = __commonJS((exports, module) => {
  var hslToRgb = function(h, s, l) {
    var r, g, b;
    h = h % 360;
    if (h < 0)
      h += 360;
    h = ~~h / 360;
    if (s < 0)
      s = 0;
    else if (s > 100)
      s = 100;
    s = ~~s / 100;
    if (l < 0)
      l = 0;
    else if (l > 100)
      l = 100;
    l = ~~l / 100;
    if (s === 0) {
      r = g = b = l;
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hueToRgb(p, q, h + 1 / 3);
      g = hueToRgb(p, q, h);
      b = hueToRgb(p, q, h - 1 / 3);
    }
    return [~~(r * 255), ~~(g * 255), ~~(b * 255)];
  };
  var hueToRgb = function(p, q, t) {
    if (t < 0)
      t += 1;
    if (t > 1)
      t -= 1;
    if (t < 1 / 6)
      return p + (q - p) * 6 * t;
    if (t < 1 / 2)
      return q;
    if (t < 2 / 3)
      return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  };
  var shortenHsl = function(hue, saturation, lightness) {
    var asRgb = hslToRgb(hue, saturation, lightness);
    var redAsHex = asRgb[0].toString(16);
    var greenAsHex = asRgb[1].toString(16);
    var blueAsHex = asRgb[2].toString(16);
    return "#" + ((redAsHex.length == 1 ? "0" : "") + redAsHex) + ((greenAsHex.length == 1 ? "0" : "") + greenAsHex) + ((blueAsHex.length == 1 ? "0" : "") + blueAsHex);
  };
  module.exports = shortenHsl;
});

// node_modules/clean-css/lib/optimizer/level-1/shorten-rgb.js
var require_shorten_rgb = __commonJS((exports, module) => {
  var shortenRgb = function(red, green, blue) {
    var normalizedRed = Math.max(0, Math.min(parseInt(red), 255));
    var normalizedGreen = Math.max(0, Math.min(parseInt(green), 255));
    var normalizedBlue = Math.max(0, Math.min(parseInt(blue), 255));
    return "#" + ("00000" + (normalizedRed << 16 | normalizedGreen << 8 | normalizedBlue).toString(16)).slice(-6);
  };
  module.exports = shortenRgb;
});

// node_modules/clean-css/lib/utils/natural-compare.js
var require_natural_compare = __commonJS((exports, module) => {
  var naturalCompare = function(value1, value2) {
    var keys1 = ("" + value1).split(NUMBER_PATTERN).map(tryParseInt);
    var keys2 = ("" + value2).split(NUMBER_PATTERN).map(tryParseInt);
    var key1;
    var key2;
    var compareFirst = Math.min(keys1.length, keys2.length);
    var i, l;
    for (i = 0, l = compareFirst;i < l; i++) {
      key1 = keys1[i];
      key2 = keys2[i];
      if (key1 != key2) {
        return key1 > key2 ? 1 : -1;
      }
    }
    return keys1.length > keys2.length ? 1 : keys1.length == keys2.length ? 0 : -1;
  };
  var tryParseInt = function(value) {
    return "" + parseInt(value) == value ? parseInt(value) : value;
  };
  var NUMBER_PATTERN = /([0-9]+)/;
  module.exports = naturalCompare;
});

// node_modules/clean-css/lib/optimizer/level-1/sort-selectors.js
var require_sort_selectors = __commonJS((exports, module) => {
  var naturalSorter = function(scope1, scope2) {
    return naturalCompare(scope1[1], scope2[1]);
  };
  var standardSorter = function(scope1, scope2) {
    return scope1[1] > scope2[1] ? 1 : -1;
  };
  var sortSelectors = function(selectors, method) {
    switch (method) {
      case "natural":
        return selectors.sort(naturalSorter);
      case "standard":
        return selectors.sort(standardSorter);
      case "none":
      case false:
        return selectors;
    }
  };
  var naturalCompare = require_natural_compare();
  module.exports = sortSelectors;
});

// node_modules/clean-css/lib/utils/override.js
var require_override = __commonJS((exports, module) => {
  var override = function(source1, source2) {
    var target = {};
    var key1;
    var key2;
    var item;
    for (key1 in source1) {
      item = source1[key1];
      if (Array.isArray(item)) {
        target[key1] = item.slice(0);
      } else if (typeof item == "object" && item !== null) {
        target[key1] = override(item, {});
      } else {
        target[key1] = item;
      }
    }
    for (key2 in source2) {
      item = source2[key2];
      if (key2 in target && Array.isArray(item)) {
        target[key2] = item.slice(0);
      } else if (key2 in target && typeof item == "object" && item !== null) {
        target[key2] = override(target[key2], item);
      } else {
        target[key2] = item;
      }
    }
    return target;
  };
  module.exports = override;
});

// node_modules/clean-css/lib/options/format.js
var require_format = __commonJS((exports, module) => {
  var breaks = function(value) {
    var breakOptions = {};
    breakOptions[Breaks.AfterAtRule] = value;
    breakOptions[Breaks.AfterBlockBegins] = value;
    breakOptions[Breaks.AfterBlockEnds] = value;
    breakOptions[Breaks.AfterComment] = value;
    breakOptions[Breaks.AfterProperty] = value;
    breakOptions[Breaks.AfterRuleBegins] = value;
    breakOptions[Breaks.AfterRuleEnds] = value;
    breakOptions[Breaks.BeforeBlockEnds] = value;
    breakOptions[Breaks.BetweenSelectors] = value;
    return breakOptions;
  };
  var spaces = function(value) {
    var spaceOptions = {};
    spaceOptions[Spaces.AroundSelectorRelation] = value;
    spaceOptions[Spaces.BeforeBlockBegins] = value;
    spaceOptions[Spaces.BeforeValue] = value;
    return spaceOptions;
  };
  var formatFrom = function(source) {
    if (source === undefined || source === false) {
      return false;
    }
    if (typeof source == "object" && "breakWith" in source) {
      source = override(source, { breakWith: mapBreakWith(source.breakWith) });
    }
    if (typeof source == "object" && "indentBy" in source) {
      source = override(source, { indentBy: parseInt(source.indentBy) });
    }
    if (typeof source == "object" && "indentWith" in source) {
      source = override(source, { indentWith: mapIndentWith(source.indentWith) });
    }
    if (typeof source == "object") {
      return override(DEFAULTS, source);
    }
    if (typeof source == "object") {
      return override(DEFAULTS, source);
    }
    if (typeof source == "string" && source == BEAUTIFY_ALIAS) {
      return override(DEFAULTS, {
        breaks: breaks(true),
        indentBy: 2,
        spaces: spaces(true)
      });
    }
    if (typeof source == "string" && source == KEEP_BREAKS_ALIAS) {
      return override(DEFAULTS, {
        breaks: {
          afterAtRule: true,
          afterBlockBegins: true,
          afterBlockEnds: true,
          afterComment: true,
          afterRuleEnds: true,
          beforeBlockEnds: true
        }
      });
    }
    if (typeof source == "string") {
      return override(DEFAULTS, toHash(source));
    }
    return DEFAULTS;
  };
  var toHash = function(string) {
    return string.split(OPTION_SEPARATOR).reduce(function(accumulator, directive) {
      var parts = directive.split(OPTION_NAME_VALUE_SEPARATOR);
      var name = parts[0];
      var value = parts[1];
      if (name == "breaks" || name == "spaces") {
        accumulator[name] = hashValuesToHash(value);
      } else if (name == "indentBy" || name == "wrapAt") {
        accumulator[name] = parseInt(value);
      } else if (name == "indentWith") {
        accumulator[name] = mapIndentWith(value);
      } else if (name == "breakWith") {
        accumulator[name] = mapBreakWith(value);
      }
      return accumulator;
    }, {});
  };
  var hashValuesToHash = function(string) {
    return string.split(HASH_VALUES_OPTION_SEPARATOR).reduce(function(accumulator, directive) {
      var parts = directive.split(HASH_VALUES_NAME_VALUE_SEPARATOR);
      var name = parts[0];
      var value = parts[1];
      accumulator[name] = normalizeValue(value);
      return accumulator;
    }, {});
  };
  var normalizeValue = function(value) {
    switch (value) {
      case FALSE_KEYWORD_1:
      case FALSE_KEYWORD_2:
        return false;
      case TRUE_KEYWORD_1:
      case TRUE_KEYWORD_2:
        return true;
      default:
        return value;
    }
  };
  var mapBreakWith = function(value) {
    switch (value) {
      case "windows":
      case "crlf":
      case BreakWith.CarriageReturnLineFeed:
        return BreakWith.CarriageReturnLineFeed;
      case "unix":
      case "lf":
      case BreakWith.LineFeed:
        return BreakWith.LineFeed;
      default:
        return systemLineBreak;
    }
  };
  var mapIndentWith = function(value) {
    switch (value) {
      case "space":
        return IndentWith.Space;
      case "tab":
        return IndentWith.Tab;
      default:
        return value;
    }
  };
  var systemLineBreak = import.meta.require("os").EOL;
  var override = require_override();
  var Breaks = {
    AfterAtRule: "afterAtRule",
    AfterBlockBegins: "afterBlockBegins",
    AfterBlockEnds: "afterBlockEnds",
    AfterComment: "afterComment",
    AfterProperty: "afterProperty",
    AfterRuleBegins: "afterRuleBegins",
    AfterRuleEnds: "afterRuleEnds",
    BeforeBlockEnds: "beforeBlockEnds",
    BetweenSelectors: "betweenSelectors"
  };
  var BreakWith = {
    CarriageReturnLineFeed: "\r\n",
    LineFeed: "\n",
    System: systemLineBreak
  };
  var IndentWith = {
    Space: " ",
    Tab: "\t"
  };
  var Spaces = {
    AroundSelectorRelation: "aroundSelectorRelation",
    BeforeBlockBegins: "beforeBlockBegins",
    BeforeValue: "beforeValue"
  };
  var DEFAULTS = {
    breaks: breaks(false),
    breakWith: BreakWith.System,
    indentBy: 0,
    indentWith: IndentWith.Space,
    spaces: spaces(false),
    wrapAt: false,
    semicolonAfterLastProperty: false
  };
  var BEAUTIFY_ALIAS = "beautify";
  var KEEP_BREAKS_ALIAS = "keep-breaks";
  var OPTION_SEPARATOR = ";";
  var OPTION_NAME_VALUE_SEPARATOR = ":";
  var HASH_VALUES_OPTION_SEPARATOR = ",";
  var HASH_VALUES_NAME_VALUE_SEPARATOR = "=";
  var FALSE_KEYWORD_1 = "false";
  var FALSE_KEYWORD_2 = "off";
  var TRUE_KEYWORD_1 = "true";
  var TRUE_KEYWORD_2 = "on";
  module.exports = {
    Breaks,
    Spaces,
    formatFrom
  };
});

// node_modules/clean-css/lib/tokenizer/marker.js
var require_marker = __commonJS((exports, module) => {
  var Marker = {
    ASTERISK: "*",
    AT: "@",
    BACK_SLASH: "\\",
    CARRIAGE_RETURN: "\r",
    CLOSE_CURLY_BRACKET: "}",
    CLOSE_ROUND_BRACKET: ")",
    CLOSE_SQUARE_BRACKET: "]",
    COLON: ":",
    COMMA: ",",
    DOUBLE_QUOTE: '"',
    EXCLAMATION: "!",
    FORWARD_SLASH: "/",
    INTERNAL: "-clean-css-",
    NEW_LINE_NIX: "\n",
    OPEN_CURLY_BRACKET: "{",
    OPEN_ROUND_BRACKET: "(",
    OPEN_SQUARE_BRACKET: "[",
    SEMICOLON: ";",
    SINGLE_QUOTE: "\'",
    SPACE: " ",
    TAB: "\t",
    UNDERSCORE: "_"
  };
  module.exports = Marker;
});

// node_modules/clean-css/lib/utils/format-position.js
var require_format_position = __commonJS((exports, module) => {
  var formatPosition = function(metadata) {
    var line = metadata[0];
    var column = metadata[1];
    var source = metadata[2];
    return source ? source + ":" + line + ":" + column : line + ":" + column;
  };
  module.exports = formatPosition;
});

// node_modules/clean-css/lib/optimizer/level-1/tidy-rules.js
var require_tidy_rules = __commonJS((exports, module) => {
  var hasInvalidCharacters = function(value) {
    var isEscaped;
    var isInvalid = false;
    var character;
    var isQuote = false;
    var i, l;
    for (i = 0, l = value.length;i < l; i++) {
      character = value[i];
      if (isEscaped) {
      } else if (character == Marker.SINGLE_QUOTE || character == Marker.DOUBLE_QUOTE) {
        isQuote = !isQuote;
      } else if (!isQuote && (character == Marker.CLOSE_CURLY_BRACKET || character == Marker.EXCLAMATION || character == LESS_THAN || character == Marker.SEMICOLON)) {
        isInvalid = true;
        break;
      } else if (!isQuote && i === 0 && RELATION_PATTERN.test(character)) {
        isInvalid = true;
        break;
      }
      isEscaped = character == Marker.BACK_SLASH;
    }
    return isInvalid;
  };
  var removeWhitespace = function(value, format) {
    var stripped = [];
    var character;
    var isNewLineNix;
    var isNewLineWin;
    var isEscaped;
    var wasEscaped;
    var isQuoted;
    var isSingleQuoted;
    var isDoubleQuoted;
    var isAttribute;
    var isRelation;
    var isWhitespace;
    var roundBracketLevel = 0;
    var wasRelation = false;
    var wasWhitespace = false;
    var withCaseAttribute = CASE_ATTRIBUTE_PATTERN.test(value);
    var spaceAroundRelation = format && format.spaces[Spaces.AroundSelectorRelation];
    var i, l;
    for (i = 0, l = value.length;i < l; i++) {
      character = value[i];
      isNewLineNix = character == Marker.NEW_LINE_NIX;
      isNewLineWin = character == Marker.NEW_LINE_NIX && value[i - 1] == Marker.CARRIAGE_RETURN;
      isQuoted = isSingleQuoted || isDoubleQuoted;
      isRelation = !isAttribute && !isEscaped && roundBracketLevel === 0 && RELATION_PATTERN.test(character);
      isWhitespace = WHITESPACE_PATTERN.test(character);
      if (wasEscaped && isQuoted && isNewLineWin) {
        stripped.pop();
        stripped.pop();
      } else if (isEscaped && isQuoted && isNewLineNix) {
        stripped.pop();
      } else if (isEscaped) {
        stripped.push(character);
      } else if (character == Marker.OPEN_SQUARE_BRACKET && !isQuoted) {
        stripped.push(character);
        isAttribute = true;
      } else if (character == Marker.CLOSE_SQUARE_BRACKET && !isQuoted) {
        stripped.push(character);
        isAttribute = false;
      } else if (character == Marker.OPEN_ROUND_BRACKET && !isQuoted) {
        stripped.push(character);
        roundBracketLevel++;
      } else if (character == Marker.CLOSE_ROUND_BRACKET && !isQuoted) {
        stripped.push(character);
        roundBracketLevel--;
      } else if (character == Marker.SINGLE_QUOTE && !isQuoted) {
        stripped.push(character);
        isSingleQuoted = true;
      } else if (character == Marker.DOUBLE_QUOTE && !isQuoted) {
        stripped.push(character);
        isDoubleQuoted = true;
      } else if (character == Marker.SINGLE_QUOTE && isQuoted) {
        stripped.push(character);
        isSingleQuoted = false;
      } else if (character == Marker.DOUBLE_QUOTE && isQuoted) {
        stripped.push(character);
        isDoubleQuoted = false;
      } else if (isWhitespace && wasRelation && !spaceAroundRelation) {
        continue;
      } else if (!isWhitespace && wasRelation && spaceAroundRelation) {
        stripped.push(Marker.SPACE);
        stripped.push(character);
      } else if (isWhitespace && (isAttribute || roundBracketLevel > 0) && !isQuoted) {
      } else if (isWhitespace && wasWhitespace && !isQuoted) {
      } else if ((isNewLineWin || isNewLineNix) && (isAttribute || roundBracketLevel > 0) && isQuoted) {
      } else if (isRelation && wasWhitespace && !spaceAroundRelation) {
        stripped.pop();
        stripped.push(character);
      } else if (isRelation && !wasWhitespace && spaceAroundRelation) {
        stripped.push(Marker.SPACE);
        stripped.push(character);
      } else if (isWhitespace) {
        stripped.push(Marker.SPACE);
      } else {
        stripped.push(character);
      }
      wasEscaped = isEscaped;
      isEscaped = character == Marker.BACK_SLASH;
      wasRelation = isRelation;
      wasWhitespace = isWhitespace;
    }
    return withCaseAttribute ? stripped.join("").replace(CASE_RESTORE_PATTERN, "$1 $2]") : stripped.join("");
  };
  var removeQuotes = function(value) {
    if (value.indexOf("\'") == -1 && value.indexOf('"') == -1) {
      return value;
    }
    return value.replace(SINGLE_QUOTE_CASE_PATTERN, "=$1 $2").replace(SINGLE_QUOTE_PATTERN, "=$1$2").replace(DOUBLE_QUOTE_CASE_PATTERN, "=$1 $2").replace(DOUBLE_QUOTE_PATTERN, "=$1$2");
  };
  var tidyRules = function(rules, removeUnsupported, adjacentSpace, format, warnings) {
    var list = [];
    var repeated = [];
    function removeHTMLComment(rule2, match) {
      warnings.push("HTML comment \'" + match + "\' at " + formatPosition(rule2[2][0]) + ". Removing.");
      return "";
    }
    for (var i = 0, l = rules.length;i < l; i++) {
      var rule = rules[i];
      var reduced = rule[1];
      reduced = reduced.replace(HTML_COMMENT_PATTERN, removeHTMLComment.bind(null, rule));
      if (hasInvalidCharacters(reduced)) {
        warnings.push("Invalid selector \'" + rule[1] + "\' at " + formatPosition(rule[2][0]) + ". Ignoring.");
        continue;
      }
      reduced = removeWhitespace(reduced, format);
      reduced = removeQuotes(reduced);
      if (adjacentSpace && reduced.indexOf("nav") > 0) {
        reduced = reduced.replace(/\+nav(\S|$)/, "+ nav$1");
      }
      if (removeUnsupported && reduced.indexOf(ASTERISK_PLUS_HTML_HACK) > -1) {
        continue;
      }
      if (removeUnsupported && reduced.indexOf(ASTERISK_FIRST_CHILD_PLUS_HTML_HACK) > -1) {
        continue;
      }
      if (reduced.indexOf("*") > -1) {
        reduced = reduced.replace(/\*([:#\.\[])/g, "$1").replace(/^(\:first\-child)?\+html/, "*$1+html");
      }
      if (repeated.indexOf(reduced) > -1) {
        continue;
      }
      rule[1] = reduced;
      repeated.push(reduced);
      list.push(rule);
    }
    if (list.length == 1 && list[0][1].length === 0) {
      warnings.push("Empty selector \'" + list[0][1] + "\' at " + formatPosition(list[0][2][0]) + ". Ignoring.");
      list = [];
    }
    return list;
  };
  var Spaces = require_format().Spaces;
  var Marker = require_marker();
  var formatPosition = require_format_position();
  var CASE_ATTRIBUTE_PATTERN = /[\s"'][iI]\s*\]/;
  var CASE_RESTORE_PATTERN = /([\d\w])([iI])\]/g;
  var DOUBLE_QUOTE_CASE_PATTERN = /="([a-zA-Z][a-zA-Z\d\-_]+)"([iI])/g;
  var DOUBLE_QUOTE_PATTERN = /="([a-zA-Z][a-zA-Z\d\-_]+)"(\s|\])/g;
  var HTML_COMMENT_PATTERN = /^(?:(?:<!--|-->)\s*)+/;
  var SINGLE_QUOTE_CASE_PATTERN = /='([a-zA-Z][a-zA-Z\d\-_]+)'([iI])/g;
  var SINGLE_QUOTE_PATTERN = /='([a-zA-Z][a-zA-Z\d\-_]+)'(\s|\])/g;
  var RELATION_PATTERN = /[>\+~]/;
  var WHITESPACE_PATTERN = /\s/;
  var ASTERISK_PLUS_HTML_HACK = "*+html ";
  var ASTERISK_FIRST_CHILD_PLUS_HTML_HACK = "*:first-child+html ";
  var LESS_THAN = "<";
  module.exports = tidyRules;
});

// node_modules/clean-css/lib/optimizer/level-1/tidy-block.js
var require_tidy_block = __commonJS((exports, module) => {
  var tidyBlock = function(values, spaceAfterClosingBrace) {
    var withoutSpaceAfterClosingBrace;
    var i;
    for (i = values.length - 1;i >= 0; i--) {
      withoutSpaceAfterClosingBrace = !spaceAfterClosingBrace && SUPPORTED_COMPACT_BLOCK_MATCHER.test(values[i][1]);
      values[i][1] = values[i][1].replace(/\n|\r\n/g, " ").replace(/\s+/g, " ").replace(/(,|:|\() /g, "$1").replace(/ \)/g, ")").replace(/'([a-zA-Z][a-zA-Z\d\-_]+)'/, "$1").replace(/"([a-zA-Z][a-zA-Z\d\-_]+)"/, "$1").replace(withoutSpaceAfterClosingBrace ? /\) /g : null, ")");
    }
    return values;
  };
  var SUPPORTED_COMPACT_BLOCK_MATCHER = /^@media\W/;
  module.exports = tidyBlock;
});

// node_modules/clean-css/lib/optimizer/level-1/tidy-at-rule.js
var require_tidy_at_rule = __commonJS((exports, module) => {
  var tidyAtRule = function(value) {
    return value.replace(/\s+/g, " ").replace(/url\(\s+/g, "url(").replace(/\s+\)/g, ")").trim();
  };
  module.exports = tidyAtRule;
});

// node_modules/clean-css/lib/optimizer/hack.js
var require_hack = __commonJS((exports, module) => {
  var Hack = {
    ASTERISK: "asterisk",
    BANG: "bang",
    BACKSLASH: "backslash",
    UNDERSCORE: "underscore"
  };
  module.exports = Hack;
});

// node_modules/clean-css/lib/optimizer/remove-unused.js
var require_remove_unused = __commonJS((exports, module) => {
  var removeUnused = function(properties) {
    for (var i = properties.length - 1;i >= 0; i--) {
      var property = properties[i];
      if (property.unused) {
        property.all.splice(property.position, 1);
      }
    }
  };
  module.exports = removeUnused;
});

// node_modules/clean-css/lib/optimizer/restore-from-optimizing.js
var require_restore_from_optimizing = __commonJS((exports, module) => {
  var restoreFromOptimizing = function(properties, restoreCallback) {
    var property;
    var restored;
    var current;
    var i;
    for (i = properties.length - 1;i >= 0; i--) {
      property = properties[i];
      if (property.unused) {
        continue;
      }
      if (!property.dirty && !property.important && !property.hack) {
        continue;
      }
      if (restoreCallback) {
        restored = restoreCallback(property);
        property.value = restored;
      } else {
        restored = property.value;
      }
      if (property.important) {
        restoreImportant(property);
      }
      if (property.hack) {
        restoreHack(property);
      }
      if ("all" in property) {
        current = property.all[property.position];
        current[1][1] = property.name;
        current.splice(2, current.length - 1);
        Array.prototype.push.apply(current, restored);
      }
    }
  };
  var restoreImportant = function(property) {
    property.value[property.value.length - 1][1] += IMPORTANT_TOKEN;
  };
  var restoreHack = function(property) {
    if (property.hack[0] == Hack.UNDERSCORE) {
      property.name = UNDERSCORE_HACK + property.name;
    } else if (property.hack[0] == Hack.ASTERISK) {
      property.name = ASTERISK_HACK + property.name;
    } else if (property.hack[0] == Hack.BACKSLASH) {
      property.value[property.value.length - 1][1] += BACKSLASH_HACK + property.hack[1];
    } else if (property.hack[0] == Hack.BANG) {
      property.value[property.value.length - 1][1] += Marker.SPACE + BANG_HACK;
    }
  };
  var Hack = require_hack();
  var Marker = require_marker();
  var ASTERISK_HACK = "*";
  var BACKSLASH_HACK = "\\";
  var IMPORTANT_TOKEN = "!important";
  var UNDERSCORE_HACK = "_";
  var BANG_HACK = "!ie";
  module.exports = restoreFromOptimizing;
});

// node_modules/clean-css/lib/tokenizer/token.js
var require_token = __commonJS((exports, module) => {
  var Token = {
    AT_RULE: "at-rule",
    AT_RULE_BLOCK: "at-rule-block",
    AT_RULE_BLOCK_SCOPE: "at-rule-block-scope",
    COMMENT: "comment",
    NESTED_BLOCK: "nested-block",
    NESTED_BLOCK_SCOPE: "nested-block-scope",
    PROPERTY: "property",
    PROPERTY_BLOCK: "property-block",
    PROPERTY_NAME: "property-name",
    PROPERTY_VALUE: "property-value",
    RAW: "raw",
    RULE: "rule",
    RULE_SCOPE: "rule-scope"
  };
  module.exports = Token;
});

// node_modules/clean-css/lib/optimizer/wrap-for-optimizing.js
var require_wrap_for_optimizing = __commonJS((exports, module) => {
  var wrapAll = function(properties, includeVariable, skipProperties) {
    var wrapped = [];
    var single;
    var property;
    var i;
    for (i = properties.length - 1;i >= 0; i--) {
      property = properties[i];
      if (property[0] != Token.PROPERTY) {
        continue;
      }
      if (!includeVariable && someVariableReferences(property)) {
        continue;
      }
      if (skipProperties && skipProperties.indexOf(property[1][1]) > -1) {
        continue;
      }
      single = wrapSingle(property);
      single.all = properties;
      single.position = i;
      wrapped.unshift(single);
    }
    return wrapped;
  };
  var someVariableReferences = function(property) {
    var i, l;
    var value;
    for (i = 2, l = property.length;i < l; i++) {
      value = property[i];
      if (value[0] != Token.PROPERTY_VALUE) {
        continue;
      }
      if (isVariableReference(value[1])) {
        return true;
      }
    }
    return false;
  };
  var isVariableReference = function(value) {
    return Match.VARIABLE_REFERENCE_PATTERN.test(value);
  };
  var isMultiplex = function(property) {
    var value;
    var i, l;
    for (i = 3, l = property.length;i < l; i++) {
      value = property[i];
      if (value[0] == Token.PROPERTY_VALUE && (value[1] == Marker.COMMA || value[1] == Marker.FORWARD_SLASH)) {
        return true;
      }
    }
    return false;
  };
  var hackFrom = function(property) {
    var match = false;
    var name = property[1][1];
    var lastValue = property[property.length - 1];
    if (name[0] == Match.UNDERSCORE) {
      match = [Hack.UNDERSCORE];
    } else if (name[0] == Match.ASTERISK) {
      match = [Hack.ASTERISK];
    } else if (lastValue[1][0] == Match.BANG && !lastValue[1].match(Match.IMPORTANT_WORD_PATTERN)) {
      match = [Hack.BANG];
    } else if (lastValue[1].indexOf(Match.BANG) > 0 && !lastValue[1].match(Match.IMPORTANT_WORD_PATTERN) && Match.BANG_SUFFIX_PATTERN.test(lastValue[1])) {
      match = [Hack.BANG];
    } else if (lastValue[1].indexOf(Match.BACKSLASH) > 0 && lastValue[1].indexOf(Match.BACKSLASH) == lastValue[1].length - Match.BACKSLASH.length - 1) {
      match = [Hack.BACKSLASH, lastValue[1].substring(lastValue[1].indexOf(Match.BACKSLASH) + 1)];
    } else if (lastValue[1].indexOf(Match.BACKSLASH) === 0 && lastValue[1].length == 2) {
      match = [Hack.BACKSLASH, lastValue[1].substring(1)];
    }
    return match;
  };
  var isImportant = function(property) {
    if (property.length < 3)
      return false;
    var lastValue = property[property.length - 1];
    if (Match.IMPORTANT_TOKEN_PATTERN.test(lastValue[1])) {
      return true;
    } else if (Match.IMPORTANT_WORD_PATTERN.test(lastValue[1]) && Match.SUFFIX_BANG_PATTERN.test(property[property.length - 2][1])) {
      return true;
    }
    return false;
  };
  var stripImportant = function(property) {
    var lastValue = property[property.length - 1];
    var oneButLastValue = property[property.length - 2];
    if (Match.IMPORTANT_TOKEN_PATTERN.test(lastValue[1])) {
      lastValue[1] = lastValue[1].replace(Match.IMPORTANT_TOKEN_PATTERN, "");
    } else {
      lastValue[1] = lastValue[1].replace(Match.IMPORTANT_WORD_PATTERN, "");
      oneButLastValue[1] = oneButLastValue[1].replace(Match.SUFFIX_BANG_PATTERN, "");
    }
    if (lastValue[1].length === 0) {
      property.pop();
    }
    if (oneButLastValue[1].length === 0) {
      property.pop();
    }
  };
  var stripPrefixHack = function(property) {
    property[1][1] = property[1][1].substring(1);
  };
  var stripSuffixHack = function(property, hackFrom2) {
    var lastValue = property[property.length - 1];
    lastValue[1] = lastValue[1].substring(0, lastValue[1].indexOf(hackFrom2[0] == Hack.BACKSLASH ? Match.BACKSLASH : Match.BANG)).trim();
    if (lastValue[1].length === 0) {
      property.pop();
    }
  };
  var wrapSingle = function(property) {
    var importantProperty = isImportant(property);
    if (importantProperty) {
      stripImportant(property);
    }
    var whichHack = hackFrom(property);
    if (whichHack[0] == Hack.ASTERISK || whichHack[0] == Hack.UNDERSCORE) {
      stripPrefixHack(property);
    } else if (whichHack[0] == Hack.BACKSLASH || whichHack[0] == Hack.BANG) {
      stripSuffixHack(property, whichHack);
    }
    return {
      block: property[2] && property[2][0] == Token.PROPERTY_BLOCK,
      components: [],
      dirty: false,
      hack: whichHack,
      important: importantProperty,
      name: property[1][1],
      multiplex: property.length > 3 ? isMultiplex(property) : false,
      position: 0,
      shorthand: false,
      unused: false,
      value: property.slice(2)
    };
  };
  var Hack = require_hack();
  var Marker = require_marker();
  var Token = require_token();
  var Match = {
    ASTERISK: "*",
    BACKSLASH: "\\",
    BANG: "!",
    BANG_SUFFIX_PATTERN: /!\w+$/,
    IMPORTANT_TOKEN: "!important",
    IMPORTANT_TOKEN_PATTERN: new RegExp("!important$", "i"),
    IMPORTANT_WORD: "important",
    IMPORTANT_WORD_PATTERN: new RegExp("important$", "i"),
    SUFFIX_BANG_PATTERN: /!$/,
    UNDERSCORE: "_",
    VARIABLE_REFERENCE_PATTERN: /var\(--.+\)$/
  };
  module.exports = {
    all: wrapAll,
    single: wrapSingle
  };
});

// node_modules/clean-css/lib/options/rounding-precision.js
var require_rounding_precision = __commonJS((exports, module) => {
  var roundingPrecisionFrom = function(source) {
    return override(defaults2(DEFAULT_PRECISION), buildPrecisionFrom(source));
  };
  var defaults2 = function(value) {
    return {
      ch: value,
      cm: value,
      em: value,
      ex: value,
      in: value,
      mm: value,
      pc: value,
      pt: value,
      px: value,
      q: value,
      rem: value,
      vh: value,
      vmax: value,
      vmin: value,
      vw: value,
      "%": value
    };
  };
  var buildPrecisionFrom = function(source) {
    if (source === null || source === undefined) {
      return {};
    }
    if (typeof source == "boolean") {
      return {};
    }
    if (typeof source == "number" && source == -1) {
      return defaults2(DEFAULT_PRECISION);
    }
    if (typeof source == "number") {
      return defaults2(source);
    }
    if (typeof source == "string" && INTEGER_PATTERN.test(source)) {
      return defaults2(parseInt(source));
    }
    if (typeof source == "string" && source == DEFAULT_PRECISION) {
      return defaults2(DEFAULT_PRECISION);
    }
    if (typeof source == "object") {
      return source;
    }
    return source.split(DIRECTIVES_SEPARATOR).reduce(function(accumulator, directive) {
      var directiveParts = directive.split(DIRECTIVE_VALUE_SEPARATOR);
      var name = directiveParts[0];
      var value = parseInt(directiveParts[1]);
      if (isNaN(value) || value == -1) {
        value = DEFAULT_PRECISION;
      }
      if (ALL_UNITS.indexOf(name) > -1) {
        accumulator = override(accumulator, defaults2(value));
      } else {
        accumulator[name] = value;
      }
      return accumulator;
    }, {});
  };
  var override = require_override();
  var INTEGER_PATTERN = /^\d+$/;
  var ALL_UNITS = ["*", "all"];
  var DEFAULT_PRECISION = "off";
  var DIRECTIVES_SEPARATOR = ",";
  var DIRECTIVE_VALUE_SEPARATOR = "=";
  module.exports = {
    DEFAULT: DEFAULT_PRECISION,
    roundingPrecisionFrom
  };
});

// node_modules/clean-css/lib/options/optimization-level.js
var require_optimization_level = __commonJS((exports, module) => {
  var noop2 = function() {
  };
  var optimizationLevelFrom = function(source) {
    var level = override(DEFAULTS, {});
    var Zero = OptimizationLevel.Zero;
    var One = OptimizationLevel.One;
    var Two = OptimizationLevel.Two;
    if (source === undefined) {
      delete level[Two];
      return level;
    }
    if (typeof source == "string") {
      source = parseInt(source);
    }
    if (typeof source == "number" && source === parseInt(Two)) {
      return level;
    }
    if (typeof source == "number" && source === parseInt(One)) {
      delete level[Two];
      return level;
    }
    if (typeof source == "number" && source === parseInt(Zero)) {
      delete level[Two];
      delete level[One];
      return level;
    }
    if (typeof source == "object") {
      source = covertValuesToHashes(source);
    }
    if (One in source && "roundingPrecision" in source[One]) {
      source[One].roundingPrecision = roundingPrecisionFrom(source[One].roundingPrecision);
    }
    if (Two in source && "skipProperties" in source[Two] && typeof source[Two].skipProperties == "string") {
      source[Two].skipProperties = source[Two].skipProperties.split(LIST_VALUE_SEPARATOR);
    }
    if (Zero in source || One in source || Two in source) {
      level[Zero] = override(level[Zero], source[Zero]);
    }
    if (One in source && ALL_KEYWORD_1 in source[One]) {
      level[One] = override(level[One], defaults2(One, normalizeValue(source[One][ALL_KEYWORD_1])));
      delete source[One][ALL_KEYWORD_1];
    }
    if (One in source && ALL_KEYWORD_2 in source[One]) {
      level[One] = override(level[One], defaults2(One, normalizeValue(source[One][ALL_KEYWORD_2])));
      delete source[One][ALL_KEYWORD_2];
    }
    if (One in source || Two in source) {
      level[One] = override(level[One], source[One]);
    } else {
      delete level[One];
    }
    if (Two in source && ALL_KEYWORD_1 in source[Two]) {
      level[Two] = override(level[Two], defaults2(Two, normalizeValue(source[Two][ALL_KEYWORD_1])));
      delete source[Two][ALL_KEYWORD_1];
    }
    if (Two in source && ALL_KEYWORD_2 in source[Two]) {
      level[Two] = override(level[Two], defaults2(Two, normalizeValue(source[Two][ALL_KEYWORD_2])));
      delete source[Two][ALL_KEYWORD_2];
    }
    if (Two in source) {
      level[Two] = override(level[Two], source[Two]);
    } else {
      delete level[Two];
    }
    return level;
  };
  var defaults2 = function(level, value) {
    var options = override(DEFAULTS[level], {});
    var key;
    for (key in options) {
      if (typeof options[key] == "boolean") {
        options[key] = value;
      }
    }
    return options;
  };
  var normalizeValue = function(value) {
    switch (value) {
      case FALSE_KEYWORD_1:
      case FALSE_KEYWORD_2:
        return false;
      case TRUE_KEYWORD_1:
      case TRUE_KEYWORD_2:
        return true;
      default:
        return value;
    }
  };
  var covertValuesToHashes = function(source) {
    var clonedSource = override(source, {});
    var level;
    var i;
    for (i = 0;i <= 2; i++) {
      level = "" + i;
      if (level in clonedSource && (clonedSource[level] === undefined || clonedSource[level] === false)) {
        delete clonedSource[level];
      }
      if (level in clonedSource && clonedSource[level] === true) {
        clonedSource[level] = {};
      }
      if (level in clonedSource && typeof clonedSource[level] == "string") {
        clonedSource[level] = covertToHash(clonedSource[level], level);
      }
    }
    return clonedSource;
  };
  var covertToHash = function(asString, level) {
    return asString.split(OPTION_SEPARATOR).reduce(function(accumulator, directive) {
      var parts = directive.split(OPTION_VALUE_SEPARATOR);
      var name = parts[0];
      var value = parts[1];
      var normalizedValue = normalizeValue(value);
      if (ALL_KEYWORD_1 == name || ALL_KEYWORD_2 == name) {
        accumulator = override(accumulator, defaults2(level, normalizedValue));
      } else {
        accumulator[name] = normalizedValue;
      }
      return accumulator;
    }, {});
  };
  var roundingPrecisionFrom = require_rounding_precision().roundingPrecisionFrom;
  var override = require_override();
  var OptimizationLevel = {
    Zero: "0",
    One: "1",
    Two: "2"
  };
  var DEFAULTS = {};
  DEFAULTS[OptimizationLevel.Zero] = {};
  DEFAULTS[OptimizationLevel.One] = {
    cleanupCharsets: true,
    normalizeUrls: true,
    optimizeBackground: true,
    optimizeBorderRadius: true,
    optimizeFilter: true,
    optimizeFontWeight: true,
    optimizeOutline: true,
    removeEmpty: true,
    removeNegativePaddings: true,
    removeQuotes: true,
    removeWhitespace: true,
    replaceMultipleZeros: true,
    replaceTimeUnits: true,
    replaceZeroUnits: true,
    roundingPrecision: roundingPrecisionFrom(undefined),
    selectorsSortingMethod: "standard",
    specialComments: "all",
    tidyAtRules: true,
    tidyBlockScopes: true,
    tidySelectors: true,
    transform: noop2
  };
  DEFAULTS[OptimizationLevel.Two] = {
    mergeAdjacentRules: true,
    mergeIntoShorthands: true,
    mergeMedia: true,
    mergeNonAdjacentRules: true,
    mergeSemantically: false,
    overrideProperties: true,
    removeEmpty: true,
    reduceNonAdjacentRules: true,
    removeDuplicateFontRules: true,
    removeDuplicateMediaBlocks: true,
    removeDuplicateRules: true,
    removeUnusedAtRules: false,
    restructureRules: false,
    skipProperties: []
  };
  var ALL_KEYWORD_1 = "*";
  var ALL_KEYWORD_2 = "all";
  var FALSE_KEYWORD_1 = "false";
  var FALSE_KEYWORD_2 = "off";
  var TRUE_KEYWORD_1 = "true";
  var TRUE_KEYWORD_2 = "on";
  var LIST_VALUE_SEPARATOR = ",";
  var OPTION_SEPARATOR = ";";
  var OPTION_VALUE_SEPARATOR = ":";
  module.exports = {
    OptimizationLevel,
    optimizationLevelFrom
  };
});

// node_modules/clean-css/lib/utils/split.js
var require_split = __commonJS((exports, module) => {
  var split = function(value, separator) {
    var openLevel = Marker.OPEN_ROUND_BRACKET;
    var closeLevel = Marker.CLOSE_ROUND_BRACKET;
    var level = 0;
    var cursor = 0;
    var lastStart = 0;
    var lastValue;
    var lastCharacter;
    var len = value.length;
    var parts = [];
    if (value.indexOf(separator) == -1) {
      return [value];
    }
    if (value.indexOf(openLevel) == -1) {
      return value.split(separator);
    }
    while (cursor < len) {
      if (value[cursor] == openLevel) {
        level++;
      } else if (value[cursor] == closeLevel) {
        level--;
      }
      if (level === 0 && cursor > 0 && cursor + 1 < len && value[cursor] == separator) {
        parts.push(value.substring(lastStart, cursor));
        lastStart = cursor + 1;
      }
      cursor++;
    }
    if (lastStart < cursor + 1) {
      lastValue = value.substring(lastStart);
      lastCharacter = lastValue[lastValue.length - 1];
      if (lastCharacter == separator) {
        lastValue = lastValue.substring(0, lastValue.length - 1);
      }
      parts.push(lastValue);
    }
    return parts;
  };
  var Marker = require_marker();
  module.exports = split;
});

// node_modules/clean-css/lib/writer/helpers.js
var require_helpers = __commonJS((exports, module) => {
  var supportsAfterClosingBrace = function(token) {
    return token[1][1] == "background" || token[1][1] == "transform" || token[1][1] == "src";
  };
  var afterClosingBrace = function(token, valueIndex) {
    return token[valueIndex][1][token[valueIndex][1].length - 1] == Marker.CLOSE_ROUND_BRACKET;
  };
  var afterComma = function(token, valueIndex) {
    return token[valueIndex][1] == Marker.COMMA;
  };
  var afterSlash = function(token, valueIndex) {
    return token[valueIndex][1] == Marker.FORWARD_SLASH;
  };
  var beforeComma = function(token, valueIndex) {
    return token[valueIndex + 1] && token[valueIndex + 1][1] == Marker.COMMA;
  };
  var beforeSlash = function(token, valueIndex) {
    return token[valueIndex + 1] && token[valueIndex + 1][1] == Marker.FORWARD_SLASH;
  };
  var inFilter = function(token) {
    return token[1][1] == "filter" || token[1][1] == "-ms-filter";
  };
  var disallowsSpace = function(context, token, valueIndex) {
    return !context.spaceAfterClosingBrace && supportsAfterClosingBrace(token) && afterClosingBrace(token, valueIndex) || beforeSlash(token, valueIndex) || afterSlash(token, valueIndex) || beforeComma(token, valueIndex) || afterComma(token, valueIndex);
  };
  var rules = function(context, tokens) {
    var store = context.store;
    for (var i = 0, l = tokens.length;i < l; i++) {
      store(context, tokens[i]);
      if (i < l - 1) {
        store(context, comma(context));
      }
    }
  };
  var body = function(context, tokens) {
    var lastPropertyAt = lastPropertyIndex(tokens);
    for (var i = 0, l = tokens.length;i < l; i++) {
      property(context, tokens, i, lastPropertyAt);
    }
  };
  var lastPropertyIndex = function(tokens) {
    var index = tokens.length - 1;
    for (;index >= 0; index--) {
      if (tokens[index][0] != Token.COMMENT) {
        break;
      }
    }
    return index;
  };
  var property = function(context, tokens, position, lastPropertyAt) {
    var store = context.store;
    var token = tokens[position];
    var propertyValue = token[2];
    var isPropertyBlock = propertyValue && propertyValue[0] === Token.PROPERTY_BLOCK;
    var needsSemicolon;
    if (context.format) {
      if (context.format.semicolonAfterLastProperty || isPropertyBlock) {
        needsSemicolon = true;
      } else if (position < lastPropertyAt) {
        needsSemicolon = true;
      } else {
        needsSemicolon = false;
      }
    } else {
      needsSemicolon = position < lastPropertyAt || isPropertyBlock;
    }
    var isLast = position === lastPropertyAt;
    switch (token[0]) {
      case Token.AT_RULE:
        store(context, token);
        store(context, semicolon(context, Breaks.AfterProperty, false));
        break;
      case Token.AT_RULE_BLOCK:
        rules(context, token[1]);
        store(context, openBrace(context, Breaks.AfterRuleBegins, true));
        body(context, token[2]);
        store(context, closeBrace(context, Breaks.AfterRuleEnds, false, isLast));
        break;
      case Token.COMMENT:
        store(context, token);
        break;
      case Token.PROPERTY:
        store(context, token[1]);
        store(context, colon(context));
        if (propertyValue) {
          value(context, token);
        }
        store(context, needsSemicolon ? semicolon(context, Breaks.AfterProperty, isLast) : emptyCharacter);
        break;
      case Token.RAW:
        store(context, token);
    }
  };
  var value = function(context, token) {
    var store = context.store;
    var j, m;
    if (token[2][0] == Token.PROPERTY_BLOCK) {
      store(context, openBrace(context, Breaks.AfterBlockBegins, false));
      body(context, token[2][1]);
      store(context, closeBrace(context, Breaks.AfterBlockEnds, false, true));
    } else {
      for (j = 2, m = token.length;j < m; j++) {
        store(context, token[j]);
        if (j < m - 1 && (inFilter(token) || !disallowsSpace(context, token, j))) {
          store(context, Marker.SPACE);
        }
      }
    }
  };
  var allowsBreak = function(context, where) {
    return context.format && context.format.breaks[where];
  };
  var allowsSpace = function(context, where) {
    return context.format && context.format.spaces[where];
  };
  var openBrace = function(context, where, needsPrefixSpace) {
    if (context.format) {
      context.indentBy += context.format.indentBy;
      context.indentWith = context.format.indentWith.repeat(context.indentBy);
      return (needsPrefixSpace && allowsSpace(context, Spaces.BeforeBlockBegins) ? Marker.SPACE : emptyCharacter) + Marker.OPEN_CURLY_BRACKET + (allowsBreak(context, where) ? context.format.breakWith : emptyCharacter) + context.indentWith;
    } else {
      return Marker.OPEN_CURLY_BRACKET;
    }
  };
  var closeBrace = function(context, where, beforeBlockEnd, isLast) {
    if (context.format) {
      context.indentBy -= context.format.indentBy;
      context.indentWith = context.format.indentWith.repeat(context.indentBy);
      return (allowsBreak(context, Breaks.AfterProperty) || beforeBlockEnd && allowsBreak(context, Breaks.BeforeBlockEnds) ? context.format.breakWith : emptyCharacter) + context.indentWith + Marker.CLOSE_CURLY_BRACKET + (isLast ? emptyCharacter : (allowsBreak(context, where) ? context.format.breakWith : emptyCharacter) + context.indentWith);
    } else {
      return Marker.CLOSE_CURLY_BRACKET;
    }
  };
  var colon = function(context) {
    return context.format ? Marker.COLON + (allowsSpace(context, Spaces.BeforeValue) ? Marker.SPACE : emptyCharacter) : Marker.COLON;
  };
  var semicolon = function(context, where, isLast) {
    return context.format ? Marker.SEMICOLON + (isLast || !allowsBreak(context, where) ? emptyCharacter : context.format.breakWith + context.indentWith) : Marker.SEMICOLON;
  };
  var comma = function(context) {
    return context.format ? Marker.COMMA + (allowsBreak(context, Breaks.BetweenSelectors) ? context.format.breakWith : emptyCharacter) + context.indentWith : Marker.COMMA;
  };
  var all2 = function(context, tokens) {
    var store = context.store;
    var token;
    var isLast;
    var i, l;
    for (i = 0, l = tokens.length;i < l; i++) {
      token = tokens[i];
      isLast = i == l - 1;
      switch (token[0]) {
        case Token.AT_RULE:
          store(context, token);
          store(context, semicolon(context, Breaks.AfterAtRule, isLast));
          break;
        case Token.AT_RULE_BLOCK:
          rules(context, token[1]);
          store(context, openBrace(context, Breaks.AfterRuleBegins, true));
          body(context, token[2]);
          store(context, closeBrace(context, Breaks.AfterRuleEnds, false, isLast));
          break;
        case Token.NESTED_BLOCK:
          rules(context, token[1]);
          store(context, openBrace(context, Breaks.AfterBlockBegins, true));
          all2(context, token[2]);
          store(context, closeBrace(context, Breaks.AfterBlockEnds, true, isLast));
          break;
        case Token.COMMENT:
          store(context, token);
          store(context, allowsBreak(context, Breaks.AfterComment) ? context.format.breakWith : emptyCharacter);
          break;
        case Token.RAW:
          store(context, token);
          break;
        case Token.RULE:
          rules(context, token[1]);
          store(context, openBrace(context, Breaks.AfterRuleBegins, true));
          body(context, token[2]);
          store(context, closeBrace(context, Breaks.AfterRuleEnds, false, isLast));
          break;
      }
    }
  };
  var emptyCharacter = "";
  var Breaks = require_format().Breaks;
  var Spaces = require_format().Spaces;
  var Marker = require_marker();
  var Token = require_token();
  module.exports = {
    all: all2,
    body,
    property,
    rules,
    value
  };
});

// node_modules/clean-css/lib/writer/one-time.js
var require_one_time = __commonJS((exports, module) => {
  var store = function(serializeContext, token) {
    serializeContext.output.push(typeof token == "string" ? token : token[1]);
  };
  var context = function() {
    var newContext = {
      output: [],
      store
    };
    return newContext;
  };
  var all2 = function(tokens) {
    var oneTimeContext = context();
    helpers.all(oneTimeContext, tokens);
    return oneTimeContext.output.join("");
  };
  var body = function(tokens) {
    var oneTimeContext = context();
    helpers.body(oneTimeContext, tokens);
    return oneTimeContext.output.join("");
  };
  var property = function(tokens, position) {
    var oneTimeContext = context();
    helpers.property(oneTimeContext, tokens, position, true);
    return oneTimeContext.output.join("");
  };
  var rules = function(tokens) {
    var oneTimeContext = context();
    helpers.rules(oneTimeContext, tokens);
    return oneTimeContext.output.join("");
  };
  var value = function(tokens) {
    var oneTimeContext = context();
    helpers.value(oneTimeContext, tokens);
    return oneTimeContext.output.join("");
  };
  var helpers = require_helpers();
  module.exports = {
    all: all2,
    body,
    property,
    rules,
    value
  };
});

// node_modules/clean-css/lib/optimizer/level-1/optimize.js
var require_optimize2 = __commonJS((exports, module) => {
  var isLocal = function(value) {
    return LOCAL_PREFIX_PATTERN.test(value);
  };
  var isNegative = function(value) {
    return value && value[1][0] == "-" && parseFloat(value[1]) < 0;
  };
  var isQuoted = function(value) {
    return QUOTED_PATTERN.test(value);
  };
  var isUrl = function(value) {
    return URL_PREFIX_PATTERN.test(value);
  };
  var normalizeUrl = function(value) {
    return value.replace(URL_PREFIX_PATTERN, "url(").replace(/\\?\n|\\?\r\n/g, "");
  };
  var optimizeBackground = function(property) {
    var values = property.value;
    if (values.length == 1 && values[0][1] == "none") {
      values[0][1] = "0 0";
    }
    if (values.length == 1 && values[0][1] == "transparent") {
      values[0][1] = "0 0";
    }
  };
  var optimizeBorderRadius = function(property) {
    var values = property.value;
    var spliceAt;
    if (values.length == 3 && values[1][1] == "/" && values[0][1] == values[2][1]) {
      spliceAt = 1;
    } else if (values.length == 5 && values[2][1] == "/" && values[0][1] == values[3][1] && values[1][1] == values[4][1]) {
      spliceAt = 2;
    } else if (values.length == 7 && values[3][1] == "/" && values[0][1] == values[4][1] && values[1][1] == values[5][1] && values[2][1] == values[6][1]) {
      spliceAt = 3;
    } else if (values.length == 9 && values[4][1] == "/" && values[0][1] == values[5][1] && values[1][1] == values[6][1] && values[2][1] == values[7][1] && values[3][1] == values[8][1]) {
      spliceAt = 4;
    }
    if (spliceAt) {
      property.value.splice(spliceAt);
      property.dirty = true;
    }
  };
  var optimizeColors = function(name, value, compatibility) {
    if (!value.match(/#|rgb|hsl/gi)) {
      return shortenHex(value);
    }
    value = value.replace(/(rgb|hsl)a?\((\-?\d+),(\-?\d+\%?),(\-?\d+\%?),(0*[1-9]+[0-9]*(\.?\d*)?)\)/gi, function(match, colorFn, p1, p2, p3, alpha) {
      return parseInt(alpha, 10) >= 1 ? colorFn + "(" + [p1, p2, p3].join(",") + ")" : match;
    }).replace(/rgb\((\-?\d+),(\-?\d+),(\-?\d+)\)/gi, function(match, red, green, blue) {
      return shortenRgb(red, green, blue);
    }).replace(/hsl\((-?\d+),(-?\d+)%?,(-?\d+)%?\)/gi, function(match, hue, saturation, lightness) {
      return shortenHsl(hue, saturation, lightness);
    }).replace(/(^|[^='"])#([0-9a-f]{6})/gi, function(match, prefix, color, at, inputValue) {
      var suffix = inputValue[at + match.length];
      if (suffix && HEX_VALUE_PATTERN.test(suffix)) {
        return match;
      } else if (color[0] == color[1] && color[2] == color[3] && color[4] == color[5]) {
        return (prefix + "#" + color[0] + color[2] + color[4]).toLowerCase();
      } else {
        return (prefix + "#" + color).toLowerCase();
      }
    }).replace(/(^|[^='"])#([0-9a-f]{3})/gi, function(match, prefix, color) {
      return prefix + "#" + color.toLowerCase();
    }).replace(/(rgb|rgba|hsl|hsla)\(([^\)]+)\)/gi, function(match, colorFunction, colorDef) {
      var tokens = colorDef.split(",");
      var colorFnLowercase = colorFunction && colorFunction.toLowerCase();
      var applies = colorFnLowercase == "hsl" && tokens.length == 3 || colorFnLowercase == "hsla" && tokens.length == 4 || colorFnLowercase == "rgb" && tokens.length === 3 && colorDef.indexOf("%") > 0 || colorFnLowercase == "rgba" && tokens.length == 4 && colorDef.indexOf("%") > 0;
      if (!applies) {
        return match;
      }
      if (tokens[1].indexOf("%") == -1) {
        tokens[1] += "%";
      }
      if (tokens[2].indexOf("%") == -1) {
        tokens[2] += "%";
      }
      return colorFunction + "(" + tokens.join(",") + ")";
    });
    if (compatibility.colors.opacity && name.indexOf("background") == -1) {
      value = value.replace(/(?:rgba|hsla)\(0,0%?,0%?,0\)/g, function(match) {
        if (split(value, ",").pop().indexOf("gradient(") > -1) {
          return match;
        }
        return "transparent";
      });
    }
    return shortenHex(value);
  };
  var optimizeFilter = function(property) {
    if (property.value.length == 1) {
      property.value[0][1] = property.value[0][1].replace(/progid:DXImageTransform\.Microsoft\.(Alpha|Chroma)(\W)/, function(match, filter, suffix) {
        return filter.toLowerCase() + suffix;
      });
    }
    property.value[0][1] = property.value[0][1].replace(/,(\S)/g, ", $1").replace(/ ?= ?/g, "=");
  };
  var optimizeFontWeight = function(property, atIndex) {
    var value = property.value[atIndex][1];
    if (value == "normal") {
      value = "400";
    } else if (value == "bold") {
      value = "700";
    }
    property.value[atIndex][1] = value;
  };
  var optimizeMultipleZeros = function(property) {
    var values = property.value;
    var spliceAt;
    if (values.length == 4 && values[0][1] === "0" && values[1][1] === "0" && values[2][1] === "0" && values[3][1] === "0") {
      if (property.name.indexOf("box-shadow") > -1) {
        spliceAt = 2;
      } else {
        spliceAt = 1;
      }
    }
    if (spliceAt) {
      property.value.splice(spliceAt);
      property.dirty = true;
    }
  };
  var optimizeOutline = function(property) {
    var values = property.value;
    if (values.length == 1 && values[0][1] == "none") {
      values[0][1] = "0";
    }
  };
  var optimizePixelLengths = function(_, value, compatibility) {
    if (!WHOLE_PIXEL_VALUE.test(value)) {
      return value;
    }
    return value.replace(WHOLE_PIXEL_VALUE, function(match, val) {
      var newValue;
      var intVal = parseInt(val);
      if (intVal === 0) {
        return match;
      }
      if (compatibility.properties.shorterLengthUnits && compatibility.units.pt && intVal * 3 % 4 === 0) {
        newValue = intVal * 3 / 4 + "pt";
      }
      if (compatibility.properties.shorterLengthUnits && compatibility.units.pc && intVal % 16 === 0) {
        newValue = intVal / 16 + "pc";
      }
      if (compatibility.properties.shorterLengthUnits && compatibility.units.in && intVal % 96 === 0) {
        newValue = intVal / 96 + "in";
      }
      if (newValue) {
        newValue = match.substring(0, match.indexOf(val)) + newValue;
      }
      return newValue && newValue.length < match.length ? newValue : match;
    });
  };
  var optimizePrecision = function(_, value, precisionOptions) {
    if (!precisionOptions.enabled || value.indexOf(".") === -1) {
      return value;
    }
    return value.replace(precisionOptions.decimalPointMatcher, "$1$2$3").replace(precisionOptions.zeroMatcher, function(match, integerPart, fractionPart, unit) {
      var multiplier = precisionOptions.units[unit].multiplier;
      var parsedInteger = parseInt(integerPart);
      var integer = isNaN(parsedInteger) ? 0 : parsedInteger;
      var fraction = parseFloat(fractionPart);
      return Math.round((integer + fraction) * multiplier) / multiplier + unit;
    });
  };
  var optimizeTimeUnits = function(_, value) {
    if (!TIME_VALUE.test(value))
      return value;
    return value.replace(TIME_VALUE, function(match, val, unit) {
      var newValue;
      if (unit == "ms") {
        newValue = parseInt(val) / 1000 + "s";
      } else if (unit == "s") {
        newValue = parseFloat(val) * 1000 + "ms";
      }
      return newValue.length < match.length ? newValue : match;
    });
  };
  var optimizeUnits = function(name, value, unitsRegexp) {
    if (/^(?:\-moz\-calc|\-webkit\-calc|calc|rgb|hsl|rgba|hsla)\(/.test(value)) {
      return value;
    }
    if (name == "flex" || name == "-ms-flex" || name == "-webkit-flex" || name == "flex-basis" || name == "-webkit-flex-basis") {
      return value;
    }
    if (value.indexOf("%") > 0 && (name == "height" || name == "max-height" || name == "width" || name == "max-width")) {
      return value;
    }
    return value.replace(unitsRegexp, "$10$2").replace(unitsRegexp, "$10$2");
  };
  var optimizeWhitespace = function(name, value) {
    if (name.indexOf("filter") > -1 || value.indexOf(" ") == -1 || value.indexOf("expression") === 0) {
      return value;
    }
    if (value.indexOf(Marker.SINGLE_QUOTE) > -1 || value.indexOf(Marker.DOUBLE_QUOTE) > -1) {
      return value;
    }
    value = value.replace(/\s+/g, " ");
    if (value.indexOf("calc") > -1) {
      value = value.replace(/\) ?\/ ?/g, ")/ ");
    }
    return value.replace(/(\(;?)\s+/g, "$1").replace(/\s+(;?\))/g, "$1").replace(/, /g, ",");
  };
  var optimizeZeroDegUnit = function(_, value) {
    if (value.indexOf("0deg") == -1) {
      return value;
    }
    return value.replace(/\(0deg\)/g, "(0)");
  };
  var optimizeZeroUnits = function(name, value) {
    if (value.indexOf("0") == -1) {
      return value;
    }
    if (value.indexOf("-") > -1) {
      value = value.replace(/([^\w\d\-]|^)\-0([^\.]|$)/g, "$10$2").replace(/([^\w\d\-]|^)\-0([^\.]|$)/g, "$10$2");
    }
    return value.replace(/(^|\s)0+([1-9])/g, "$1$2").replace(/(^|\D)\.0+(\D|$)/g, "$10$2").replace(/(^|\D)\.0+(\D|$)/g, "$10$2").replace(/\.([1-9]*)0+(\D|$)/g, function(match, nonZeroPart, suffix) {
      return (nonZeroPart.length > 0 ? "." : "") + nonZeroPart + suffix;
    }).replace(/(^|\D)0\.(\d)/g, "$1.$2");
  };
  var removeQuotes = function(name, value) {
    if (name == "content" || name.indexOf("font-variation-settings") > -1 || name.indexOf("font-feature-settings") > -1 || name == "grid" || name.indexOf("grid-") > -1) {
      return value;
    }
    return QUOTED_BUT_SAFE_PATTERN.test(value) ? value.substring(1, value.length - 1) : value;
  };
  var removeUrlQuotes = function(value) {
    return /^url\(['"].+['"]\)$/.test(value) && !/^url\(['"].*[\*\s\(\)'"].*['"]\)$/.test(value) && !/^url\(['"]data:[^;]+;charset/.test(value) ? value.replace(/["']/g, "") : value;
  };
  var transformValue = function(propertyName, propertyValue, rule, transformCallback) {
    var selector = serializeRules(rule);
    var transformedValue = transformCallback(propertyName, propertyValue, selector);
    if (transformedValue === undefined) {
      return propertyValue;
    } else if (transformedValue === false) {
      return IgnoreProperty;
    } else {
      return transformedValue;
    }
  };
  var optimizeBody = function(rule, properties, context) {
    var options = context.options;
    var levelOptions = options.level[OptimizationLevel.One];
    var property, name, type, value;
    var valueIsUrl;
    var propertyToken;
    var _properties = wrapForOptimizing(properties, true);
    propertyLoop:
      for (var i = 0, l = _properties.length;i < l; i++) {
        property = _properties[i];
        name = property.name;
        if (!PROPERTY_NAME_PATTERN.test(name)) {
          propertyToken = property.all[property.position];
          context.warnings.push("Invalid property name \'" + name + "\' at " + formatPosition(propertyToken[1][2][0]) + ". Ignoring.");
          property.unused = true;
        }
        if (property.value.length === 0) {
          propertyToken = property.all[property.position];
          context.warnings.push("Empty property \'" + name + "\' at " + formatPosition(propertyToken[1][2][0]) + ". Ignoring.");
          property.unused = true;
        }
        if (property.hack && ((property.hack[0] == Hack.ASTERISK || property.hack[0] == Hack.UNDERSCORE) && !options.compatibility.properties.iePrefixHack || property.hack[0] == Hack.BACKSLASH && !options.compatibility.properties.ieSuffixHack || property.hack[0] == Hack.BANG && !options.compatibility.properties.ieBangHack)) {
          property.unused = true;
        }
        if (levelOptions.removeNegativePaddings && name.indexOf("padding") === 0 && (isNegative(property.value[0]) || isNegative(property.value[1]) || isNegative(property.value[2]) || isNegative(property.value[3]))) {
          property.unused = true;
        }
        if (!options.compatibility.properties.ieFilters && isLegacyFilter(property)) {
          property.unused = true;
        }
        if (property.unused) {
          continue;
        }
        if (property.block) {
          optimizeBody(rule, property.value[0][1], context);
          continue;
        }
        if (VARIABLE_NAME_PATTERN.test(name)) {
          continue;
        }
        for (var j = 0, m = property.value.length;j < m; j++) {
          type = property.value[j][0];
          value = property.value[j][1];
          valueIsUrl = isUrl(value);
          if (type == Token.PROPERTY_BLOCK) {
            property.unused = true;
            context.warnings.push("Invalid value token at " + formatPosition(value[0][1][2][0]) + ". Ignoring.");
            break;
          }
          if (valueIsUrl && !context.validator.isUrl(value)) {
            property.unused = true;
            context.warnings.push("Broken URL \'" + value + "\' at " + formatPosition(property.value[j][2][0]) + ". Ignoring.");
            break;
          }
          if (valueIsUrl) {
            value = levelOptions.normalizeUrls ? normalizeUrl(value) : value;
            value = !options.compatibility.properties.urlQuotes ? removeUrlQuotes(value) : value;
          } else if (isQuoted(value) || isLocal(value)) {
            value = levelOptions.removeQuotes ? removeQuotes(name, value) : value;
          } else {
            value = levelOptions.removeWhitespace ? optimizeWhitespace(name, value) : value;
            value = optimizePrecision(name, value, options.precision);
            value = optimizePixelLengths(name, value, options.compatibility);
            value = levelOptions.replaceTimeUnits ? optimizeTimeUnits(name, value) : value;
            value = levelOptions.replaceZeroUnits ? optimizeZeroUnits(name, value) : value;
            if (options.compatibility.properties.zeroUnits) {
              value = optimizeZeroDegUnit(name, value);
              value = optimizeUnits(name, value, options.unitsRegexp);
            }
            if (options.compatibility.properties.colors) {
              value = optimizeColors(name, value, options.compatibility);
            }
          }
          value = transformValue(name, value, rule, levelOptions.transform);
          if (value === IgnoreProperty) {
            property.unused = true;
            continue propertyLoop;
          }
          property.value[j][1] = value;
        }
        if (levelOptions.replaceMultipleZeros) {
          optimizeMultipleZeros(property);
        }
        if (name == "background" && levelOptions.optimizeBackground) {
          optimizeBackground(property);
        } else if (name.indexOf("border") === 0 && name.indexOf("radius") > 0 && levelOptions.optimizeBorderRadius) {
          optimizeBorderRadius(property);
        } else if (name == "filter" && levelOptions.optimizeFilter && options.compatibility.properties.ieFilters) {
          optimizeFilter(property);
        } else if (name == "font-weight" && levelOptions.optimizeFontWeight) {
          optimizeFontWeight(property, 0);
        } else if (name == "outline" && levelOptions.optimizeOutline) {
          optimizeOutline(property);
        }
      }
    restoreFromOptimizing(_properties);
    removeUnused(_properties);
    removeComments(properties, options);
  };
  var removeComments = function(tokens, options) {
    var token;
    var i;
    for (i = 0;i < tokens.length; i++) {
      token = tokens[i];
      if (token[0] != Token.COMMENT) {
        continue;
      }
      optimizeComment(token, options);
      if (token[1].length === 0) {
        tokens.splice(i, 1);
        i--;
      }
    }
  };
  var optimizeComment = function(token, options) {
    if (token[1][2] == Marker.EXCLAMATION && (options.level[OptimizationLevel.One].specialComments == "all" || options.commentsKept < options.level[OptimizationLevel.One].specialComments)) {
      options.commentsKept++;
      return;
    }
    token[1] = [];
  };
  var cleanupCharsets = function(tokens) {
    var hasCharset = false;
    for (var i = 0, l = tokens.length;i < l; i++) {
      var token = tokens[i];
      if (token[0] != Token.AT_RULE)
        continue;
      if (!CHARSET_REGEXP.test(token[1]))
        continue;
      if (hasCharset || token[1].indexOf(CHARSET_TOKEN) == -1) {
        tokens.splice(i, 1);
        i--;
        l--;
      } else {
        hasCharset = true;
        tokens.splice(i, 1);
        tokens.unshift([Token.AT_RULE, token[1].replace(CHARSET_REGEXP, CHARSET_TOKEN)]);
      }
    }
  };
  var buildUnitRegexp = function(options) {
    var units = ["px", "em", "ex", "cm", "mm", "in", "pt", "pc", "%"];
    var otherUnits = ["ch", "rem", "vh", "vm", "vmax", "vmin", "vw"];
    otherUnits.forEach(function(unit) {
      if (options.compatibility.units[unit]) {
        units.push(unit);
      }
    });
    return new RegExp("(^|\\s|\\(|,)0(?:" + units.join("|") + ")(\\W|$)", "g");
  };
  var buildPrecisionOptions = function(roundingPrecision) {
    var precisionOptions = {
      matcher: null,
      units: {}
    };
    var optimizable = [];
    var unit;
    var value;
    for (unit in roundingPrecision) {
      value = roundingPrecision[unit];
      if (value != DEFAULT_ROUNDING_PRECISION) {
        precisionOptions.units[unit] = {};
        precisionOptions.units[unit].value = value;
        precisionOptions.units[unit].multiplier = Math.pow(10, value);
        optimizable.push(unit);
      }
    }
    if (optimizable.length > 0) {
      precisionOptions.enabled = true;
      precisionOptions.decimalPointMatcher = new RegExp("(\\d)\\.($|" + optimizable.join("|") + ")($|\\W)", "g");
      precisionOptions.zeroMatcher = new RegExp("(\\d*)(\\.\\d+)(" + optimizable.join("|") + ")", "g");
    }
    return precisionOptions;
  };
  var isImport = function(token) {
    return IMPORT_PREFIX_PATTERN.test(token[1]);
  };
  var isLegacyFilter = function(property) {
    var value;
    if (property.name == "filter" || property.name == "-ms-filter") {
      value = property.value[0][1];
      return value.indexOf("progid") > -1 || value.indexOf("alpha") === 0 || value.indexOf("chroma") === 0;
    } else {
      return false;
    }
  };
  var level1Optimize = function(tokens, context) {
    var options = context.options;
    var levelOptions = options.level[OptimizationLevel.One];
    var ie7Hack = options.compatibility.selectors.ie7Hack;
    var adjacentSpace = options.compatibility.selectors.adjacentSpace;
    var spaceAfterClosingBrace = options.compatibility.properties.spaceAfterClosingBrace;
    var format = options.format;
    var mayHaveCharset = false;
    var afterRules = false;
    options.unitsRegexp = options.unitsRegexp || buildUnitRegexp(options);
    options.precision = options.precision || buildPrecisionOptions(levelOptions.roundingPrecision);
    options.commentsKept = options.commentsKept || 0;
    for (var i = 0, l = tokens.length;i < l; i++) {
      var token = tokens[i];
      switch (token[0]) {
        case Token.AT_RULE:
          token[1] = isImport(token) && afterRules ? "" : token[1];
          token[1] = levelOptions.tidyAtRules ? tidyAtRule(token[1]) : token[1];
          mayHaveCharset = true;
          break;
        case Token.AT_RULE_BLOCK:
          optimizeBody(token[1], token[2], context);
          afterRules = true;
          break;
        case Token.NESTED_BLOCK:
          token[1] = levelOptions.tidyBlockScopes ? tidyBlock(token[1], spaceAfterClosingBrace) : token[1];
          level1Optimize(token[2], context);
          afterRules = true;
          break;
        case Token.COMMENT:
          optimizeComment(token, options);
          break;
        case Token.RULE:
          token[1] = levelOptions.tidySelectors ? tidyRules(token[1], !ie7Hack, adjacentSpace, format, context.warnings) : token[1];
          token[1] = token[1].length > 1 ? sortSelectors(token[1], levelOptions.selectorsSortingMethod) : token[1];
          optimizeBody(token[1], token[2], context);
          afterRules = true;
          break;
      }
      if (token[0] == Token.COMMENT && token[1].length === 0 || levelOptions.removeEmpty && (token[1].length === 0 || token[2] && token[2].length === 0)) {
        tokens.splice(i, 1);
        i--;
        l--;
      }
    }
    if (levelOptions.cleanupCharsets && mayHaveCharset) {
      cleanupCharsets(tokens);
    }
    return tokens;
  };
  var shortenHex = require_shorten_hex();
  var shortenHsl = require_shorten_hsl();
  var shortenRgb = require_shorten_rgb();
  var sortSelectors = require_sort_selectors();
  var tidyRules = require_tidy_rules();
  var tidyBlock = require_tidy_block();
  var tidyAtRule = require_tidy_at_rule();
  var Hack = require_hack();
  var removeUnused = require_remove_unused();
  var restoreFromOptimizing = require_restore_from_optimizing();
  var wrapForOptimizing = require_wrap_for_optimizing().all;
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  var Token = require_token();
  var Marker = require_marker();
  var formatPosition = require_format_position();
  var split = require_split();
  var serializeRules = require_one_time().rules;
  var IgnoreProperty = "ignore-property";
  var CHARSET_TOKEN = "@charset";
  var CHARSET_REGEXP = new RegExp("^" + CHARSET_TOKEN, "i");
  var DEFAULT_ROUNDING_PRECISION = require_rounding_precision().DEFAULT;
  var WHOLE_PIXEL_VALUE = /(?:^|\s|\()(-?\d+)px/;
  var TIME_VALUE = /^(\-?[\d\.]+)(m?s)$/;
  var HEX_VALUE_PATTERN = /[0-9a-f]/i;
  var PROPERTY_NAME_PATTERN = /^(?:\-chrome\-|\-[\w\-]+\w|\w[\w\-]+\w|\-\-\S+)$/;
  var IMPORT_PREFIX_PATTERN = /^@import/i;
  var QUOTED_PATTERN = /^('.*'|".*")$/;
  var QUOTED_BUT_SAFE_PATTERN = /^['"][a-zA-Z][a-zA-Z\d\-_]+['"]$/;
  var URL_PREFIX_PATTERN = /^url\(/i;
  var LOCAL_PREFIX_PATTERN = /^local\(/i;
  var VARIABLE_NAME_PATTERN = /^--\S+$/;
  module.exports = level1Optimize;
});

// node_modules/clean-css/lib/optimizer/level-2/is-mergeable.js
var require_is_mergeable = __commonJS((exports, module) => {
  var isMergeable = function(selector, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) {
    var singleSelectors = split(selector, Marker.COMMA);
    var singleSelector;
    var i, l;
    for (i = 0, l = singleSelectors.length;i < l; i++) {
      singleSelector = singleSelectors[i];
      if (singleSelector.length === 0 || isDeepSelector(singleSelector) || singleSelector.indexOf(Marker.COLON) > -1 && !areMergeable(singleSelector, extractPseudoFrom(singleSelector), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging)) {
        return false;
      }
    }
    return true;
  };
  var isDeepSelector = function(selector) {
    return DEEP_SELECTOR_PATTERN.test(selector);
  };
  var extractPseudoFrom = function(selector) {
    var list = [];
    var character;
    var buffer = [];
    var level = Level.ROOT;
    var roundBracketLevel = 0;
    var isQuoted;
    var isEscaped;
    var isPseudo = false;
    var isRelation;
    var wasColon = false;
    var index;
    var len;
    for (index = 0, len = selector.length;index < len; index++) {
      character = selector[index];
      isRelation = !isEscaped && RELATION_PATTERN.test(character);
      isQuoted = level == Level.DOUBLE_QUOTE || level == Level.SINGLE_QUOTE;
      if (isEscaped) {
        buffer.push(character);
      } else if (character == Marker.DOUBLE_QUOTE && level == Level.ROOT) {
        buffer.push(character);
        level = Level.DOUBLE_QUOTE;
      } else if (character == Marker.DOUBLE_QUOTE && level == Level.DOUBLE_QUOTE) {
        buffer.push(character);
        level = Level.ROOT;
      } else if (character == Marker.SINGLE_QUOTE && level == Level.ROOT) {
        buffer.push(character);
        level = Level.SINGLE_QUOTE;
      } else if (character == Marker.SINGLE_QUOTE && level == Level.SINGLE_QUOTE) {
        buffer.push(character);
        level = Level.ROOT;
      } else if (isQuoted) {
        buffer.push(character);
      } else if (character == Marker.OPEN_ROUND_BRACKET) {
        buffer.push(character);
        roundBracketLevel++;
      } else if (character == Marker.CLOSE_ROUND_BRACKET && roundBracketLevel == 1 && isPseudo) {
        buffer.push(character);
        list.push(buffer.join(""));
        roundBracketLevel--;
        buffer = [];
        isPseudo = false;
      } else if (character == Marker.CLOSE_ROUND_BRACKET) {
        buffer.push(character);
        roundBracketLevel--;
      } else if (character == Marker.COLON && roundBracketLevel === 0 && isPseudo && !wasColon) {
        list.push(buffer.join(""));
        buffer = [];
        buffer.push(character);
      } else if (character == Marker.COLON && roundBracketLevel === 0 && !wasColon) {
        buffer = [];
        buffer.push(character);
        isPseudo = true;
      } else if (character == Marker.SPACE && roundBracketLevel === 0 && isPseudo) {
        list.push(buffer.join(""));
        buffer = [];
        isPseudo = false;
      } else if (isRelation && roundBracketLevel === 0 && isPseudo) {
        list.push(buffer.join(""));
        buffer = [];
        isPseudo = false;
      } else {
        buffer.push(character);
      }
      isEscaped = character == Marker.BACK_SLASH;
      wasColon = character == Marker.COLON;
    }
    if (buffer.length > 0 && isPseudo) {
      list.push(buffer.join(""));
    }
    return list;
  };
  var areMergeable = function(selector, matches, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) {
    return areAllowed(matches, mergeablePseudoClasses, mergeablePseudoElements) && needArguments(matches) && (matches.length < 2 || !someIncorrectlyChained(selector, matches)) && (matches.length < 2 || multiplePseudoMerging && allMixable(matches));
  };
  var areAllowed = function(matches, mergeablePseudoClasses, mergeablePseudoElements) {
    var match;
    var name;
    var i, l;
    for (i = 0, l = matches.length;i < l; i++) {
      match = matches[i];
      name = match.indexOf(Marker.OPEN_ROUND_BRACKET) > -1 ? match.substring(0, match.indexOf(Marker.OPEN_ROUND_BRACKET)) : match;
      if (mergeablePseudoClasses.indexOf(name) === -1 && mergeablePseudoElements.indexOf(name) === -1) {
        return false;
      }
    }
    return true;
  };
  var needArguments = function(matches) {
    var match;
    var name;
    var bracketOpensAt;
    var hasArguments;
    var i, l;
    for (i = 0, l = matches.length;i < l; i++) {
      match = matches[i];
      bracketOpensAt = match.indexOf(Marker.OPEN_ROUND_BRACKET);
      hasArguments = bracketOpensAt > -1;
      name = hasArguments ? match.substring(0, bracketOpensAt) : match;
      if (hasArguments && PSEUDO_CLASSES_WITH_ARGUMENTS.indexOf(name) == -1) {
        return false;
      }
      if (!hasArguments && PSEUDO_CLASSES_WITH_ARGUMENTS.indexOf(name) > -1) {
        return false;
      }
    }
    return true;
  };
  var someIncorrectlyChained = function(selector, matches) {
    var positionInSelector = 0;
    var match;
    var matchAt;
    var nextMatch;
    var nextMatchAt;
    var name;
    var nextName;
    var areChained;
    var i, l;
    for (i = 0, l = matches.length;i < l; i++) {
      match = matches[i];
      nextMatch = matches[i + 1];
      if (!nextMatch) {
        break;
      }
      matchAt = selector.indexOf(match, positionInSelector);
      nextMatchAt = selector.indexOf(match, matchAt + 1);
      positionInSelector = nextMatchAt;
      areChained = matchAt + match.length == nextMatchAt;
      if (areChained) {
        name = match.indexOf(Marker.OPEN_ROUND_BRACKET) > -1 ? match.substring(0, match.indexOf(Marker.OPEN_ROUND_BRACKET)) : match;
        nextName = nextMatch.indexOf(Marker.OPEN_ROUND_BRACKET) > -1 ? nextMatch.substring(0, nextMatch.indexOf(Marker.OPEN_ROUND_BRACKET)) : nextMatch;
        if (name != NOT_PSEUDO || nextName != NOT_PSEUDO) {
          return true;
        }
      }
    }
    return false;
  };
  var allMixable = function(matches) {
    var unmixableMatches = 0;
    var match;
    var i, l;
    for (i = 0, l = matches.length;i < l; i++) {
      match = matches[i];
      if (isPseudoElement(match)) {
        unmixableMatches += UNMIXABLE_PSEUDO_ELEMENTS.indexOf(match) > -1 ? 1 : 0;
      } else {
        unmixableMatches += UNMIXABLE_PSEUDO_CLASSES.indexOf(match) > -1 ? 1 : 0;
      }
      if (unmixableMatches > 1) {
        return false;
      }
    }
    return true;
  };
  var isPseudoElement = function(pseudo) {
    return DOUBLE_COLON_PATTERN.test(pseudo);
  };
  var Marker = require_marker();
  var split = require_split();
  var DEEP_SELECTOR_PATTERN = /\/deep\//;
  var DOUBLE_COLON_PATTERN = /^::/;
  var NOT_PSEUDO = ":not";
  var PSEUDO_CLASSES_WITH_ARGUMENTS = [
    ":dir",
    ":lang",
    ":not",
    ":nth-child",
    ":nth-last-child",
    ":nth-last-of-type",
    ":nth-of-type"
  ];
  var RELATION_PATTERN = /[>\+~]/;
  var UNMIXABLE_PSEUDO_CLASSES = [
    ":after",
    ":before",
    ":first-letter",
    ":first-line",
    ":lang"
  ];
  var UNMIXABLE_PSEUDO_ELEMENTS = [
    "::after",
    "::before",
    "::first-letter",
    "::first-line"
  ];
  var Level = {
    DOUBLE_QUOTE: "double-quote",
    SINGLE_QUOTE: "single-quote",
    ROOT: "root"
  };
  module.exports = isMergeable;
});

// node_modules/clean-css/lib/optimizer/level-2/properties/every-values-pair.js
var require_every_values_pair = __commonJS((exports, module) => {
  var everyValuesPair = function(fn, left, right) {
    var leftSize = left.value.length;
    var rightSize = right.value.length;
    var total = Math.max(leftSize, rightSize);
    var lowerBound = Math.min(leftSize, rightSize) - 1;
    var leftValue;
    var rightValue;
    var position;
    for (position = 0;position < total; position++) {
      leftValue = left.value[position] && left.value[position][1] || leftValue;
      rightValue = right.value[position] && right.value[position][1] || rightValue;
      if (leftValue == Marker.COMMA || rightValue == Marker.COMMA) {
        continue;
      }
      if (!fn(leftValue, rightValue, position, position <= lowerBound)) {
        return false;
      }
    }
    return true;
  };
  var Marker = require_marker();
  module.exports = everyValuesPair;
});

// node_modules/clean-css/lib/optimizer/level-2/properties/has-inherit.js
var require_has_inherit = __commonJS((exports, module) => {
  var hasInherit = function(property) {
    for (var i = property.value.length - 1;i >= 0; i--) {
      if (property.value[i][1] == "inherit")
        return true;
    }
    return false;
  };
  module.exports = hasInherit;
});

// node_modules/clean-css/lib/optimizer/level-2/invalid-property-error.js
var require_invalid_property_error = __commonJS((exports, module) => {
  var InvalidPropertyError = function(message) {
    this.name = "InvalidPropertyError";
    this.message = message;
    this.stack = new Error().stack;
  };
  InvalidPropertyError.prototype = Object.create(Error.prototype);
  InvalidPropertyError.prototype.constructor = InvalidPropertyError;
  module.exports = InvalidPropertyError;
});

// node_modules/clean-css/lib/optimizer/level-2/break-up.js
var require_break_up = __commonJS((exports, module) => {
  var _anyIsInherit = function(values) {
    var i, l;
    for (i = 0, l = values.length;i < l; i++) {
      if (values[i][1] == "inherit") {
        return true;
      }
    }
    return false;
  };
  var _colorFilter = function(validator) {
    return function(value) {
      return value[1] == "invert" || validator.isColor(value[1]) || validator.isPrefixed(value[1]);
    };
  };
  var _styleFilter = function(validator) {
    return function(value) {
      return value[1] != "inherit" && validator.isStyleKeyword(value[1]) && !validator.isColorFunction(value[1]);
    };
  };
  var _wrapDefault = function(name, property, compactable) {
    var descriptor = compactable[name];
    if (descriptor.doubleValues && descriptor.defaultValue.length == 2) {
      return wrapSingle([
        Token.PROPERTY,
        [Token.PROPERTY_NAME, name],
        [Token.PROPERTY_VALUE, descriptor.defaultValue[0]],
        [Token.PROPERTY_VALUE, descriptor.defaultValue[1]]
      ]);
    } else if (descriptor.doubleValues && descriptor.defaultValue.length == 1) {
      return wrapSingle([
        Token.PROPERTY,
        [Token.PROPERTY_NAME, name],
        [Token.PROPERTY_VALUE, descriptor.defaultValue[0]]
      ]);
    } else {
      return wrapSingle([
        Token.PROPERTY,
        [Token.PROPERTY_NAME, name],
        [Token.PROPERTY_VALUE, descriptor.defaultValue]
      ]);
    }
  };
  var _widthFilter = function(validator) {
    return function(value) {
      return value[1] != "inherit" && (validator.isWidth(value[1]) || validator.isUnit(value[1]) && !validator.isDynamicUnit(value[1])) && !validator.isStyleKeyword(value[1]) && !validator.isColorFunction(value[1]);
    };
  };
  var animation = function(property, compactable, validator) {
    var duration = _wrapDefault(property.name + "-duration", property, compactable);
    var timing = _wrapDefault(property.name + "-timing-function", property, compactable);
    var delay = _wrapDefault(property.name + "-delay", property, compactable);
    var iteration = _wrapDefault(property.name + "-iteration-count", property, compactable);
    var direction = _wrapDefault(property.name + "-direction", property, compactable);
    var fill = _wrapDefault(property.name + "-fill-mode", property, compactable);
    var play = _wrapDefault(property.name + "-play-state", property, compactable);
    var name = _wrapDefault(property.name + "-name", property, compactable);
    var components = [duration, timing, delay, iteration, direction, fill, play, name];
    var values = property.value;
    var value;
    var durationSet = false;
    var timingSet = false;
    var delaySet = false;
    var iterationSet = false;
    var directionSet = false;
    var fillSet = false;
    var playSet = false;
    var nameSet = false;
    var i;
    var l;
    if (property.value.length == 1 && property.value[0][1] == "inherit") {
      duration.value = timing.value = delay.value = iteration.value = direction.value = fill.value = play.value = name.value = property.value;
      return components;
    }
    if (values.length > 1 && _anyIsInherit(values)) {
      throw new InvalidPropertyError("Invalid animation values at " + formatPosition(values[0][2][0]) + ". Ignoring.");
    }
    for (i = 0, l = values.length;i < l; i++) {
      value = values[i];
      if (validator.isTime(value[1]) && !durationSet) {
        duration.value = [value];
        durationSet = true;
      } else if (validator.isTime(value[1]) && !delaySet) {
        delay.value = [value];
        delaySet = true;
      } else if ((validator.isGlobal(value[1]) || validator.isTimingFunction(value[1])) && !timingSet) {
        timing.value = [value];
        timingSet = true;
      } else if ((validator.isAnimationIterationCountKeyword(value[1]) || validator.isPositiveNumber(value[1])) && !iterationSet) {
        iteration.value = [value];
        iterationSet = true;
      } else if (validator.isAnimationDirectionKeyword(value[1]) && !directionSet) {
        direction.value = [value];
        directionSet = true;
      } else if (validator.isAnimationFillModeKeyword(value[1]) && !fillSet) {
        fill.value = [value];
        fillSet = true;
      } else if (validator.isAnimationPlayStateKeyword(value[1]) && !playSet) {
        play.value = [value];
        playSet = true;
      } else if ((validator.isAnimationNameKeyword(value[1]) || validator.isIdentifier(value[1])) && !nameSet) {
        name.value = [value];
        nameSet = true;
      } else {
        throw new InvalidPropertyError("Invalid animation value at " + formatPosition(value[2][0]) + ". Ignoring.");
      }
    }
    return components;
  };
  var background = function(property, compactable, validator) {
    var image = _wrapDefault("background-image", property, compactable);
    var position = _wrapDefault("background-position", property, compactable);
    var size = _wrapDefault("background-size", property, compactable);
    var repeat = _wrapDefault("background-repeat", property, compactable);
    var attachment = _wrapDefault("background-attachment", property, compactable);
    var origin = _wrapDefault("background-origin", property, compactable);
    var clip = _wrapDefault("background-clip", property, compactable);
    var color = _wrapDefault("background-color", property, compactable);
    var components = [image, position, size, repeat, attachment, origin, clip, color];
    var values = property.value;
    var positionSet = false;
    var clipSet = false;
    var originSet = false;
    var repeatSet = false;
    var anyValueSet = false;
    if (property.value.length == 1 && property.value[0][1] == "inherit") {
      color.value = image.value = repeat.value = position.value = size.value = origin.value = clip.value = property.value;
      return components;
    }
    if (property.value.length == 1 && property.value[0][1] == "0 0") {
      return components;
    }
    for (var i = values.length - 1;i >= 0; i--) {
      var value = values[i];
      if (validator.isBackgroundAttachmentKeyword(value[1])) {
        attachment.value = [value];
        anyValueSet = true;
      } else if (validator.isBackgroundClipKeyword(value[1]) || validator.isBackgroundOriginKeyword(value[1])) {
        if (clipSet) {
          origin.value = [value];
          originSet = true;
        } else {
          clip.value = [value];
          clipSet = true;
        }
        anyValueSet = true;
      } else if (validator.isBackgroundRepeatKeyword(value[1])) {
        if (repeatSet) {
          repeat.value.unshift(value);
        } else {
          repeat.value = [value];
          repeatSet = true;
        }
        anyValueSet = true;
      } else if (validator.isBackgroundPositionKeyword(value[1]) || validator.isBackgroundSizeKeyword(value[1]) || validator.isUnit(value[1]) || validator.isDynamicUnit(value[1])) {
        if (i > 0) {
          var previousValue = values[i - 1];
          if (previousValue[1] == Marker.FORWARD_SLASH) {
            size.value = [value];
          } else if (i > 1 && values[i - 2][1] == Marker.FORWARD_SLASH) {
            size.value = [previousValue, value];
            i -= 2;
          } else {
            if (!positionSet)
              position.value = [];
            position.value.unshift(value);
            positionSet = true;
          }
        } else {
          if (!positionSet)
            position.value = [];
          position.value.unshift(value);
          positionSet = true;
        }
        anyValueSet = true;
      } else if ((color.value[0][1] == compactable[color.name].defaultValue || color.value[0][1] == "none") && (validator.isColor(value[1]) || validator.isPrefixed(value[1]))) {
        color.value = [value];
        anyValueSet = true;
      } else if (validator.isUrl(value[1]) || validator.isFunction(value[1])) {
        image.value = [value];
        anyValueSet = true;
      }
    }
    if (clipSet && !originSet)
      origin.value = clip.value.slice(0);
    if (!anyValueSet) {
      throw new InvalidPropertyError("Invalid background value at " + formatPosition(values[0][2][0]) + ". Ignoring.");
    }
    return components;
  };
  var borderRadius = function(property, compactable) {
    var values = property.value;
    var splitAt = -1;
    for (var i = 0, l = values.length;i < l; i++) {
      if (values[i][1] == Marker.FORWARD_SLASH) {
        splitAt = i;
        break;
      }
    }
    if (splitAt === 0 || splitAt === values.length - 1) {
      throw new InvalidPropertyError("Invalid border-radius value at " + formatPosition(values[0][2][0]) + ". Ignoring.");
    }
    var target = _wrapDefault(property.name, property, compactable);
    target.value = splitAt > -1 ? values.slice(0, splitAt) : values.slice(0);
    target.components = fourValues(target, compactable);
    var remainder = _wrapDefault(property.name, property, compactable);
    remainder.value = splitAt > -1 ? values.slice(splitAt + 1) : values.slice(0);
    remainder.components = fourValues(remainder, compactable);
    for (var j = 0;j < 4; j++) {
      target.components[j].multiplex = true;
      target.components[j].value = target.components[j].value.concat(remainder.components[j].value);
    }
    return target.components;
  };
  var font = function(property, compactable, validator) {
    var style = _wrapDefault("font-style", property, compactable);
    var variant = _wrapDefault("font-variant", property, compactable);
    var weight = _wrapDefault("font-weight", property, compactable);
    var stretch = _wrapDefault("font-stretch", property, compactable);
    var size = _wrapDefault("font-size", property, compactable);
    var height = _wrapDefault("line-height", property, compactable);
    var family = _wrapDefault("font-family", property, compactable);
    var components = [style, variant, weight, stretch, size, height, family];
    var values = property.value;
    var fuzzyMatched = 4;
    var index = 0;
    var isStretchSet = false;
    var isStretchValid;
    var isStyleSet = false;
    var isStyleValid;
    var isVariantSet = false;
    var isVariantValid;
    var isWeightSet = false;
    var isWeightValid;
    var isSizeSet = false;
    var appendableFamilyName = false;
    if (!values[index]) {
      throw new InvalidPropertyError("Missing font values at " + formatPosition(property.all[property.position][1][2][0]) + ". Ignoring.");
    }
    if (values.length == 1 && values[0][1] == "inherit") {
      style.value = variant.value = weight.value = stretch.value = size.value = height.value = family.value = values;
      return components;
    }
    if (values.length == 1 && (validator.isFontKeyword(values[0][1]) || validator.isGlobal(values[0][1]) || validator.isPrefixed(values[0][1]))) {
      values[0][1] = Marker.INTERNAL + values[0][1];
      style.value = variant.value = weight.value = stretch.value = size.value = height.value = family.value = values;
      return components;
    }
    if (values.length < 2 || !_anyIsFontSize(values, validator) || !_anyIsFontFamily(values, validator)) {
      throw new InvalidPropertyError("Invalid font values at " + formatPosition(property.all[property.position][1][2][0]) + ". Ignoring.");
    }
    if (values.length > 1 && _anyIsInherit(values)) {
      throw new InvalidPropertyError("Invalid font values at " + formatPosition(values[0][2][0]) + ". Ignoring.");
    }
    while (index < fuzzyMatched) {
      isStretchValid = validator.isFontStretchKeyword(values[index][1]) || validator.isGlobal(values[index][1]);
      isStyleValid = validator.isFontStyleKeyword(values[index][1]) || validator.isGlobal(values[index][1]);
      isVariantValid = validator.isFontVariantKeyword(values[index][1]) || validator.isGlobal(values[index][1]);
      isWeightValid = validator.isFontWeightKeyword(values[index][1]) || validator.isGlobal(values[index][1]);
      if (isStyleValid && !isStyleSet) {
        style.value = [values[index]];
        isStyleSet = true;
      } else if (isVariantValid && !isVariantSet) {
        variant.value = [values[index]];
        isVariantSet = true;
      } else if (isWeightValid && !isWeightSet) {
        weight.value = [values[index]];
        isWeightSet = true;
      } else if (isStretchValid && !isStretchSet) {
        stretch.value = [values[index]];
        isStretchSet = true;
      } else if (isStyleValid && isStyleSet || isVariantValid && isVariantSet || isWeightValid && isWeightSet || isStretchValid && isStretchSet) {
        throw new InvalidPropertyError("Invalid font style / variant / weight / stretch value at " + formatPosition(values[0][2][0]) + ". Ignoring.");
      } else {
        break;
      }
      index++;
    }
    if (validator.isFontSizeKeyword(values[index][1]) || validator.isUnit(values[index][1]) && !validator.isDynamicUnit(values[index][1])) {
      size.value = [values[index]];
      isSizeSet = true;
      index++;
    } else {
      throw new InvalidPropertyError("Missing font size at " + formatPosition(values[0][2][0]) + ". Ignoring.");
    }
    if (!values[index]) {
      throw new InvalidPropertyError("Missing font family at " + formatPosition(values[0][2][0]) + ". Ignoring.");
    }
    if (isSizeSet && values[index] && values[index][1] == Marker.FORWARD_SLASH && values[index + 1] && (validator.isLineHeightKeyword(values[index + 1][1]) || validator.isUnit(values[index + 1][1]) || validator.isNumber(values[index + 1][1]))) {
      height.value = [values[index + 1]];
      index++;
      index++;
    }
    family.value = [];
    while (values[index]) {
      if (values[index][1] == Marker.COMMA) {
        appendableFamilyName = false;
      } else {
        if (appendableFamilyName) {
          family.value[family.value.length - 1][1] += Marker.SPACE + values[index][1];
        } else {
          family.value.push(values[index]);
        }
        appendableFamilyName = true;
      }
      index++;
    }
    if (family.value.length === 0) {
      throw new InvalidPropertyError("Missing font family at " + formatPosition(values[0][2][0]) + ". Ignoring.");
    }
    return components;
  };
  var _anyIsFontSize = function(values, validator) {
    var value;
    var i, l;
    for (i = 0, l = values.length;i < l; i++) {
      value = values[i];
      if (validator.isFontSizeKeyword(value[1]) || validator.isUnit(value[1]) && !validator.isDynamicUnit(value[1]) || validator.isFunction(value[1])) {
        return true;
      }
    }
    return false;
  };
  var _anyIsFontFamily = function(values, validator) {
    var value;
    var i, l;
    for (i = 0, l = values.length;i < l; i++) {
      value = values[i];
      if (validator.isIdentifier(value[1])) {
        return true;
      }
    }
    return false;
  };
  var fourValues = function(property, compactable) {
    var componentNames = compactable[property.name].components;
    var components = [];
    var value = property.value;
    if (value.length < 1)
      return [];
    if (value.length < 2)
      value[1] = value[0].slice(0);
    if (value.length < 3)
      value[2] = value[0].slice(0);
    if (value.length < 4)
      value[3] = value[1].slice(0);
    for (var i = componentNames.length - 1;i >= 0; i--) {
      var component = wrapSingle([
        Token.PROPERTY,
        [Token.PROPERTY_NAME, componentNames[i]]
      ]);
      component.value = [value[i]];
      components.unshift(component);
    }
    return components;
  };
  var multiplex = function(splitWith) {
    return function(property, compactable, validator) {
      var splitsAt = [];
      var values = property.value;
      var i, j, l, m;
      for (i = 0, l = values.length;i < l; i++) {
        if (values[i][1] == ",")
          splitsAt.push(i);
      }
      if (splitsAt.length === 0)
        return splitWith(property, compactable, validator);
      var splitComponents = [];
      for (i = 0, l = splitsAt.length;i <= l; i++) {
        var from = i === 0 ? 0 : splitsAt[i - 1] + 1;
        var to = i < l ? splitsAt[i] : values.length;
        var _property = _wrapDefault(property.name, property, compactable);
        _property.value = values.slice(from, to);
        splitComponents.push(splitWith(_property, compactable, validator));
      }
      var components = splitComponents[0];
      for (i = 0, l = components.length;i < l; i++) {
        components[i].multiplex = true;
        for (j = 1, m = splitComponents.length;j < m; j++) {
          components[i].value.push([Token.PROPERTY_VALUE, Marker.COMMA]);
          Array.prototype.push.apply(components[i].value, splitComponents[j][i].value);
        }
      }
      return components;
    };
  };
  var listStyle = function(property, compactable, validator) {
    var type = _wrapDefault("list-style-type", property, compactable);
    var position = _wrapDefault("list-style-position", property, compactable);
    var image = _wrapDefault("list-style-image", property, compactable);
    var components = [type, position, image];
    if (property.value.length == 1 && property.value[0][1] == "inherit") {
      type.value = position.value = image.value = [property.value[0]];
      return components;
    }
    var values = property.value.slice(0);
    var total = values.length;
    var index = 0;
    for (index = 0, total = values.length;index < total; index++) {
      if (validator.isUrl(values[index][1]) || values[index][1] == "0") {
        image.value = [values[index]];
        values.splice(index, 1);
        break;
      }
    }
    for (index = 0, total = values.length;index < total; index++) {
      if (validator.isListStylePositionKeyword(values[index][1])) {
        position.value = [values[index]];
        values.splice(index, 1);
        break;
      }
    }
    if (values.length > 0 && (validator.isListStyleTypeKeyword(values[0][1]) || validator.isIdentifier(values[0][1]))) {
      type.value = [values[0]];
    }
    return components;
  };
  var transition = function(property, compactable, validator) {
    var prop = _wrapDefault(property.name + "-property", property, compactable);
    var duration = _wrapDefault(property.name + "-duration", property, compactable);
    var timing = _wrapDefault(property.name + "-timing-function", property, compactable);
    var delay = _wrapDefault(property.name + "-delay", property, compactable);
    var components = [prop, duration, timing, delay];
    var values = property.value;
    var value;
    var durationSet = false;
    var delaySet = false;
    var propSet = false;
    var timingSet = false;
    var i;
    var l;
    if (property.value.length == 1 && property.value[0][1] == "inherit") {
      prop.value = duration.value = timing.value = delay.value = property.value;
      return components;
    }
    if (values.length > 1 && _anyIsInherit(values)) {
      throw new InvalidPropertyError("Invalid animation values at " + formatPosition(values[0][2][0]) + ". Ignoring.");
    }
    for (i = 0, l = values.length;i < l; i++) {
      value = values[i];
      if (validator.isTime(value[1]) && !durationSet) {
        duration.value = [value];
        durationSet = true;
      } else if (validator.isTime(value[1]) && !delaySet) {
        delay.value = [value];
        delaySet = true;
      } else if ((validator.isGlobal(value[1]) || validator.isTimingFunction(value[1])) && !timingSet) {
        timing.value = [value];
        timingSet = true;
      } else if (validator.isIdentifier(value[1]) && !propSet) {
        prop.value = [value];
        propSet = true;
      } else {
        throw new InvalidPropertyError("Invalid animation value at " + formatPosition(value[2][0]) + ". Ignoring.");
      }
    }
    return components;
  };
  var widthStyleColor = function(property, compactable, validator) {
    var descriptor = compactable[property.name];
    var components = [
      _wrapDefault(descriptor.components[0], property, compactable),
      _wrapDefault(descriptor.components[1], property, compactable),
      _wrapDefault(descriptor.components[2], property, compactable)
    ];
    var color, style, width;
    for (var i = 0;i < 3; i++) {
      var component = components[i];
      if (component.name.indexOf("color") > 0)
        color = component;
      else if (component.name.indexOf("style") > 0)
        style = component;
      else
        width = component;
    }
    if (property.value.length == 1 && property.value[0][1] == "inherit" || property.value.length == 3 && property.value[0][1] == "inherit" && property.value[1][1] == "inherit" && property.value[2][1] == "inherit") {
      color.value = style.value = width.value = [property.value[0]];
      return components;
    }
    var values = property.value.slice(0);
    var match, matches;
    if (values.length > 0) {
      matches = values.filter(_widthFilter(validator));
      match = matches.length > 1 && (matches[0][1] == "none" || matches[0][1] == "auto") ? matches[1] : matches[0];
      if (match) {
        width.value = [match];
        values.splice(values.indexOf(match), 1);
      }
    }
    if (values.length > 0) {
      match = values.filter(_styleFilter(validator))[0];
      if (match) {
        style.value = [match];
        values.splice(values.indexOf(match), 1);
      }
    }
    if (values.length > 0) {
      match = values.filter(_colorFilter(validator))[0];
      if (match) {
        color.value = [match];
        values.splice(values.indexOf(match), 1);
      }
    }
    return components;
  };
  var InvalidPropertyError = require_invalid_property_error();
  var wrapSingle = require_wrap_for_optimizing().single;
  var Token = require_token();
  var Marker = require_marker();
  var formatPosition = require_format_position();
  module.exports = {
    animation,
    background,
    border: widthStyleColor,
    borderRadius,
    font,
    fourValues,
    listStyle,
    multiplex,
    outline: widthStyleColor,
    transition
  };
});

// node_modules/clean-css/lib/optimizer/level-2/properties/vendor-prefixes.js
var require_vendor_prefixes = __commonJS((exports, module) => {
  var unique = function(value) {
    var prefixes = [];
    var match;
    while ((match = VENDOR_PREFIX_PATTERN.exec(value)) !== null) {
      if (prefixes.indexOf(match[0]) == -1) {
        prefixes.push(match[0]);
      }
    }
    return prefixes;
  };
  var same = function(value1, value2) {
    return unique(value1).sort().join(",") == unique(value2).sort().join(",");
  };
  var VENDOR_PREFIX_PATTERN = /(?:^|\W)(\-\w+\-)/g;
  module.exports = {
    unique,
    same
  };
});

// node_modules/clean-css/lib/optimizer/level-2/properties/understandable.js
var require_understandable = __commonJS((exports, module) => {
  var understandable = function(validator, value1, value2, _position, isPaired) {
    if (!sameVendorPrefixes(value1, value2)) {
      return false;
    }
    if (isPaired && validator.isVariable(value1) !== validator.isVariable(value2)) {
      return false;
    }
    return true;
  };
  var sameVendorPrefixes = require_vendor_prefixes().same;
  module.exports = understandable;
});

// node_modules/clean-css/lib/optimizer/level-2/can-override.js
var require_can_override = __commonJS((exports, module) => {
  var animationIterationCount = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !(validator.isAnimationIterationCountKeyword(value2) || validator.isPositiveNumber(value2))) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    }
    return validator.isAnimationIterationCountKeyword(value2) || validator.isPositiveNumber(value2);
  };
  var animationName = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !(validator.isAnimationNameKeyword(value2) || validator.isIdentifier(value2))) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    }
    return validator.isAnimationNameKeyword(value2) || validator.isIdentifier(value2);
  };
  var areSameFunction = function(validator, value1, value2) {
    if (!validator.isFunction(value1) || !validator.isFunction(value2)) {
      return false;
    }
    var function1Name = value1.substring(0, value1.indexOf("("));
    var function2Name = value2.substring(0, value2.indexOf("("));
    return function1Name === function2Name;
  };
  var backgroundPosition = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !(validator.isBackgroundPositionKeyword(value2) || validator.isGlobal(value2))) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    } else if (validator.isBackgroundPositionKeyword(value2) || validator.isGlobal(value2)) {
      return true;
    }
    return unit(validator, value1, value2);
  };
  var backgroundSize = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !(validator.isBackgroundSizeKeyword(value2) || validator.isGlobal(value2))) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    } else if (validator.isBackgroundSizeKeyword(value2) || validator.isGlobal(value2)) {
      return true;
    }
    return unit(validator, value1, value2);
  };
  var color = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !validator.isColor(value2)) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    } else if (!validator.colorOpacity && (validator.isRgbColor(value1) || validator.isHslColor(value1))) {
      return false;
    } else if (!validator.colorOpacity && (validator.isRgbColor(value2) || validator.isHslColor(value2))) {
      return false;
    } else if (validator.isColor(value1) && validator.isColor(value2)) {
      return true;
    }
    return sameFunctionOrValue(validator, value1, value2);
  };
  var components = function(overrideCheckers) {
    return function(validator, value1, value2, position) {
      return overrideCheckers[position](validator, value1, value2);
    };
  };
  var fontFamily = function(validator, value1, value2) {
    return understandable(validator, value1, value2, 0, true);
  };
  var image = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !validator.isImage(value2)) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    } else if (validator.isImage(value2)) {
      return true;
    } else if (validator.isImage(value1)) {
      return false;
    }
    return sameFunctionOrValue(validator, value1, value2);
  };
  var keyword = function(propertyName2) {
    return function(validator, value1, value2) {
      if (!understandable(validator, value1, value2, 0, true) && !validator.isKeyword(propertyName2)(value2)) {
        return false;
      } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
        return true;
      }
      return validator.isKeyword(propertyName2)(value2);
    };
  };
  var keywordWithGlobal = function(propertyName2) {
    return function(validator, value1, value2) {
      if (!understandable(validator, value1, value2, 0, true) && !(validator.isKeyword(propertyName2)(value2) || validator.isGlobal(value2))) {
        return false;
      } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
        return true;
      }
      return validator.isKeyword(propertyName2)(value2) || validator.isGlobal(value2);
    };
  };
  var propertyName = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !validator.isIdentifier(value2)) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    }
    return validator.isIdentifier(value2);
  };
  var sameFunctionOrValue = function(validator, value1, value2) {
    return areSameFunction(validator, value1, value2) ? true : value1 === value2;
  };
  var textShadow = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !(validator.isUnit(value2) || validator.isColor(value2) || validator.isGlobal(value2))) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    }
    return validator.isUnit(value2) || validator.isColor(value2) || validator.isGlobal(value2);
  };
  var time = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !validator.isTime(value2)) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    } else if (validator.isTime(value1) && !validator.isTime(value2)) {
      return false;
    } else if (validator.isTime(value2)) {
      return true;
    } else if (validator.isTime(value1)) {
      return false;
    } else if (validator.isFunction(value1) && !validator.isPrefixed(value1) && validator.isFunction(value2) && !validator.isPrefixed(value2)) {
      return true;
    }
    return sameFunctionOrValue(validator, value1, value2);
  };
  var timingFunction = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !(validator.isTimingFunction(value2) || validator.isGlobal(value2))) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    }
    return validator.isTimingFunction(value2) || validator.isGlobal(value2);
  };
  var unit = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !validator.isUnit(value2)) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    } else if (validator.isUnit(value1) && !validator.isUnit(value2)) {
      return false;
    } else if (validator.isUnit(value2)) {
      return true;
    } else if (validator.isUnit(value1)) {
      return false;
    } else if (validator.isFunction(value1) && !validator.isPrefixed(value1) && validator.isFunction(value2) && !validator.isPrefixed(value2)) {
      return true;
    }
    return sameFunctionOrValue(validator, value1, value2);
  };
  var unitOrKeywordWithGlobal = function(propertyName2) {
    var byKeyword = keywordWithGlobal(propertyName2);
    return function(validator, value1, value2) {
      return unit(validator, value1, value2) || byKeyword(validator, value1, value2);
    };
  };
  var unitOrNumber = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !(validator.isUnit(value2) || validator.isNumber(value2))) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    } else if ((validator.isUnit(value1) || validator.isNumber(value1)) && !(validator.isUnit(value2) || validator.isNumber(value2))) {
      return false;
    } else if (validator.isUnit(value2) || validator.isNumber(value2)) {
      return true;
    } else if (validator.isUnit(value1) || validator.isNumber(value1)) {
      return false;
    } else if (validator.isFunction(value1) && !validator.isPrefixed(value1) && validator.isFunction(value2) && !validator.isPrefixed(value2)) {
      return true;
    }
    return sameFunctionOrValue(validator, value1, value2);
  };
  var zIndex = function(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !validator.isZIndex(value2)) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    }
    return validator.isZIndex(value2);
  };
  var understandable = require_understandable();
  module.exports = {
    generic: {
      color,
      components,
      image,
      propertyName,
      time,
      timingFunction,
      unit,
      unitOrNumber
    },
    property: {
      animationDirection: keywordWithGlobal("animation-direction"),
      animationFillMode: keyword("animation-fill-mode"),
      animationIterationCount,
      animationName,
      animationPlayState: keywordWithGlobal("animation-play-state"),
      backgroundAttachment: keyword("background-attachment"),
      backgroundClip: keywordWithGlobal("background-clip"),
      backgroundOrigin: keyword("background-origin"),
      backgroundPosition,
      backgroundRepeat: keyword("background-repeat"),
      backgroundSize,
      bottom: unitOrKeywordWithGlobal("bottom"),
      borderCollapse: keyword("border-collapse"),
      borderStyle: keywordWithGlobal("*-style"),
      clear: keywordWithGlobal("clear"),
      cursor: keywordWithGlobal("cursor"),
      display: keywordWithGlobal("display"),
      float: keywordWithGlobal("float"),
      left: unitOrKeywordWithGlobal("left"),
      fontFamily,
      fontStretch: keywordWithGlobal("font-stretch"),
      fontStyle: keywordWithGlobal("font-style"),
      fontVariant: keywordWithGlobal("font-variant"),
      fontWeight: keywordWithGlobal("font-weight"),
      listStyleType: keywordWithGlobal("list-style-type"),
      listStylePosition: keywordWithGlobal("list-style-position"),
      outlineStyle: keywordWithGlobal("*-style"),
      overflow: keywordWithGlobal("overflow"),
      position: keywordWithGlobal("position"),
      right: unitOrKeywordWithGlobal("right"),
      textAlign: keywordWithGlobal("text-align"),
      textDecoration: keywordWithGlobal("text-decoration"),
      textOverflow: keywordWithGlobal("text-overflow"),
      textShadow,
      top: unitOrKeywordWithGlobal("top"),
      transform: sameFunctionOrValue,
      verticalAlign: unitOrKeywordWithGlobal("vertical-align"),
      visibility: keywordWithGlobal("visibility"),
      whiteSpace: keywordWithGlobal("white-space"),
      zIndex
    }
  };
});

// node_modules/clean-css/lib/optimizer/level-2/clone.js
var require_clone = __commonJS((exports, module) => {
  var deep = function(property) {
    var cloned = shallow(property);
    for (var i = property.components.length - 1;i >= 0; i--) {
      var component = shallow(property.components[i]);
      component.value = property.components[i].value.slice(0);
      cloned.components.unshift(component);
    }
    cloned.dirty = true;
    cloned.value = property.value.slice(0);
    return cloned;
  };
  var shallow = function(property) {
    var cloned = wrapSingle([
      Token.PROPERTY,
      [Token.PROPERTY_NAME, property.name]
    ]);
    cloned.important = property.important;
    cloned.hack = property.hack;
    cloned.unused = false;
    return cloned;
  };
  var wrapSingle = require_wrap_for_optimizing().single;
  var Token = require_token();
  module.exports = {
    deep,
    shallow
  };
});

// node_modules/clean-css/lib/optimizer/level-2/restore.js
var require_restore = __commonJS((exports, module) => {
  var isInheritOnly = function(values) {
    for (var i = 0, l = values.length;i < l; i++) {
      var value = values[i][1];
      if (value != "inherit" && value != Marker.COMMA && value != Marker.FORWARD_SLASH)
        return false;
    }
    return true;
  };
  var background = function(property, compactable, lastInMultiplex) {
    var components = property.components;
    var restored = [];
    var needsOne, needsBoth;
    function restoreValue(component2) {
      Array.prototype.unshift.apply(restored, component2.value);
    }
    function isDefaultValue(component2) {
      var descriptor = compactable[component2.name];
      if (descriptor.doubleValues && descriptor.defaultValue.length == 1) {
        return component2.value[0][1] == descriptor.defaultValue[0] && (component2.value[1] ? component2.value[1][1] == descriptor.defaultValue[0] : true);
      } else if (descriptor.doubleValues && descriptor.defaultValue.length != 1) {
        return component2.value[0][1] == descriptor.defaultValue[0] && (component2.value[1] ? component2.value[1][1] : component2.value[0][1]) == descriptor.defaultValue[1];
      } else {
        return component2.value[0][1] == descriptor.defaultValue;
      }
    }
    for (var i = components.length - 1;i >= 0; i--) {
      var component = components[i];
      var isDefault2 = isDefaultValue(component);
      if (component.name == "background-clip") {
        var originComponent = components[i - 1];
        var isOriginDefault = isDefaultValue(originComponent);
        needsOne = component.value[0][1] == originComponent.value[0][1];
        needsBoth = !needsOne && (isOriginDefault && !isDefault2 || !isOriginDefault && !isDefault2 || !isOriginDefault && isDefault2 && component.value[0][1] != originComponent.value[0][1]);
        if (needsOne) {
          restoreValue(originComponent);
        } else if (needsBoth) {
          restoreValue(component);
          restoreValue(originComponent);
        }
        i--;
      } else if (component.name == "background-size") {
        var positionComponent = components[i - 1];
        var isPositionDefault = isDefaultValue(positionComponent);
        needsOne = !isPositionDefault && isDefault2;
        needsBoth = !needsOne && (isPositionDefault && !isDefault2 || !isPositionDefault && !isDefault2);
        if (needsOne) {
          restoreValue(positionComponent);
        } else if (needsBoth) {
          restoreValue(component);
          restored.unshift([Token.PROPERTY_VALUE, Marker.FORWARD_SLASH]);
          restoreValue(positionComponent);
        } else if (positionComponent.value.length == 1) {
          restoreValue(positionComponent);
        }
        i--;
      } else {
        if (isDefault2 || compactable[component.name].multiplexLastOnly && !lastInMultiplex)
          continue;
        restoreValue(component);
      }
    }
    if (restored.length === 0 && property.value.length == 1 && property.value[0][1] == "0")
      restored.push(property.value[0]);
    if (restored.length === 0)
      restored.push([Token.PROPERTY_VALUE, compactable[property.name].defaultValue]);
    if (isInheritOnly(restored))
      return [restored[0]];
    return restored;
  };
  var borderRadius = function(property, compactable) {
    if (property.multiplex) {
      var horizontal = shallowClone(property);
      var vertical = shallowClone(property);
      for (var i = 0;i < 4; i++) {
        var component = property.components[i];
        var horizontalComponent = shallowClone(property);
        horizontalComponent.value = [component.value[0]];
        horizontal.components.push(horizontalComponent);
        var verticalComponent = shallowClone(property);
        verticalComponent.value = [component.value[1] || component.value[0]];
        vertical.components.push(verticalComponent);
      }
      var horizontalValues = fourValues(horizontal, compactable);
      var verticalValues = fourValues(vertical, compactable);
      if (horizontalValues.length == verticalValues.length && horizontalValues[0][1] == verticalValues[0][1] && (horizontalValues.length > 1 ? horizontalValues[1][1] == verticalValues[1][1] : true) && (horizontalValues.length > 2 ? horizontalValues[2][1] == verticalValues[2][1] : true) && (horizontalValues.length > 3 ? horizontalValues[3][1] == verticalValues[3][1] : true)) {
        return horizontalValues;
      } else {
        return horizontalValues.concat([[Token.PROPERTY_VALUE, Marker.FORWARD_SLASH]]).concat(verticalValues);
      }
    } else {
      return fourValues(property, compactable);
    }
  };
  var font = function(property, compactable) {
    var components = property.components;
    var restored = [];
    var component;
    var componentIndex = 0;
    var fontFamilyIndex = 0;
    if (property.value[0][1].indexOf(Marker.INTERNAL) === 0) {
      property.value[0][1] = property.value[0][1].substring(Marker.INTERNAL.length);
      return property.value;
    }
    while (componentIndex < 4) {
      component = components[componentIndex];
      if (component.value[0][1] != compactable[component.name].defaultValue) {
        Array.prototype.push.apply(restored, component.value);
      }
      componentIndex++;
    }
    Array.prototype.push.apply(restored, components[componentIndex].value);
    componentIndex++;
    if (components[componentIndex].value[0][1] != compactable[components[componentIndex].name].defaultValue) {
      Array.prototype.push.apply(restored, [[Token.PROPERTY_VALUE, Marker.FORWARD_SLASH]]);
      Array.prototype.push.apply(restored, components[componentIndex].value);
    }
    componentIndex++;
    while (components[componentIndex].value[fontFamilyIndex]) {
      restored.push(components[componentIndex].value[fontFamilyIndex]);
      if (components[componentIndex].value[fontFamilyIndex + 1]) {
        restored.push([Token.PROPERTY_VALUE, Marker.COMMA]);
      }
      fontFamilyIndex++;
    }
    if (isInheritOnly(restored)) {
      return [restored[0]];
    }
    return restored;
  };
  var fourValues = function(property) {
    var components = property.components;
    var value1 = components[0].value[0];
    var value2 = components[1].value[0];
    var value3 = components[2].value[0];
    var value4 = components[3].value[0];
    if (value1[1] == value2[1] && value1[1] == value3[1] && value1[1] == value4[1]) {
      return [value1];
    } else if (value1[1] == value3[1] && value2[1] == value4[1]) {
      return [value1, value2];
    } else if (value2[1] == value4[1]) {
      return [value1, value2, value3];
    } else {
      return [value1, value2, value3, value4];
    }
  };
  var multiplex = function(restoreWith) {
    return function(property, compactable) {
      if (!property.multiplex)
        return restoreWith(property, compactable, true);
      var multiplexSize = 0;
      var restored = [];
      var componentMultiplexSoFar = {};
      var i, l;
      for (i = 0, l = property.components[0].value.length;i < l; i++) {
        if (property.components[0].value[i][1] == Marker.COMMA)
          multiplexSize++;
      }
      for (i = 0;i <= multiplexSize; i++) {
        var _property = shallowClone(property);
        for (var j = 0, m = property.components.length;j < m; j++) {
          var componentToClone = property.components[j];
          var _component = shallowClone(componentToClone);
          _property.components.push(_component);
          for (var k = componentMultiplexSoFar[_component.name] || 0, n = componentToClone.value.length;k < n; k++) {
            if (componentToClone.value[k][1] == Marker.COMMA) {
              componentMultiplexSoFar[_component.name] = k + 1;
              break;
            }
            _component.value.push(componentToClone.value[k]);
          }
        }
        var lastInMultiplex = i == multiplexSize;
        var _restored = restoreWith(_property, compactable, lastInMultiplex);
        Array.prototype.push.apply(restored, _restored);
        if (i < multiplexSize)
          restored.push([Token.PROPERTY_VALUE, Marker.COMMA]);
      }
      return restored;
    };
  };
  var withoutDefaults = function(property, compactable) {
    var components = property.components;
    var restored = [];
    for (var i = components.length - 1;i >= 0; i--) {
      var component = components[i];
      var descriptor = compactable[component.name];
      if (component.value[0][1] != descriptor.defaultValue || "keepUnlessDefault" in descriptor && !isDefault(components, compactable, descriptor.keepUnlessDefault)) {
        restored.unshift(component.value[0]);
      }
    }
    if (restored.length === 0)
      restored.push([Token.PROPERTY_VALUE, compactable[property.name].defaultValue]);
    if (isInheritOnly(restored))
      return [restored[0]];
    return restored;
  };
  var isDefault = function(components, compactable, propertyName) {
    var component;
    var i, l;
    for (i = 0, l = components.length;i < l; i++) {
      component = components[i];
      if (component.name == propertyName && component.value[0][1] == compactable[propertyName].defaultValue) {
        return true;
      }
    }
    return false;
  };
  var shallowClone = require_clone().shallow;
  var Token = require_token();
  var Marker = require_marker();
  module.exports = {
    background,
    borderRadius,
    font,
    fourValues,
    multiplex,
    withoutDefaults
  };
});

// node_modules/clean-css/lib/optimizer/level-2/compactable.js
var require_compactable = __commonJS((exports, module) => {
  var cloneDescriptor = function(propertyName2, prefix2) {
    var clonedDescriptor2 = override(compactable[propertyName2], {});
    if ("componentOf" in clonedDescriptor2) {
      clonedDescriptor2.componentOf = clonedDescriptor2.componentOf.map(function(shorthandName) {
        return prefix2 + shorthandName;
      });
    }
    if ("components" in clonedDescriptor2) {
      clonedDescriptor2.components = clonedDescriptor2.components.map(function(longhandName) {
        return prefix2 + longhandName;
      });
    }
    if ("keepUnlessDefault" in clonedDescriptor2) {
      clonedDescriptor2.keepUnlessDefault = prefix2 + clonedDescriptor2.keepUnlessDefault;
    }
    return clonedDescriptor2;
  };
  var breakUp = require_break_up();
  var canOverride = require_can_override();
  var restore = require_restore();
  var override = require_override();
  var compactable = {
    animation: {
      canOverride: canOverride.generic.components([
        canOverride.generic.time,
        canOverride.generic.timingFunction,
        canOverride.generic.time,
        canOverride.property.animationIterationCount,
        canOverride.property.animationDirection,
        canOverride.property.animationFillMode,
        canOverride.property.animationPlayState,
        canOverride.property.animationName
      ]),
      components: [
        "animation-duration",
        "animation-timing-function",
        "animation-delay",
        "animation-iteration-count",
        "animation-direction",
        "animation-fill-mode",
        "animation-play-state",
        "animation-name"
      ],
      breakUp: breakUp.multiplex(breakUp.animation),
      defaultValue: "none",
      restore: restore.multiplex(restore.withoutDefaults),
      shorthand: true,
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "animation-delay": {
      canOverride: canOverride.generic.time,
      componentOf: [
        "animation"
      ],
      defaultValue: "0s",
      intoMultiplexMode: "real",
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "animation-direction": {
      canOverride: canOverride.property.animationDirection,
      componentOf: [
        "animation"
      ],
      defaultValue: "normal",
      intoMultiplexMode: "real",
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "animation-duration": {
      canOverride: canOverride.generic.time,
      componentOf: [
        "animation"
      ],
      defaultValue: "0s",
      intoMultiplexMode: "real",
      keepUnlessDefault: "animation-delay",
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "animation-fill-mode": {
      canOverride: canOverride.property.animationFillMode,
      componentOf: [
        "animation"
      ],
      defaultValue: "none",
      intoMultiplexMode: "real",
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "animation-iteration-count": {
      canOverride: canOverride.property.animationIterationCount,
      componentOf: [
        "animation"
      ],
      defaultValue: "1",
      intoMultiplexMode: "real",
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "animation-name": {
      canOverride: canOverride.property.animationName,
      componentOf: [
        "animation"
      ],
      defaultValue: "none",
      intoMultiplexMode: "real",
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "animation-play-state": {
      canOverride: canOverride.property.animationPlayState,
      componentOf: [
        "animation"
      ],
      defaultValue: "running",
      intoMultiplexMode: "real",
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "animation-timing-function": {
      canOverride: canOverride.generic.timingFunction,
      componentOf: [
        "animation"
      ],
      defaultValue: "ease",
      intoMultiplexMode: "real",
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    background: {
      canOverride: canOverride.generic.components([
        canOverride.generic.image,
        canOverride.property.backgroundPosition,
        canOverride.property.backgroundSize,
        canOverride.property.backgroundRepeat,
        canOverride.property.backgroundAttachment,
        canOverride.property.backgroundOrigin,
        canOverride.property.backgroundClip,
        canOverride.generic.color
      ]),
      components: [
        "background-image",
        "background-position",
        "background-size",
        "background-repeat",
        "background-attachment",
        "background-origin",
        "background-clip",
        "background-color"
      ],
      breakUp: breakUp.multiplex(breakUp.background),
      defaultValue: "0 0",
      restore: restore.multiplex(restore.background),
      shortestValue: "0",
      shorthand: true
    },
    "background-attachment": {
      canOverride: canOverride.property.backgroundAttachment,
      componentOf: [
        "background"
      ],
      defaultValue: "scroll",
      intoMultiplexMode: "real"
    },
    "background-clip": {
      canOverride: canOverride.property.backgroundClip,
      componentOf: [
        "background"
      ],
      defaultValue: "border-box",
      intoMultiplexMode: "real",
      shortestValue: "border-box"
    },
    "background-color": {
      canOverride: canOverride.generic.color,
      componentOf: [
        "background"
      ],
      defaultValue: "transparent",
      intoMultiplexMode: "real",
      multiplexLastOnly: true,
      nonMergeableValue: "none",
      shortestValue: "red"
    },
    "background-image": {
      canOverride: canOverride.generic.image,
      componentOf: [
        "background"
      ],
      defaultValue: "none",
      intoMultiplexMode: "default"
    },
    "background-origin": {
      canOverride: canOverride.property.backgroundOrigin,
      componentOf: [
        "background"
      ],
      defaultValue: "padding-box",
      intoMultiplexMode: "real",
      shortestValue: "border-box"
    },
    "background-position": {
      canOverride: canOverride.property.backgroundPosition,
      componentOf: [
        "background"
      ],
      defaultValue: ["0", "0"],
      doubleValues: true,
      intoMultiplexMode: "real",
      shortestValue: "0"
    },
    "background-repeat": {
      canOverride: canOverride.property.backgroundRepeat,
      componentOf: [
        "background"
      ],
      defaultValue: ["repeat"],
      doubleValues: true,
      intoMultiplexMode: "real"
    },
    "background-size": {
      canOverride: canOverride.property.backgroundSize,
      componentOf: [
        "background"
      ],
      defaultValue: ["auto"],
      doubleValues: true,
      intoMultiplexMode: "real",
      shortestValue: "0 0"
    },
    bottom: {
      canOverride: canOverride.property.bottom,
      defaultValue: "auto"
    },
    border: {
      breakUp: breakUp.border,
      canOverride: canOverride.generic.components([
        canOverride.generic.unit,
        canOverride.property.borderStyle,
        canOverride.generic.color
      ]),
      components: [
        "border-width",
        "border-style",
        "border-color"
      ],
      defaultValue: "none",
      overridesShorthands: [
        "border-bottom",
        "border-left",
        "border-right",
        "border-top"
      ],
      restore: restore.withoutDefaults,
      shorthand: true,
      shorthandComponents: true
    },
    "border-bottom": {
      breakUp: breakUp.border,
      canOverride: canOverride.generic.components([
        canOverride.generic.unit,
        canOverride.property.borderStyle,
        canOverride.generic.color
      ]),
      components: [
        "border-bottom-width",
        "border-bottom-style",
        "border-bottom-color"
      ],
      defaultValue: "none",
      restore: restore.withoutDefaults,
      shorthand: true
    },
    "border-bottom-color": {
      canOverride: canOverride.generic.color,
      componentOf: [
        "border-bottom",
        "border-color"
      ],
      defaultValue: "none"
    },
    "border-bottom-left-radius": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "border-radius"
      ],
      defaultValue: "0",
      vendorPrefixes: [
        "-moz-",
        "-o-"
      ]
    },
    "border-bottom-right-radius": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "border-radius"
      ],
      defaultValue: "0",
      vendorPrefixes: [
        "-moz-",
        "-o-"
      ]
    },
    "border-bottom-style": {
      canOverride: canOverride.property.borderStyle,
      componentOf: [
        "border-bottom",
        "border-style"
      ],
      defaultValue: "none"
    },
    "border-bottom-width": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "border-bottom",
        "border-width"
      ],
      defaultValue: "medium",
      oppositeTo: "border-top-width",
      shortestValue: "0"
    },
    "border-collapse": {
      canOverride: canOverride.property.borderCollapse,
      defaultValue: "separate"
    },
    "border-color": {
      breakUp: breakUp.fourValues,
      canOverride: canOverride.generic.components([
        canOverride.generic.color,
        canOverride.generic.color,
        canOverride.generic.color,
        canOverride.generic.color
      ]),
      componentOf: [
        "border"
      ],
      components: [
        "border-top-color",
        "border-right-color",
        "border-bottom-color",
        "border-left-color"
      ],
      defaultValue: "none",
      restore: restore.fourValues,
      shortestValue: "red",
      shorthand: true
    },
    "border-left": {
      breakUp: breakUp.border,
      canOverride: canOverride.generic.components([
        canOverride.generic.unit,
        canOverride.property.borderStyle,
        canOverride.generic.color
      ]),
      components: [
        "border-left-width",
        "border-left-style",
        "border-left-color"
      ],
      defaultValue: "none",
      restore: restore.withoutDefaults,
      shorthand: true
    },
    "border-left-color": {
      canOverride: canOverride.generic.color,
      componentOf: [
        "border-color",
        "border-left"
      ],
      defaultValue: "none"
    },
    "border-left-style": {
      canOverride: canOverride.property.borderStyle,
      componentOf: [
        "border-left",
        "border-style"
      ],
      defaultValue: "none"
    },
    "border-left-width": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "border-left",
        "border-width"
      ],
      defaultValue: "medium",
      oppositeTo: "border-right-width",
      shortestValue: "0"
    },
    "border-radius": {
      breakUp: breakUp.borderRadius,
      canOverride: canOverride.generic.components([
        canOverride.generic.unit,
        canOverride.generic.unit,
        canOverride.generic.unit,
        canOverride.generic.unit
      ]),
      components: [
        "border-top-left-radius",
        "border-top-right-radius",
        "border-bottom-right-radius",
        "border-bottom-left-radius"
      ],
      defaultValue: "0",
      restore: restore.borderRadius,
      shorthand: true,
      vendorPrefixes: [
        "-moz-",
        "-o-"
      ]
    },
    "border-right": {
      breakUp: breakUp.border,
      canOverride: canOverride.generic.components([
        canOverride.generic.unit,
        canOverride.property.borderStyle,
        canOverride.generic.color
      ]),
      components: [
        "border-right-width",
        "border-right-style",
        "border-right-color"
      ],
      defaultValue: "none",
      restore: restore.withoutDefaults,
      shorthand: true
    },
    "border-right-color": {
      canOverride: canOverride.generic.color,
      componentOf: [
        "border-color",
        "border-right"
      ],
      defaultValue: "none"
    },
    "border-right-style": {
      canOverride: canOverride.property.borderStyle,
      componentOf: [
        "border-right",
        "border-style"
      ],
      defaultValue: "none"
    },
    "border-right-width": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "border-right",
        "border-width"
      ],
      defaultValue: "medium",
      oppositeTo: "border-left-width",
      shortestValue: "0"
    },
    "border-style": {
      breakUp: breakUp.fourValues,
      canOverride: canOverride.generic.components([
        canOverride.property.borderStyle,
        canOverride.property.borderStyle,
        canOverride.property.borderStyle,
        canOverride.property.borderStyle
      ]),
      componentOf: [
        "border"
      ],
      components: [
        "border-top-style",
        "border-right-style",
        "border-bottom-style",
        "border-left-style"
      ],
      defaultValue: "none",
      restore: restore.fourValues,
      shorthand: true
    },
    "border-top": {
      breakUp: breakUp.border,
      canOverride: canOverride.generic.components([
        canOverride.generic.unit,
        canOverride.property.borderStyle,
        canOverride.generic.color
      ]),
      components: [
        "border-top-width",
        "border-top-style",
        "border-top-color"
      ],
      defaultValue: "none",
      restore: restore.withoutDefaults,
      shorthand: true
    },
    "border-top-color": {
      canOverride: canOverride.generic.color,
      componentOf: [
        "border-color",
        "border-top"
      ],
      defaultValue: "none"
    },
    "border-top-left-radius": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "border-radius"
      ],
      defaultValue: "0",
      vendorPrefixes: [
        "-moz-",
        "-o-"
      ]
    },
    "border-top-right-radius": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "border-radius"
      ],
      defaultValue: "0",
      vendorPrefixes: [
        "-moz-",
        "-o-"
      ]
    },
    "border-top-style": {
      canOverride: canOverride.property.borderStyle,
      componentOf: [
        "border-style",
        "border-top"
      ],
      defaultValue: "none"
    },
    "border-top-width": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "border-top",
        "border-width"
      ],
      defaultValue: "medium",
      oppositeTo: "border-bottom-width",
      shortestValue: "0"
    },
    "border-width": {
      breakUp: breakUp.fourValues,
      canOverride: canOverride.generic.components([
        canOverride.generic.unit,
        canOverride.generic.unit,
        canOverride.generic.unit,
        canOverride.generic.unit
      ]),
      componentOf: [
        "border"
      ],
      components: [
        "border-top-width",
        "border-right-width",
        "border-bottom-width",
        "border-left-width"
      ],
      defaultValue: "medium",
      restore: restore.fourValues,
      shortestValue: "0",
      shorthand: true
    },
    clear: {
      canOverride: canOverride.property.clear,
      defaultValue: "none"
    },
    color: {
      canOverride: canOverride.generic.color,
      defaultValue: "transparent",
      shortestValue: "red"
    },
    cursor: {
      canOverride: canOverride.property.cursor,
      defaultValue: "auto"
    },
    display: {
      canOverride: canOverride.property.display
    },
    float: {
      canOverride: canOverride.property.float,
      defaultValue: "none"
    },
    font: {
      breakUp: breakUp.font,
      canOverride: canOverride.generic.components([
        canOverride.property.fontStyle,
        canOverride.property.fontVariant,
        canOverride.property.fontWeight,
        canOverride.property.fontStretch,
        canOverride.generic.unit,
        canOverride.generic.unit,
        canOverride.property.fontFamily
      ]),
      components: [
        "font-style",
        "font-variant",
        "font-weight",
        "font-stretch",
        "font-size",
        "line-height",
        "font-family"
      ],
      restore: restore.font,
      shorthand: true
    },
    "font-family": {
      canOverride: canOverride.property.fontFamily,
      defaultValue: "user|agent|specific"
    },
    "font-size": {
      canOverride: canOverride.generic.unit,
      defaultValue: "medium",
      shortestValue: "0"
    },
    "font-stretch": {
      canOverride: canOverride.property.fontStretch,
      defaultValue: "normal"
    },
    "font-style": {
      canOverride: canOverride.property.fontStyle,
      defaultValue: "normal"
    },
    "font-variant": {
      canOverride: canOverride.property.fontVariant,
      defaultValue: "normal"
    },
    "font-weight": {
      canOverride: canOverride.property.fontWeight,
      defaultValue: "normal",
      shortestValue: "400"
    },
    height: {
      canOverride: canOverride.generic.unit,
      defaultValue: "auto",
      shortestValue: "0"
    },
    left: {
      canOverride: canOverride.property.left,
      defaultValue: "auto"
    },
    "line-height": {
      canOverride: canOverride.generic.unitOrNumber,
      defaultValue: "normal",
      shortestValue: "0"
    },
    "list-style": {
      canOverride: canOverride.generic.components([
        canOverride.property.listStyleType,
        canOverride.property.listStylePosition,
        canOverride.property.listStyleImage
      ]),
      components: [
        "list-style-type",
        "list-style-position",
        "list-style-image"
      ],
      breakUp: breakUp.listStyle,
      restore: restore.withoutDefaults,
      defaultValue: "outside",
      shortestValue: "none",
      shorthand: true
    },
    "list-style-image": {
      canOverride: canOverride.generic.image,
      componentOf: [
        "list-style"
      ],
      defaultValue: "none"
    },
    "list-style-position": {
      canOverride: canOverride.property.listStylePosition,
      componentOf: [
        "list-style"
      ],
      defaultValue: "outside",
      shortestValue: "inside"
    },
    "list-style-type": {
      canOverride: canOverride.property.listStyleType,
      componentOf: [
        "list-style"
      ],
      defaultValue: "decimal|disc",
      shortestValue: "none"
    },
    margin: {
      breakUp: breakUp.fourValues,
      canOverride: canOverride.generic.components([
        canOverride.generic.unit,
        canOverride.generic.unit,
        canOverride.generic.unit,
        canOverride.generic.unit
      ]),
      components: [
        "margin-top",
        "margin-right",
        "margin-bottom",
        "margin-left"
      ],
      defaultValue: "0",
      restore: restore.fourValues,
      shorthand: true
    },
    "margin-bottom": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "margin"
      ],
      defaultValue: "0",
      oppositeTo: "margin-top"
    },
    "margin-left": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "margin"
      ],
      defaultValue: "0",
      oppositeTo: "margin-right"
    },
    "margin-right": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "margin"
      ],
      defaultValue: "0",
      oppositeTo: "margin-left"
    },
    "margin-top": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "margin"
      ],
      defaultValue: "0",
      oppositeTo: "margin-bottom"
    },
    outline: {
      canOverride: canOverride.generic.components([
        canOverride.generic.color,
        canOverride.property.outlineStyle,
        canOverride.generic.unit
      ]),
      components: [
        "outline-color",
        "outline-style",
        "outline-width"
      ],
      breakUp: breakUp.outline,
      restore: restore.withoutDefaults,
      defaultValue: "0",
      shorthand: true
    },
    "outline-color": {
      canOverride: canOverride.generic.color,
      componentOf: [
        "outline"
      ],
      defaultValue: "invert",
      shortestValue: "red"
    },
    "outline-style": {
      canOverride: canOverride.property.outlineStyle,
      componentOf: [
        "outline"
      ],
      defaultValue: "none"
    },
    "outline-width": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "outline"
      ],
      defaultValue: "medium",
      shortestValue: "0"
    },
    overflow: {
      canOverride: canOverride.property.overflow,
      defaultValue: "visible"
    },
    "overflow-x": {
      canOverride: canOverride.property.overflow,
      defaultValue: "visible"
    },
    "overflow-y": {
      canOverride: canOverride.property.overflow,
      defaultValue: "visible"
    },
    padding: {
      breakUp: breakUp.fourValues,
      canOverride: canOverride.generic.components([
        canOverride.generic.unit,
        canOverride.generic.unit,
        canOverride.generic.unit,
        canOverride.generic.unit
      ]),
      components: [
        "padding-top",
        "padding-right",
        "padding-bottom",
        "padding-left"
      ],
      defaultValue: "0",
      restore: restore.fourValues,
      shorthand: true
    },
    "padding-bottom": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "padding"
      ],
      defaultValue: "0",
      oppositeTo: "padding-top"
    },
    "padding-left": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "padding"
      ],
      defaultValue: "0",
      oppositeTo: "padding-right"
    },
    "padding-right": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "padding"
      ],
      defaultValue: "0",
      oppositeTo: "padding-left"
    },
    "padding-top": {
      canOverride: canOverride.generic.unit,
      componentOf: [
        "padding"
      ],
      defaultValue: "0",
      oppositeTo: "padding-bottom"
    },
    position: {
      canOverride: canOverride.property.position,
      defaultValue: "static"
    },
    right: {
      canOverride: canOverride.property.right,
      defaultValue: "auto"
    },
    "text-align": {
      canOverride: canOverride.property.textAlign,
      defaultValue: "left|right"
    },
    "text-decoration": {
      canOverride: canOverride.property.textDecoration,
      defaultValue: "none"
    },
    "text-overflow": {
      canOverride: canOverride.property.textOverflow,
      defaultValue: "none"
    },
    "text-shadow": {
      canOverride: canOverride.property.textShadow,
      defaultValue: "none"
    },
    top: {
      canOverride: canOverride.property.top,
      defaultValue: "auto"
    },
    transform: {
      canOverride: canOverride.property.transform,
      vendorPrefixes: [
        "-moz-",
        "-ms-",
        "-webkit-"
      ]
    },
    transition: {
      breakUp: breakUp.multiplex(breakUp.transition),
      canOverride: canOverride.generic.components([
        canOverride.property.transitionProperty,
        canOverride.generic.time,
        canOverride.generic.timingFunction,
        canOverride.generic.time
      ]),
      components: [
        "transition-property",
        "transition-duration",
        "transition-timing-function",
        "transition-delay"
      ],
      defaultValue: "none",
      restore: restore.multiplex(restore.withoutDefaults),
      shorthand: true,
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "transition-delay": {
      canOverride: canOverride.generic.time,
      componentOf: [
        "transition"
      ],
      defaultValue: "0s",
      intoMultiplexMode: "real",
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "transition-duration": {
      canOverride: canOverride.generic.time,
      componentOf: [
        "transition"
      ],
      defaultValue: "0s",
      intoMultiplexMode: "real",
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "transition-property": {
      canOverride: canOverride.generic.propertyName,
      componentOf: [
        "transition"
      ],
      defaultValue: "all",
      intoMultiplexMode: "placeholder",
      placeholderValue: "_",
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "transition-timing-function": {
      canOverride: canOverride.generic.timingFunction,
      componentOf: [
        "transition"
      ],
      defaultValue: "ease",
      intoMultiplexMode: "real",
      vendorPrefixes: [
        "-moz-",
        "-o-",
        "-webkit-"
      ]
    },
    "vertical-align": {
      canOverride: canOverride.property.verticalAlign,
      defaultValue: "baseline"
    },
    visibility: {
      canOverride: canOverride.property.visibility,
      defaultValue: "visible"
    },
    "white-space": {
      canOverride: canOverride.property.whiteSpace,
      defaultValue: "normal"
    },
    width: {
      canOverride: canOverride.generic.unit,
      defaultValue: "auto",
      shortestValue: "0"
    },
    "z-index": {
      canOverride: canOverride.property.zIndex,
      defaultValue: "auto"
    }
  };
  var vendorPrefixedCompactable = {};
  for (propertyName in compactable) {
    descriptor = compactable[propertyName];
    if (!("vendorPrefixes" in descriptor)) {
      continue;
    }
    for (i = 0;i < descriptor.vendorPrefixes.length; i++) {
      prefix = descriptor.vendorPrefixes[i];
      clonedDescriptor = cloneDescriptor(propertyName, prefix);
      delete clonedDescriptor.vendorPrefixes;
      vendorPrefixedCompactable[prefix + propertyName] = clonedDescriptor;
    }
    delete descriptor.vendorPrefixes;
  }
  var descriptor;
  var prefix;
  var clonedDescriptor;
  var i;
  var propertyName;
  module.exports = override(compactable, vendorPrefixedCompactable);
});

// node_modules/clean-css/lib/optimizer/level-2/properties/populate-components.js
var require_populate_components = __commonJS((exports, module) => {
  var populateComponents = function(properties, validator, warnings) {
    var component;
    var j, m;
    for (var i = properties.length - 1;i >= 0; i--) {
      var property = properties[i];
      var descriptor = compactable[property.name];
      if (descriptor && descriptor.shorthand) {
        property.shorthand = true;
        property.dirty = true;
        try {
          property.components = descriptor.breakUp(property, compactable, validator);
          if (descriptor.shorthandComponents) {
            for (j = 0, m = property.components.length;j < m; j++) {
              component = property.components[j];
              component.components = compactable[component.name].breakUp(component, compactable, validator);
            }
          }
        } catch (e) {
          if (e instanceof InvalidPropertyError) {
            property.components = [];
            warnings.push(e.message);
          } else {
            throw e;
          }
        }
        if (property.components.length > 0)
          property.multiplex = property.components[0].multiplex;
        else
          property.unused = true;
      }
    }
  };
  var compactable = require_compactable();
  var InvalidPropertyError = require_invalid_property_error();
  module.exports = populateComponents;
});

// node_modules/clean-css/lib/optimizer/level-2/restore-with-components.js
var require_restore_with_components = __commonJS((exports, module) => {
  var restoreWithComponents = function(property) {
    var descriptor = compactable[property.name];
    if (descriptor && descriptor.shorthand) {
      return descriptor.restore(property, compactable);
    } else {
      return property.value;
    }
  };
  var compactable = require_compactable();
  module.exports = restoreWithComponents;
});

// node_modules/clean-css/lib/optimizer/level-2/properties/merge-into-shorthands.js
var require_merge_into_shorthands = __commonJS((exports, module) => {
  var mergeIntoShorthands = function(properties, validator) {
    var candidates = {};
    var descriptor;
    var componentOf;
    var property;
    var i, l;
    var j, m;
    if (properties.length < 3) {
      return;
    }
    for (i = 0, l = properties.length;i < l; i++) {
      property = properties[i];
      descriptor = compactable[property.name];
      if (property.unused) {
        continue;
      }
      if (property.hack) {
        continue;
      }
      if (property.block) {
        continue;
      }
      invalidateOrCompact(properties, i, candidates, validator);
      if (descriptor && descriptor.componentOf) {
        for (j = 0, m = descriptor.componentOf.length;j < m; j++) {
          componentOf = descriptor.componentOf[j];
          candidates[componentOf] = candidates[componentOf] || {};
          candidates[componentOf][property.name] = property;
        }
      }
    }
    invalidateOrCompact(properties, i, candidates, validator);
  };
  var invalidateOrCompact = function(properties, position, candidates, validator) {
    var invalidatedBy = properties[position];
    var shorthandName;
    var shorthandDescriptor;
    var candidateComponents;
    for (shorthandName in candidates) {
      if (invalidatedBy !== undefined && shorthandName == invalidatedBy.name) {
        continue;
      }
      shorthandDescriptor = compactable[shorthandName];
      candidateComponents = candidates[shorthandName];
      if (invalidatedBy && invalidates(candidates, shorthandName, invalidatedBy)) {
        delete candidates[shorthandName];
        continue;
      }
      if (shorthandDescriptor.components.length > Object.keys(candidateComponents).length) {
        continue;
      }
      if (mixedImportance(candidateComponents)) {
        continue;
      }
      if (!overridable(candidateComponents, shorthandName, validator)) {
        continue;
      }
      if (!mergeable(candidateComponents)) {
        continue;
      }
      if (mixedInherit(candidateComponents)) {
        replaceWithInheritBestFit(properties, candidateComponents, shorthandName, validator);
      } else {
        replaceWithShorthand(properties, candidateComponents, shorthandName, validator);
      }
    }
  };
  var invalidates = function(candidates, shorthandName, invalidatedBy) {
    var shorthandDescriptor = compactable[shorthandName];
    var invalidatedByDescriptor = compactable[invalidatedBy.name];
    var componentName;
    if ("overridesShorthands" in shorthandDescriptor && shorthandDescriptor.overridesShorthands.indexOf(invalidatedBy.name) > -1) {
      return true;
    }
    if (invalidatedByDescriptor && "componentOf" in invalidatedByDescriptor) {
      for (componentName in candidates[shorthandName]) {
        if (invalidatedByDescriptor.componentOf.indexOf(componentName) > -1) {
          return true;
        }
      }
    }
    return false;
  };
  var mixedImportance = function(components) {
    var important;
    var componentName;
    for (componentName in components) {
      if (important !== undefined && components[componentName].important != important) {
        return true;
      }
      important = components[componentName].important;
    }
    return false;
  };
  var overridable = function(components, shorthandName, validator) {
    var descriptor = compactable[shorthandName];
    var newValuePlaceholder = [
      Token.PROPERTY,
      [Token.PROPERTY_NAME, shorthandName],
      [Token.PROPERTY_VALUE, descriptor.defaultValue]
    ];
    var newProperty = wrapSingle(newValuePlaceholder);
    var component;
    var mayOverride;
    var i, l;
    populateComponents([newProperty], validator, []);
    for (i = 0, l = descriptor.components.length;i < l; i++) {
      component = components[descriptor.components[i]];
      mayOverride = compactable[component.name].canOverride;
      if (!everyValuesPair(mayOverride.bind(null, validator), newProperty.components[i], component)) {
        return false;
      }
    }
    return true;
  };
  var mergeable = function(components) {
    var lastCount = null;
    var currentCount;
    var componentName;
    var component;
    var descriptor;
    var values;
    for (componentName in components) {
      component = components[componentName];
      descriptor = compactable[componentName];
      if (!("restore" in descriptor)) {
        continue;
      }
      restoreFromOptimizing([component.all[component.position]], restoreWithComponents);
      values = descriptor.restore(component, compactable);
      currentCount = values.length;
      if (lastCount !== null && currentCount !== lastCount) {
        return false;
      }
      lastCount = currentCount;
    }
    return true;
  };
  var mixedInherit = function(components) {
    var componentName;
    var lastValue = null;
    var currentValue;
    for (componentName in components) {
      currentValue = hasInherit(components[componentName]);
      if (lastValue !== null && lastValue !== currentValue) {
        return true;
      }
      lastValue = currentValue;
    }
    return false;
  };
  var replaceWithInheritBestFit = function(properties, candidateComponents, shorthandName, validator) {
    var viaLonghands = buildSequenceWithInheritLonghands(candidateComponents, shorthandName, validator);
    var viaShorthand = buildSequenceWithInheritShorthand(candidateComponents, shorthandName, validator);
    var longhandTokensSequence = viaLonghands[0];
    var shorthandTokensSequence = viaShorthand[0];
    var isLonghandsShorter = serializeBody(longhandTokensSequence).length < serializeBody(shorthandTokensSequence).length;
    var newTokensSequence = isLonghandsShorter ? longhandTokensSequence : shorthandTokensSequence;
    var newProperty = isLonghandsShorter ? viaLonghands[1] : viaShorthand[1];
    var newComponents = isLonghandsShorter ? viaLonghands[2] : viaShorthand[2];
    var all2 = candidateComponents[Object.keys(candidateComponents)[0]].all;
    var componentName;
    var oldComponent;
    var newComponent;
    var newToken;
    newProperty.position = all2.length;
    newProperty.shorthand = true;
    newProperty.dirty = true;
    newProperty.all = all2;
    newProperty.all.push(newTokensSequence[0]);
    properties.push(newProperty);
    for (componentName in candidateComponents) {
      oldComponent = candidateComponents[componentName];
      oldComponent.unused = true;
      if (oldComponent.name in newComponents) {
        newComponent = newComponents[oldComponent.name];
        newToken = findTokenIn(newTokensSequence, componentName);
        newComponent.position = all2.length;
        newComponent.all = all2;
        newComponent.all.push(newToken);
        properties.push(newComponent);
      }
    }
  };
  var buildSequenceWithInheritLonghands = function(components, shorthandName, validator) {
    var tokensSequence = [];
    var inheritComponents = {};
    var nonInheritComponents = {};
    var descriptor = compactable[shorthandName];
    var shorthandToken = [
      Token.PROPERTY,
      [Token.PROPERTY_NAME, shorthandName],
      [Token.PROPERTY_VALUE, descriptor.defaultValue]
    ];
    var newProperty = wrapSingle(shorthandToken);
    var component;
    var longhandToken;
    var newComponent;
    var nameMetadata;
    var i, l;
    populateComponents([newProperty], validator, []);
    for (i = 0, l = descriptor.components.length;i < l; i++) {
      component = components[descriptor.components[i]];
      if (hasInherit(component)) {
        longhandToken = component.all[component.position].slice(0, 2);
        Array.prototype.push.apply(longhandToken, component.value);
        tokensSequence.push(longhandToken);
        newComponent = deepClone(component);
        newComponent.value = inferComponentValue(components, newComponent.name);
        newProperty.components[i] = newComponent;
        inheritComponents[component.name] = deepClone(component);
      } else {
        newComponent = deepClone(component);
        newComponent.all = component.all;
        newProperty.components[i] = newComponent;
        nonInheritComponents[component.name] = component;
      }
    }
    nameMetadata = joinMetadata(nonInheritComponents, 1);
    shorthandToken[1].push(nameMetadata);
    restoreFromOptimizing([newProperty], restoreWithComponents);
    shorthandToken = shorthandToken.slice(0, 2);
    Array.prototype.push.apply(shorthandToken, newProperty.value);
    tokensSequence.unshift(shorthandToken);
    return [tokensSequence, newProperty, inheritComponents];
  };
  var inferComponentValue = function(components, propertyName) {
    var descriptor = compactable[propertyName];
    if ("oppositeTo" in descriptor) {
      return components[descriptor.oppositeTo].value;
    } else {
      return [[Token.PROPERTY_VALUE, descriptor.defaultValue]];
    }
  };
  var joinMetadata = function(components, at) {
    var metadata = [];
    var component;
    var originalValue;
    var componentMetadata;
    var componentName;
    for (componentName in components) {
      component = components[componentName];
      originalValue = component.all[component.position];
      componentMetadata = originalValue[at][originalValue[at].length - 1];
      Array.prototype.push.apply(metadata, componentMetadata);
    }
    return metadata.sort(metadataSorter);
  };
  var metadataSorter = function(metadata1, metadata2) {
    var line1 = metadata1[0];
    var line2 = metadata2[0];
    var column1 = metadata1[1];
    var column2 = metadata2[1];
    if (line1 < line2) {
      return -1;
    } else if (line1 === line2) {
      return column1 < column2 ? -1 : 1;
    } else {
      return 1;
    }
  };
  var buildSequenceWithInheritShorthand = function(components, shorthandName, validator) {
    var tokensSequence = [];
    var inheritComponents = {};
    var nonInheritComponents = {};
    var descriptor = compactable[shorthandName];
    var shorthandToken = [
      Token.PROPERTY,
      [Token.PROPERTY_NAME, shorthandName],
      [Token.PROPERTY_VALUE, "inherit"]
    ];
    var newProperty = wrapSingle(shorthandToken);
    var component;
    var longhandToken;
    var nameMetadata;
    var valueMetadata;
    var i, l;
    populateComponents([newProperty], validator, []);
    for (i = 0, l = descriptor.components.length;i < l; i++) {
      component = components[descriptor.components[i]];
      if (hasInherit(component)) {
        inheritComponents[component.name] = component;
      } else {
        longhandToken = component.all[component.position].slice(0, 2);
        Array.prototype.push.apply(longhandToken, component.value);
        tokensSequence.push(longhandToken);
        nonInheritComponents[component.name] = deepClone(component);
      }
    }
    nameMetadata = joinMetadata(inheritComponents, 1);
    shorthandToken[1].push(nameMetadata);
    valueMetadata = joinMetadata(inheritComponents, 2);
    shorthandToken[2].push(valueMetadata);
    tokensSequence.unshift(shorthandToken);
    return [tokensSequence, newProperty, nonInheritComponents];
  };
  var findTokenIn = function(tokens, componentName) {
    var i, l;
    for (i = 0, l = tokens.length;i < l; i++) {
      if (tokens[i][1][1] == componentName) {
        return tokens[i];
      }
    }
  };
  var replaceWithShorthand = function(properties, candidateComponents, shorthandName, validator) {
    var descriptor = compactable[shorthandName];
    var nameMetadata;
    var valueMetadata;
    var newValuePlaceholder = [
      Token.PROPERTY,
      [Token.PROPERTY_NAME, shorthandName],
      [Token.PROPERTY_VALUE, descriptor.defaultValue]
    ];
    var all2;
    var newProperty = wrapSingle(newValuePlaceholder);
    newProperty.shorthand = true;
    newProperty.dirty = true;
    populateComponents([newProperty], validator, []);
    for (var i = 0, l = descriptor.components.length;i < l; i++) {
      var component = candidateComponents[descriptor.components[i]];
      newProperty.components[i] = deepClone(component);
      newProperty.important = component.important;
      all2 = component.all;
    }
    for (var componentName in candidateComponents) {
      candidateComponents[componentName].unused = true;
    }
    nameMetadata = joinMetadata(candidateComponents, 1);
    newValuePlaceholder[1].push(nameMetadata);
    valueMetadata = joinMetadata(candidateComponents, 2);
    newValuePlaceholder[2].push(valueMetadata);
    newProperty.position = all2.length;
    newProperty.all = all2;
    newProperty.all.push(newValuePlaceholder);
    properties.push(newProperty);
  };
  var everyValuesPair = require_every_values_pair();
  var hasInherit = require_has_inherit();
  var populateComponents = require_populate_components();
  var compactable = require_compactable();
  var deepClone = require_clone().deep;
  var restoreWithComponents = require_restore_with_components();
  var restoreFromOptimizing = require_restore_from_optimizing();
  var wrapSingle = require_wrap_for_optimizing().single;
  var serializeBody = require_one_time().body;
  var Token = require_token();
  module.exports = mergeIntoShorthands;
});

// node_modules/clean-css/lib/optimizer/level-2/properties/find-component-in.js
var require_find_component_in = __commonJS((exports, module) => {
  var findComponentIn = function(shorthand, longhand) {
    var comparator = nameComparator(longhand);
    return findInDirectComponents(shorthand, comparator) || findInSubComponents(shorthand, comparator);
  };
  var nameComparator = function(to) {
    return function(property) {
      return to.name === property.name;
    };
  };
  var findInDirectComponents = function(shorthand, comparator) {
    return shorthand.components.filter(comparator)[0];
  };
  var findInSubComponents = function(shorthand, comparator) {
    var shorthandComponent;
    var longhandMatch;
    var i, l;
    if (!compactable[shorthand.name].shorthandComponents) {
      return;
    }
    for (i = 0, l = shorthand.components.length;i < l; i++) {
      shorthandComponent = shorthand.components[i];
      longhandMatch = findInDirectComponents(shorthandComponent, comparator);
      if (longhandMatch) {
        return longhandMatch;
      }
    }
    return;
  };
  var compactable = require_compactable();
  module.exports = findComponentIn;
});

// node_modules/clean-css/lib/optimizer/level-2/properties/is-component-of.js
var require_is_component_of = __commonJS((exports, module) => {
  var isComponentOf = function(property1, property2, shallow) {
    return isDirectComponentOf(property1, property2) || !shallow && !!compactable[property1.name].shorthandComponents && isSubComponentOf(property1, property2);
  };
  var isDirectComponentOf = function(property1, property2) {
    var descriptor = compactable[property1.name];
    return "components" in descriptor && descriptor.components.indexOf(property2.name) > -1;
  };
  var isSubComponentOf = function(property1, property2) {
    return property1.components.some(function(component) {
      return isDirectComponentOf(component, property2);
    });
  };
  var compactable = require_compactable();
  module.exports = isComponentOf;
});

// node_modules/clean-css/lib/optimizer/level-2/properties/is-mergeable-shorthand.js
var require_is_mergeable_shorthand = __commonJS((exports, module) => {
  var isMergeableShorthand = function(shorthand) {
    if (shorthand.name != "font") {
      return true;
    }
    return shorthand.value[0][1].indexOf(Marker.INTERNAL) == -1;
  };
  var Marker = require_marker();
  module.exports = isMergeableShorthand;
});

// node_modules/clean-css/lib/optimizer/level-2/properties/overrides-non-component-shorthand.js
var require_overrides_non_component_shorthand = __commonJS((exports, module) => {
  var overridesNonComponentShorthand = function(property1, property2) {
    return property1.name in compactable && "overridesShorthands" in compactable[property1.name] && compactable[property1.name].overridesShorthands.indexOf(property2.name) > -1;
  };
  var compactable = require_compactable();
  module.exports = overridesNonComponentShorthand;
});

// node_modules/clean-css/lib/optimizer/level-2/properties/override-properties.js
var require_override_properties = __commonJS((exports, module) => {
  var wouldBreakCompatibility = function(property, validator) {
    for (var i = 0;i < property.components.length; i++) {
      var component = property.components[i];
      var descriptor = compactable[component.name];
      var canOverride = descriptor && descriptor.canOverride || canOverride.sameValue;
      var _component = shallowClone(component);
      _component.value = [[Token.PROPERTY_VALUE, descriptor.defaultValue]];
      if (!everyValuesPair(canOverride.bind(null, validator), _component, component)) {
        return true;
      }
    }
    return false;
  };
  var overrideIntoMultiplex = function(property, by) {
    by.unused = true;
    turnIntoMultiplex(by, multiplexSize(property));
    property.value = by.value;
  };
  var overrideByMultiplex = function(property, by) {
    by.unused = true;
    property.multiplex = true;
    property.value = by.value;
  };
  var overrideSimple = function(property, by) {
    by.unused = true;
    property.value = by.value;
  };
  var override = function(property, by) {
    if (by.multiplex)
      overrideByMultiplex(property, by);
    else if (property.multiplex)
      overrideIntoMultiplex(property, by);
    else
      overrideSimple(property, by);
  };
  var overrideShorthand = function(property, by) {
    by.unused = true;
    for (var i = 0, l = property.components.length;i < l; i++) {
      override(property.components[i], by.components[i], property.multiplex);
    }
  };
  var turnIntoMultiplex = function(property, size) {
    property.multiplex = true;
    if (compactable[property.name].shorthand) {
      turnShorthandValueIntoMultiplex(property, size);
    } else {
      turnLonghandValueIntoMultiplex(property, size);
    }
  };
  var turnShorthandValueIntoMultiplex = function(property, size) {
    var component;
    var i, l;
    for (i = 0, l = property.components.length;i < l; i++) {
      component = property.components[i];
      if (!component.multiplex) {
        turnLonghandValueIntoMultiplex(component, size);
      }
    }
  };
  var turnLonghandValueIntoMultiplex = function(property, size) {
    var descriptor = compactable[property.name];
    var withRealValue = descriptor.intoMultiplexMode == "real";
    var withValue = descriptor.intoMultiplexMode == "real" ? property.value.slice(0) : descriptor.intoMultiplexMode == "placeholder" ? descriptor.placeholderValue : descriptor.defaultValue;
    var i = multiplexSize(property);
    var j;
    var m = withValue.length;
    for (;i < size; i++) {
      property.value.push([Token.PROPERTY_VALUE, Marker.COMMA]);
      if (Array.isArray(withValue)) {
        for (j = 0;j < m; j++) {
          property.value.push(withRealValue ? withValue[j] : [Token.PROPERTY_VALUE, withValue[j]]);
        }
      } else {
        property.value.push(withRealValue ? withValue : [Token.PROPERTY_VALUE, withValue]);
      }
    }
  };
  var multiplexSize = function(component) {
    var size = 0;
    for (var i = 0, l = component.value.length;i < l; i++) {
      if (component.value[i][1] == Marker.COMMA)
        size++;
    }
    return size + 1;
  };
  var lengthOf = function(property) {
    var fakeAsArray = [
      Token.PROPERTY,
      [Token.PROPERTY_NAME, property.name]
    ].concat(property.value);
    return serializeProperty([fakeAsArray], 0).length;
  };
  var moreSameShorthands = function(properties, startAt, name) {
    var count = 0;
    for (var i = startAt;i >= 0; i--) {
      if (properties[i].name == name && !properties[i].unused)
        count++;
      if (count > 1)
        break;
    }
    return count > 1;
  };
  var overridingFunction = function(shorthand, validator) {
    for (var i = 0, l = shorthand.components.length;i < l; i++) {
      if (!anyValue(validator.isUrl, shorthand.components[i]) && anyValue(validator.isFunction, shorthand.components[i])) {
        return true;
      }
    }
    return false;
  };
  var anyValue = function(fn, property) {
    for (var i = 0, l = property.value.length;i < l; i++) {
      if (property.value[i][1] == Marker.COMMA)
        continue;
      if (fn(property.value[i][1]))
        return true;
    }
    return false;
  };
  var wouldResultInLongerValue = function(left, right) {
    if (!left.multiplex && !right.multiplex || left.multiplex && right.multiplex)
      return false;
    var multiplex = left.multiplex ? left : right;
    var simple = left.multiplex ? right : left;
    var component;
    var multiplexClone = deepClone(multiplex);
    restoreFromOptimizing([multiplexClone], restoreWithComponents);
    var simpleClone = deepClone(simple);
    restoreFromOptimizing([simpleClone], restoreWithComponents);
    var lengthBefore = lengthOf(multiplexClone) + 1 + lengthOf(simpleClone);
    if (left.multiplex) {
      component = findComponentIn(multiplexClone, simpleClone);
      overrideIntoMultiplex(component, simpleClone);
    } else {
      component = findComponentIn(simpleClone, multiplexClone);
      turnIntoMultiplex(simpleClone, multiplexSize(multiplexClone));
      overrideByMultiplex(component, multiplexClone);
    }
    restoreFromOptimizing([simpleClone], restoreWithComponents);
    var lengthAfter = lengthOf(simpleClone);
    return lengthBefore <= lengthAfter;
  };
  var isCompactable = function(property) {
    return property.name in compactable;
  };
  var noneOverrideHack = function(left, right) {
    return !left.multiplex && (left.name == "background" || left.name == "background-image") && right.multiplex && (right.name == "background" || right.name == "background-image") && anyLayerIsNone(right.value);
  };
  var anyLayerIsNone = function(values) {
    var layers = intoLayers(values);
    for (var i = 0, l = layers.length;i < l; i++) {
      if (layers[i].length == 1 && layers[i][0][1] == "none")
        return true;
    }
    return false;
  };
  var intoLayers = function(values) {
    var layers = [];
    for (var i = 0, layer = [], l = values.length;i < l; i++) {
      var value = values[i];
      if (value[1] == Marker.COMMA) {
        layers.push(layer);
        layer = [];
      } else {
        layer.push(value);
      }
    }
    layers.push(layer);
    return layers;
  };
  var overrideProperties = function(properties, withMerging, compatibility, validator) {
    var mayOverride, right, left, component;
    var overriddenComponents;
    var overriddenComponent;
    var overridingComponent;
    var overridable;
    var i, j, k;
    propertyLoop:
      for (i = properties.length - 1;i >= 0; i--) {
        right = properties[i];
        if (!isCompactable(right))
          continue;
        if (right.block)
          continue;
        mayOverride = compactable[right.name].canOverride;
        traverseLoop:
          for (j = i - 1;j >= 0; j--) {
            left = properties[j];
            if (!isCompactable(left))
              continue;
            if (left.block)
              continue;
            if (left.unused || right.unused)
              continue;
            if (left.hack && !right.hack && !right.important || !left.hack && !left.important && right.hack)
              continue;
            if (left.important == right.important && left.hack[0] != right.hack[0])
              continue;
            if (left.important == right.important && (left.hack[0] != right.hack[0] || left.hack[1] && left.hack[1] != right.hack[1]))
              continue;
            if (hasInherit(right))
              continue;
            if (noneOverrideHack(left, right))
              continue;
            if (right.shorthand && isComponentOf(right, left)) {
              if (!right.important && left.important)
                continue;
              if (!sameVendorPrefixesIn([left], right.components))
                continue;
              if (!anyValue(validator.isFunction, left) && overridingFunction(right, validator))
                continue;
              if (!isMergeableShorthand(right)) {
                left.unused = true;
                continue;
              }
              component = findComponentIn(right, left);
              mayOverride = compactable[left.name].canOverride;
              if (everyValuesPair(mayOverride.bind(null, validator), left, component)) {
                left.unused = true;
              }
            } else if (right.shorthand && overridesNonComponentShorthand(right, left)) {
              if (!right.important && left.important) {
                continue;
              }
              if (!sameVendorPrefixesIn([left], right.components)) {
                continue;
              }
              if (!anyValue(validator.isFunction, left) && overridingFunction(right, validator)) {
                continue;
              }
              overriddenComponents = left.shorthand ? left.components : [left];
              for (k = overriddenComponents.length - 1;k >= 0; k--) {
                overriddenComponent = overriddenComponents[k];
                overridingComponent = findComponentIn(right, overriddenComponent);
                mayOverride = compactable[overriddenComponent.name].canOverride;
                if (!everyValuesPair(mayOverride.bind(null, validator), left, overridingComponent)) {
                  continue traverseLoop;
                }
              }
              left.unused = true;
            } else if (withMerging && left.shorthand && !right.shorthand && isComponentOf(left, right, true)) {
              if (right.important && !left.important)
                continue;
              if (!right.important && left.important) {
                right.unused = true;
                continue;
              }
              if (moreSameShorthands(properties, i - 1, left.name))
                continue;
              if (overridingFunction(left, validator))
                continue;
              if (!isMergeableShorthand(left))
                continue;
              component = findComponentIn(left, right);
              if (everyValuesPair(mayOverride.bind(null, validator), component, right)) {
                var disabledBackgroundMerging = !compatibility.properties.backgroundClipMerging && component.name.indexOf("background-clip") > -1 || !compatibility.properties.backgroundOriginMerging && component.name.indexOf("background-origin") > -1 || !compatibility.properties.backgroundSizeMerging && component.name.indexOf("background-size") > -1;
                var nonMergeableValue = compactable[right.name].nonMergeableValue === right.value[0][1];
                if (disabledBackgroundMerging || nonMergeableValue)
                  continue;
                if (!compatibility.properties.merging && wouldBreakCompatibility(left, validator))
                  continue;
                if (component.value[0][1] != right.value[0][1] && (hasInherit(left) || hasInherit(right)))
                  continue;
                if (wouldResultInLongerValue(left, right))
                  continue;
                if (!left.multiplex && right.multiplex)
                  turnIntoMultiplex(left, multiplexSize(right));
                override(component, right);
                left.dirty = true;
              }
            } else if (withMerging && left.shorthand && right.shorthand && left.name == right.name) {
              if (!left.multiplex && right.multiplex)
                continue;
              if (!right.important && left.important) {
                right.unused = true;
                continue propertyLoop;
              }
              if (right.important && !left.important) {
                left.unused = true;
                continue;
              }
              if (!isMergeableShorthand(right)) {
                left.unused = true;
                continue;
              }
              for (k = left.components.length - 1;k >= 0; k--) {
                var leftComponent = left.components[k];
                var rightComponent = right.components[k];
                mayOverride = compactable[leftComponent.name].canOverride;
                if (!everyValuesPair(mayOverride.bind(null, validator), leftComponent, rightComponent))
                  continue propertyLoop;
              }
              overrideShorthand(left, right);
              left.dirty = true;
            } else if (withMerging && left.shorthand && right.shorthand && isComponentOf(left, right)) {
              if (!left.important && right.important)
                continue;
              component = findComponentIn(left, right);
              mayOverride = compactable[right.name].canOverride;
              if (!everyValuesPair(mayOverride.bind(null, validator), component, right))
                continue;
              if (left.important && !right.important) {
                right.unused = true;
                continue;
              }
              var rightRestored = compactable[right.name].restore(right, compactable);
              if (rightRestored.length > 1)
                continue;
              component = findComponentIn(left, right);
              override(component, right);
              right.dirty = true;
            } else if (left.name == right.name) {
              overridable = true;
              if (right.shorthand) {
                for (k = right.components.length - 1;k >= 0 && overridable; k--) {
                  overriddenComponent = left.components[k];
                  overridingComponent = right.components[k];
                  mayOverride = compactable[overridingComponent.name].canOverride;
                  overridable = overridable && everyValuesPair(mayOverride.bind(null, validator), overriddenComponent, overridingComponent);
                }
              } else {
                mayOverride = compactable[right.name].canOverride;
                overridable = everyValuesPair(mayOverride.bind(null, validator), left, right);
              }
              if (left.important && !right.important && overridable) {
                right.unused = true;
                continue;
              }
              if (!left.important && right.important && overridable) {
                left.unused = true;
                continue;
              }
              if (!overridable) {
                continue;
              }
              left.unused = true;
            }
          }
      }
  };
  var hasInherit = require_has_inherit();
  var everyValuesPair = require_every_values_pair();
  var findComponentIn = require_find_component_in();
  var isComponentOf = require_is_component_of();
  var isMergeableShorthand = require_is_mergeable_shorthand();
  var overridesNonComponentShorthand = require_overrides_non_component_shorthand();
  var sameVendorPrefixesIn = require_vendor_prefixes().same;
  var compactable = require_compactable();
  var deepClone = require_clone().deep;
  var restoreWithComponents = require_restore_with_components();
  var shallowClone = require_clone().shallow;
  var restoreFromOptimizing = require_restore_from_optimizing();
  var Token = require_token();
  var Marker = require_marker();
  var serializeProperty = require_one_time().property;
  module.exports = overrideProperties;
});

// node_modules/clean-css/lib/optimizer/level-2/properties/optimize.js
var require_optimize3 = __commonJS((exports, module) => {
  var optimizeProperties = function(properties, withOverriding, withMerging, context) {
    var levelOptions = context.options.level[OptimizationLevel.Two];
    var _properties = wrapForOptimizing(properties, false, levelOptions.skipProperties);
    var _property;
    var i, l;
    populateComponents(_properties, context.validator, context.warnings);
    for (i = 0, l = _properties.length;i < l; i++) {
      _property = _properties[i];
      if (_property.block) {
        optimizeProperties(_property.value[0][1], withOverriding, withMerging, context);
      }
    }
    if (withMerging && levelOptions.mergeIntoShorthands) {
      mergeIntoShorthands(_properties, context.validator);
    }
    if (withOverriding && levelOptions.overrideProperties) {
      overrideProperties(_properties, withMerging, context.options.compatibility, context.validator);
    }
    restoreFromOptimizing(_properties, restoreWithComponents);
    removeUnused(_properties);
  };
  var mergeIntoShorthands = require_merge_into_shorthands();
  var overrideProperties = require_override_properties();
  var populateComponents = require_populate_components();
  var restoreWithComponents = require_restore_with_components();
  var wrapForOptimizing = require_wrap_for_optimizing().all;
  var removeUnused = require_remove_unused();
  var restoreFromOptimizing = require_restore_from_optimizing();
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  module.exports = optimizeProperties;
});

// node_modules/clean-css/lib/optimizer/level-2/merge-adjacent.js
var require_merge_adjacent = __commonJS((exports, module) => {
  var mergeAdjacent = function(tokens, context) {
    var lastToken = [null, [], []];
    var options = context.options;
    var adjacentSpace = options.compatibility.selectors.adjacentSpace;
    var selectorsSortingMethod = options.level[OptimizationLevel.One].selectorsSortingMethod;
    var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;
    var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;
    var mergeLimit = options.compatibility.selectors.mergeLimit;
    var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;
    for (var i = 0, l = tokens.length;i < l; i++) {
      var token = tokens[i];
      if (token[0] != Token.RULE) {
        lastToken = [null, [], []];
        continue;
      }
      if (lastToken[0] == Token.RULE && serializeRules(token[1]) == serializeRules(lastToken[1])) {
        Array.prototype.push.apply(lastToken[2], token[2]);
        optimizeProperties(lastToken[2], true, true, context);
        token[2] = [];
      } else if (lastToken[0] == Token.RULE && serializeBody(token[2]) == serializeBody(lastToken[2]) && isMergeable(serializeRules(token[1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) && isMergeable(serializeRules(lastToken[1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) && lastToken[1].length < mergeLimit) {
        lastToken[1] = tidyRules(lastToken[1].concat(token[1]), false, adjacentSpace, false, context.warnings);
        lastToken[1] = lastToken.length > 1 ? sortSelectors(lastToken[1], selectorsSortingMethod) : lastToken[1];
        token[2] = [];
      } else {
        lastToken = token;
      }
    }
  };
  var isMergeable = require_is_mergeable();
  var optimizeProperties = require_optimize3();
  var sortSelectors = require_sort_selectors();
  var tidyRules = require_tidy_rules();
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  var serializeBody = require_one_time().body;
  var serializeRules = require_one_time().rules;
  var Token = require_token();
  module.exports = mergeAdjacent;
});

// node_modules/clean-css/lib/optimizer/level-2/rules-overlap.js
var require_rules_overlap = __commonJS((exports, module) => {
  var rulesOverlap = function(rule1, rule2, bemMode) {
    var scope1;
    var scope2;
    var i, l;
    var j, m;
    for (i = 0, l = rule1.length;i < l; i++) {
      scope1 = rule1[i][1];
      for (j = 0, m = rule2.length;j < m; j++) {
        scope2 = rule2[j][1];
        if (scope1 == scope2) {
          return true;
        }
        if (bemMode && withoutModifiers(scope1) == withoutModifiers(scope2)) {
          return true;
        }
      }
    }
    return false;
  };
  var withoutModifiers = function(scope) {
    return scope.replace(MODIFIER_PATTERN, "");
  };
  var MODIFIER_PATTERN = /\-\-.+$/;
  module.exports = rulesOverlap;
});

// node_modules/clean-css/lib/optimizer/level-2/specificity.js
var require_specificity = __commonJS((exports, module) => {
  var specificity = function(selector) {
    var result = [0, 0, 0];
    var character;
    var isEscaped;
    var isSingleQuoted;
    var isDoubleQuoted;
    var roundBracketLevel = 0;
    var couldIntroduceNewTypeSelector;
    var withinNotPseudoClass = false;
    var wasPseudoClass = false;
    var i, l;
    for (i = 0, l = selector.length;i < l; i++) {
      character = selector[i];
      if (isEscaped) {
      } else if (character == Marker.SINGLE_QUOTE && !isDoubleQuoted && !isSingleQuoted) {
        isSingleQuoted = true;
      } else if (character == Marker.SINGLE_QUOTE && !isDoubleQuoted && isSingleQuoted) {
        isSingleQuoted = false;
      } else if (character == Marker.DOUBLE_QUOTE && !isDoubleQuoted && !isSingleQuoted) {
        isDoubleQuoted = true;
      } else if (character == Marker.DOUBLE_QUOTE && isDoubleQuoted && !isSingleQuoted) {
        isDoubleQuoted = false;
      } else if (isSingleQuoted || isDoubleQuoted) {
        continue;
      } else if (roundBracketLevel > 0 && !withinNotPseudoClass) {
      } else if (character == Marker.OPEN_ROUND_BRACKET) {
        roundBracketLevel++;
      } else if (character == Marker.CLOSE_ROUND_BRACKET && roundBracketLevel == 1) {
        roundBracketLevel--;
        withinNotPseudoClass = false;
      } else if (character == Marker.CLOSE_ROUND_BRACKET) {
        roundBracketLevel--;
      } else if (character == Selector.HASH) {
        result[0]++;
      } else if (character == Selector.DOT || character == Marker.OPEN_SQUARE_BRACKET) {
        result[1]++;
      } else if (character == Selector.PSEUDO && !wasPseudoClass && !isNotPseudoClass(selector, i)) {
        result[1]++;
        withinNotPseudoClass = false;
      } else if (character == Selector.PSEUDO) {
        withinNotPseudoClass = true;
      } else if ((i === 0 || couldIntroduceNewTypeSelector) && LETTER_PATTERN.test(character)) {
        result[2]++;
      }
      isEscaped = character == Marker.BACK_SLASH;
      wasPseudoClass = character == Selector.PSEUDO;
      couldIntroduceNewTypeSelector = !isEscaped && SEPARATOR_PATTERN.test(character);
    }
    return result;
  };
  var isNotPseudoClass = function(selector, index) {
    return selector.indexOf(NOT_PREFIX, index) === index;
  };
  var Marker = require_marker();
  var Selector = {
    ADJACENT_SIBLING: "+",
    DESCENDANT: ">",
    DOT: ".",
    HASH: "#",
    NON_ADJACENT_SIBLING: "~",
    PSEUDO: ":"
  };
  var LETTER_PATTERN = /[a-zA-Z]/;
  var NOT_PREFIX = ":not(";
  var SEPARATOR_PATTERN = /[\s,\(>~\+]/;
  module.exports = specificity;
});

// node_modules/clean-css/lib/optimizer/level-2/specificities-overlap.js
var require_specificities_overlap = __commonJS((exports, module) => {
  var specificitiesOverlap = function(selector1, selector2, cache) {
    var specificity1;
    var specificity2;
    var i, l;
    var j, m;
    for (i = 0, l = selector1.length;i < l; i++) {
      specificity1 = findSpecificity(selector1[i][1], cache);
      for (j = 0, m = selector2.length;j < m; j++) {
        specificity2 = findSpecificity(selector2[j][1], cache);
        if (specificity1[0] === specificity2[0] && specificity1[1] === specificity2[1] && specificity1[2] === specificity2[2]) {
          return true;
        }
      }
    }
    return false;
  };
  var findSpecificity = function(selector, cache) {
    var value;
    if (!(selector in cache)) {
      cache[selector] = value = specificity(selector);
    }
    return value || cache[selector];
  };
  var specificity = require_specificity();
  module.exports = specificitiesOverlap;
});

// node_modules/clean-css/lib/optimizer/level-2/reorderable.js
var require_reorderable = __commonJS((exports, module) => {
  var canReorder = function(left, right, cache) {
    for (var i = right.length - 1;i >= 0; i--) {
      for (var j = left.length - 1;j >= 0; j--) {
        if (!canReorderSingle(left[j], right[i], cache))
          return false;
      }
    }
    return true;
  };
  var canReorderSingle = function(left, right, cache) {
    var leftName = left[0];
    var leftValue = left[1];
    var leftNameRoot = left[2];
    var leftSelector = left[5];
    var leftInSpecificSelector = left[6];
    var rightName = right[0];
    var rightValue = right[1];
    var rightNameRoot = right[2];
    var rightSelector = right[5];
    var rightInSpecificSelector = right[6];
    if (leftName == "font" && rightName == "line-height" || rightName == "font" && leftName == "line-height")
      return false;
    if (FLEX_PROPERTIES.test(leftName) && FLEX_PROPERTIES.test(rightName))
      return false;
    if (leftNameRoot == rightNameRoot && unprefixed(leftName) == unprefixed(rightName) && vendorPrefixed(leftName) ^ vendorPrefixed(rightName))
      return false;
    if (leftNameRoot == "border" && BORDER_PROPERTIES.test(rightNameRoot) && (leftName == "border" || leftName == rightNameRoot || leftValue != rightValue && sameBorderComponent(leftName, rightName)))
      return false;
    if (rightNameRoot == "border" && BORDER_PROPERTIES.test(leftNameRoot) && (rightName == "border" || rightName == leftNameRoot || leftValue != rightValue && sameBorderComponent(leftName, rightName)))
      return false;
    if (leftNameRoot == "border" && rightNameRoot == "border" && leftName != rightName && (isSideBorder(leftName) && isStyleBorder(rightName) || isStyleBorder(leftName) && isSideBorder(rightName)))
      return false;
    if (leftNameRoot != rightNameRoot)
      return true;
    if (leftName == rightName && leftNameRoot == rightNameRoot && (leftValue == rightValue || withDifferentVendorPrefix(leftValue, rightValue)))
      return true;
    if (leftName != rightName && leftNameRoot == rightNameRoot && leftName != leftNameRoot && rightName != rightNameRoot)
      return true;
    if (leftName != rightName && leftNameRoot == rightNameRoot && leftValue == rightValue)
      return true;
    if (rightInSpecificSelector && leftInSpecificSelector && !inheritable(leftNameRoot) && !inheritable(rightNameRoot) && !rulesOverlap(rightSelector, leftSelector, false))
      return true;
    if (!specificitiesOverlap(leftSelector, rightSelector, cache))
      return true;
    return false;
  };
  var vendorPrefixed = function(name) {
    return /^\-(?:moz|webkit|ms|o)\-/.test(name);
  };
  var unprefixed = function(name) {
    return name.replace(/^\-(?:moz|webkit|ms|o)\-/, "");
  };
  var sameBorderComponent = function(name1, name2) {
    return name1.split("-").pop() == name2.split("-").pop();
  };
  var isSideBorder = function(name) {
    return name == "border-top" || name == "border-right" || name == "border-bottom" || name == "border-left";
  };
  var isStyleBorder = function(name) {
    return name == "border-color" || name == "border-style" || name == "border-width";
  };
  var withDifferentVendorPrefix = function(value1, value2) {
    return vendorPrefixed(value1) && vendorPrefixed(value2) && value1.split("-")[1] != value2.split("-")[2];
  };
  var inheritable = function(name) {
    return name == "font" || name == "line-height" || name == "list-style";
  };
  var rulesOverlap = require_rules_overlap();
  var specificitiesOverlap = require_specificities_overlap();
  var FLEX_PROPERTIES = /align\-items|box\-align|box\-pack|flex|justify/;
  var BORDER_PROPERTIES = /^border\-(top|right|bottom|left|color|style|width|radius)/;
  module.exports = {
    canReorder,
    canReorderSingle
  };
});

// node_modules/clean-css/lib/optimizer/level-2/extract-properties.js
var require_extract_properties = __commonJS((exports, module) => {
  var extractProperties = function(token) {
    var properties = [];
    var inSpecificSelector;
    var property;
    var name;
    var value;
    var i, l;
    if (token[0] == Token.RULE) {
      inSpecificSelector = !/[\.\+>~]/.test(serializeRules(token[1]));
      for (i = 0, l = token[2].length;i < l; i++) {
        property = token[2][i];
        if (property[0] != Token.PROPERTY)
          continue;
        name = property[1][1];
        if (name.length === 0)
          continue;
        if (name.indexOf("--") === 0)
          continue;
        value = serializeValue(property, i);
        properties.push([
          name,
          value,
          findNameRoot(name),
          token[2][i],
          name + ":" + value,
          token[1],
          inSpecificSelector
        ]);
      }
    } else if (token[0] == Token.NESTED_BLOCK) {
      for (i = 0, l = token[2].length;i < l; i++) {
        properties = properties.concat(extractProperties(token[2][i]));
      }
    }
    return properties;
  };
  var findNameRoot = function(name) {
    if (name == "list-style")
      return name;
    if (name.indexOf("-radius") > 0)
      return "border-radius";
    if (name == "border-collapse" || name == "border-spacing" || name == "border-image")
      return name;
    if (name.indexOf("border-") === 0 && /^border\-\w+\-\w+$/.test(name))
      return name.match(/border\-\w+/)[0];
    if (name.indexOf("border-") === 0 && /^border\-\w+$/.test(name))
      return "border";
    if (name.indexOf("text-") === 0)
      return name;
    if (name == "-chrome-")
      return name;
    return name.replace(/^\-\w+\-/, "").match(/([a-zA-Z]+)/)[0].toLowerCase();
  };
  var Token = require_token();
  var serializeRules = require_one_time().rules;
  var serializeValue = require_one_time().value;
  module.exports = extractProperties;
});

// node_modules/clean-css/lib/optimizer/level-2/merge-media-queries.js
var require_merge_media_queries = __commonJS((exports, module) => {
  var mergeMediaQueries = function(tokens, context) {
    var mergeSemantically = context.options.level[OptimizationLevel.Two].mergeSemantically;
    var specificityCache = context.cache.specificity;
    var candidates = {};
    var reduced = [];
    for (var i = tokens.length - 1;i >= 0; i--) {
      var token = tokens[i];
      if (token[0] != Token.NESTED_BLOCK) {
        continue;
      }
      var key = serializeRules(token[1]);
      var candidate = candidates[key];
      if (!candidate) {
        candidate = [];
        candidates[key] = candidate;
      }
      candidate.push(i);
    }
    for (var name in candidates) {
      var positions = candidates[name];
      positionLoop:
        for (var j = positions.length - 1;j > 0; j--) {
          var positionOne = positions[j];
          var tokenOne = tokens[positionOne];
          var positionTwo = positions[j - 1];
          var tokenTwo = tokens[positionTwo];
          directionLoop:
            for (var direction = 1;direction >= -1; direction -= 2) {
              var topToBottom = direction == 1;
              var from = topToBottom ? positionOne + 1 : positionTwo - 1;
              var to = topToBottom ? positionTwo : positionOne;
              var delta = topToBottom ? 1 : -1;
              var source = topToBottom ? tokenOne : tokenTwo;
              var target = topToBottom ? tokenTwo : tokenOne;
              var movedProperties = extractProperties(source);
              while (from != to) {
                var traversedProperties = extractProperties(tokens[from]);
                from += delta;
                if (mergeSemantically && allSameRulePropertiesCanBeReordered(movedProperties, traversedProperties, specificityCache)) {
                  continue;
                }
                if (!canReorder(movedProperties, traversedProperties, specificityCache))
                  continue directionLoop;
              }
              target[2] = topToBottom ? source[2].concat(target[2]) : target[2].concat(source[2]);
              source[2] = [];
              reduced.push(target);
              continue positionLoop;
            }
        }
    }
    return reduced;
  };
  var allSameRulePropertiesCanBeReordered = function(movedProperties, traversedProperties, specificityCache) {
    var movedProperty;
    var movedRule;
    var traversedProperty;
    var traversedRule;
    var i, l;
    var j, m;
    for (i = 0, l = movedProperties.length;i < l; i++) {
      movedProperty = movedProperties[i];
      movedRule = movedProperty[5];
      for (j = 0, m = traversedProperties.length;j < m; j++) {
        traversedProperty = traversedProperties[j];
        traversedRule = traversedProperty[5];
        if (rulesOverlap(movedRule, traversedRule, true) && !canReorderSingle(movedProperty, traversedProperty, specificityCache)) {
          return false;
        }
      }
    }
    return true;
  };
  var canReorder = require_reorderable().canReorder;
  var canReorderSingle = require_reorderable().canReorderSingle;
  var extractProperties = require_extract_properties();
  var rulesOverlap = require_rules_overlap();
  var serializeRules = require_one_time().rules;
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  var Token = require_token();
  module.exports = mergeMediaQueries;
});

// node_modules/clean-css/lib/optimizer/level-2/merge-non-adjacent-by-body.js
var require_merge_non_adjacent_by_body = __commonJS((exports, module) => {
  var unsafeSelector = function(value) {
    return /\.|\*| :/.test(value);
  };
  var isBemElement = function(token) {
    var asString = serializeRules(token[1]);
    return asString.indexOf("__") > -1 || asString.indexOf("--") > -1;
  };
  var withoutModifier = function(selector) {
    return selector.replace(/--[^ ,>\+~:]+/g, "");
  };
  var removeAnyUnsafeElements = function(left, candidates) {
    var leftSelector = withoutModifier(serializeRules(left[1]));
    for (var body in candidates) {
      var right = candidates[body];
      var rightSelector = withoutModifier(serializeRules(right[1]));
      if (rightSelector.indexOf(leftSelector) > -1 || leftSelector.indexOf(rightSelector) > -1)
        delete candidates[body];
    }
  };
  var mergeNonAdjacentByBody = function(tokens, context) {
    var options = context.options;
    var mergeSemantically = options.level[OptimizationLevel.Two].mergeSemantically;
    var adjacentSpace = options.compatibility.selectors.adjacentSpace;
    var selectorsSortingMethod = options.level[OptimizationLevel.One].selectorsSortingMethod;
    var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;
    var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;
    var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;
    var candidates = {};
    for (var i = tokens.length - 1;i >= 0; i--) {
      var token = tokens[i];
      if (token[0] != Token.RULE)
        continue;
      if (token[2].length > 0 && (!mergeSemantically && unsafeSelector(serializeRules(token[1]))))
        candidates = {};
      if (token[2].length > 0 && mergeSemantically && isBemElement(token))
        removeAnyUnsafeElements(token, candidates);
      var candidateBody = serializeBody(token[2]);
      var oldToken = candidates[candidateBody];
      if (oldToken && isMergeable(serializeRules(token[1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) && isMergeable(serializeRules(oldToken[1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging)) {
        if (token[2].length > 0) {
          token[1] = tidyRules(oldToken[1].concat(token[1]), false, adjacentSpace, false, context.warnings);
          token[1] = token[1].length > 1 ? sortSelectors(token[1], selectorsSortingMethod) : token[1];
        } else {
          token[1] = oldToken[1].concat(token[1]);
        }
        oldToken[2] = [];
        candidates[candidateBody] = null;
      }
      candidates[serializeBody(token[2])] = token;
    }
  };
  var isMergeable = require_is_mergeable();
  var sortSelectors = require_sort_selectors();
  var tidyRules = require_tidy_rules();
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  var serializeBody = require_one_time().body;
  var serializeRules = require_one_time().rules;
  var Token = require_token();
  module.exports = mergeNonAdjacentByBody;
});

// node_modules/clean-css/lib/optimizer/level-2/merge-non-adjacent-by-selector.js
var require_merge_non_adjacent_by_selector = __commonJS((exports, module) => {
  var mergeNonAdjacentBySelector = function(tokens, context) {
    var specificityCache = context.cache.specificity;
    var allSelectors = {};
    var repeatedSelectors = [];
    var i;
    for (i = tokens.length - 1;i >= 0; i--) {
      if (tokens[i][0] != Token.RULE)
        continue;
      if (tokens[i][2].length === 0)
        continue;
      var selector = serializeRules(tokens[i][1]);
      allSelectors[selector] = [i].concat(allSelectors[selector] || []);
      if (allSelectors[selector].length == 2)
        repeatedSelectors.push(selector);
    }
    for (i = repeatedSelectors.length - 1;i >= 0; i--) {
      var positions = allSelectors[repeatedSelectors[i]];
      selectorIterator:
        for (var j = positions.length - 1;j > 0; j--) {
          var positionOne = positions[j - 1];
          var tokenOne = tokens[positionOne];
          var positionTwo = positions[j];
          var tokenTwo = tokens[positionTwo];
          directionIterator:
            for (var direction = 1;direction >= -1; direction -= 2) {
              var topToBottom = direction == 1;
              var from = topToBottom ? positionOne + 1 : positionTwo - 1;
              var to = topToBottom ? positionTwo : positionOne;
              var delta = topToBottom ? 1 : -1;
              var moved = topToBottom ? tokenOne : tokenTwo;
              var target = topToBottom ? tokenTwo : tokenOne;
              var movedProperties = extractProperties(moved);
              while (from != to) {
                var traversedProperties = extractProperties(tokens[from]);
                from += delta;
                var reorderable = topToBottom ? canReorder(movedProperties, traversedProperties, specificityCache) : canReorder(traversedProperties, movedProperties, specificityCache);
                if (!reorderable && !topToBottom)
                  continue selectorIterator;
                if (!reorderable && topToBottom)
                  continue directionIterator;
              }
              if (topToBottom) {
                Array.prototype.push.apply(moved[2], target[2]);
                target[2] = moved[2];
              } else {
                Array.prototype.push.apply(target[2], moved[2]);
              }
              optimizeProperties(target[2], true, true, context);
              moved[2] = [];
            }
        }
    }
  };
  var canReorder = require_reorderable().canReorder;
  var extractProperties = require_extract_properties();
  var optimizeProperties = require_optimize3();
  var serializeRules = require_one_time().rules;
  var Token = require_token();
  module.exports = mergeNonAdjacentBySelector;
});

// node_modules/clean-css/lib/utils/clone-array.js
var require_clone_array = __commonJS((exports, module) => {
  var cloneArray = function(array) {
    var cloned = array.slice(0);
    for (var i = 0, l = cloned.length;i < l; i++) {
      if (Array.isArray(cloned[i]))
        cloned[i] = cloneArray(cloned[i]);
    }
    return cloned;
  };
  module.exports = cloneArray;
});

// node_modules/clean-css/lib/optimizer/level-2/reduce-non-adjacent.js
var require_reduce_non_adjacent = __commonJS((exports, module) => {
  var reduceNonAdjacent = function(tokens, context) {
    var options = context.options;
    var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;
    var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;
    var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;
    var candidates = {};
    var repeated = [];
    for (var i = tokens.length - 1;i >= 0; i--) {
      var token = tokens[i];
      if (token[0] != Token.RULE) {
        continue;
      } else if (token[2].length === 0) {
        continue;
      }
      var selectorAsString = serializeRules(token[1]);
      var isComplexAndNotSpecial = token[1].length > 1 && isMergeable(selectorAsString, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging);
      var wrappedSelectors = wrappedSelectorsFrom(token[1]);
      var selectors = isComplexAndNotSpecial ? [selectorAsString].concat(wrappedSelectors) : [selectorAsString];
      for (var j = 0, m = selectors.length;j < m; j++) {
        var selector = selectors[j];
        if (!candidates[selector])
          candidates[selector] = [];
        else
          repeated.push(selector);
        candidates[selector].push({
          where: i,
          list: wrappedSelectors,
          isPartial: isComplexAndNotSpecial && j > 0,
          isComplex: isComplexAndNotSpecial && j === 0
        });
      }
    }
    reduceSimpleNonAdjacentCases(tokens, repeated, candidates, options, context);
    reduceComplexNonAdjacentCases(tokens, candidates, options, context);
  };
  var wrappedSelectorsFrom = function(list) {
    var wrapped = [];
    for (var i = 0;i < list.length; i++) {
      wrapped.push([list[i][1]]);
    }
    return wrapped;
  };
  var reduceSimpleNonAdjacentCases = function(tokens, repeated, candidates, options, context) {
    function filterOut(idx, bodies) {
      return data[idx].isPartial && bodies.length === 0;
    }
    function reduceBody(token, newBody, processedCount, tokenIdx) {
      if (!data[processedCount - tokenIdx - 1].isPartial)
        token[2] = newBody;
    }
    for (var i = 0, l = repeated.length;i < l; i++) {
      var selector = repeated[i];
      var data = candidates[selector];
      reduceSelector(tokens, data, {
        filterOut,
        callback: reduceBody
      }, options, context);
    }
  };
  var reduceComplexNonAdjacentCases = function(tokens, candidates, options, context) {
    var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;
    var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;
    var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;
    var localContext = {};
    function filterOut(idx) {
      return localContext.data[idx].where < localContext.intoPosition;
    }
    function collectReducedBodies(token, newBody, processedCount, tokenIdx) {
      if (tokenIdx === 0)
        localContext.reducedBodies.push(newBody);
    }
    allSelectors:
      for (var complexSelector in candidates) {
        var into = candidates[complexSelector];
        if (!into[0].isComplex)
          continue;
        var intoPosition = into[into.length - 1].where;
        var intoToken = tokens[intoPosition];
        var reducedBodies = [];
        var selectors = isMergeable(complexSelector, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) ? into[0].list : [complexSelector];
        localContext.intoPosition = intoPosition;
        localContext.reducedBodies = reducedBodies;
        for (var j = 0, m = selectors.length;j < m; j++) {
          var selector = selectors[j];
          var data = candidates[selector];
          if (data.length < 2)
            continue allSelectors;
          localContext.data = data;
          reduceSelector(tokens, data, {
            filterOut,
            callback: collectReducedBodies
          }, options, context);
          if (serializeBody(reducedBodies[reducedBodies.length - 1]) != serializeBody(reducedBodies[0]))
            continue allSelectors;
        }
        intoToken[2] = reducedBodies[0];
      }
  };
  var reduceSelector = function(tokens, data, context, options, outerContext) {
    var bodies = [];
    var bodiesAsList = [];
    var processedTokens = [];
    for (var j = data.length - 1;j >= 0; j--) {
      if (context.filterOut(j, bodies))
        continue;
      var where = data[j].where;
      var token = tokens[where];
      var clonedBody = cloneArray(token[2]);
      bodies = bodies.concat(clonedBody);
      bodiesAsList.push(clonedBody);
      processedTokens.push(where);
    }
    optimizeProperties(bodies, true, false, outerContext);
    var processedCount = processedTokens.length;
    var propertyIdx = bodies.length - 1;
    var tokenIdx = processedCount - 1;
    while (tokenIdx >= 0) {
      if ((tokenIdx === 0 || bodies[propertyIdx] && bodiesAsList[tokenIdx].indexOf(bodies[propertyIdx]) > -1) && propertyIdx > -1) {
        propertyIdx--;
        continue;
      }
      var newBody = bodies.splice(propertyIdx + 1);
      context.callback(tokens[processedTokens[tokenIdx]], newBody, processedCount, tokenIdx);
      tokenIdx--;
    }
  };
  var isMergeable = require_is_mergeable();
  var optimizeProperties = require_optimize3();
  var cloneArray = require_clone_array();
  var Token = require_token();
  var serializeBody = require_one_time().body;
  var serializeRules = require_one_time().rules;
  module.exports = reduceNonAdjacent;
});

// node_modules/clean-css/lib/optimizer/level-2/remove-duplicate-font-at-rules.js
var require_remove_duplicate_font_at_rules = __commonJS((exports, module) => {
  var removeDuplicateFontAtRules = function(tokens) {
    var fontAtRules = [];
    var token;
    var key;
    var i, l;
    for (i = 0, l = tokens.length;i < l; i++) {
      token = tokens[i];
      if (token[0] != Token.AT_RULE_BLOCK && token[1][0][1] != FONT_FACE_SCOPE) {
        continue;
      }
      key = serializeAll([token]);
      if (fontAtRules.indexOf(key) > -1) {
        token[2] = [];
      } else {
        fontAtRules.push(key);
      }
    }
  };
  var Token = require_token();
  var serializeAll = require_one_time().all;
  var FONT_FACE_SCOPE = "@font-face";
  module.exports = removeDuplicateFontAtRules;
});

// node_modules/clean-css/lib/optimizer/level-2/remove-duplicate-media-queries.js
var require_remove_duplicate_media_queries = __commonJS((exports, module) => {
  var removeDuplicateMediaQueries = function(tokens) {
    var candidates = {};
    var candidate;
    var token;
    var key;
    var i, l;
    for (i = 0, l = tokens.length;i < l; i++) {
      token = tokens[i];
      if (token[0] != Token.NESTED_BLOCK) {
        continue;
      }
      key = serializeRules(token[1]) + "%" + serializeAll(token[2]);
      candidate = candidates[key];
      if (candidate) {
        candidate[2] = [];
      }
      candidates[key] = token;
    }
  };
  var Token = require_token();
  var serializeAll = require_one_time().all;
  var serializeRules = require_one_time().rules;
  module.exports = removeDuplicateMediaQueries;
});

// node_modules/clean-css/lib/optimizer/level-2/remove-duplicates.js
var require_remove_duplicates = __commonJS((exports, module) => {
  var removeDuplicates = function(tokens) {
    var matched = {};
    var moreThanOnce = [];
    var id, token;
    var body, bodies;
    for (var i = 0, l = tokens.length;i < l; i++) {
      token = tokens[i];
      if (token[0] != Token.RULE)
        continue;
      id = serializeRules(token[1]);
      if (matched[id] && matched[id].length == 1)
        moreThanOnce.push(id);
      else
        matched[id] = matched[id] || [];
      matched[id].push(i);
    }
    for (i = 0, l = moreThanOnce.length;i < l; i++) {
      id = moreThanOnce[i];
      bodies = [];
      for (var j = matched[id].length - 1;j >= 0; j--) {
        token = tokens[matched[id][j]];
        body = serializeBody(token[2]);
        if (bodies.indexOf(body) > -1)
          token[2] = [];
        else
          bodies.push(body);
      }
    }
  };
  var Token = require_token();
  var serializeBody = require_one_time().body;
  var serializeRules = require_one_time().rules;
  module.exports = removeDuplicates;
});

// node_modules/clean-css/lib/optimizer/level-2/remove-unused-at-rules.js
var require_remove_unused_at_rules = __commonJS((exports, module) => {
  var normalize = function(value) {
    return value.replace(optionalMatchingQuotesRegex, "$2").replace(importantRegex, "");
  };
  var removeUnusedAtRules = function(tokens, context) {
    removeUnusedAtRule(tokens, matchCounterStyle, markCounterStylesAsUsed, context);
    removeUnusedAtRule(tokens, matchFontFace, markFontFacesAsUsed, context);
    removeUnusedAtRule(tokens, matchKeyframe, markKeyframesAsUsed, context);
    removeUnusedAtRule(tokens, matchNamespace, markNamespacesAsUsed, context);
  };
  var removeUnusedAtRule = function(tokens, matchCallback, markCallback, context) {
    var atRules = {};
    var atRule;
    var atRuleTokens;
    var atRuleToken;
    var zeroAt;
    var i, l;
    for (i = 0, l = tokens.length;i < l; i++) {
      matchCallback(tokens[i], atRules);
    }
    if (Object.keys(atRules).length === 0) {
      return;
    }
    markUsedAtRules(tokens, markCallback, atRules, context);
    for (atRule in atRules) {
      atRuleTokens = atRules[atRule];
      for (i = 0, l = atRuleTokens.length;i < l; i++) {
        atRuleToken = atRuleTokens[i];
        zeroAt = atRuleToken[0] == Token.AT_RULE ? 1 : 2;
        atRuleToken[zeroAt] = [];
      }
    }
  };
  var markUsedAtRules = function(tokens, markCallback, atRules, context) {
    var boundMarkCallback = markCallback(atRules);
    var i, l;
    for (i = 0, l = tokens.length;i < l; i++) {
      switch (tokens[i][0]) {
        case Token.RULE:
          boundMarkCallback(tokens[i], context);
          break;
        case Token.NESTED_BLOCK:
          markUsedAtRules(tokens[i][2], markCallback, atRules, context);
      }
    }
  };
  var matchCounterStyle = function(token, atRules) {
    var match;
    if (token[0] == Token.AT_RULE_BLOCK && token[1][0][1].indexOf("@counter-style") === 0) {
      match = token[1][0][1].split(" ")[1];
      atRules[match] = atRules[match] || [];
      atRules[match].push(token);
    }
  };
  var markCounterStylesAsUsed = function(atRules) {
    return function(token, context) {
      var property;
      var wrappedProperty;
      var i, l;
      for (i = 0, l = token[2].length;i < l; i++) {
        property = token[2][i];
        if (property[1][1] == "list-style") {
          wrappedProperty = wrapForOptimizing(property);
          populateComponents([wrappedProperty], context.validator, context.warnings);
          if (wrappedProperty.components[0].value[0][1] in atRules) {
            delete atRules[property[2][1]];
          }
          restoreFromOptimizing([wrappedProperty]);
        }
        if (property[1][1] == "list-style-type" && property[2][1] in atRules) {
          delete atRules[property[2][1]];
        }
      }
    };
  };
  var matchFontFace = function(token, atRules) {
    var property;
    var match;
    var i, l;
    if (token[0] == Token.AT_RULE_BLOCK && token[1][0][1] == "@font-face") {
      for (i = 0, l = token[2].length;i < l; i++) {
        property = token[2][i];
        if (property[1][1] == "font-family") {
          match = normalize(property[2][1].toLowerCase());
          atRules[match] = atRules[match] || [];
          atRules[match].push(token);
          break;
        }
      }
    }
  };
  var markFontFacesAsUsed = function(atRules) {
    return function(token, context) {
      var property;
      var wrappedProperty;
      var component;
      var normalizedMatch;
      var i, l;
      var j, m;
      for (i = 0, l = token[2].length;i < l; i++) {
        property = token[2][i];
        if (property[1][1] == "font") {
          wrappedProperty = wrapForOptimizing(property);
          populateComponents([wrappedProperty], context.validator, context.warnings);
          component = wrappedProperty.components[6];
          for (j = 0, m = component.value.length;j < m; j++) {
            normalizedMatch = normalize(component.value[j][1].toLowerCase());
            if (normalizedMatch in atRules) {
              delete atRules[normalizedMatch];
            }
          }
          restoreFromOptimizing([wrappedProperty]);
        }
        if (property[1][1] == "font-family") {
          for (j = 2, m = property.length;j < m; j++) {
            normalizedMatch = normalize(property[j][1].toLowerCase());
            if (normalizedMatch in atRules) {
              delete atRules[normalizedMatch];
            }
          }
        }
      }
    };
  };
  var matchKeyframe = function(token, atRules) {
    var match;
    if (token[0] == Token.NESTED_BLOCK && keyframeRegex.test(token[1][0][1])) {
      match = token[1][0][1].split(" ")[1];
      atRules[match] = atRules[match] || [];
      atRules[match].push(token);
    }
  };
  var markKeyframesAsUsed = function(atRules) {
    return function(token, context) {
      var property;
      var wrappedProperty;
      var component;
      var i, l;
      var j, m;
      for (i = 0, l = token[2].length;i < l; i++) {
        property = token[2][i];
        if (animationRegex.test(property[1][1])) {
          wrappedProperty = wrapForOptimizing(property);
          populateComponents([wrappedProperty], context.validator, context.warnings);
          component = wrappedProperty.components[7];
          for (j = 0, m = component.value.length;j < m; j++) {
            if (component.value[j][1] in atRules) {
              delete atRules[component.value[j][1]];
            }
          }
          restoreFromOptimizing([wrappedProperty]);
        }
        if (animationNameRegex.test(property[1][1])) {
          for (j = 2, m = property.length;j < m; j++) {
            if (property[j][1] in atRules) {
              delete atRules[property[j][1]];
            }
          }
        }
      }
    };
  };
  var matchNamespace = function(token, atRules) {
    var match;
    if (token[0] == Token.AT_RULE && token[1].indexOf("@namespace") === 0) {
      match = token[1].split(" ")[1];
      atRules[match] = atRules[match] || [];
      atRules[match].push(token);
    }
  };
  var markNamespacesAsUsed = function(atRules) {
    var namespaceRegex = new RegExp(Object.keys(atRules).join("\\||") + "\\|", "g");
    return function(token) {
      var match;
      var scope;
      var normalizedMatch;
      var i, l;
      var j, m;
      for (i = 0, l = token[1].length;i < l; i++) {
        scope = token[1][i];
        match = scope[1].match(namespaceRegex);
        for (j = 0, m = match.length;j < m; j++) {
          normalizedMatch = match[j].substring(0, match[j].length - 1);
          if (normalizedMatch in atRules) {
            delete atRules[normalizedMatch];
          }
        }
      }
    };
  };
  var populateComponents = require_populate_components();
  var wrapForOptimizing = require_wrap_for_optimizing().single;
  var restoreFromOptimizing = require_restore_from_optimizing();
  var Token = require_token();
  var animationNameRegex = /^(\-moz\-|\-o\-|\-webkit\-)?animation-name$/;
  var animationRegex = /^(\-moz\-|\-o\-|\-webkit\-)?animation$/;
  var keyframeRegex = /^@(\-moz\-|\-o\-|\-webkit\-)?keyframes /;
  var importantRegex = /\s{0,31}!important$/;
  var optionalMatchingQuotesRegex = /^(['"]?)(.*)\1$/;
  module.exports = removeUnusedAtRules;
});

// node_modules/clean-css/lib/optimizer/level-2/tidy-rule-duplicates.js
var require_tidy_rule_duplicates = __commonJS((exports, module) => {
  var ruleSorter = function(s1, s2) {
    return s1[1] > s2[1] ? 1 : -1;
  };
  var tidyRuleDuplicates = function(rules) {
    var list = [];
    var repeated = [];
    for (var i = 0, l = rules.length;i < l; i++) {
      var rule = rules[i];
      if (repeated.indexOf(rule[1]) == -1) {
        repeated.push(rule[1]);
        list.push(rule);
      }
    }
    return list.sort(ruleSorter);
  };
  module.exports = tidyRuleDuplicates;
});

// node_modules/clean-css/lib/optimizer/level-2/restructure.js
var require_restructure = __commonJS((exports, module) => {
  var naturalSorter = function(a, b) {
    return a > b ? 1 : -1;
  };
  var cloneAndMergeSelectors = function(propertyA, propertyB) {
    var cloned = cloneArray(propertyA);
    cloned[5] = cloned[5].concat(propertyB[5]);
    return cloned;
  };
  var restructure = function(tokens, context) {
    var options = context.options;
    var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;
    var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;
    var mergeLimit = options.compatibility.selectors.mergeLimit;
    var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;
    var specificityCache = context.cache.specificity;
    var movableTokens = {};
    var movedProperties = [];
    var multiPropertyMoveCache = {};
    var movedToBeDropped = [];
    var maxCombinationsLevel = 2;
    var ID_JOIN_CHARACTER = "%";
    function sendToMultiPropertyMoveCache(position2, movedProperty2, allFits) {
      for (var i2 = allFits.length - 1;i2 >= 0; i2--) {
        var fit = allFits[i2][0];
        var id = addToCache(movedProperty2, fit);
        if (multiPropertyMoveCache[id].length > 1 && processMultiPropertyMove(position2, multiPropertyMoveCache[id])) {
          removeAllMatchingFromCache(id);
          break;
        }
      }
    }
    function addToCache(movedProperty2, fit) {
      var id = cacheId(fit);
      multiPropertyMoveCache[id] = multiPropertyMoveCache[id] || [];
      multiPropertyMoveCache[id].push([movedProperty2, fit]);
      return id;
    }
    function removeAllMatchingFromCache(matchId) {
      var matchSelectors = matchId.split(ID_JOIN_CHARACTER);
      var forRemoval = [];
      var i2;
      for (var id in multiPropertyMoveCache) {
        var selectors = id.split(ID_JOIN_CHARACTER);
        for (i2 = selectors.length - 1;i2 >= 0; i2--) {
          if (matchSelectors.indexOf(selectors[i2]) > -1) {
            forRemoval.push(id);
            break;
          }
        }
      }
      for (i2 = forRemoval.length - 1;i2 >= 0; i2--) {
        delete multiPropertyMoveCache[forRemoval[i2]];
      }
    }
    function cacheId(cachedTokens) {
      var id = [];
      for (var i2 = 0, l = cachedTokens.length;i2 < l; i2++) {
        id.push(serializeRules(cachedTokens[i2][1]));
      }
      return id.join(ID_JOIN_CHARACTER);
    }
    function tokensToMerge(sourceTokens) {
      var uniqueTokensWithBody = [];
      var mergeableTokens = [];
      for (var i2 = sourceTokens.length - 1;i2 >= 0; i2--) {
        if (!isMergeable(serializeRules(sourceTokens[i2][1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging)) {
          continue;
        }
        mergeableTokens.unshift(sourceTokens[i2]);
        if (sourceTokens[i2][2].length > 0 && uniqueTokensWithBody.indexOf(sourceTokens[i2]) == -1)
          uniqueTokensWithBody.push(sourceTokens[i2]);
      }
      return uniqueTokensWithBody.length > 1 ? mergeableTokens : [];
    }
    function shortenIfPossible(position2, movedProperty2) {
      var name = movedProperty2[0];
      var value = movedProperty2[1];
      var key2 = movedProperty2[4];
      var valueSize = name.length + value.length + 1;
      var allSelectors = [];
      var qualifiedTokens = [];
      var mergeableTokens = tokensToMerge(movableTokens[key2]);
      if (mergeableTokens.length < 2)
        return;
      var allFits = findAllFits(mergeableTokens, valueSize, 1);
      var bestFit = allFits[0];
      if (bestFit[1] > 0)
        return sendToMultiPropertyMoveCache(position2, movedProperty2, allFits);
      for (var i2 = bestFit[0].length - 1;i2 >= 0; i2--) {
        allSelectors = bestFit[0][i2][1].concat(allSelectors);
        qualifiedTokens.unshift(bestFit[0][i2]);
      }
      allSelectors = tidyRuleDuplicates(allSelectors);
      dropAsNewTokenAt(position2, [movedProperty2], allSelectors, qualifiedTokens);
    }
    function fitSorter(fit1, fit2) {
      return fit1[1] > fit2[1] ? 1 : fit1[1] == fit2[1] ? 0 : -1;
    }
    function findAllFits(mergeableTokens, propertySize, propertiesCount) {
      var combinations = allCombinations(mergeableTokens, propertySize, propertiesCount, maxCombinationsLevel - 1);
      return combinations.sort(fitSorter);
    }
    function allCombinations(tokensVariant, propertySize, propertiesCount, level) {
      var differenceVariants = [[tokensVariant, sizeDifference(tokensVariant, propertySize, propertiesCount)]];
      if (tokensVariant.length > 2 && level > 0) {
        for (var i2 = tokensVariant.length - 1;i2 >= 0; i2--) {
          var subVariant = Array.prototype.slice.call(tokensVariant, 0);
          subVariant.splice(i2, 1);
          differenceVariants = differenceVariants.concat(allCombinations(subVariant, propertySize, propertiesCount, level - 1));
        }
      }
      return differenceVariants;
    }
    function sizeDifference(tokensVariant, propertySize, propertiesCount) {
      var allSelectorsSize = 0;
      for (var i2 = tokensVariant.length - 1;i2 >= 0; i2--) {
        allSelectorsSize += tokensVariant[i2][2].length > propertiesCount ? serializeRules(tokensVariant[i2][1]).length : -1;
      }
      return allSelectorsSize - (tokensVariant.length - 1) * propertySize + 1;
    }
    function dropAsNewTokenAt(position2, properties2, allSelectors, mergeableTokens) {
      var i2, j2, k2, m2;
      var allProperties = [];
      for (i2 = mergeableTokens.length - 1;i2 >= 0; i2--) {
        var mergeableToken = mergeableTokens[i2];
        for (j2 = mergeableToken[2].length - 1;j2 >= 0; j2--) {
          var mergeableProperty = mergeableToken[2][j2];
          for (k2 = 0, m2 = properties2.length;k2 < m2; k2++) {
            var property2 = properties2[k2];
            var mergeablePropertyName = mergeableProperty[1][1];
            var propertyName = property2[0];
            var propertyBody = property2[4];
            if (mergeablePropertyName == propertyName && serializeBody([mergeableProperty]) == propertyBody) {
              mergeableToken[2].splice(j2, 1);
              break;
            }
          }
        }
      }
      for (i2 = properties2.length - 1;i2 >= 0; i2--) {
        allProperties.unshift(properties2[i2][3]);
      }
      var newToken = [Token.RULE, allSelectors, allProperties];
      tokens.splice(position2, 0, newToken);
    }
    function dropPropertiesAt(position2, movedProperty2) {
      var key2 = movedProperty2[4];
      var toMove = movableTokens[key2];
      if (toMove && toMove.length > 1) {
        if (!shortenMultiMovesIfPossible(position2, movedProperty2))
          shortenIfPossible(position2, movedProperty2);
      }
    }
    function shortenMultiMovesIfPossible(position2, movedProperty2) {
      var candidates = [];
      var propertiesAndMergableTokens = [];
      var key2 = movedProperty2[4];
      var j2, k2;
      var mergeableTokens = tokensToMerge(movableTokens[key2]);
      if (mergeableTokens.length < 2)
        return;
      movableLoop:
        for (var value in movableTokens) {
          var tokensList = movableTokens[value];
          for (j2 = mergeableTokens.length - 1;j2 >= 0; j2--) {
            if (tokensList.indexOf(mergeableTokens[j2]) == -1)
              continue movableLoop;
          }
          candidates.push(value);
        }
      if (candidates.length < 2)
        return false;
      for (j2 = candidates.length - 1;j2 >= 0; j2--) {
        for (k2 = movedProperties.length - 1;k2 >= 0; k2--) {
          if (movedProperties[k2][4] == candidates[j2]) {
            propertiesAndMergableTokens.unshift([movedProperties[k2], mergeableTokens]);
            break;
          }
        }
      }
      return processMultiPropertyMove(position2, propertiesAndMergableTokens);
    }
    function processMultiPropertyMove(position2, propertiesAndMergableTokens) {
      var valueSize = 0;
      var properties2 = [];
      var property2;
      for (var i2 = propertiesAndMergableTokens.length - 1;i2 >= 0; i2--) {
        property2 = propertiesAndMergableTokens[i2][0];
        var fullValue = property2[4];
        valueSize += fullValue.length + (i2 > 0 ? 1 : 0);
        properties2.push(property2);
      }
      var mergeableTokens = propertiesAndMergableTokens[0][1];
      var bestFit = findAllFits(mergeableTokens, valueSize, properties2.length)[0];
      if (bestFit[1] > 0)
        return false;
      var allSelectors = [];
      var qualifiedTokens = [];
      for (i2 = bestFit[0].length - 1;i2 >= 0; i2--) {
        allSelectors = bestFit[0][i2][1].concat(allSelectors);
        qualifiedTokens.unshift(bestFit[0][i2]);
      }
      allSelectors = tidyRuleDuplicates(allSelectors);
      dropAsNewTokenAt(position2, properties2, allSelectors, qualifiedTokens);
      for (i2 = properties2.length - 1;i2 >= 0; i2--) {
        property2 = properties2[i2];
        var index = movedProperties.indexOf(property2);
        delete movableTokens[property2[4]];
        if (index > -1 && movedToBeDropped.indexOf(index) == -1)
          movedToBeDropped.push(index);
      }
      return true;
    }
    function boundToAnotherPropertyInCurrrentToken(property2, movedProperty2, token2) {
      var propertyName = property2[0];
      var movedPropertyName = movedProperty2[0];
      if (propertyName != movedPropertyName)
        return false;
      var key2 = movedProperty2[4];
      var toMove = movableTokens[key2];
      return toMove && toMove.indexOf(token2) > -1;
    }
    for (var i = tokens.length - 1;i >= 0; i--) {
      var token = tokens[i];
      var isRule;
      var j, k, m;
      var samePropertyAt;
      if (token[0] == Token.RULE) {
        isRule = true;
      } else if (token[0] == Token.NESTED_BLOCK) {
        isRule = false;
      } else {
        continue;
      }
      var movedCount = movedProperties.length;
      var properties = extractProperties(token);
      movedToBeDropped = [];
      var unmovableInCurrentToken = [];
      for (j = properties.length - 1;j >= 0; j--) {
        for (k = j - 1;k >= 0; k--) {
          if (!canReorderSingle(properties[j], properties[k], specificityCache)) {
            unmovableInCurrentToken.push(j);
            break;
          }
        }
      }
      for (j = properties.length - 1;j >= 0; j--) {
        var property = properties[j];
        var movedSameProperty = false;
        for (k = 0;k < movedCount; k++) {
          var movedProperty = movedProperties[k];
          if (movedToBeDropped.indexOf(k) == -1 && (!canReorderSingle(property, movedProperty, specificityCache) && !boundToAnotherPropertyInCurrrentToken(property, movedProperty, token) || movableTokens[movedProperty[4]] && movableTokens[movedProperty[4]].length === mergeLimit)) {
            dropPropertiesAt(i + 1, movedProperty, token);
            if (movedToBeDropped.indexOf(k) == -1) {
              movedToBeDropped.push(k);
              delete movableTokens[movedProperty[4]];
            }
          }
          if (!movedSameProperty) {
            movedSameProperty = property[0] == movedProperty[0] && property[1] == movedProperty[1];
            if (movedSameProperty) {
              samePropertyAt = k;
            }
          }
        }
        if (!isRule || unmovableInCurrentToken.indexOf(j) > -1)
          continue;
        var key = property[4];
        if (movedSameProperty && movedProperties[samePropertyAt][5].length + property[5].length > mergeLimit) {
          dropPropertiesAt(i + 1, movedProperties[samePropertyAt]);
          movedProperties.splice(samePropertyAt, 1);
          movableTokens[key] = [token];
          movedSameProperty = false;
        } else {
          movableTokens[key] = movableTokens[key] || [];
          movableTokens[key].push(token);
        }
        if (movedSameProperty) {
          movedProperties[samePropertyAt] = cloneAndMergeSelectors(movedProperties[samePropertyAt], property);
        } else {
          movedProperties.push(property);
        }
      }
      movedToBeDropped = movedToBeDropped.sort(naturalSorter);
      for (j = 0, m = movedToBeDropped.length;j < m; j++) {
        var dropAt = movedToBeDropped[j] - j;
        movedProperties.splice(dropAt, 1);
      }
    }
    var position = tokens[0] && tokens[0][0] == Token.AT_RULE && tokens[0][1].indexOf("@charset") === 0 ? 1 : 0;
    for (;position < tokens.length - 1; position++) {
      var isImportRule = tokens[position][0] === Token.AT_RULE && tokens[position][1].indexOf("@import") === 0;
      var isComment = tokens[position][0] === Token.COMMENT;
      if (!(isImportRule || isComment))
        break;
    }
    for (i = 0;i < movedProperties.length; i++) {
      dropPropertiesAt(position, movedProperties[i]);
    }
  };
  var canReorderSingle = require_reorderable().canReorderSingle;
  var extractProperties = require_extract_properties();
  var isMergeable = require_is_mergeable();
  var tidyRuleDuplicates = require_tidy_rule_duplicates();
  var Token = require_token();
  var cloneArray = require_clone_array();
  var serializeBody = require_one_time().body;
  var serializeRules = require_one_time().rules;
  module.exports = restructure;
});

// node_modules/clean-css/lib/optimizer/level-2/optimize.js
var require_optimize4 = __commonJS((exports, module) => {
  var removeEmpty = function(tokens) {
    for (var i = 0, l = tokens.length;i < l; i++) {
      var token = tokens[i];
      var isEmpty = false;
      switch (token[0]) {
        case Token.RULE:
          isEmpty = token[1].length === 0 || token[2].length === 0;
          break;
        case Token.NESTED_BLOCK:
          removeEmpty(token[2]);
          isEmpty = token[2].length === 0;
          break;
        case Token.AT_RULE:
          isEmpty = token[1].length === 0;
          break;
        case Token.AT_RULE_BLOCK:
          isEmpty = token[2].length === 0;
      }
      if (isEmpty) {
        tokens.splice(i, 1);
        i--;
        l--;
      }
    }
  };
  var recursivelyOptimizeBlocks = function(tokens, context) {
    for (var i = 0, l = tokens.length;i < l; i++) {
      var token = tokens[i];
      if (token[0] == Token.NESTED_BLOCK) {
        var isKeyframes = /@(-moz-|-o-|-webkit-)?keyframes/.test(token[1][0][1]);
        level2Optimize(token[2], context, !isKeyframes);
      }
    }
  };
  var recursivelyOptimizeProperties = function(tokens, context) {
    for (var i = 0, l = tokens.length;i < l; i++) {
      var token = tokens[i];
      switch (token[0]) {
        case Token.RULE:
          optimizeProperties(token[2], true, true, context);
          break;
        case Token.NESTED_BLOCK:
          recursivelyOptimizeProperties(token[2], context);
      }
    }
  };
  var level2Optimize = function(tokens, context, withRestructuring) {
    var levelOptions = context.options.level[OptimizationLevel.Two];
    var reduced;
    var i;
    recursivelyOptimizeBlocks(tokens, context);
    recursivelyOptimizeProperties(tokens, context);
    if (levelOptions.removeDuplicateRules) {
      removeDuplicates(tokens, context);
    }
    if (levelOptions.mergeAdjacentRules) {
      mergeAdjacent(tokens, context);
    }
    if (levelOptions.reduceNonAdjacentRules) {
      reduceNonAdjacent(tokens, context);
    }
    if (levelOptions.mergeNonAdjacentRules && levelOptions.mergeNonAdjacentRules != "body") {
      mergeNonAdjacentBySelector(tokens, context);
    }
    if (levelOptions.mergeNonAdjacentRules && levelOptions.mergeNonAdjacentRules != "selector") {
      mergeNonAdjacentByBody(tokens, context);
    }
    if (levelOptions.restructureRules && levelOptions.mergeAdjacentRules && withRestructuring) {
      restructure(tokens, context);
      mergeAdjacent(tokens, context);
    }
    if (levelOptions.restructureRules && !levelOptions.mergeAdjacentRules && withRestructuring) {
      restructure(tokens, context);
    }
    if (levelOptions.removeDuplicateFontRules) {
      removeDuplicateFontAtRules(tokens, context);
    }
    if (levelOptions.removeDuplicateMediaBlocks) {
      removeDuplicateMediaQueries(tokens, context);
    }
    if (levelOptions.removeUnusedAtRules) {
      removeUnusedAtRules(tokens, context);
    }
    if (levelOptions.mergeMedia) {
      reduced = mergeMediaQueries(tokens, context);
      for (i = reduced.length - 1;i >= 0; i--) {
        level2Optimize(reduced[i][2], context, false);
      }
    }
    if (levelOptions.removeEmpty) {
      removeEmpty(tokens);
    }
    return tokens;
  };
  var mergeAdjacent = require_merge_adjacent();
  var mergeMediaQueries = require_merge_media_queries();
  var mergeNonAdjacentByBody = require_merge_non_adjacent_by_body();
  var mergeNonAdjacentBySelector = require_merge_non_adjacent_by_selector();
  var reduceNonAdjacent = require_reduce_non_adjacent();
  var removeDuplicateFontAtRules = require_remove_duplicate_font_at_rules();
  var removeDuplicateMediaQueries = require_remove_duplicate_media_queries();
  var removeDuplicates = require_remove_duplicates();
  var removeUnusedAtRules = require_remove_unused_at_rules();
  var restructure = require_restructure();
  var optimizeProperties = require_optimize3();
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  var Token = require_token();
  module.exports = level2Optimize;
});

// node_modules/clean-css/lib/optimizer/validator.js
var require_validator = __commonJS((exports, module) => {
  var isColor = function(value) {
    return value != "auto" && (isKeyword("color")(value) || isHexColor(value) || isColorFunction(value) || isNamedEntity(value));
  };
  var isColorFunction = function(value) {
    return isRgbColor(value) || isHslColor(value);
  };
  var isDynamicUnit = function(value) {
    return calcRegex.test(value);
  };
  var isFunction = function(value) {
    return functionAnyRegex.test(value);
  };
  var isHexColor = function(value) {
    return threeValueColorRegex.test(value) || fourValueColorRegex.test(value) || sixValueColorRegex.test(value) || eightValueColorRegex.test(value);
  };
  var isHslColor = function(value) {
    return hslColorRegex.test(value);
  };
  var isIdentifier = function(value) {
    return identifierRegex.test(value);
  };
  var isImage = function(value) {
    return value == "none" || value == "inherit" || isUrl(value);
  };
  var isKeyword = function(propertyName) {
    return function(value) {
      return Keywords[propertyName].indexOf(value) > -1;
    };
  };
  var isNamedEntity = function(value) {
    return namedEntityRegex.test(value);
  };
  var isNumber = function(value) {
    return scanForNumber(value) == value.length;
  };
  var isRgbColor = function(value) {
    return rgbColorRegex.test(value);
  };
  var isPrefixed = function(value) {
    return prefixRegex.test(value);
  };
  var isPositiveNumber = function(value) {
    return isNumber(value) && parseFloat(value) >= 0;
  };
  var isVariable = function(value) {
    return variableRegex.test(value);
  };
  var isTime = function(value) {
    var numberUpTo = scanForNumber(value);
    return numberUpTo == value.length && parseInt(value) === 0 || numberUpTo > -1 && validTimeUnits.indexOf(value.slice(numberUpTo + 1)) > -1;
  };
  var isTimingFunction = function() {
    var isTimingFunctionKeyword = isKeyword("*-timing-function");
    return function(value) {
      return isTimingFunctionKeyword(value) || timingFunctionRegex.test(value);
    };
  };
  var isUnit = function(validUnits, value) {
    var numberUpTo = scanForNumber(value);
    return numberUpTo == value.length && parseInt(value) === 0 || numberUpTo > -1 && validUnits.indexOf(value.slice(numberUpTo + 1)) > -1 || value == "auto" || value == "inherit";
  };
  var isUrl = function(value) {
    return urlRegex.test(value);
  };
  var isZIndex = function(value) {
    return value == "auto" || isNumber(value) || isKeyword("^")(value);
  };
  var scanForNumber = function(value) {
    var hasDot = false;
    var hasSign = false;
    var character;
    var i, l;
    for (i = 0, l = value.length;i < l; i++) {
      character = value[i];
      if (i === 0 && (character == PLUS_SIGN || character == MINUS_SIGN)) {
        hasSign = true;
      } else if (i > 0 && hasSign && (character == PLUS_SIGN || character == MINUS_SIGN)) {
        return i - 1;
      } else if (character == DECIMAL_DOT && !hasDot) {
        hasDot = true;
      } else if (character == DECIMAL_DOT && hasDot) {
        return i - 1;
      } else if (decimalRegex.test(character)) {
        continue;
      } else {
        return i - 1;
      }
    }
    return i;
  };
  var validator = function(compatibility) {
    var validUnits = Units.slice(0).filter(function(value) {
      return !(value in compatibility.units) || compatibility.units[value] === true;
    });
    return {
      colorOpacity: compatibility.colors.opacity,
      isAnimationDirectionKeyword: isKeyword("animation-direction"),
      isAnimationFillModeKeyword: isKeyword("animation-fill-mode"),
      isAnimationIterationCountKeyword: isKeyword("animation-iteration-count"),
      isAnimationNameKeyword: isKeyword("animation-name"),
      isAnimationPlayStateKeyword: isKeyword("animation-play-state"),
      isTimingFunction: isTimingFunction(),
      isBackgroundAttachmentKeyword: isKeyword("background-attachment"),
      isBackgroundClipKeyword: isKeyword("background-clip"),
      isBackgroundOriginKeyword: isKeyword("background-origin"),
      isBackgroundPositionKeyword: isKeyword("background-position"),
      isBackgroundRepeatKeyword: isKeyword("background-repeat"),
      isBackgroundSizeKeyword: isKeyword("background-size"),
      isColor,
      isColorFunction,
      isDynamicUnit,
      isFontKeyword: isKeyword("font"),
      isFontSizeKeyword: isKeyword("font-size"),
      isFontStretchKeyword: isKeyword("font-stretch"),
      isFontStyleKeyword: isKeyword("font-style"),
      isFontVariantKeyword: isKeyword("font-variant"),
      isFontWeightKeyword: isKeyword("font-weight"),
      isFunction,
      isGlobal: isKeyword("^"),
      isHslColor,
      isIdentifier,
      isImage,
      isKeyword,
      isLineHeightKeyword: isKeyword("line-height"),
      isListStylePositionKeyword: isKeyword("list-style-position"),
      isListStyleTypeKeyword: isKeyword("list-style-type"),
      isNumber,
      isPrefixed,
      isPositiveNumber,
      isRgbColor,
      isStyleKeyword: isKeyword("*-style"),
      isTime,
      isUnit: isUnit.bind(null, validUnits),
      isUrl,
      isVariable,
      isWidth: isKeyword("width"),
      isZIndex
    };
  };
  var functionNoVendorRegexStr = "[A-Z]+(\\-|[A-Z]|[0-9])+\\(.*?\\)";
  var functionVendorRegexStr = "\\-(\\-|[A-Z]|[0-9])+\\(.*?\\)";
  var variableRegexStr = "var\\(\\-\\-[^\\)]+\\)";
  var functionAnyRegexStr = "(" + variableRegexStr + "|" + functionNoVendorRegexStr + "|" + functionVendorRegexStr + ")";
  var calcRegex = new RegExp("^(\\-moz\\-|\\-webkit\\-)?calc\\([^\\)]+\\)$", "i");
  var decimalRegex = /[0-9]/;
  var functionAnyRegex = new RegExp("^" + functionAnyRegexStr + "$", "i");
  var hslColorRegex = /^hsl\(\s{0,31}[\-\.]?\d+\s{0,31},\s{0,31}\.?\d+%\s{0,31},\s{0,31}\.?\d+%\s{0,31}\)|hsla\(\s{0,31}[\-\.]?\d+\s{0,31},\s{0,31}\.?\d+%\s{0,31},\s{0,31}\.?\d+%\s{0,31},\s{0,31}\.?\d+\s{0,31}\)$/i;
  var identifierRegex = /^(\-[a-z0-9_][a-z0-9\-_]*|[a-z][a-z0-9\-_]*)$/i;
  var namedEntityRegex = /^[a-z]+$/i;
  var prefixRegex = /^-([a-z0-9]|-)*$/i;
  var rgbColorRegex = /^rgb\(\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\d]{1,3}\s{0,31}\)|rgba\(\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\.\d]+\s{0,31}\)$/i;
  var timingFunctionRegex = /^(cubic\-bezier|steps)\([^\)]+\)$/;
  var validTimeUnits = ["ms", "s"];
  var urlRegex = /^url\([\s\S]+\)$/i;
  var variableRegex = new RegExp("^" + variableRegexStr + "$", "i");
  var eightValueColorRegex = /^#[0-9a-f]{8}$/i;
  var fourValueColorRegex = /^#[0-9a-f]{4}$/i;
  var sixValueColorRegex = /^#[0-9a-f]{6}$/i;
  var threeValueColorRegex = /^#[0-9a-f]{3}$/i;
  var DECIMAL_DOT = ".";
  var MINUS_SIGN = "-";
  var PLUS_SIGN = "+";
  var Keywords = {
    "^": [
      "inherit",
      "initial",
      "unset"
    ],
    "*-style": [
      "auto",
      "dashed",
      "dotted",
      "double",
      "groove",
      "hidden",
      "inset",
      "none",
      "outset",
      "ridge",
      "solid"
    ],
    "*-timing-function": [
      "ease",
      "ease-in",
      "ease-in-out",
      "ease-out",
      "linear",
      "step-end",
      "step-start"
    ],
    "animation-direction": [
      "alternate",
      "alternate-reverse",
      "normal",
      "reverse"
    ],
    "animation-fill-mode": [
      "backwards",
      "both",
      "forwards",
      "none"
    ],
    "animation-iteration-count": [
      "infinite"
    ],
    "animation-name": [
      "none"
    ],
    "animation-play-state": [
      "paused",
      "running"
    ],
    "background-attachment": [
      "fixed",
      "inherit",
      "local",
      "scroll"
    ],
    "background-clip": [
      "border-box",
      "content-box",
      "inherit",
      "padding-box",
      "text"
    ],
    "background-origin": [
      "border-box",
      "content-box",
      "inherit",
      "padding-box"
    ],
    "background-position": [
      "bottom",
      "center",
      "left",
      "right",
      "top"
    ],
    "background-repeat": [
      "no-repeat",
      "inherit",
      "repeat",
      "repeat-x",
      "repeat-y",
      "round",
      "space"
    ],
    "background-size": [
      "auto",
      "cover",
      "contain"
    ],
    "border-collapse": [
      "collapse",
      "inherit",
      "separate"
    ],
    bottom: [
      "auto"
    ],
    clear: [
      "both",
      "left",
      "none",
      "right"
    ],
    color: [
      "transparent"
    ],
    cursor: [
      "all-scroll",
      "auto",
      "col-resize",
      "crosshair",
      "default",
      "e-resize",
      "help",
      "move",
      "n-resize",
      "ne-resize",
      "no-drop",
      "not-allowed",
      "nw-resize",
      "pointer",
      "progress",
      "row-resize",
      "s-resize",
      "se-resize",
      "sw-resize",
      "text",
      "vertical-text",
      "w-resize",
      "wait"
    ],
    display: [
      "block",
      "inline",
      "inline-block",
      "inline-table",
      "list-item",
      "none",
      "table",
      "table-caption",
      "table-cell",
      "table-column",
      "table-column-group",
      "table-footer-group",
      "table-header-group",
      "table-row",
      "table-row-group"
    ],
    float: [
      "left",
      "none",
      "right"
    ],
    left: [
      "auto"
    ],
    font: [
      "caption",
      "icon",
      "menu",
      "message-box",
      "small-caption",
      "status-bar",
      "unset"
    ],
    "font-size": [
      "large",
      "larger",
      "medium",
      "small",
      "smaller",
      "x-large",
      "x-small",
      "xx-large",
      "xx-small"
    ],
    "font-stretch": [
      "condensed",
      "expanded",
      "extra-condensed",
      "extra-expanded",
      "normal",
      "semi-condensed",
      "semi-expanded",
      "ultra-condensed",
      "ultra-expanded"
    ],
    "font-style": [
      "italic",
      "normal",
      "oblique"
    ],
    "font-variant": [
      "normal",
      "small-caps"
    ],
    "font-weight": [
      "100",
      "200",
      "300",
      "400",
      "500",
      "600",
      "700",
      "800",
      "900",
      "bold",
      "bolder",
      "lighter",
      "normal"
    ],
    "line-height": [
      "normal"
    ],
    "list-style-position": [
      "inside",
      "outside"
    ],
    "list-style-type": [
      "armenian",
      "circle",
      "decimal",
      "decimal-leading-zero",
      "disc",
      "decimal|disc",
      "georgian",
      "lower-alpha",
      "lower-greek",
      "lower-latin",
      "lower-roman",
      "none",
      "square",
      "upper-alpha",
      "upper-latin",
      "upper-roman"
    ],
    overflow: [
      "auto",
      "hidden",
      "scroll",
      "visible"
    ],
    position: [
      "absolute",
      "fixed",
      "relative",
      "static"
    ],
    right: [
      "auto"
    ],
    "text-align": [
      "center",
      "justify",
      "left",
      "left|right",
      "right"
    ],
    "text-decoration": [
      "line-through",
      "none",
      "overline",
      "underline"
    ],
    "text-overflow": [
      "clip",
      "ellipsis"
    ],
    top: [
      "auto"
    ],
    "vertical-align": [
      "baseline",
      "bottom",
      "middle",
      "sub",
      "super",
      "text-bottom",
      "text-top",
      "top"
    ],
    visibility: [
      "collapse",
      "hidden",
      "visible"
    ],
    "white-space": [
      "normal",
      "nowrap",
      "pre"
    ],
    width: [
      "inherit",
      "initial",
      "medium",
      "thick",
      "thin"
    ]
  };
  var Units = [
    "%",
    "ch",
    "cm",
    "em",
    "ex",
    "in",
    "mm",
    "pc",
    "pt",
    "px",
    "rem",
    "vh",
    "vm",
    "vmax",
    "vmin",
    "vw"
  ];
  module.exports = validator;
});

// node_modules/clean-css/lib/options/compatibility.js
var require_compatibility = __commonJS((exports, module) => {
  var compatibilityFrom = function(source) {
    return merge(DEFAULTS["*"], calculateSource(source));
  };
  var merge = function(source, target) {
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        var value = source[key];
        if (Object.prototype.hasOwnProperty.call(target, key) && typeof value === "object" && !Array.isArray(value)) {
          target[key] = merge(value, target[key] || {});
        } else {
          target[key] = key in target ? target[key] : value;
        }
      }
    }
    return target;
  };
  var calculateSource = function(source) {
    if (typeof source == "object")
      return source;
    if (!/[,\+\-]/.test(source))
      return DEFAULTS[source] || DEFAULTS["*"];
    var parts = source.split(",");
    var template = parts[0] in DEFAULTS ? DEFAULTS[parts.shift()] : DEFAULTS["*"];
    source = {};
    parts.forEach(function(part) {
      var isAdd = part[0] == "+";
      var key = part.substring(1).split(".");
      var group = key[0];
      var option = key[1];
      source[group] = source[group] || {};
      source[group][option] = isAdd;
    });
    return merge(template, source);
  };
  var DEFAULTS = {
    "*": {
      colors: {
        opacity: true
      },
      properties: {
        backgroundClipMerging: true,
        backgroundOriginMerging: true,
        backgroundSizeMerging: true,
        colors: true,
        ieBangHack: false,
        ieFilters: false,
        iePrefixHack: false,
        ieSuffixHack: false,
        merging: true,
        shorterLengthUnits: false,
        spaceAfterClosingBrace: true,
        urlQuotes: false,
        zeroUnits: true
      },
      selectors: {
        adjacentSpace: false,
        ie7Hack: false,
        mergeablePseudoClasses: [
          ":active",
          ":after",
          ":before",
          ":empty",
          ":checked",
          ":disabled",
          ":empty",
          ":enabled",
          ":first-child",
          ":first-letter",
          ":first-line",
          ":first-of-type",
          ":focus",
          ":hover",
          ":lang",
          ":last-child",
          ":last-of-type",
          ":link",
          ":not",
          ":nth-child",
          ":nth-last-child",
          ":nth-last-of-type",
          ":nth-of-type",
          ":only-child",
          ":only-of-type",
          ":root",
          ":target",
          ":visited"
        ],
        mergeablePseudoElements: [
          "::after",
          "::before",
          "::first-letter",
          "::first-line"
        ],
        mergeLimit: 8191,
        multiplePseudoMerging: true
      },
      units: {
        ch: true,
        in: true,
        pc: true,
        pt: true,
        rem: true,
        vh: true,
        vm: true,
        vmax: true,
        vmin: true,
        vw: true
      }
    }
  };
  DEFAULTS.ie11 = DEFAULTS["*"];
  DEFAULTS.ie10 = DEFAULTS["*"];
  DEFAULTS.ie9 = merge(DEFAULTS["*"], {
    properties: {
      ieFilters: true,
      ieSuffixHack: true
    }
  });
  DEFAULTS.ie8 = merge(DEFAULTS.ie9, {
    colors: {
      opacity: false
    },
    properties: {
      backgroundClipMerging: false,
      backgroundOriginMerging: false,
      backgroundSizeMerging: false,
      iePrefixHack: true,
      merging: false
    },
    selectors: {
      mergeablePseudoClasses: [
        ":after",
        ":before",
        ":first-child",
        ":first-letter",
        ":focus",
        ":hover",
        ":visited"
      ],
      mergeablePseudoElements: []
    },
    units: {
      ch: false,
      rem: false,
      vh: false,
      vm: false,
      vmax: false,
      vmin: false,
      vw: false
    }
  });
  DEFAULTS.ie7 = merge(DEFAULTS.ie8, {
    properties: {
      ieBangHack: true
    },
    selectors: {
      ie7Hack: true,
      mergeablePseudoClasses: [
        ":first-child",
        ":first-letter",
        ":hover",
        ":visited"
      ]
    }
  });
  module.exports = compatibilityFrom;
});

// node_modules/clean-css/lib/utils/is-http-resource.js
var require_is_http_resource = __commonJS((exports, module) => {
  var isHttpResource = function(uri) {
    return HTTP_RESOURCE_PATTERN.test(uri);
  };
  var HTTP_RESOURCE_PATTERN = /^http:\/\//;
  module.exports = isHttpResource;
});

// node_modules/clean-css/lib/utils/is-https-resource.js
var require_is_https_resource = __commonJS((exports, module) => {
  var isHttpsResource = function(uri) {
    return HTTPS_RESOURCE_PATTERN.test(uri);
  };
  var HTTPS_RESOURCE_PATTERN = /^https:\/\//;
  module.exports = isHttpsResource;
});

// node_modules/clean-css/lib/reader/load-remote-resource.js
var require_load_remote_resource = __commonJS((exports, module) => {
  var loadRemoteResource = function(uri, inlineRequest, inlineTimeout, callback) {
    var proxyProtocol = inlineRequest.protocol || inlineRequest.hostname;
    var errorHandled = false;
    var requestOptions;
    var fetch;
    requestOptions = override(url.parse(uri), inlineRequest || {});
    if (inlineRequest.hostname !== undefined) {
      requestOptions.protocol = inlineRequest.protocol || HTTP_PROTOCOL;
      requestOptions.path = requestOptions.href;
    }
    fetch = proxyProtocol && !isHttpsResource(proxyProtocol) || isHttpResource(uri) ? http.get : https.get;
    fetch(requestOptions, function(res) {
      var chunks = [];
      var movedUri;
      if (errorHandled) {
        return;
      }
      if (res.statusCode < 200 || res.statusCode > 399) {
        return callback(res.statusCode, null);
      } else if (res.statusCode > 299) {
        movedUri = url.resolve(uri, res.headers.location);
        return loadRemoteResource(movedUri, inlineRequest, inlineTimeout, callback);
      }
      res.on("data", function(chunk) {
        chunks.push(chunk.toString());
      });
      res.on("end", function() {
        var body = chunks.join("");
        callback(null, body);
      });
    }).on("error", function(res) {
      if (errorHandled) {
        return;
      }
      errorHandled = true;
      callback(res.message, null);
    }).on("timeout", function() {
      if (errorHandled) {
        return;
      }
      errorHandled = true;
      callback("timeout", null);
    }).setTimeout(inlineTimeout);
  };
  var http = import.meta.require("http");
  var https = import.meta.require("https");
  var url = import.meta.require("url");
  var isHttpResource = require_is_http_resource();
  var isHttpsResource = require_is_https_resource();
  var override = require_override();
  var HTTP_PROTOCOL = "http:";
  module.exports = loadRemoteResource;
});

// node_modules/clean-css/lib/options/fetch.js
var require_fetch = __commonJS((exports, module) => {
  var fetchFrom = function(callback) {
    return callback || loadRemoteResource;
  };
  var loadRemoteResource = require_load_remote_resource();
  module.exports = fetchFrom;
});

// node_modules/clean-css/lib/options/inline.js
var require_inline = __commonJS((exports, module) => {
  var inlineOptionsFrom = function(rules) {
    if (Array.isArray(rules)) {
      return rules;
    }
    if (rules === false) {
      return ["none"];
    }
    return rules === undefined ? ["local"] : rules.split(",");
  };
  module.exports = inlineOptionsFrom;
});

// node_modules/clean-css/lib/options/inline-request.js
var require_inline_request = __commonJS((exports, module) => {
  var inlineRequestFrom = function(option) {
    return override(proxyOptionsFrom(process.env.HTTP_PROXY || process.env.http_proxy), option || {});
  };
  var proxyOptionsFrom = function(httpProxy) {
    return httpProxy ? {
      hostname: url.parse(httpProxy).hostname,
      port: parseInt(url.parse(httpProxy).port)
    } : {};
  };
  var url = import.meta.require("url");
  var override = require_override();
  module.exports = inlineRequestFrom;
});

// node_modules/clean-css/lib/options/inline-timeout.js
var require_inline_timeout = __commonJS((exports, module) => {
  var inlineTimeoutFrom = function(option) {
    return option || DEFAULT_TIMEOUT;
  };
  var DEFAULT_TIMEOUT = 5000;
  module.exports = inlineTimeoutFrom;
});

// node_modules/clean-css/lib/options/rebase.js
var require_rebase = __commonJS((exports, module) => {
  var rebaseFrom = function(rebaseOption) {
    return rebaseOption === undefined ? true : !!rebaseOption;
  };
  module.exports = rebaseFrom;
});

// node_modules/clean-css/lib/options/rebase-to.js
var require_rebase_to = __commonJS((exports, module) => {
  var rebaseToFrom = function(option) {
    return option ? path.resolve(option) : process.cwd();
  };
  var path = import.meta.require("path");
  module.exports = rebaseToFrom;
});

// node_modules/source-map/lib/base64.js
var require_base64 = __commonJS((exports) => {
  var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  exports.encode = function(number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
  };
  exports.decode = function(charCode) {
    var bigA = 65;
    var bigZ = 90;
    var littleA = 97;
    var littleZ = 122;
    var zero = 48;
    var nine = 57;
    var plus = 43;
    var slash = 47;
    var littleOffset = 26;
    var numberOffset = 52;
    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }
    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }
    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }
    if (charCode == plus) {
      return 62;
    }
    if (charCode == slash) {
      return 63;
    }
    return -1;
  };
});

// node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS((exports) => {
  var toVLQSigned = function(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  };
  var fromVLQSigned = function(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  };
  var base64 = require_base64();
  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);
    return encoded;
  };
  exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };
});

// node_modules/source-map/lib/util.js
var require_util = __commonJS((exports) => {
  var getArg = function(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  };
  var urlParse = function(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  };
  var urlGenerate = function(aParsedUrl) {
    var url = "";
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ":";
    }
    url += "//";
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + "@";
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  };
  var normalize = function(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = exports.isAbsolute(path);
    var parts = path.split(/\/+/);
    for (var part, up = 0, i = parts.length - 1;i >= 0; i--) {
      part = parts[i];
      if (part === ".") {
        parts.splice(i, 1);
      } else if (part === "..") {
        up++;
      } else if (up > 0) {
        if (part === "") {
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join("/");
    if (path === "") {
      path = isAbsolute ? "/" : ".";
    }
    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  };
  var join = function(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || "/";
    }
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }
    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }
    var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  };
  var relative = function(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    aRoot = aRoot.replace(/\/$/, "");
    var level = 0;
    while (aPath.indexOf(aRoot + "/") !== 0) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) {
        return aPath;
      }
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }
      ++level;
    }
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  };
  var identity = function(s) {
    return s;
  };
  var toSetString = function(aStr) {
    if (isProtoString(aStr)) {
      return "$" + aStr;
    }
    return aStr;
  };
  var fromSetString = function(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }
    return aStr;
  };
  var isProtoString = function(s) {
    if (!s) {
      return false;
    }
    var length = s.length;
    if (length < 9) {
      return false;
    }
    if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
      return false;
    }
    for (var i = length - 10;i >= 0; i--) {
      if (s.charCodeAt(i) !== 36) {
        return false;
      }
    }
    return true;
  };
  var compareByOriginalPositions = function(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  };
  var compareByGeneratedPositionsDeflated = function(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  };
  var strcmp = function(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }
    if (aStr1 === null) {
      return 1;
    }
    if (aStr2 === null) {
      return -1;
    }
    if (aStr1 > aStr2) {
      return 1;
    }
    return -1;
  };
  var compareByGeneratedPositionsInflated = function(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  };
  var parseSourceMapInput = function(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
  };
  var computeSourceURL = function(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || "";
    if (sourceRoot) {
      if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
        sourceRoot += "/";
      }
      sourceURL = sourceRoot + sourceURL;
    }
    if (sourceMapURL) {
      var parsed = urlParse(sourceMapURL);
      if (!parsed) {
        throw new Error("sourceMapURL could not be parsed");
      }
      if (parsed.path) {
        var index = parsed.path.lastIndexOf("/");
        if (index >= 0) {
          parsed.path = parsed.path.substring(0, index + 1);
        }
      }
      sourceURL = join(urlGenerate(parsed), sourceURL);
    }
    return normalize(sourceURL);
  };
  exports.getArg = getArg;
  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;
  exports.urlParse = urlParse;
  exports.urlGenerate = urlGenerate;
  exports.normalize = normalize;
  exports.join = join;
  exports.isAbsolute = function(aPath) {
    return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
  };
  exports.relative = relative;
  var supportsNullProto = function() {
    var obj = Object.create(null);
    return !("__proto__" in obj);
  }();
  exports.toSetString = supportsNullProto ? identity : toSetString;
  exports.fromSetString = supportsNullProto ? identity : fromSetString;
  exports.compareByOriginalPositions = compareByOriginalPositions;
  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  exports.parseSourceMapInput = parseSourceMapInput;
  exports.computeSourceURL = computeSourceURL;
});

// node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS((exports) => {
  var ArraySet = function() {
    this._array = [];
    this._set = hasNativeMap ? new Map : Object.create(null);
  };
  var util = require_util();
  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet;
    for (var i = 0, len = aArray.length;i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };
  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util.toSetString(aStr);
      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error("No element indexed by " + aIdx);
  };
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };
  exports.ArraySet = ArraySet;
});

// node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS((exports) => {
  var generatedPositionAfter = function(mappingA, mappingB) {
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  };
  var MappingList = function() {
    this._array = [];
    this._sorted = true;
    this._last = { generatedLine: -1, generatedColumn: 0 };
  };
  var util = require_util();
  MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };
  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };
  exports.MappingList = MappingList;
});

// node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS((exports) => {
  var SourceMapGenerator = function(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, "file", null);
    this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
    this._skipValidation = util.getArg(aArgs, "skipValidation", false);
    this._sources = new ArraySet;
    this._names = new ArraySet;
    this._mappings = new MappingList;
    this._sourcesContents = null;
  };
  var base64VLQ = require_base64_vlq();
  var util = require_util();
  var ArraySet = require_array_set().ArraySet;
  var MappingList = require_mapping_list().MappingList;
  SourceMapGenerator.prototype._version = 3;
  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot
    });
    aSourceMapConsumer.eachMapping(function(mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };
      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }
        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };
        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }
      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }
      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };
  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, "generated");
    var original = util.getArg(aArgs, "original", null);
    var source = util.getArg(aArgs, "source", null);
    var name = util.getArg(aArgs, "name", null);
    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }
    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }
    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }
    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source,
      name
    });
  };
  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }
    if (aSourceContent != null) {
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };
  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.');
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    var newSources = new ArraySet;
    var newNames = new ArraySet;
    this._mappings.unsortedForEach(function(mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }
      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }
      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }
    }, this);
    this._sources = newSources;
    this._names = newNames;
    aSourceMapConsumer.sources.forEach(function(sourceFile2) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile2 = util.join(aSourceMapPath, sourceFile2);
        }
        if (sourceRoot != null) {
          sourceFile2 = util.relative(sourceRoot, sourceFile2);
        }
        this.setSourceContent(sourceFile2, content);
      }
    }, this);
  };
  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
      throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
    }
    if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      return;
    } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      return;
    } else {
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };
  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = "";
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;
    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length;i < len; i++) {
      mapping = mappings[i];
      next = "";
      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ";";
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ",";
        }
      }
      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;
      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;
        next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;
        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }
      result += next;
    }
    return result;
  };
  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function(source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };
  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }
    return map;
  };
  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };
  exports.SourceMapGenerator = SourceMapGenerator;
});

// node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS((exports) => {
  var recursiveSearch = function(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      return mid;
    } else if (cmp > 0) {
      if (aHigh - mid > 1) {
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    } else {
      if (mid - aLow > 1) {
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  };
  exports.GREATEST_LOWER_BOUND = 1;
  exports.LEAST_UPPER_BOUND = 2;
  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }
    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    if (index < 0) {
      return -1;
    }
    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }
      --index;
    }
    return index;
  };
});

// node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS((exports) => {
  var swap = function(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  };
  var randomIntInRange = function(low, high) {
    return Math.round(low + Math.random() * (high - low));
  };
  var doQuickSort = function(ary, comparator, p, r) {
    if (p < r) {
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;
      swap(ary, pivotIndex, r);
      var pivot = ary[r];
      for (var j = p;j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }
      swap(ary, i + 1, j);
      var q = i + 1;
      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  };
  exports.quickSort = function(ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };
});

// node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS((exports) => {
  var SourceMapConsumer = function(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
  };
  var BasicSourceMapConsumer = function(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, "version");
    var sources = util.getArg(sourceMap, "sources");
    var names = util.getArg(sourceMap, "names", []);
    var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
    var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
    var mappings = util.getArg(sourceMap, "mappings");
    var file = util.getArg(sourceMap, "file", null);
    if (version != this._version) {
      throw new Error("Unsupported version: " + version);
    }
    if (sourceRoot) {
      sourceRoot = util.normalize(sourceRoot);
    }
    sources = sources.map(String).map(util.normalize).map(function(source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
    });
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);
    this._absoluteSources = this._sources.toArray().map(function(s) {
      return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
    });
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this._sourceMapURL = aSourceMapURL;
    this.file = file;
  };
  var Mapping = function() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  };
  var IndexedSourceMapConsumer = function(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, "version");
    var sections = util.getArg(sourceMap, "sections");
    if (version != this._version) {
      throw new Error("Unsupported version: " + version);
    }
    this._sources = new ArraySet;
    this._names = new ArraySet;
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function(s) {
      if (s.url) {
        throw new Error("Support for url field in sections not implemented.");
      }
      var offset = util.getArg(s, "offset");
      var offsetLine = util.getArg(offset, "line");
      var offsetColumn = util.getArg(offset, "column");
      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
        throw new Error("Section offsets must be ordered and non-overlapping.");
      }
      lastOffset = offset;
      return {
        generatedOffset: {
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
      };
    });
  };
  var util = require_util();
  var binarySearch = require_binary_search();
  var ArraySet = require_array_set().ArraySet;
  var base64VLQ = require_base64_vlq();
  var quickSort = require_quick_sort().quickSort;
  SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
  };
  SourceMapConsumer.prototype._version = 3;
  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
    configurable: true,
    enumerable: true,
    get: function() {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__generatedMappings;
    }
  });
  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
    configurable: true,
    enumerable: true,
    get: function() {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__originalMappings;
    }
  });
  SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };
  SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };
  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;
  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
  SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    var mappings;
    switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var sourceRoot = this.sourceRoot;
    mappings.map(function(mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };
  SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, "line");
    var needle = {
      source: util.getArg(aArgs, "source"),
      originalLine: line,
      originalColumn: util.getArg(aArgs, "column", 0)
    };
    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }
    var mappings = [];
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;
        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index];
        }
      }
    }
    return mappings;
  };
  exports.SourceMapConsumer = SourceMapConsumer;
  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
  BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    if (this._sources.has(relativeSource)) {
      return this._sources.indexOf(relativeSource);
    }
    var i;
    for (i = 0;i < this._absoluteSources.length; ++i) {
      if (this._absoluteSources[i] == aSource) {
        return i;
      }
    }
    return -1;
  };
  BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function(s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });
    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];
    for (var i = 0, length = generatedMappings.length;i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;
      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;
        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }
        destOriginalMappings.push(destMapping);
      }
      destGeneratedMappings.push(destMapping);
    }
    quickSort(smc.__originalMappings, util.compareByOriginalPositions);
    return smc;
  };
  BasicSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
    get: function() {
      return this._absoluteSources.slice();
    }
  });
  BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;
    while (index < length) {
      if (aStr.charAt(index) === ";") {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      } else if (aStr.charAt(index) === ",") {
        index++;
      } else {
        mapping = new Mapping;
        mapping.generatedLine = generatedLine;
        for (end = index;end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);
        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }
          if (segment.length === 2) {
            throw new Error("Found a source, but no line and column");
          }
          if (segment.length === 3) {
            throw new Error("Found a source and line, but no column");
          }
          cachedSegments[str] = segment;
        }
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;
        if (segment.length > 1) {
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          mapping.originalLine += 1;
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;
          if (segment.length > 4) {
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }
        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === "number") {
          originalMappings.push(mapping);
        }
      }
    }
    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;
    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };
  BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    if (aNeedle[aLineName] <= 0) {
      throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
    }
    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };
  BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0;index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];
        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }
      mapping.lastGeneratedColumn = Infinity;
    }
  };
  BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    };
    var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._generatedMappings[index];
      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, "source", null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util.getArg(mapping, "name", null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source,
          line: util.getArg(mapping, "originalLine", null),
          column: util.getArg(mapping, "originalColumn", null),
          name
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
      return sc == null;
    });
  };
  BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }
    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    var url;
    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }
      if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };
  BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, "source");
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    var needle = {
      source,
      originalLine: util.getArg(aArgs, "line"),
      originalColumn: util.getArg(aArgs, "column")
    };
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, "generatedLine", null),
          column: util.getArg(mapping, "generatedColumn", null),
          lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
        };
      }
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };
  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
  IndexedSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
    get: function() {
      var sources = [];
      for (var i = 0;i < this._sections.length; i++) {
        for (var j = 0;j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }
      return sources;
    }
  });
  IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    };
    var sectionIndex = binarySearch.search(needle, this._sections, function(needle2, section2) {
      var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
      if (cmp) {
        return cmp;
      }
      return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
    });
    var section = this._sections[sectionIndex];
    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }
    return section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    });
  };
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function(s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };
  IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0;i < this._sections.length; i++) {
      var section = this._sections[i];
      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };
  IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0;i < this._sections.length; i++) {
      var section = this._sections[i];
      if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
        };
        return ret;
      }
    }
    return {
      line: null,
      column: null
    };
  };
  IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0;i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0;j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];
        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);
        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }
        var adjustedMapping = {
          source,
          generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name
        };
        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === "number") {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }
    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };
  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
});

// node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS((exports) => {
  var SourceNode = function(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null)
      this.add(aChunks);
  };
  var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
  var util = require_util();
  var REGEX_NEWLINE = /(\r?\n)/;
  var NEWLINE_CODE = 10;
  var isSourceNode = "$$$isSourceNode$$$";
  SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    var node = new SourceNode;
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      var newLine = getNextLine() || "";
      return lineContents + newLine;
      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
      }
    };
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;
    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function(mapping) {
      if (lastMapping !== null) {
        if (lastGeneratedLine < mapping.generatedLine) {
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
        } else {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          lastMapping = mapping;
          return;
        }
      }
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || "";
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });
    return node;
    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
        node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
      }
    }
  };
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function(chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length - 1;i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length;i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else {
        if (chunk !== "") {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name
          });
        }
      }
    }
  };
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0;i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === "string") {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push("".replace(aPattern, aReplacement));
    }
    return this;
  };
  SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };
  SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length;i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }
    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length;i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function(chunk) {
      str += chunk;
    });
    return str;
  };
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function(chunk, original) {
      generated.code += chunk;
      if (original.source !== null && original.line !== null && original.column !== null) {
        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length;idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function(sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });
    return { code: generated.code, map };
  };
  exports.SourceNode = SourceNode;
});

// node_modules/source-map/source-map.js
var require_source_map = __commonJS((exports) => {
  exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
  exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
  exports.SourceNode = require_source_node().SourceNode;
});

// node_modules/clean-css/lib/reader/input-source-map-tracker.js
var require_input_source_map_tracker = __commonJS((exports, module) => {
  var inputSourceMapTracker = function() {
    var maps = {};
    return {
      all: all2.bind(null, maps),
      isTracking: isTracking.bind(null, maps),
      originalPositionFor: originalPositionFor.bind(null, maps),
      track: track.bind(null, maps)
    };
  };
  var all2 = function(maps) {
    return maps;
  };
  var isTracking = function(maps, source) {
    return source in maps;
  };
  var originalPositionFor = function(maps, metadata, range, selectorFallbacks) {
    var line = metadata[0];
    var column = metadata[1];
    var source = metadata[2];
    var position = {
      line,
      column: column + range
    };
    var originalPosition;
    while (!originalPosition && position.column > column) {
      position.column--;
      originalPosition = maps[source].originalPositionFor(position);
    }
    if (!originalPosition || originalPosition.column < 0) {
      return metadata;
    }
    if (originalPosition.line === null && line > 1 && selectorFallbacks > 0) {
      return originalPositionFor(maps, [line - 1, column, source], range, selectorFallbacks - 1);
    }
    return originalPosition.line !== null ? toMetadata(originalPosition) : metadata;
  };
  var toMetadata = function(asHash) {
    return [asHash.line, asHash.column, asHash.source];
  };
  var track = function(maps, source, data) {
    maps[source] = new SourceMapConsumer(data);
  };
  var SourceMapConsumer = require_source_map().SourceMapConsumer;
  module.exports = inputSourceMapTracker;
});

// node_modules/clean-css/lib/utils/is-remote-resource.js
var require_is_remote_resource = __commonJS((exports, module) => {
  var isRemoteResource = function(uri) {
    return REMOTE_RESOURCE_PATTERN.test(uri);
  };
  var REMOTE_RESOURCE_PATTERN = /^(\w+:\/\/|\/\/)/;
  module.exports = isRemoteResource;
});

// node_modules/clean-css/lib/utils/has-protocol.js
var require_has_protocol = __commonJS((exports, module) => {
  var hasProtocol = function(uri) {
    return !NO_PROTOCOL_RESOURCE_PATTERN.test(uri);
  };
  var NO_PROTOCOL_RESOURCE_PATTERN = /^\/\//;
  module.exports = hasProtocol;
});

// node_modules/clean-css/lib/reader/is-allowed-resource.js
var require_is_allowed_resource = __commonJS((exports, module) => {
  var isAllowedResource = function(uri, isRemote, rules) {
    var match;
    var absoluteUri;
    var allowed = isRemote ? false : true;
    var rule;
    var isNegated;
    var normalizedRule;
    var i;
    if (rules.length === 0) {
      return false;
    }
    if (isRemote && !hasProtocol(uri)) {
      uri = HTTP_PROTOCOL + uri;
    }
    match = isRemote ? url.parse(uri).host : uri;
    absoluteUri = isRemote ? uri : path.resolve(uri);
    for (i = 0;i < rules.length; i++) {
      rule = rules[i];
      isNegated = rule[0] == "!";
      normalizedRule = rule.substring(1);
      if (isNegated && isRemote && isRemoteRule(normalizedRule)) {
        allowed = allowed && !isAllowedResource(uri, true, [normalizedRule]);
      } else if (isNegated && !isRemote && !isRemoteRule(normalizedRule)) {
        allowed = allowed && !isAllowedResource(uri, false, [normalizedRule]);
      } else if (isNegated) {
        allowed = allowed && true;
      } else if (rule == "all") {
        allowed = true;
      } else if (isRemote && rule == "local") {
        allowed = allowed || false;
      } else if (isRemote && rule == "remote") {
        allowed = true;
      } else if (!isRemote && rule == "remote") {
        allowed = false;
      } else if (!isRemote && rule == "local") {
        allowed = true;
      } else if (rule === match) {
        allowed = true;
      } else if (rule === uri) {
        allowed = true;
      } else if (isRemote && absoluteUri.indexOf(rule) === 0) {
        allowed = true;
      } else if (!isRemote && absoluteUri.indexOf(path.resolve(rule)) === 0) {
        allowed = true;
      } else if (isRemote != isRemoteRule(normalizedRule)) {
        allowed = allowed && true;
      } else {
        allowed = false;
      }
    }
    return allowed;
  };
  var isRemoteRule = function(rule) {
    return isRemoteResource(rule) || url.parse(HTTP_PROTOCOL + "//" + rule).host == rule;
  };
  var path = import.meta.require("path");
  var url = import.meta.require("url");
  var isRemoteResource = require_is_remote_resource();
  var hasProtocol = require_has_protocol();
  var HTTP_PROTOCOL = "http:";
  module.exports = isAllowedResource;
});

// node_modules/clean-css/lib/reader/match-data-uri.js
var require_match_data_uri = __commonJS((exports, module) => {
  var matchDataUri = function(uri) {
    return DATA_URI_PATTERN.exec(uri);
  };
  var DATA_URI_PATTERN = /^data:(\S*?)?(;charset=[^;]+)?(;[^,]+?)?,(.+)/;
  module.exports = matchDataUri;
});

// node_modules/clean-css/lib/reader/rebase-local-map.js
var require_rebase_local_map = __commonJS((exports, module) => {
  var rebaseLocalMap = function(sourceMap, sourceUri, rebaseTo) {
    var currentPath = path.resolve("");
    var absoluteUri = path.resolve(currentPath, sourceUri);
    var absoluteUriDirectory = path.dirname(absoluteUri);
    sourceMap.sources = sourceMap.sources.map(function(source) {
      return path.relative(rebaseTo, path.resolve(absoluteUriDirectory, source));
    });
    return sourceMap;
  };
  var path = import.meta.require("path");
  module.exports = rebaseLocalMap;
});

// node_modules/clean-css/lib/reader/rebase-remote-map.js
var require_rebase_remote_map = __commonJS((exports, module) => {
  var rebaseRemoteMap = function(sourceMap, sourceUri) {
    var sourceDirectory = path.dirname(sourceUri);
    sourceMap.sources = sourceMap.sources.map(function(source) {
      return url.resolve(sourceDirectory, source);
    });
    return sourceMap;
  };
  var path = import.meta.require("path");
  var url = import.meta.require("url");
  module.exports = rebaseRemoteMap;
});

// node_modules/clean-css/lib/utils/is-data-uri-resource.js
var require_is_data_uri_resource = __commonJS((exports, module) => {
  var isDataUriResource = function(uri) {
    return DATA_URI_PATTERN.test(uri);
  };
  var DATA_URI_PATTERN = /^data:(\S*?)?(;charset=[^;]+)?(;[^,]+?)?,(.+)/;
  module.exports = isDataUriResource;
});

// node_modules/clean-css/lib/reader/apply-source-maps.js
var require_apply_source_maps = __commonJS((exports, module) => {
  var applySourceMaps = function(tokens, context, callback) {
    var applyContext = {
      callback,
      fetch: context.options.fetch,
      index: 0,
      inline: context.options.inline,
      inlineRequest: context.options.inlineRequest,
      inlineTimeout: context.options.inlineTimeout,
      inputSourceMapTracker: context.inputSourceMapTracker,
      localOnly: context.localOnly,
      processedTokens: [],
      rebaseTo: context.options.rebaseTo,
      sourceTokens: tokens,
      warnings: context.warnings
    };
    return context.options.sourceMap && tokens.length > 0 ? doApplySourceMaps(applyContext) : callback(tokens);
  };
  var doApplySourceMaps = function(applyContext) {
    var singleSourceTokens = [];
    var lastSource = findTokenSource(applyContext.sourceTokens[0]);
    var source;
    var token;
    var l;
    for (l = applyContext.sourceTokens.length;applyContext.index < l; applyContext.index++) {
      token = applyContext.sourceTokens[applyContext.index];
      source = findTokenSource(token);
      if (source != lastSource) {
        singleSourceTokens = [];
        lastSource = source;
      }
      singleSourceTokens.push(token);
      applyContext.processedTokens.push(token);
      if (token[0] == Token.COMMENT && MAP_MARKER_PATTERN.test(token[1])) {
        return fetchAndApplySourceMap(token[1], source, singleSourceTokens, applyContext);
      }
    }
    return applyContext.callback(applyContext.processedTokens);
  };
  var findTokenSource = function(token) {
    var scope;
    var metadata;
    if (token[0] == Token.AT_RULE || token[0] == Token.COMMENT) {
      metadata = token[2][0];
    } else {
      scope = token[1][0];
      metadata = scope[2][0];
    }
    return metadata[2];
  };
  var fetchAndApplySourceMap = function(sourceMapComment, source, singleSourceTokens, applyContext) {
    return extractInputSourceMapFrom(sourceMapComment, applyContext, function(inputSourceMap) {
      if (inputSourceMap) {
        applyContext.inputSourceMapTracker.track(source, inputSourceMap);
        applySourceMapRecursively(singleSourceTokens, applyContext.inputSourceMapTracker);
      }
      applyContext.index++;
      return doApplySourceMaps(applyContext);
    });
  };
  var extractInputSourceMapFrom = function(sourceMapComment, applyContext, whenSourceMapReady) {
    var uri = MAP_MARKER_PATTERN.exec(sourceMapComment)[1];
    var absoluteUri;
    var sourceMap;
    var rebasedMap;
    if (isDataUriResource(uri)) {
      sourceMap = extractInputSourceMapFromDataUri(uri);
      return whenSourceMapReady(sourceMap);
    } else if (isRemoteResource(uri)) {
      return loadInputSourceMapFromRemoteUri(uri, applyContext, function(sourceMap2) {
        var parsedMap;
        if (sourceMap2) {
          parsedMap = JSON.parse(sourceMap2);
          rebasedMap = rebaseRemoteMap(parsedMap, uri);
          whenSourceMapReady(rebasedMap);
        } else {
          whenSourceMapReady(null);
        }
      });
    } else {
      absoluteUri = path.resolve(applyContext.rebaseTo, uri);
      sourceMap = loadInputSourceMapFromLocalUri(absoluteUri, applyContext);
      if (sourceMap) {
        rebasedMap = rebaseLocalMap(sourceMap, absoluteUri, applyContext.rebaseTo);
        return whenSourceMapReady(rebasedMap);
      } else {
        return whenSourceMapReady(null);
      }
    }
  };
  var extractInputSourceMapFromDataUri = function(uri) {
    var dataUriMatch = matchDataUri(uri);
    var charset = dataUriMatch[2] ? dataUriMatch[2].split(/[=;]/)[2] : "us-ascii";
    var encoding = dataUriMatch[3] ? dataUriMatch[3].split(";")[1] : "utf8";
    var data = encoding == "utf8" ? global.unescape(dataUriMatch[4]) : dataUriMatch[4];
    var buffer = new Buffer(data, encoding);
    buffer.charset = charset;
    return JSON.parse(buffer.toString());
  };
  var loadInputSourceMapFromRemoteUri = function(uri, applyContext, whenLoaded) {
    var isAllowed = isAllowedResource(uri, true, applyContext.inline);
    var isRuntimeResource = !hasProtocol(uri);
    if (applyContext.localOnly) {
      applyContext.warnings.push('Cannot fetch remote resource from "' + uri + '" as no callback given.');
      return whenLoaded(null);
    } else if (isRuntimeResource) {
      applyContext.warnings.push('Cannot fetch "' + uri + '" as no protocol given.');
      return whenLoaded(null);
    } else if (!isAllowed) {
      applyContext.warnings.push('Cannot fetch "' + uri + '" as resource is not allowed.');
      return whenLoaded(null);
    }
    applyContext.fetch(uri, applyContext.inlineRequest, applyContext.inlineTimeout, function(error, body) {
      if (error) {
        applyContext.warnings.push('Missing source map at "' + uri + '" - ' + error);
        return whenLoaded(null);
      }
      whenLoaded(body);
    });
  };
  var loadInputSourceMapFromLocalUri = function(uri, applyContext) {
    var isAllowed = isAllowedResource(uri, false, applyContext.inline);
    var sourceMap;
    if (!fs.existsSync(uri) || !fs.statSync(uri).isFile()) {
      applyContext.warnings.push('Ignoring local source map at "' + uri + '" as resource is missing.');
      return null;
    } else if (!isAllowed) {
      applyContext.warnings.push('Cannot fetch "' + uri + '" as resource is not allowed.');
      return null;
    }
    sourceMap = fs.readFileSync(uri, "utf-8");
    return JSON.parse(sourceMap);
  };
  var applySourceMapRecursively = function(tokens, inputSourceMapTracker) {
    var token;
    var i, l;
    for (i = 0, l = tokens.length;i < l; i++) {
      token = tokens[i];
      switch (token[0]) {
        case Token.AT_RULE:
          applySourceMapTo(token, inputSourceMapTracker);
          break;
        case Token.AT_RULE_BLOCK:
          applySourceMapRecursively(token[1], inputSourceMapTracker);
          applySourceMapRecursively(token[2], inputSourceMapTracker);
          break;
        case Token.AT_RULE_BLOCK_SCOPE:
          applySourceMapTo(token, inputSourceMapTracker);
          break;
        case Token.NESTED_BLOCK:
          applySourceMapRecursively(token[1], inputSourceMapTracker);
          applySourceMapRecursively(token[2], inputSourceMapTracker);
          break;
        case Token.NESTED_BLOCK_SCOPE:
          applySourceMapTo(token, inputSourceMapTracker);
          break;
        case Token.COMMENT:
          applySourceMapTo(token, inputSourceMapTracker);
          break;
        case Token.PROPERTY:
          applySourceMapRecursively(token, inputSourceMapTracker);
          break;
        case Token.PROPERTY_BLOCK:
          applySourceMapRecursively(token[1], inputSourceMapTracker);
          break;
        case Token.PROPERTY_NAME:
          applySourceMapTo(token, inputSourceMapTracker);
          break;
        case Token.PROPERTY_VALUE:
          applySourceMapTo(token, inputSourceMapTracker);
          break;
        case Token.RULE:
          applySourceMapRecursively(token[1], inputSourceMapTracker);
          applySourceMapRecursively(token[2], inputSourceMapTracker);
          break;
        case Token.RULE_SCOPE:
          applySourceMapTo(token, inputSourceMapTracker);
      }
    }
    return tokens;
  };
  var applySourceMapTo = function(token, inputSourceMapTracker) {
    var value = token[1];
    var metadata = token[2];
    var newMetadata = [];
    var i, l;
    for (i = 0, l = metadata.length;i < l; i++) {
      newMetadata.push(inputSourceMapTracker.originalPositionFor(metadata[i], value.length));
    }
    token[2] = newMetadata;
  };
  var fs = import.meta.require("fs");
  var path = import.meta.require("path");
  var isAllowedResource = require_is_allowed_resource();
  var matchDataUri = require_match_data_uri();
  var rebaseLocalMap = require_rebase_local_map();
  var rebaseRemoteMap = require_rebase_remote_map();
  var Token = require_token();
  var hasProtocol = require_has_protocol();
  var isDataUriResource = require_is_data_uri_resource();
  var isRemoteResource = require_is_remote_resource();
  var MAP_MARKER_PATTERN = /^\/\*# sourceMappingURL=(\S+) \*\/$/;
  module.exports = applySourceMaps;
});

// node_modules/clean-css/lib/reader/extract-import-url-and-media.js
var require_extract_import_url_and_media = __commonJS((exports, module) => {
  var extractImportUrlAndMedia = function(atRuleValue) {
    var uri;
    var mediaQuery;
    var stripped;
    var parts;
    stripped = atRuleValue.replace(IMPORT_PREFIX_PATTERN, "").trim().replace(URL_PREFIX_PATTERN, "(").replace(URL_SUFFIX_PATTERN, ")").replace(QUOTE_PREFIX_PATTERN, "").replace(QUOTE_SUFFIX_PATTERN, "");
    parts = split(stripped, " ");
    uri = parts[0].replace(BRACE_PREFIX, "").replace(BRACE_SUFFIX, "");
    mediaQuery = parts.slice(1).join(" ");
    return [uri, mediaQuery];
  };
  var split = require_split();
  var BRACE_PREFIX = /^\(/;
  var BRACE_SUFFIX = /\)$/;
  var IMPORT_PREFIX_PATTERN = /^@import/i;
  var QUOTE_PREFIX_PATTERN = /['"]\s*/;
  var QUOTE_SUFFIX_PATTERN = /\s*['"]/;
  var URL_PREFIX_PATTERN = /^url\(\s*/i;
  var URL_SUFFIX_PATTERN = /\s*\)/i;
  module.exports = extractImportUrlAndMedia;
});

// node_modules/clean-css/lib/reader/load-original-sources.js
var require_load_original_sources = __commonJS((exports, module) => {
  var loadOriginalSources = function(context, callback) {
    var loadContext = {
      callback,
      fetch: context.options.fetch,
      index: 0,
      inline: context.options.inline,
      inlineRequest: context.options.inlineRequest,
      inlineTimeout: context.options.inlineTimeout,
      localOnly: context.localOnly,
      rebaseTo: context.options.rebaseTo,
      sourcesContent: context.sourcesContent,
      uriToSource: uriToSourceMapping(context.inputSourceMapTracker.all()),
      warnings: context.warnings
    };
    return context.options.sourceMap && context.options.sourceMapInlineSources ? doLoadOriginalSources(loadContext) : callback();
  };
  var uriToSourceMapping = function(allSourceMapConsumers) {
    var mapping = {};
    var consumer;
    var uri;
    var source;
    var i, l;
    for (source in allSourceMapConsumers) {
      consumer = allSourceMapConsumers[source];
      for (i = 0, l = consumer.sources.length;i < l; i++) {
        uri = consumer.sources[i];
        source = consumer.sourceContentFor(uri, true);
        mapping[uri] = source;
      }
    }
    return mapping;
  };
  var doLoadOriginalSources = function(loadContext) {
    var uris = Object.keys(loadContext.uriToSource);
    var uri;
    var source;
    var total;
    for (total = uris.length;loadContext.index < total; loadContext.index++) {
      uri = uris[loadContext.index];
      source = loadContext.uriToSource[uri];
      if (source) {
        loadContext.sourcesContent[uri] = source;
      } else {
        return loadOriginalSource(uri, loadContext);
      }
    }
    return loadContext.callback();
  };
  var loadOriginalSource = function(uri, loadContext) {
    var content;
    if (isRemoteResource(uri)) {
      return loadOriginalSourceFromRemoteUri(uri, loadContext, function(content2) {
        loadContext.index++;
        loadContext.sourcesContent[uri] = content2;
        return doLoadOriginalSources(loadContext);
      });
    } else {
      content = loadOriginalSourceFromLocalUri(uri, loadContext);
      loadContext.index++;
      loadContext.sourcesContent[uri] = content;
      return doLoadOriginalSources(loadContext);
    }
  };
  var loadOriginalSourceFromRemoteUri = function(uri, loadContext, whenLoaded) {
    var isAllowed = isAllowedResource(uri, true, loadContext.inline);
    var isRuntimeResource = !hasProtocol(uri);
    if (loadContext.localOnly) {
      loadContext.warnings.push('Cannot fetch remote resource from "' + uri + '" as no callback given.');
      return whenLoaded(null);
    } else if (isRuntimeResource) {
      loadContext.warnings.push('Cannot fetch "' + uri + '" as no protocol given.');
      return whenLoaded(null);
    } else if (!isAllowed) {
      loadContext.warnings.push('Cannot fetch "' + uri + '" as resource is not allowed.');
      return whenLoaded(null);
    }
    loadContext.fetch(uri, loadContext.inlineRequest, loadContext.inlineTimeout, function(error, content) {
      if (error) {
        loadContext.warnings.push('Missing original source at "' + uri + '" - ' + error);
      }
      whenLoaded(content);
    });
  };
  var loadOriginalSourceFromLocalUri = function(relativeUri, loadContext) {
    var isAllowed = isAllowedResource(relativeUri, false, loadContext.inline);
    var absoluteUri = path.resolve(loadContext.rebaseTo, relativeUri);
    if (!fs.existsSync(absoluteUri) || !fs.statSync(absoluteUri).isFile()) {
      loadContext.warnings.push('Ignoring local source map at "' + absoluteUri + '" as resource is missing.');
      return null;
    } else if (!isAllowed) {
      loadContext.warnings.push('Cannot fetch "' + absoluteUri + '" as resource is not allowed.');
      return null;
    }
    return fs.readFileSync(absoluteUri, "utf8");
  };
  var fs = import.meta.require("fs");
  var path = import.meta.require("path");
  var isAllowedResource = require_is_allowed_resource();
  var hasProtocol = require_has_protocol();
  var isRemoteResource = require_is_remote_resource();
  module.exports = loadOriginalSources;
});

// node_modules/clean-css/lib/reader/normalize-path.js
var require_normalize_path = __commonJS((exports, module) => {
  var normalizePath = function(path) {
    return path.replace(WINDOWS_SEPARATOR_PATTERN, UNIX_SEPARATOR);
  };
  var UNIX_SEPARATOR = "/";
  var WINDOWS_SEPARATOR_PATTERN = /\\/g;
  module.exports = normalizePath;
});

// node_modules/clean-css/lib/reader/restore-import.js
var require_restore_import = __commonJS((exports, module) => {
  var restoreImport = function(uri, mediaQuery) {
    return ("@import " + uri + " " + mediaQuery).trim();
  };
  module.exports = restoreImport;
});

// node_modules/clean-css/lib/reader/rewrite-url.js
var require_rewrite_url = __commonJS((exports, module) => {
  var rebase = function(uri, rebaseConfig) {
    if (!rebaseConfig) {
      return uri;
    }
    if (isAbsolute(uri) && !isRemote(rebaseConfig.toBase)) {
      return uri;
    }
    if (isRemote(uri) || isSVGMarker(uri) || isInternal(uri)) {
      return uri;
    }
    if (isData(uri)) {
      return "\'" + uri + "\'";
    }
    if (isRemote(rebaseConfig.toBase)) {
      return url.resolve(rebaseConfig.toBase, uri);
    }
    return rebaseConfig.absolute ? normalize(absolute(uri, rebaseConfig)) : normalize(relative(uri, rebaseConfig));
  };
  var isAbsolute = function(uri) {
    return path.isAbsolute(uri);
  };
  var isSVGMarker = function(uri) {
    return uri[0] == "#";
  };
  var isInternal = function(uri) {
    return /^\w+:\w+/.test(uri);
  };
  var isRemote = function(uri) {
    return /^[^:]+?:\/\//.test(uri) || uri.indexOf("//") === 0;
  };
  var isData = function(uri) {
    return uri.indexOf("data:") === 0;
  };
  var absolute = function(uri, rebaseConfig) {
    return path.resolve(path.join(rebaseConfig.fromBase || "", uri)).replace(rebaseConfig.toBase, "");
  };
  var relative = function(uri, rebaseConfig) {
    return path.relative(rebaseConfig.toBase, path.join(rebaseConfig.fromBase || "", uri));
  };
  var normalize = function(uri) {
    return isWindows ? uri.replace(/\\/g, "/") : uri;
  };
  var quoteFor = function(unquotedUrl) {
    if (unquotedUrl.indexOf(SINGLE_QUOTE) > -1) {
      return DOUBLE_QUOTE;
    } else if (unquotedUrl.indexOf(DOUBLE_QUOTE) > -1) {
      return SINGLE_QUOTE;
    } else if (hasWhitespace(unquotedUrl) || hasRoundBrackets(unquotedUrl)) {
      return SINGLE_QUOTE;
    } else {
      return "";
    }
  };
  var hasWhitespace = function(url2) {
    return WHITESPACE_PATTERN.test(url2);
  };
  var hasRoundBrackets = function(url2) {
    return ROUND_BRACKETS_PATTERN.test(url2);
  };
  var rewriteUrl = function(originalUrl, rebaseConfig, pathOnly) {
    var strippedUrl = originalUrl.replace(URL_PREFIX_PATTERN, "").replace(URL_SUFFIX_PATTERN, "").trim();
    var unquotedUrl = strippedUrl.replace(QUOTE_PREFIX_PATTERN, "").replace(QUOTE_SUFFIX_PATTERN, "").trim();
    var quote = strippedUrl[0] == SINGLE_QUOTE || strippedUrl[0] == DOUBLE_QUOTE ? strippedUrl[0] : quoteFor(unquotedUrl);
    return pathOnly ? rebase(unquotedUrl, rebaseConfig) : URL_PREFIX + quote + rebase(unquotedUrl, rebaseConfig) + quote + URL_SUFFIX;
  };
  var path = import.meta.require("path");
  var url = import.meta.require("url");
  var DOUBLE_QUOTE = '"';
  var SINGLE_QUOTE = "\'";
  var URL_PREFIX = "url(";
  var URL_SUFFIX = ")";
  var QUOTE_PREFIX_PATTERN = /^["']/;
  var QUOTE_SUFFIX_PATTERN = /["']$/;
  var ROUND_BRACKETS_PATTERN = /[\(\)]/;
  var URL_PREFIX_PATTERN = /^url\(/i;
  var URL_SUFFIX_PATTERN = /\)$/;
  var WHITESPACE_PATTERN = /\s/;
  var isWindows = process.platform == "win32";
  module.exports = rewriteUrl;
});

// node_modules/clean-css/lib/utils/is-import.js
var require_is_import = __commonJS((exports, module) => {
  var isImport = function(value) {
    return IMPORT_PREFIX_PATTERN.test(value);
  };
  var IMPORT_PREFIX_PATTERN = /^@import/i;
  module.exports = isImport;
});

// node_modules/clean-css/lib/reader/rebase.js
var require_rebase2 = __commonJS((exports, module) => {
  var rebase = function(tokens, rebaseAll, validator, rebaseConfig) {
    return rebaseAll ? rebaseEverything(tokens, validator, rebaseConfig) : rebaseAtRules(tokens, validator, rebaseConfig);
  };
  var rebaseEverything = function(tokens, validator, rebaseConfig) {
    var token;
    var i, l;
    for (i = 0, l = tokens.length;i < l; i++) {
      token = tokens[i];
      switch (token[0]) {
        case Token.AT_RULE:
          rebaseAtRule(token, validator, rebaseConfig);
          break;
        case Token.AT_RULE_BLOCK:
          rebaseProperties(token[2], validator, rebaseConfig);
          break;
        case Token.COMMENT:
          rebaseSourceMapComment(token, rebaseConfig);
          break;
        case Token.NESTED_BLOCK:
          rebaseEverything(token[2], validator, rebaseConfig);
          break;
        case Token.RULE:
          rebaseProperties(token[2], validator, rebaseConfig);
          break;
      }
    }
    return tokens;
  };
  var rebaseAtRules = function(tokens, validator, rebaseConfig) {
    var token;
    var i, l;
    for (i = 0, l = tokens.length;i < l; i++) {
      token = tokens[i];
      switch (token[0]) {
        case Token.AT_RULE:
          rebaseAtRule(token, validator, rebaseConfig);
          break;
      }
    }
    return tokens;
  };
  var rebaseAtRule = function(token, validator, rebaseConfig) {
    if (!isImport(token[1])) {
      return;
    }
    var uriAndMediaQuery = extractImportUrlAndMedia(token[1]);
    var newUrl = rewriteUrl(uriAndMediaQuery[0], rebaseConfig);
    var mediaQuery = uriAndMediaQuery[1];
    token[1] = restoreImport(newUrl, mediaQuery);
  };
  var rebaseSourceMapComment = function(token, rebaseConfig) {
    var matches = SOURCE_MAP_COMMENT_PATTERN.exec(token[1]);
    if (matches && matches[1].indexOf("data:") === -1) {
      token[1] = token[1].replace(matches[1], rewriteUrl(matches[1], rebaseConfig, true));
    }
  };
  var rebaseProperties = function(properties, validator, rebaseConfig) {
    var property;
    var value;
    var i, l;
    var j, m;
    for (i = 0, l = properties.length;i < l; i++) {
      property = properties[i];
      for (j = 2, m = property.length;j < m; j++) {
        value = property[j][1];
        if (validator.isUrl(value)) {
          property[j][1] = rewriteUrl(value, rebaseConfig);
        }
      }
    }
  };
  var extractImportUrlAndMedia = require_extract_import_url_and_media();
  var restoreImport = require_restore_import();
  var rewriteUrl = require_rewrite_url();
  var Token = require_token();
  var isImport = require_is_import();
  var SOURCE_MAP_COMMENT_PATTERN = /^\/\*# sourceMappingURL=(\S+) \*\/$/;
  module.exports = rebase;
});

// node_modules/clean-css/lib/tokenizer/tokenize.js
var require_tokenize = __commonJS((exports, module) => {
  var tokenize = function(source, externalContext) {
    var internalContext = {
      level: Level.BLOCK,
      position: {
        source: externalContext.source || undefined,
        line: 1,
        column: 0,
        index: 0
      }
    };
    return intoTokens(source, externalContext, internalContext, false);
  };
  var intoTokens = function(source, externalContext, internalContext, isNested) {
    var allTokens = [];
    var newTokens = allTokens;
    var lastToken;
    var ruleToken;
    var ruleTokens = [];
    var propertyToken;
    var metadata;
    var metadatas = [];
    var level = internalContext.level;
    var levels = [];
    var buffer = [];
    var buffers = [];
    var serializedBuffer;
    var serializedBufferPart;
    var roundBracketLevel = 0;
    var isQuoted;
    var isSpace;
    var isNewLineNix;
    var isNewLineWin;
    var isCarriageReturn;
    var isCommentStart;
    var wasCommentStart = false;
    var isCommentEnd;
    var wasCommentEnd = false;
    var isCommentEndMarker;
    var isEscaped;
    var wasEscaped = false;
    var isRaw = false;
    var seekingValue = false;
    var seekingPropertyBlockClosing = false;
    var position = internalContext.position;
    var lastCommentStartAt;
    for (;position.index < source.length; position.index++) {
      var character = source[position.index];
      isQuoted = level == Level.SINGLE_QUOTE || level == Level.DOUBLE_QUOTE;
      isSpace = character == Marker.SPACE || character == Marker.TAB;
      isNewLineNix = character == Marker.NEW_LINE_NIX;
      isNewLineWin = character == Marker.NEW_LINE_NIX && source[position.index - 1] == Marker.CARRIAGE_RETURN;
      isCarriageReturn = character == Marker.CARRIAGE_RETURN && source[position.index + 1] && source[position.index + 1] != Marker.NEW_LINE_NIX;
      isCommentStart = !wasCommentEnd && level != Level.COMMENT && !isQuoted && character == Marker.ASTERISK && source[position.index - 1] == Marker.FORWARD_SLASH;
      isCommentEndMarker = !wasCommentStart && !isQuoted && character == Marker.FORWARD_SLASH && source[position.index - 1] == Marker.ASTERISK;
      isCommentEnd = level == Level.COMMENT && isCommentEndMarker;
      roundBracketLevel = Math.max(roundBracketLevel, 0);
      metadata = buffer.length === 0 ? [position.line, position.column, position.source] : metadata;
      if (isEscaped) {
        buffer.push(character);
      } else if (!isCommentEnd && level == Level.COMMENT) {
        buffer.push(character);
      } else if (!isCommentStart && !isCommentEnd && isRaw) {
        buffer.push(character);
      } else if (isCommentStart && (level == Level.BLOCK || level == Level.RULE) && buffer.length > 1) {
        metadatas.push(metadata);
        buffer.push(character);
        buffers.push(buffer.slice(0, buffer.length - 2));
        buffer = buffer.slice(buffer.length - 2);
        metadata = [position.line, position.column - 1, position.source];
        levels.push(level);
        level = Level.COMMENT;
      } else if (isCommentStart) {
        levels.push(level);
        level = Level.COMMENT;
        buffer.push(character);
      } else if (isCommentEnd && isIgnoreStartComment(buffer)) {
        serializedBuffer = buffer.join("").trim() + character;
        lastToken = [Token.COMMENT, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]];
        newTokens.push(lastToken);
        isRaw = true;
        metadata = metadatas.pop() || null;
        buffer = buffers.pop() || [];
      } else if (isCommentEnd && isIgnoreEndComment(buffer)) {
        serializedBuffer = buffer.join("") + character;
        lastCommentStartAt = serializedBuffer.lastIndexOf(Marker.FORWARD_SLASH + Marker.ASTERISK);
        serializedBufferPart = serializedBuffer.substring(0, lastCommentStartAt);
        lastToken = [Token.RAW, serializedBufferPart, [originalMetadata(metadata, serializedBufferPart, externalContext)]];
        newTokens.push(lastToken);
        serializedBufferPart = serializedBuffer.substring(lastCommentStartAt);
        metadata = [position.line, position.column - serializedBufferPart.length + 1, position.source];
        lastToken = [Token.COMMENT, serializedBufferPart, [originalMetadata(metadata, serializedBufferPart, externalContext)]];
        newTokens.push(lastToken);
        isRaw = false;
        level = levels.pop();
        metadata = metadatas.pop() || null;
        buffer = buffers.pop() || [];
      } else if (isCommentEnd) {
        serializedBuffer = buffer.join("").trim() + character;
        lastToken = [Token.COMMENT, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]];
        newTokens.push(lastToken);
        level = levels.pop();
        metadata = metadatas.pop() || null;
        buffer = buffers.pop() || [];
      } else if (isCommentEndMarker && source[position.index + 1] != Marker.ASTERISK) {
        externalContext.warnings.push("Unexpected \'*/\' at " + formatPosition([position.line, position.column, position.source]) + ".");
        buffer = [];
      } else if (character == Marker.SINGLE_QUOTE && !isQuoted) {
        levels.push(level);
        level = Level.SINGLE_QUOTE;
        buffer.push(character);
      } else if (character == Marker.SINGLE_QUOTE && level == Level.SINGLE_QUOTE) {
        level = levels.pop();
        buffer.push(character);
      } else if (character == Marker.DOUBLE_QUOTE && !isQuoted) {
        levels.push(level);
        level = Level.DOUBLE_QUOTE;
        buffer.push(character);
      } else if (character == Marker.DOUBLE_QUOTE && level == Level.DOUBLE_QUOTE) {
        level = levels.pop();
        buffer.push(character);
      } else if (!isCommentStart && !isCommentEnd && character != Marker.CLOSE_ROUND_BRACKET && character != Marker.OPEN_ROUND_BRACKET && level != Level.COMMENT && !isQuoted && roundBracketLevel > 0) {
        buffer.push(character);
      } else if (character == Marker.OPEN_ROUND_BRACKET && !isQuoted && level != Level.COMMENT && !seekingValue) {
        buffer.push(character);
        roundBracketLevel++;
      } else if (character == Marker.CLOSE_ROUND_BRACKET && !isQuoted && level != Level.COMMENT && !seekingValue) {
        buffer.push(character);
        roundBracketLevel--;
      } else if (character == Marker.SEMICOLON && level == Level.BLOCK && buffer[0] == Marker.AT) {
        serializedBuffer = buffer.join("").trim();
        allTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        buffer = [];
      } else if (character == Marker.COMMA && level == Level.BLOCK && ruleToken) {
        serializedBuffer = buffer.join("").trim();
        ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, ruleToken[1].length)]]);
        buffer = [];
      } else if (character == Marker.COMMA && level == Level.BLOCK && tokenTypeFrom(buffer) == Token.AT_RULE) {
        buffer.push(character);
      } else if (character == Marker.COMMA && level == Level.BLOCK) {
        ruleToken = [tokenTypeFrom(buffer), [], []];
        serializedBuffer = buffer.join("").trim();
        ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, 0)]]);
        buffer = [];
      } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK && ruleToken && ruleToken[0] == Token.NESTED_BLOCK) {
        serializedBuffer = buffer.join("").trim();
        ruleToken[1].push([Token.NESTED_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        allTokens.push(ruleToken);
        levels.push(level);
        position.column++;
        position.index++;
        buffer = [];
        ruleToken[2] = intoTokens(source, externalContext, internalContext, true);
        ruleToken = null;
      } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK && tokenTypeFrom(buffer) == Token.NESTED_BLOCK) {
        serializedBuffer = buffer.join("").trim();
        ruleToken = ruleToken || [Token.NESTED_BLOCK, [], []];
        ruleToken[1].push([Token.NESTED_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        allTokens.push(ruleToken);
        levels.push(level);
        position.column++;
        position.index++;
        buffer = [];
        ruleToken[2] = intoTokens(source, externalContext, internalContext, true);
        ruleToken = null;
      } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK) {
        serializedBuffer = buffer.join("").trim();
        ruleToken = ruleToken || [tokenTypeFrom(buffer), [], []];
        ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, ruleToken[1].length)]]);
        newTokens = ruleToken[2];
        allTokens.push(ruleToken);
        levels.push(level);
        level = Level.RULE;
        buffer = [];
      } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.RULE && seekingValue) {
        ruleTokens.push(ruleToken);
        ruleToken = [Token.PROPERTY_BLOCK, []];
        propertyToken.push(ruleToken);
        newTokens = ruleToken[1];
        levels.push(level);
        level = Level.RULE;
        seekingValue = false;
      } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.RULE && isPageMarginBox(buffer)) {
        serializedBuffer = buffer.join("").trim();
        ruleTokens.push(ruleToken);
        ruleToken = [Token.AT_RULE_BLOCK, [], []];
        ruleToken[1].push([Token.AT_RULE_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        newTokens.push(ruleToken);
        newTokens = ruleToken[2];
        levels.push(level);
        level = Level.RULE;
        buffer = [];
      } else if (character == Marker.COLON && level == Level.RULE && !seekingValue) {
        serializedBuffer = buffer.join("").trim();
        propertyToken = [Token.PROPERTY, [Token.PROPERTY_NAME, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]];
        newTokens.push(propertyToken);
        seekingValue = true;
        buffer = [];
      } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && ruleTokens.length > 0 && buffer.length > 0 && buffer[0] == Marker.AT) {
        serializedBuffer = buffer.join("").trim();
        ruleToken[1].push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        buffer = [];
      } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && buffer.length > 0) {
        serializedBuffer = buffer.join("").trim();
        propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        propertyToken = null;
        seekingValue = false;
        buffer = [];
      } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && buffer.length === 0) {
        propertyToken = null;
        seekingValue = false;
      } else if (character == Marker.SEMICOLON && level == Level.RULE && buffer.length > 0 && buffer[0] == Marker.AT) {
        serializedBuffer = buffer.join("");
        newTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        seekingValue = false;
        buffer = [];
      } else if (character == Marker.SEMICOLON && level == Level.RULE && seekingPropertyBlockClosing) {
        seekingPropertyBlockClosing = false;
        buffer = [];
      } else if (character == Marker.SEMICOLON && level == Level.RULE && buffer.length === 0) {
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && seekingValue && buffer.length > 0 && ruleTokens.length > 0) {
        serializedBuffer = buffer.join("");
        propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        propertyToken = null;
        ruleToken = ruleTokens.pop();
        newTokens = ruleToken[2];
        level = levels.pop();
        seekingValue = false;
        buffer = [];
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && buffer.length > 0 && buffer[0] == Marker.AT && ruleTokens.length > 0) {
        serializedBuffer = buffer.join("");
        ruleToken[1].push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        propertyToken = null;
        ruleToken = ruleTokens.pop();
        newTokens = ruleToken[2];
        level = levels.pop();
        seekingValue = false;
        buffer = [];
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && ruleTokens.length > 0) {
        propertyToken = null;
        ruleToken = ruleTokens.pop();
        newTokens = ruleToken[2];
        level = levels.pop();
        seekingValue = false;
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && buffer.length > 0) {
        serializedBuffer = buffer.join("");
        propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        propertyToken = null;
        ruleToken = ruleTokens.pop();
        newTokens = allTokens;
        level = levels.pop();
        seekingValue = false;
        buffer = [];
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && buffer.length > 0 && buffer[0] == Marker.AT) {
        propertyToken = null;
        ruleToken = null;
        serializedBuffer = buffer.join("").trim();
        newTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        newTokens = allTokens;
        level = levels.pop();
        seekingValue = false;
        buffer = [];
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && levels[levels.length - 1] == Level.RULE) {
        propertyToken = null;
        ruleToken = ruleTokens.pop();
        newTokens = ruleToken[2];
        level = levels.pop();
        seekingValue = false;
        seekingPropertyBlockClosing = true;
        buffer = [];
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE) {
        propertyToken = null;
        ruleToken = null;
        newTokens = allTokens;
        level = levels.pop();
        seekingValue = false;
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.BLOCK && !isNested && position.index <= source.length - 1) {
        externalContext.warnings.push("Unexpected \'}\' at " + formatPosition([position.line, position.column, position.source]) + ".");
        buffer.push(character);
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.BLOCK) {
        break;
      } else if (character == Marker.OPEN_ROUND_BRACKET && level == Level.RULE && seekingValue) {
        buffer.push(character);
        roundBracketLevel++;
      } else if (character == Marker.CLOSE_ROUND_BRACKET && level == Level.RULE && seekingValue && roundBracketLevel == 1) {
        buffer.push(character);
        serializedBuffer = buffer.join("").trim();
        propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        roundBracketLevel--;
        buffer = [];
      } else if (character == Marker.CLOSE_ROUND_BRACKET && level == Level.RULE && seekingValue) {
        buffer.push(character);
        roundBracketLevel--;
      } else if (character == Marker.FORWARD_SLASH && source[position.index + 1] != Marker.ASTERISK && level == Level.RULE && seekingValue && buffer.length > 0) {
        serializedBuffer = buffer.join("").trim();
        propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);
        buffer = [];
      } else if (character == Marker.FORWARD_SLASH && source[position.index + 1] != Marker.ASTERISK && level == Level.RULE && seekingValue) {
        propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);
        buffer = [];
      } else if (character == Marker.COMMA && level == Level.RULE && seekingValue && buffer.length > 0) {
        serializedBuffer = buffer.join("").trim();
        propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);
        buffer = [];
      } else if (character == Marker.COMMA && level == Level.RULE && seekingValue) {
        propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);
        buffer = [];
      } else if (character == Marker.CLOSE_SQUARE_BRACKET && propertyToken && propertyToken.length > 1 && buffer.length > 0 && isRepeatToken(buffer)) {
        buffer.push(character);
        serializedBuffer = buffer.join("").trim();
        propertyToken[propertyToken.length - 1][1] += serializedBuffer;
        buffer = [];
      } else if ((isSpace || isNewLineNix && !isNewLineWin) && level == Level.RULE && seekingValue && propertyToken && buffer.length > 0) {
        serializedBuffer = buffer.join("").trim();
        propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        buffer = [];
      } else if (isNewLineWin && level == Level.RULE && seekingValue && propertyToken && buffer.length > 1) {
        serializedBuffer = buffer.join("").trim();
        propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        buffer = [];
      } else if (isNewLineWin && level == Level.RULE && seekingValue) {
        buffer = [];
      } else if (buffer.length == 1 && isNewLineWin) {
        buffer.pop();
      } else if (buffer.length > 0 || !isSpace && !isNewLineNix && !isNewLineWin && !isCarriageReturn) {
        buffer.push(character);
      }
      wasEscaped = isEscaped;
      isEscaped = !wasEscaped && character == Marker.BACK_SLASH;
      wasCommentStart = isCommentStart;
      wasCommentEnd = isCommentEnd;
      position.line = isNewLineWin || isNewLineNix || isCarriageReturn ? position.line + 1 : position.line;
      position.column = isNewLineWin || isNewLineNix || isCarriageReturn ? 0 : position.column + 1;
    }
    if (seekingValue) {
      externalContext.warnings.push("Missing \'}\' at " + formatPosition([position.line, position.column, position.source]) + ".");
    }
    if (seekingValue && buffer.length > 0) {
      serializedBuffer = buffer.join("").replace(TAIL_BROKEN_VALUE_PATTERN, "");
      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
      buffer = [];
    }
    if (buffer.length > 0) {
      externalContext.warnings.push("Invalid character(s) \'" + buffer.join("") + "\' at " + formatPosition(metadata) + ". Ignoring.");
    }
    return allTokens;
  };
  var isIgnoreStartComment = function(buffer) {
    return IGNORE_START_COMMENT_PATTERN.test(buffer.join("") + Marker.FORWARD_SLASH);
  };
  var isIgnoreEndComment = function(buffer) {
    return IGNORE_END_COMMENT_PATTERN.test(buffer.join("") + Marker.FORWARD_SLASH);
  };
  var originalMetadata = function(metadata, value, externalContext, selectorFallbacks) {
    var source = metadata[2];
    return externalContext.inputSourceMapTracker.isTracking(source) ? externalContext.inputSourceMapTracker.originalPositionFor(metadata, value.length, selectorFallbacks) : metadata;
  };
  var tokenTypeFrom = function(buffer) {
    var isAtRule = buffer[0] == Marker.AT || buffer[0] == Marker.UNDERSCORE;
    var ruleWord = buffer.join("").split(RULE_WORD_SEPARATOR_PATTERN)[0];
    if (isAtRule && BLOCK_RULES.indexOf(ruleWord) > -1) {
      return Token.NESTED_BLOCK;
    } else if (isAtRule && AT_RULES.indexOf(ruleWord) > -1) {
      return Token.AT_RULE;
    } else if (isAtRule) {
      return Token.AT_RULE_BLOCK;
    } else {
      return Token.RULE;
    }
  };
  var tokenScopeFrom = function(tokenType) {
    if (tokenType == Token.RULE) {
      return Token.RULE_SCOPE;
    } else if (tokenType == Token.NESTED_BLOCK) {
      return Token.NESTED_BLOCK_SCOPE;
    } else if (tokenType == Token.AT_RULE_BLOCK) {
      return Token.AT_RULE_BLOCK_SCOPE;
    }
  };
  var isPageMarginBox = function(buffer) {
    var serializedBuffer = buffer.join("").trim();
    return PAGE_MARGIN_BOXES.indexOf(serializedBuffer) > -1 || EXTRA_PAGE_BOXES.indexOf(serializedBuffer) > -1;
  };
  var isRepeatToken = function(buffer) {
    return REPEAT_PATTERN.test(buffer.join("") + Marker.CLOSE_SQUARE_BRACKET);
  };
  var Marker = require_marker();
  var Token = require_token();
  var formatPosition = require_format_position();
  var Level = {
    BLOCK: "block",
    COMMENT: "comment",
    DOUBLE_QUOTE: "double-quote",
    RULE: "rule",
    SINGLE_QUOTE: "single-quote"
  };
  var AT_RULES = [
    "@charset",
    "@import"
  ];
  var BLOCK_RULES = [
    "@-moz-document",
    "@document",
    "@-moz-keyframes",
    "@-ms-keyframes",
    "@-o-keyframes",
    "@-webkit-keyframes",
    "@keyframes",
    "@media",
    "@supports"
  ];
  var IGNORE_END_COMMENT_PATTERN = /\/\* clean\-css ignore:end \*\/$/;
  var IGNORE_START_COMMENT_PATTERN = /^\/\* clean\-css ignore:start \*\//;
  var PAGE_MARGIN_BOXES = [
    "@bottom-center",
    "@bottom-left",
    "@bottom-left-corner",
    "@bottom-right",
    "@bottom-right-corner",
    "@left-bottom",
    "@left-middle",
    "@left-top",
    "@right-bottom",
    "@right-middle",
    "@right-top",
    "@top-center",
    "@top-left",
    "@top-left-corner",
    "@top-right",
    "@top-right-corner"
  ];
  var EXTRA_PAGE_BOXES = [
    "@footnote",
    "@footnotes",
    "@left",
    "@page-float-bottom",
    "@page-float-top",
    "@right"
  ];
  var REPEAT_PATTERN = /^\[\s{0,31}\d+\s{0,31}\]$/;
  var RULE_WORD_SEPARATOR_PATTERN = /[\s\(]/;
  var TAIL_BROKEN_VALUE_PATTERN = /[\s|\}]*$/;
  module.exports = tokenize;
});

// node_modules/clean-css/lib/reader/read-sources.js
var require_read_sources = __commonJS((exports, module) => {
  var readSources = function(input, context, callback) {
    return doReadSources(input, context, function(tokens) {
      return applySourceMaps(tokens, context, function() {
        return loadOriginalSources(context, function() {
          return callback(tokens);
        });
      });
    });
  };
  var doReadSources = function(input, context, callback) {
    if (typeof input == "string") {
      return fromString(input, context, callback);
    } else if (Buffer.isBuffer(input)) {
      return fromString(input.toString(), context, callback);
    } else if (Array.isArray(input)) {
      return fromArray(input, context, callback);
    } else if (typeof input == "object") {
      return fromHash(input, context, callback);
    }
  };
  var fromString = function(input, context, callback) {
    context.source = undefined;
    context.sourcesContent[undefined] = input;
    context.stats.originalSize += input.length;
    return fromStyles(input, context, { inline: context.options.inline }, callback);
  };
  var fromArray = function(input, context, callback) {
    var inputAsImports = input.reduce(function(accumulator, uriOrHash) {
      if (typeof uriOrHash === "string") {
        return addStringSource(uriOrHash, accumulator);
      } else {
        return addHashSource(uriOrHash, context, accumulator);
      }
    }, []);
    return fromStyles(inputAsImports.join(""), context, { inline: ["all"] }, callback);
  };
  var fromHash = function(input, context, callback) {
    var inputAsImports = addHashSource(input, context, []);
    return fromStyles(inputAsImports.join(""), context, { inline: ["all"] }, callback);
  };
  var addStringSource = function(input, imports) {
    imports.push(restoreAsImport(normalizeUri(input)));
    return imports;
  };
  var addHashSource = function(input, context, imports) {
    var uri;
    var normalizedUri;
    var source;
    for (uri in input) {
      source = input[uri];
      normalizedUri = normalizeUri(uri);
      imports.push(restoreAsImport(normalizedUri));
      context.sourcesContent[normalizedUri] = source.styles;
      if (source.sourceMap) {
        trackSourceMap(source.sourceMap, normalizedUri, context);
      }
    }
    return imports;
  };
  var normalizeUri = function(uri) {
    var currentPath = path.resolve("");
    var absoluteUri;
    var relativeToCurrentPath;
    var normalizedUri;
    if (isRemoteResource(uri)) {
      return uri;
    }
    absoluteUri = path.isAbsolute(uri) ? uri : path.resolve(uri);
    relativeToCurrentPath = path.relative(currentPath, absoluteUri);
    normalizedUri = normalizePath(relativeToCurrentPath);
    return normalizedUri;
  };
  var trackSourceMap = function(sourceMap, uri, context) {
    var parsedMap = typeof sourceMap == "string" ? JSON.parse(sourceMap) : sourceMap;
    var rebasedMap = isRemoteResource(uri) ? rebaseRemoteMap(parsedMap, uri) : rebaseLocalMap(parsedMap, uri || UNKNOWN_URI, context.options.rebaseTo);
    context.inputSourceMapTracker.track(uri, rebasedMap);
  };
  var restoreAsImport = function(uri) {
    return restoreImport("url(" + uri + ")", "") + Marker.SEMICOLON;
  };
  var fromStyles = function(styles, context, parentInlinerContext, callback) {
    var tokens;
    var rebaseConfig = {};
    if (!context.source) {
      rebaseConfig.fromBase = path.resolve("");
      rebaseConfig.toBase = context.options.rebaseTo;
    } else if (isRemoteResource(context.source)) {
      rebaseConfig.fromBase = context.source;
      rebaseConfig.toBase = context.source;
    } else if (path.isAbsolute(context.source)) {
      rebaseConfig.fromBase = path.dirname(context.source);
      rebaseConfig.toBase = context.options.rebaseTo;
    } else {
      rebaseConfig.fromBase = path.dirname(path.resolve(context.source));
      rebaseConfig.toBase = context.options.rebaseTo;
    }
    tokens = tokenize(styles, context);
    tokens = rebase(tokens, context.options.rebase, context.validator, rebaseConfig);
    return allowsAnyImports(parentInlinerContext.inline) ? inline(tokens, context, parentInlinerContext, callback) : callback(tokens);
  };
  var allowsAnyImports = function(inline2) {
    return !(inline2.length == 1 && inline2[0] == "none");
  };
  var inline = function(tokens, externalContext, parentInlinerContext, callback) {
    var inlinerContext = {
      afterContent: false,
      callback,
      errors: externalContext.errors,
      externalContext,
      fetch: externalContext.options.fetch,
      inlinedStylesheets: parentInlinerContext.inlinedStylesheets || externalContext.inlinedStylesheets,
      inline: parentInlinerContext.inline,
      inlineRequest: externalContext.options.inlineRequest,
      inlineTimeout: externalContext.options.inlineTimeout,
      isRemote: parentInlinerContext.isRemote || false,
      localOnly: externalContext.localOnly,
      outputTokens: [],
      rebaseTo: externalContext.options.rebaseTo,
      sourceTokens: tokens,
      warnings: externalContext.warnings
    };
    return doInlineImports(inlinerContext);
  };
  var doInlineImports = function(inlinerContext) {
    var token;
    var i, l;
    for (i = 0, l = inlinerContext.sourceTokens.length;i < l; i++) {
      token = inlinerContext.sourceTokens[i];
      if (token[0] == Token.AT_RULE && isImport(token[1])) {
        inlinerContext.sourceTokens.splice(0, i);
        return inlineStylesheet(token, inlinerContext);
      } else if (token[0] == Token.AT_RULE || token[0] == Token.COMMENT) {
        inlinerContext.outputTokens.push(token);
      } else {
        inlinerContext.outputTokens.push(token);
        inlinerContext.afterContent = true;
      }
    }
    inlinerContext.sourceTokens = [];
    return inlinerContext.callback(inlinerContext.outputTokens);
  };
  var inlineStylesheet = function(token, inlinerContext) {
    var uriAndMediaQuery = extractImportUrlAndMedia(token[1]);
    var uri = uriAndMediaQuery[0];
    var mediaQuery = uriAndMediaQuery[1];
    var metadata = token[2];
    return isRemoteResource(uri) ? inlineRemoteStylesheet(uri, mediaQuery, metadata, inlinerContext) : inlineLocalStylesheet(uri, mediaQuery, metadata, inlinerContext);
  };
  var inlineRemoteStylesheet = function(uri, mediaQuery, metadata, inlinerContext) {
    var isAllowed = isAllowedResource(uri, true, inlinerContext.inline);
    var originalUri = uri;
    var isLoaded = uri in inlinerContext.externalContext.sourcesContent;
    var isRuntimeResource = !hasProtocol(uri);
    if (inlinerContext.inlinedStylesheets.indexOf(uri) > -1) {
      inlinerContext.warnings.push('Ignoring remote @import of "' + uri + '" as it has already been imported.');
      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
      return doInlineImports(inlinerContext);
    } else if (inlinerContext.localOnly && inlinerContext.afterContent) {
      inlinerContext.warnings.push('Ignoring remote @import of "' + uri + '" as no callback given and after other content.');
      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
      return doInlineImports(inlinerContext);
    } else if (isRuntimeResource) {
      inlinerContext.warnings.push('Skipping remote @import of "' + uri + '" as no protocol given.');
      inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));
      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
      return doInlineImports(inlinerContext);
    } else if (inlinerContext.localOnly && !isLoaded) {
      inlinerContext.warnings.push('Skipping remote @import of "' + uri + '" as no callback given.');
      inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));
      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
      return doInlineImports(inlinerContext);
    } else if (!isAllowed && inlinerContext.afterContent) {
      inlinerContext.warnings.push('Ignoring remote @import of "' + uri + '" as resource is not allowed and after other content.');
      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
      return doInlineImports(inlinerContext);
    } else if (!isAllowed) {
      inlinerContext.warnings.push('Skipping remote @import of "' + uri + '" as resource is not allowed.');
      inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));
      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
      return doInlineImports(inlinerContext);
    }
    inlinerContext.inlinedStylesheets.push(uri);
    function whenLoaded(error, importedStyles) {
      if (error) {
        inlinerContext.errors.push('Broken @import declaration of "' + uri + '" - ' + error);
        return process.nextTick(function() {
          inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));
          inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
          doInlineImports(inlinerContext);
        });
      }
      inlinerContext.inline = inlinerContext.externalContext.options.inline;
      inlinerContext.isRemote = true;
      inlinerContext.externalContext.source = originalUri;
      inlinerContext.externalContext.sourcesContent[uri] = importedStyles;
      inlinerContext.externalContext.stats.originalSize += importedStyles.length;
      return fromStyles(importedStyles, inlinerContext.externalContext, inlinerContext, function(importedTokens) {
        importedTokens = wrapInMedia(importedTokens, mediaQuery, metadata);
        inlinerContext.outputTokens = inlinerContext.outputTokens.concat(importedTokens);
        inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
        return doInlineImports(inlinerContext);
      });
    }
    return isLoaded ? whenLoaded(null, inlinerContext.externalContext.sourcesContent[uri]) : inlinerContext.fetch(uri, inlinerContext.inlineRequest, inlinerContext.inlineTimeout, whenLoaded);
  };
  var inlineLocalStylesheet = function(uri, mediaQuery, metadata, inlinerContext) {
    var currentPath = path.resolve("");
    var absoluteUri = path.isAbsolute(uri) ? path.resolve(currentPath, uri[0] == "/" ? uri.substring(1) : uri) : path.resolve(inlinerContext.rebaseTo, uri);
    var relativeToCurrentPath = path.relative(currentPath, absoluteUri);
    var importedStyles;
    var isAllowed = isAllowedResource(uri, false, inlinerContext.inline);
    var normalizedPath = normalizePath(relativeToCurrentPath);
    var isLoaded = normalizedPath in inlinerContext.externalContext.sourcesContent;
    if (inlinerContext.inlinedStylesheets.indexOf(absoluteUri) > -1) {
      inlinerContext.warnings.push('Ignoring local @import of "' + uri + '" as it has already been imported.');
    } else if (!isLoaded && (!fs.existsSync(absoluteUri) || !fs.statSync(absoluteUri).isFile())) {
      inlinerContext.errors.push('Ignoring local @import of "' + uri + '" as resource is missing.');
    } else if (!isAllowed && inlinerContext.afterContent) {
      inlinerContext.warnings.push('Ignoring local @import of "' + uri + '" as resource is not allowed and after other content.');
    } else if (inlinerContext.afterContent) {
      inlinerContext.warnings.push('Ignoring local @import of "' + uri + '" as after other content.');
    } else if (!isAllowed) {
      inlinerContext.warnings.push('Skipping local @import of "' + uri + '" as resource is not allowed.');
      inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));
    } else {
      importedStyles = isLoaded ? inlinerContext.externalContext.sourcesContent[normalizedPath] : fs.readFileSync(absoluteUri, "utf-8");
      inlinerContext.inlinedStylesheets.push(absoluteUri);
      inlinerContext.inline = inlinerContext.externalContext.options.inline;
      inlinerContext.externalContext.source = normalizedPath;
      inlinerContext.externalContext.sourcesContent[normalizedPath] = importedStyles;
      inlinerContext.externalContext.stats.originalSize += importedStyles.length;
      return fromStyles(importedStyles, inlinerContext.externalContext, inlinerContext, function(importedTokens) {
        importedTokens = wrapInMedia(importedTokens, mediaQuery, metadata);
        inlinerContext.outputTokens = inlinerContext.outputTokens.concat(importedTokens);
        inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
        return doInlineImports(inlinerContext);
      });
    }
    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
    return doInlineImports(inlinerContext);
  };
  var wrapInMedia = function(tokens, mediaQuery, metadata) {
    if (mediaQuery) {
      return [[Token.NESTED_BLOCK, [[Token.NESTED_BLOCK_SCOPE, "@media " + mediaQuery, metadata]], tokens]];
    } else {
      return tokens;
    }
  };
  var fs = import.meta.require("fs");
  var path = import.meta.require("path");
  var applySourceMaps = require_apply_source_maps();
  var extractImportUrlAndMedia = require_extract_import_url_and_media();
  var isAllowedResource = require_is_allowed_resource();
  var loadOriginalSources = require_load_original_sources();
  var normalizePath = require_normalize_path();
  var rebase = require_rebase2();
  var rebaseLocalMap = require_rebase_local_map();
  var rebaseRemoteMap = require_rebase_remote_map();
  var restoreImport = require_restore_import();
  var tokenize = require_tokenize();
  var Token = require_token();
  var Marker = require_marker();
  var hasProtocol = require_has_protocol();
  var isImport = require_is_import();
  var isRemoteResource = require_is_remote_resource();
  var UNKNOWN_URI = "uri:unknown";
  module.exports = readSources;
});

// node_modules/clean-css/lib/writer/simple.js
var require_simple = __commonJS((exports, module) => {
  var store = function(serializeContext, token) {
    var value = typeof token == "string" ? token : token[1];
    var wrap2 = serializeContext.wrap;
    wrap2(serializeContext, value);
    track(serializeContext, value);
    serializeContext.output.push(value);
  };
  var wrap = function(serializeContext, value) {
    if (serializeContext.column + value.length > serializeContext.format.wrapAt) {
      track(serializeContext, serializeContext.format.breakWith);
      serializeContext.output.push(serializeContext.format.breakWith);
    }
  };
  var track = function(serializeContext, value) {
    var parts = value.split("\n");
    serializeContext.line += parts.length - 1;
    serializeContext.column = parts.length > 1 ? 0 : serializeContext.column + parts.pop().length;
  };
  var serializeStyles = function(tokens, context) {
    var serializeContext = {
      column: 0,
      format: context.options.format,
      indentBy: 0,
      indentWith: "",
      line: 1,
      output: [],
      spaceAfterClosingBrace: context.options.compatibility.properties.spaceAfterClosingBrace,
      store,
      wrap: context.options.format.wrapAt ? wrap : function() {
      }
    };
    all2(serializeContext, tokens);
    return {
      styles: serializeContext.output.join("")
    };
  };
  var all2 = require_helpers().all;
  module.exports = serializeStyles;
});

// node_modules/clean-css/lib/writer/source-maps.js
var require_source_maps = __commonJS((exports, module) => {
  var store = function(serializeContext, element) {
    var fromString = typeof element == "string";
    var value = fromString ? element : element[1];
    var mappings = fromString ? null : element[2];
    var wrap2 = serializeContext.wrap;
    wrap2(serializeContext, value);
    track(serializeContext, value, mappings);
    serializeContext.output.push(value);
  };
  var wrap = function(serializeContext, value) {
    if (serializeContext.column + value.length > serializeContext.format.wrapAt) {
      track(serializeContext, serializeContext.format.breakWith, false);
      serializeContext.output.push(serializeContext.format.breakWith);
    }
  };
  var track = function(serializeContext, value, mappings) {
    var parts = value.split("\n");
    if (mappings) {
      trackAllMappings(serializeContext, mappings);
    }
    serializeContext.line += parts.length - 1;
    serializeContext.column = parts.length > 1 ? 0 : serializeContext.column + parts.pop().length;
  };
  var trackAllMappings = function(serializeContext, mappings) {
    for (var i = 0, l = mappings.length;i < l; i++) {
      trackMapping(serializeContext, mappings[i]);
    }
  };
  var trackMapping = function(serializeContext, mapping) {
    var line = mapping[0];
    var column = mapping[1];
    var originalSource = mapping[2];
    var source = originalSource;
    var storedSource = source || UNKNOWN_SOURCE;
    if (isWindows && source && !isRemoteResource(source)) {
      storedSource = source.replace(NIX_SEPARATOR_PATTERN, WINDOWS_SEPARATOR);
    }
    serializeContext.outputMap.addMapping({
      generated: {
        line: serializeContext.line,
        column: serializeContext.column
      },
      source: storedSource,
      original: {
        line,
        column
      }
    });
    if (serializeContext.inlineSources && originalSource in serializeContext.sourcesContent) {
      serializeContext.outputMap.setSourceContent(storedSource, serializeContext.sourcesContent[originalSource]);
    }
  };
  var serializeStylesAndSourceMap = function(tokens, context) {
    var serializeContext = {
      column: 0,
      format: context.options.format,
      indentBy: 0,
      indentWith: "",
      inlineSources: context.options.sourceMapInlineSources,
      line: 1,
      output: [],
      outputMap: new SourceMapGenerator,
      sourcesContent: context.sourcesContent,
      spaceAfterClosingBrace: context.options.compatibility.properties.spaceAfterClosingBrace,
      store,
      wrap: context.options.format.wrapAt ? wrap : function() {
      }
    };
    all2(serializeContext, tokens);
    return {
      sourceMap: serializeContext.outputMap,
      styles: serializeContext.output.join("")
    };
  };
  var SourceMapGenerator = require_source_map().SourceMapGenerator;
  var all2 = require_helpers().all;
  var isRemoteResource = require_is_remote_resource();
  var isWindows = process.platform == "win32";
  var NIX_SEPARATOR_PATTERN = /\//g;
  var UNKNOWN_SOURCE = "$stdin";
  var WINDOWS_SEPARATOR = "\\";
  module.exports = serializeStylesAndSourceMap;
});

// node_modules/clean-css/lib/clean.js
var require_clean = __commonJS((exports, module) => {
  var minify2 = function(input, options, maybeSourceMap, maybeCallback) {
    var sourceMap = typeof maybeSourceMap != "function" ? maybeSourceMap : null;
    var callback = typeof maybeCallback == "function" ? maybeCallback : typeof maybeSourceMap == "function" ? maybeSourceMap : null;
    var context = {
      stats: {
        efficiency: 0,
        minifiedSize: 0,
        originalSize: 0,
        startedAt: Date.now(),
        timeSpent: 0
      },
      cache: {
        specificity: {}
      },
      errors: [],
      inlinedStylesheets: [],
      inputSourceMapTracker: inputSourceMapTracker(),
      localOnly: !callback,
      options,
      source: null,
      sourcesContent: {},
      validator: validator(options.compatibility),
      warnings: []
    };
    if (sourceMap) {
      context.inputSourceMapTracker.track(undefined, sourceMap);
    }
    return runner(context.localOnly)(function() {
      return readSources(input, context, function(tokens) {
        var serialize = context.options.sourceMap ? serializeStylesAndSourceMap : serializeStyles;
        var optimizedTokens = optimize(tokens, context);
        var optimizedStyles = serialize(optimizedTokens, context);
        var output = withMetadata(optimizedStyles, context);
        return callback ? callback(context.errors.length > 0 ? context.errors : null, output) : output;
      });
    });
  };
  var runner = function(localOnly) {
    return localOnly ? function(callback) {
      return callback();
    } : process.nextTick;
  };
  var optimize = function(tokens, context) {
    var optimized;
    optimized = level0Optimize(tokens, context);
    optimized = OptimizationLevel.One in context.options.level ? level1Optimize(tokens, context) : tokens;
    optimized = OptimizationLevel.Two in context.options.level ? level2Optimize(tokens, context, true) : optimized;
    return optimized;
  };
  var withMetadata = function(output, context) {
    output.stats = calculateStatsFrom(output.styles, context);
    output.errors = context.errors;
    output.inlinedStylesheets = context.inlinedStylesheets;
    output.warnings = context.warnings;
    return output;
  };
  var calculateStatsFrom = function(styles, context) {
    var finishedAt = Date.now();
    var timeSpent = finishedAt - context.stats.startedAt;
    delete context.stats.startedAt;
    context.stats.timeSpent = timeSpent;
    context.stats.efficiency = 1 - styles.length / context.stats.originalSize;
    context.stats.minifiedSize = styles.length;
    return context.stats;
  };
  var level0Optimize = require_optimize();
  var level1Optimize = require_optimize2();
  var level2Optimize = require_optimize4();
  var validator = require_validator();
  var compatibilityFrom = require_compatibility();
  var fetchFrom = require_fetch();
  var formatFrom = require_format().formatFrom;
  var inlineFrom = require_inline();
  var inlineRequestFrom = require_inline_request();
  var inlineTimeoutFrom = require_inline_timeout();
  var OptimizationLevel = require_optimization_level().OptimizationLevel;
  var optimizationLevelFrom = require_optimization_level().optimizationLevelFrom;
  var rebaseFrom = require_rebase();
  var rebaseToFrom = require_rebase_to();
  var inputSourceMapTracker = require_input_source_map_tracker();
  var readSources = require_read_sources();
  var serializeStyles = require_simple();
  var serializeStylesAndSourceMap = require_source_maps();
  var CleanCSS = module.exports = function CleanCSS(options) {
    options = options || {};
    this.options = {
      compatibility: compatibilityFrom(options.compatibility),
      fetch: fetchFrom(options.fetch),
      format: formatFrom(options.format),
      inline: inlineFrom(options.inline),
      inlineRequest: inlineRequestFrom(options.inlineRequest),
      inlineTimeout: inlineTimeoutFrom(options.inlineTimeout),
      level: optimizationLevelFrom(options.level),
      rebase: rebaseFrom(options.rebase),
      rebaseTo: rebaseToFrom(options.rebaseTo),
      returnPromise: !!options.returnPromise,
      sourceMap: !!options.sourceMap,
      sourceMapInlineSources: !!options.sourceMapInlineSources
    };
  };
  CleanCSS.process = function(input, opts) {
    var cleanCss;
    var optsTo = opts.to;
    delete opts.to;
    cleanCss = new CleanCSS(Object.assign({ returnPromise: true, rebaseTo: optsTo }, opts));
    return cleanCss.minify(input).then(function(output) {
      return { css: output.styles };
    });
  };
  CleanCSS.prototype.minify = function(input, maybeSourceMap, maybeCallback) {
    var options = this.options;
    if (options.returnPromise) {
      return new Promise(function(resolve, reject) {
        minify2(input, options, maybeSourceMap, function(errors, output) {
          return errors ? reject(errors) : resolve(output);
        });
      });
    } else {
      return minify2(input, options, maybeSourceMap, maybeCallback);
    }
  };
});

// node_modules/he/he.js
var require_he = __commonJS((exports, module) => {
  /*! https://mths.be/he v1.2.0 by @mathias | MIT license */
  (function(root) {
    var freeExports = typeof exports == "object" && exports;
    var freeModule = typeof module == "object" && module && exports == freeExports && module;
    var freeGlobal = typeof global == "object" && global;
    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
      root = freeGlobal;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var regexAsciiWhitelist = /[\x01-\x7F]/g;
    var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
    var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
    var encodeMap = { "\xAD": "shy", "\u200C": "zwnj", "\u200D": "zwj", "\u200E": "lrm", "\u2063": "ic", "\u2062": "it", "\u2061": "af", "\u200F": "rlm", "\u200B": "ZeroWidthSpace", "\u2060": "NoBreak", "\u0311": "DownBreve", "\u20DB": "tdot", "\u20DC": "DotDot", "\t": "Tab", "\n": "NewLine", "\u2008": "puncsp", "\u205F": "MediumSpace", "\u2009": "thinsp", "\u200A": "hairsp", "\u2004": "emsp13", "\u2002": "ensp", "\u2005": "emsp14", "\u2003": "emsp", "\u2007": "numsp", "\xA0": "nbsp", "\u205F\u200A": "ThickSpace", "\u203E": "oline", _: "lowbar", "\u2010": "dash", "\u2013": "ndash", "\u2014": "mdash", "\u2015": "horbar", ",": "comma", ";": "semi", "\u204F": "bsemi", ":": "colon", "\u2A74": "Colone", "!": "excl", "\xA1": "iexcl", "?": "quest", "\xBF": "iquest", ".": "period", "\u2025": "nldr", "\u2026": "mldr", "\xB7": "middot", "\'": "apos", "\u2018": "lsquo", "\u2019": "rsquo", "\u201A": "sbquo", "\u2039": "lsaquo", "\u203A": "rsaquo", '"': "quot", "\u201C": "ldquo", "\u201D": "rdquo", "\u201E": "bdquo", "\xAB": "laquo", "\xBB": "raquo", "(": "lpar", ")": "rpar", "[": "lsqb", "]": "rsqb", "{": "lcub", "}": "rcub", "\u2308": "lceil", "\u2309": "rceil", "\u230A": "lfloor", "\u230B": "rfloor", "\u2985": "lopar", "\u2986": "ropar", "\u298B": "lbrke", "\u298C": "rbrke", "\u298D": "lbrkslu", "\u298E": "rbrksld", "\u298F": "lbrksld", "\u2990": "rbrkslu", "\u2991": "langd", "\u2992": "rangd", "\u2993": "lparlt", "\u2994": "rpargt", "\u2995": "gtlPar", "\u2996": "ltrPar", "\u27E6": "lobrk", "\u27E7": "robrk", "\u27E8": "lang", "\u27E9": "rang", "\u27EA": "Lang", "\u27EB": "Rang", "\u27EC": "loang", "\u27ED": "roang", "\u2772": "lbbrk", "\u2773": "rbbrk", "\u2016": "Vert", "\xA7": "sect", "\xB6": "para", "@": "commat", "*": "ast", "/": "sol", undefined: null, "&": "amp", "#": "num", "%": "percnt", "\u2030": "permil", "\u2031": "pertenk", "\u2020": "dagger", "\u2021": "Dagger", "\u2022": "bull", "\u2043": "hybull", "\u2032": "prime", "\u2033": "Prime", "\u2034": "tprime", "\u2057": "qprime", "\u2035": "bprime", "\u2041": "caret", "`": "grave", "\xB4": "acute", "\u02DC": "tilde", "^": "Hat", "\xAF": "macr", "\u02D8": "breve", "\u02D9": "dot", "\xA8": "die", "\u02DA": "ring", "\u02DD": "dblac", "\xB8": "cedil", "\u02DB": "ogon", "\u02C6": "circ", "\u02C7": "caron", "\xB0": "deg", "\xA9": "copy", "\xAE": "reg", "\u2117": "copysr", "\u2118": "wp", "\u211E": "rx", "\u2127": "mho", "\u2129": "iiota", "\u2190": "larr", "\u219A": "nlarr", "\u2192": "rarr", "\u219B": "nrarr", "\u2191": "uarr", "\u2193": "darr", "\u2194": "harr", "\u21AE": "nharr", "\u2195": "varr", "\u2196": "nwarr", "\u2197": "nearr", "\u2198": "searr", "\u2199": "swarr", "\u219D": "rarrw", "\u219D\u0338": "nrarrw", "\u219E": "Larr", "\u219F": "Uarr", "\u21A0": "Rarr", "\u21A1": "Darr", "\u21A2": "larrtl", "\u21A3": "rarrtl", "\u21A4": "mapstoleft", "\u21A5": "mapstoup", "\u21A6": "map", "\u21A7": "mapstodown", "\u21A9": "larrhk", "\u21AA": "rarrhk", "\u21AB": "larrlp", "\u21AC": "rarrlp", "\u21AD": "harrw", "\u21B0": "lsh", "\u21B1": "rsh", "\u21B2": "ldsh", "\u21B3": "rdsh", "\u21B5": "crarr", "\u21B6": "cularr", "\u21B7": "curarr", "\u21BA": "olarr", "\u21BB": "orarr", "\u21BC": "lharu", "\u21BD": "lhard", "\u21BE": "uharr", "\u21BF": "uharl", "\u21C0": "rharu", "\u21C1": "rhard", "\u21C2": "dharr", "\u21C3": "dharl", "\u21C4": "rlarr", "\u21C5": "udarr", "\u21C6": "lrarr", "\u21C7": "llarr", "\u21C8": "uuarr", "\u21C9": "rrarr", "\u21CA": "ddarr", "\u21CB": "lrhar", "\u21CC": "rlhar", "\u21D0": "lArr", "\u21CD": "nlArr", "\u21D1": "uArr", "\u21D2": "rArr", "\u21CF": "nrArr", "\u21D3": "dArr", "\u21D4": "iff", "\u21CE": "nhArr", "\u21D5": "vArr", "\u21D6": "nwArr", "\u21D7": "neArr", "\u21D8": "seArr", "\u21D9": "swArr", "\u21DA": "lAarr", "\u21DB": "rAarr", "\u21DD": "zigrarr", "\u21E4": "larrb", "\u21E5": "rarrb", "\u21F5": "duarr", "\u21FD": "loarr", "\u21FE": "roarr", "\u21FF": "hoarr", "\u2200": "forall", "\u2201": "comp", "\u2202": "part", "\u2202\u0338": "npart", "\u2203": "exist", "\u2204": "nexist", "\u2205": "empty", "\u2207": "Del", "\u2208": "in", "\u2209": "notin", "\u220B": "ni", "\u220C": "notni", "\u03F6": "bepsi", "\u220F": "prod", "\u2210": "coprod", "\u2211": "sum", "+": "plus", "\xB1": "pm", "\xF7": "div", "\xD7": "times", "<": "lt", "\u226E": "nlt", "<\u20D2": "nvlt", "=": "equals", "\u2260": "ne", "=\u20E5": "bne", "\u2A75": "Equal", ">": "gt", "\u226F": "ngt", ">\u20D2": "nvgt", "\xAC": "not", "|": "vert", "\xA6": "brvbar", "\u2212": "minus", "\u2213": "mp", "\u2214": "plusdo", "\u2044": "frasl", "\u2216": "setmn", "\u2217": "lowast", "\u2218": "compfn", "\u221A": "Sqrt", "\u221D": "prop", "\u221E": "infin", "\u221F": "angrt", "\u2220": "ang", "\u2220\u20D2": "nang", "\u2221": "angmsd", "\u2222": "angsph", "\u2223": "mid", "\u2224": "nmid", "\u2225": "par", "\u2226": "npar", "\u2227": "and", "\u2228": "or", "\u2229": "cap", "\u2229\uFE00": "caps", "\u222A": "cup", "\u222A\uFE00": "cups", "\u222B": "int", "\u222C": "Int", "\u222D": "tint", "\u2A0C": "qint", "\u222E": "oint", "\u222F": "Conint", "\u2230": "Cconint", "\u2231": "cwint", "\u2232": "cwconint", "\u2233": "awconint", "\u2234": "there4", "\u2235": "becaus", "\u2236": "ratio", "\u2237": "Colon", "\u2238": "minusd", "\u223A": "mDDot", "\u223B": "homtht", "\u223C": "sim", "\u2241": "nsim", "\u223C\u20D2": "nvsim", "\u223D": "bsim", "\u223D\u0331": "race", "\u223E": "ac", "\u223E\u0333": "acE", "\u223F": "acd", "\u2240": "wr", "\u2242": "esim", "\u2242\u0338": "nesim", "\u2243": "sime", "\u2244": "nsime", "\u2245": "cong", "\u2247": "ncong", "\u2246": "simne", "\u2248": "ap", "\u2249": "nap", "\u224A": "ape", "\u224B": "apid", "\u224B\u0338": "napid", "\u224C": "bcong", "\u224D": "CupCap", "\u226D": "NotCupCap", "\u224D\u20D2": "nvap", "\u224E": "bump", "\u224E\u0338": "nbump", "\u224F": "bumpe", "\u224F\u0338": "nbumpe", "\u2250": "doteq", "\u2250\u0338": "nedot", "\u2251": "eDot", "\u2252": "efDot", "\u2253": "erDot", "\u2254": "colone", "\u2255": "ecolon", "\u2256": "ecir", "\u2257": "cire", "\u2259": "wedgeq", "\u225A": "veeeq", "\u225C": "trie", "\u225F": "equest", "\u2261": "equiv", "\u2262": "nequiv", "\u2261\u20E5": "bnequiv", "\u2264": "le", "\u2270": "nle", "\u2264\u20D2": "nvle", "\u2265": "ge", "\u2271": "nge", "\u2265\u20D2": "nvge", "\u2266": "lE", "\u2266\u0338": "nlE", "\u2267": "gE", "\u2267\u0338": "ngE", "\u2268\uFE00": "lvnE", "\u2268": "lnE", "\u2269": "gnE", "\u2269\uFE00": "gvnE", "\u226A": "ll", "\u226A\u0338": "nLtv", "\u226A\u20D2": "nLt", "\u226B": "gg", "\u226B\u0338": "nGtv", "\u226B\u20D2": "nGt", "\u226C": "twixt", "\u2272": "lsim", "\u2274": "nlsim", "\u2273": "gsim", "\u2275": "ngsim", "\u2276": "lg", "\u2278": "ntlg", "\u2277": "gl", "\u2279": "ntgl", "\u227A": "pr", "\u2280": "npr", "\u227B": "sc", "\u2281": "nsc", "\u227C": "prcue", "\u22E0": "nprcue", "\u227D": "sccue", "\u22E1": "nsccue", "\u227E": "prsim", "\u227F": "scsim", "\u227F\u0338": "NotSucceedsTilde", "\u2282": "sub", "\u2284": "nsub", "\u2282\u20D2": "vnsub", "\u2283": "sup", "\u2285": "nsup", "\u2283\u20D2": "vnsup", "\u2286": "sube", "\u2288": "nsube", "\u2287": "supe", "\u2289": "nsupe", "\u228A\uFE00": "vsubne", "\u228A": "subne", "\u228B\uFE00": "vsupne", "\u228B": "supne", "\u228D": "cupdot", "\u228E": "uplus", "\u228F": "sqsub", "\u228F\u0338": "NotSquareSubset", "\u2290": "sqsup", "\u2290\u0338": "NotSquareSuperset", "\u2291": "sqsube", "\u22E2": "nsqsube", "\u2292": "sqsupe", "\u22E3": "nsqsupe", "\u2293": "sqcap", "\u2293\uFE00": "sqcaps", "\u2294": "sqcup", "\u2294\uFE00": "sqcups", "\u2295": "oplus", "\u2296": "ominus", "\u2297": "otimes", "\u2298": "osol", "\u2299": "odot", "\u229A": "ocir", "\u229B": "oast", "\u229D": "odash", "\u229E": "plusb", "\u229F": "minusb", "\u22A0": "timesb", "\u22A1": "sdotb", "\u22A2": "vdash", "\u22AC": "nvdash", "\u22A3": "dashv", "\u22A4": "top", "\u22A5": "bot", "\u22A7": "models", "\u22A8": "vDash", "\u22AD": "nvDash", "\u22A9": "Vdash", "\u22AE": "nVdash", "\u22AA": "Vvdash", "\u22AB": "VDash", "\u22AF": "nVDash", "\u22B0": "prurel", "\u22B2": "vltri", "\u22EA": "nltri", "\u22B3": "vrtri", "\u22EB": "nrtri", "\u22B4": "ltrie", "\u22EC": "nltrie", "\u22B4\u20D2": "nvltrie", "\u22B5": "rtrie", "\u22ED": "nrtrie", "\u22B5\u20D2": "nvrtrie", "\u22B6": "origof", "\u22B7": "imof", "\u22B8": "mumap", "\u22B9": "hercon", "\u22BA": "intcal", "\u22BB": "veebar", "\u22BD": "barvee", "\u22BE": "angrtvb", "\u22BF": "lrtri", "\u22C0": "Wedge", "\u22C1": "Vee", "\u22C2": "xcap", "\u22C3": "xcup", "\u22C4": "diam", "\u22C5": "sdot", "\u22C6": "Star", "\u22C7": "divonx", "\u22C8": "bowtie", "\u22C9": "ltimes", "\u22CA": "rtimes", "\u22CB": "lthree", "\u22CC": "rthree", "\u22CD": "bsime", "\u22CE": "cuvee", "\u22CF": "cuwed", "\u22D0": "Sub", "\u22D1": "Sup", "\u22D2": "Cap", "\u22D3": "Cup", "\u22D4": "fork", "\u22D5": "epar", "\u22D6": "ltdot", "\u22D7": "gtdot", "\u22D8": "Ll", "\u22D8\u0338": "nLl", "\u22D9": "Gg", "\u22D9\u0338": "nGg", "\u22DA\uFE00": "lesg", "\u22DA": "leg", "\u22DB": "gel", "\u22DB\uFE00": "gesl", "\u22DE": "cuepr", "\u22DF": "cuesc", "\u22E6": "lnsim", "\u22E7": "gnsim", "\u22E8": "prnsim", "\u22E9": "scnsim", "\u22EE": "vellip", "\u22EF": "ctdot", "\u22F0": "utdot", "\u22F1": "dtdot", "\u22F2": "disin", "\u22F3": "isinsv", "\u22F4": "isins", "\u22F5": "isindot", "\u22F5\u0338": "notindot", "\u22F6": "notinvc", "\u22F7": "notinvb", "\u22F9": "isinE", "\u22F9\u0338": "notinE", "\u22FA": "nisd", "\u22FB": "xnis", "\u22FC": "nis", "\u22FD": "notnivc", "\u22FE": "notnivb", "\u2305": "barwed", "\u2306": "Barwed", "\u230C": "drcrop", "\u230D": "dlcrop", "\u230E": "urcrop", "\u230F": "ulcrop", "\u2310": "bnot", "\u2312": "profline", "\u2313": "profsurf", "\u2315": "telrec", "\u2316": "target", "\u231C": "ulcorn", "\u231D": "urcorn", "\u231E": "dlcorn", "\u231F": "drcorn", "\u2322": "frown", "\u2323": "smile", "\u232D": "cylcty", "\u232E": "profalar", "\u2336": "topbot", "\u233D": "ovbar", "\u233F": "solbar", "\u237C": "angzarr", "\u23B0": "lmoust", "\u23B1": "rmoust", "\u23B4": "tbrk", "\u23B5": "bbrk", "\u23B6": "bbrktbrk", "\u23DC": "OverParenthesis", "\u23DD": "UnderParenthesis", "\u23DE": "OverBrace", "\u23DF": "UnderBrace", "\u23E2": "trpezium", "\u23E7": "elinters", "\u2423": "blank", "\u2500": "boxh", "\u2502": "boxv", "\u250C": "boxdr", "\u2510": "boxdl", "\u2514": "boxur", "\u2518": "boxul", "\u251C": "boxvr", "\u2524": "boxvl", "\u252C": "boxhd", "\u2534": "boxhu", "\u253C": "boxvh", "\u2550": "boxH", "\u2551": "boxV", "\u2552": "boxdR", "\u2553": "boxDr", "\u2554": "boxDR", "\u2555": "boxdL", "\u2556": "boxDl", "\u2557": "boxDL", "\u2558": "boxuR", "\u2559": "boxUr", "\u255A": "boxUR", "\u255B": "boxuL", "\u255C": "boxUl", "\u255D": "boxUL", "\u255E": "boxvR", "\u255F": "boxVr", "\u2560": "boxVR", "\u2561": "boxvL", "\u2562": "boxVl", "\u2563": "boxVL", "\u2564": "boxHd", "\u2565": "boxhD", "\u2566": "boxHD", "\u2567": "boxHu", "\u2568": "boxhU", "\u2569": "boxHU", "\u256A": "boxvH", "\u256B": "boxVh", "\u256C": "boxVH", "\u2580": "uhblk", "\u2584": "lhblk", "\u2588": "block", "\u2591": "blk14", "\u2592": "blk12", "\u2593": "blk34", "\u25A1": "squ", "\u25AA": "squf", "\u25AB": "EmptyVerySmallSquare", "\u25AD": "rect", "\u25AE": "marker", "\u25B1": "fltns", "\u25B3": "xutri", "\u25B4": "utrif", "\u25B5": "utri", "\u25B8": "rtrif", "\u25B9": "rtri", "\u25BD": "xdtri", "\u25BE": "dtrif", "\u25BF": "dtri", "\u25C2": "ltrif", "\u25C3": "ltri", "\u25CA": "loz", "\u25CB": "cir", "\u25EC": "tridot", "\u25EF": "xcirc", "\u25F8": "ultri", "\u25F9": "urtri", "\u25FA": "lltri", "\u25FB": "EmptySmallSquare", "\u25FC": "FilledSmallSquare", "\u2605": "starf", "\u2606": "star", "\u260E": "phone", "\u2640": "female", "\u2642": "male", "\u2660": "spades", "\u2663": "clubs", "\u2665": "hearts", "\u2666": "diams", "\u266A": "sung", "\u2713": "check", "\u2717": "cross", "\u2720": "malt", "\u2736": "sext", "\u2758": "VerticalSeparator", "\u27C8": "bsolhsub", "\u27C9": "suphsol", "\u27F5": "xlarr", "\u27F6": "xrarr", "\u27F7": "xharr", "\u27F8": "xlArr", "\u27F9": "xrArr", "\u27FA": "xhArr", "\u27FC": "xmap", "\u27FF": "dzigrarr", "\u2902": "nvlArr", "\u2903": "nvrArr", "\u2904": "nvHarr", "\u2905": "Map", "\u290C": "lbarr", "\u290D": "rbarr", "\u290E": "lBarr", "\u290F": "rBarr", "\u2910": "RBarr", "\u2911": "DDotrahd", "\u2912": "UpArrowBar", "\u2913": "DownArrowBar", "\u2916": "Rarrtl", "\u2919": "latail", "\u291A": "ratail", "\u291B": "lAtail", "\u291C": "rAtail", "\u291D": "larrfs", "\u291E": "rarrfs", "\u291F": "larrbfs", "\u2920": "rarrbfs", "\u2923": "nwarhk", "\u2924": "nearhk", "\u2925": "searhk", "\u2926": "swarhk", "\u2927": "nwnear", "\u2928": "toea", "\u2929": "tosa", "\u292A": "swnwar", "\u2933": "rarrc", "\u2933\u0338": "nrarrc", "\u2935": "cudarrr", "\u2936": "ldca", "\u2937": "rdca", "\u2938": "cudarrl", "\u2939": "larrpl", "\u293C": "curarrm", "\u293D": "cularrp", "\u2945": "rarrpl", "\u2948": "harrcir", "\u2949": "Uarrocir", "\u294A": "lurdshar", "\u294B": "ldrushar", "\u294E": "LeftRightVector", "\u294F": "RightUpDownVector", "\u2950": "DownLeftRightVector", "\u2951": "LeftUpDownVector", "\u2952": "LeftVectorBar", "\u2953": "RightVectorBar", "\u2954": "RightUpVectorBar", "\u2955": "RightDownVectorBar", "\u2956": "DownLeftVectorBar", "\u2957": "DownRightVectorBar", "\u2958": "LeftUpVectorBar", "\u2959": "LeftDownVectorBar", "\u295A": "LeftTeeVector", "\u295B": "RightTeeVector", "\u295C": "RightUpTeeVector", "\u295D": "RightDownTeeVector", "\u295E": "DownLeftTeeVector", "\u295F": "DownRightTeeVector", "\u2960": "LeftUpTeeVector", "\u2961": "LeftDownTeeVector", "\u2962": "lHar", "\u2963": "uHar", "\u2964": "rHar", "\u2965": "dHar", "\u2966": "luruhar", "\u2967": "ldrdhar", "\u2968": "ruluhar", "\u2969": "rdldhar", "\u296A": "lharul", "\u296B": "llhard", "\u296C": "rharul", "\u296D": "lrhard", "\u296E": "udhar", "\u296F": "duhar", "\u2970": "RoundImplies", "\u2971": "erarr", "\u2972": "simrarr", "\u2973": "larrsim", "\u2974": "rarrsim", "\u2975": "rarrap", "\u2976": "ltlarr", "\u2978": "gtrarr", "\u2979": "subrarr", "\u297B": "suplarr", "\u297C": "lfisht", "\u297D": "rfisht", "\u297E": "ufisht", "\u297F": "dfisht", "\u299A": "vzigzag", "\u299C": "vangrt", "\u299D": "angrtvbd", "\u29A4": "ange", "\u29A5": "range", "\u29A6": "dwangle", "\u29A7": "uwangle", "\u29A8": "angmsdaa", "\u29A9": "angmsdab", "\u29AA": "angmsdac", "\u29AB": "angmsdad", "\u29AC": "angmsdae", "\u29AD": "angmsdaf", "\u29AE": "angmsdag", "\u29AF": "angmsdah", "\u29B0": "bemptyv", "\u29B1": "demptyv", "\u29B2": "cemptyv", "\u29B3": "raemptyv", "\u29B4": "laemptyv", "\u29B5": "ohbar", "\u29B6": "omid", "\u29B7": "opar", "\u29B9": "operp", "\u29BB": "olcross", "\u29BC": "odsold", "\u29BE": "olcir", "\u29BF": "ofcir", "\u29C0": "olt", "\u29C1": "ogt", "\u29C2": "cirscir", "\u29C3": "cirE", "\u29C4": "solb", "\u29C5": "bsolb", "\u29C9": "boxbox", "\u29CD": "trisb", "\u29CE": "rtriltri", "\u29CF": "LeftTriangleBar", "\u29CF\u0338": "NotLeftTriangleBar", "\u29D0": "RightTriangleBar", "\u29D0\u0338": "NotRightTriangleBar", "\u29DC": "iinfin", "\u29DD": "infintie", "\u29DE": "nvinfin", "\u29E3": "eparsl", "\u29E4": "smeparsl", "\u29E5": "eqvparsl", "\u29EB": "lozf", "\u29F4": "RuleDelayed", "\u29F6": "dsol", "\u2A00": "xodot", "\u2A01": "xoplus", "\u2A02": "xotime", "\u2A04": "xuplus", "\u2A06": "xsqcup", "\u2A0D": "fpartint", "\u2A10": "cirfnint", "\u2A11": "awint", "\u2A12": "rppolint", "\u2A13": "scpolint", "\u2A14": "npolint", "\u2A15": "pointint", "\u2A16": "quatint", "\u2A17": "intlarhk", "\u2A22": "pluscir", "\u2A23": "plusacir", "\u2A24": "simplus", "\u2A25": "plusdu", "\u2A26": "plussim", "\u2A27": "plustwo", "\u2A29": "mcomma", "\u2A2A": "minusdu", "\u2A2D": "loplus", "\u2A2E": "roplus", "\u2A2F": "Cross", "\u2A30": "timesd", "\u2A31": "timesbar", "\u2A33": "smashp", "\u2A34": "lotimes", "\u2A35": "rotimes", "\u2A36": "otimesas", "\u2A37": "Otimes", "\u2A38": "odiv", "\u2A39": "triplus", "\u2A3A": "triminus", "\u2A3B": "tritime", "\u2A3C": "iprod", "\u2A3F": "amalg", "\u2A40": "capdot", "\u2A42": "ncup", "\u2A43": "ncap", "\u2A44": "capand", "\u2A45": "cupor", "\u2A46": "cupcap", "\u2A47": "capcup", "\u2A48": "cupbrcap", "\u2A49": "capbrcup", "\u2A4A": "cupcup", "\u2A4B": "capcap", "\u2A4C": "ccups", "\u2A4D": "ccaps", "\u2A50": "ccupssm", "\u2A53": "And", "\u2A54": "Or", "\u2A55": "andand", "\u2A56": "oror", "\u2A57": "orslope", "\u2A58": "andslope", "\u2A5A": "andv", "\u2A5B": "orv", "\u2A5C": "andd", "\u2A5D": "ord", "\u2A5F": "wedbar", "\u2A66": "sdote", "\u2A6A": "simdot", "\u2A6D": "congdot", "\u2A6D\u0338": "ncongdot", "\u2A6E": "easter", "\u2A6F": "apacir", "\u2A70": "apE", "\u2A70\u0338": "napE", "\u2A71": "eplus", "\u2A72": "pluse", "\u2A73": "Esim", "\u2A77": "eDDot", "\u2A78": "equivDD", "\u2A79": "ltcir", "\u2A7A": "gtcir", "\u2A7B": "ltquest", "\u2A7C": "gtquest", "\u2A7D": "les", "\u2A7D\u0338": "nles", "\u2A7E": "ges", "\u2A7E\u0338": "nges", "\u2A7F": "lesdot", "\u2A80": "gesdot", "\u2A81": "lesdoto", "\u2A82": "gesdoto", "\u2A83": "lesdotor", "\u2A84": "gesdotol", "\u2A85": "lap", "\u2A86": "gap", "\u2A87": "lne", "\u2A88": "gne", "\u2A89": "lnap", "\u2A8A": "gnap", "\u2A8B": "lEg", "\u2A8C": "gEl", "\u2A8D": "lsime", "\u2A8E": "gsime", "\u2A8F": "lsimg", "\u2A90": "gsiml", "\u2A91": "lgE", "\u2A92": "glE", "\u2A93": "lesges", "\u2A94": "gesles", "\u2A95": "els", "\u2A96": "egs", "\u2A97": "elsdot", "\u2A98": "egsdot", "\u2A99": "el", "\u2A9A": "eg", "\u2A9D": "siml", "\u2A9E": "simg", "\u2A9F": "simlE", "\u2AA0": "simgE", "\u2AA1": "LessLess", "\u2AA1\u0338": "NotNestedLessLess", "\u2AA2": "GreaterGreater", "\u2AA2\u0338": "NotNestedGreaterGreater", "\u2AA4": "glj", "\u2AA5": "gla", "\u2AA6": "ltcc", "\u2AA7": "gtcc", "\u2AA8": "lescc", "\u2AA9": "gescc", "\u2AAA": "smt", "\u2AAB": "lat", "\u2AAC": "smte", "\u2AAC\uFE00": "smtes", "\u2AAD": "late", "\u2AAD\uFE00": "lates", "\u2AAE": "bumpE", "\u2AAF": "pre", "\u2AAF\u0338": "npre", "\u2AB0": "sce", "\u2AB0\u0338": "nsce", "\u2AB3": "prE", "\u2AB4": "scE", "\u2AB5": "prnE", "\u2AB6": "scnE", "\u2AB7": "prap", "\u2AB8": "scap", "\u2AB9": "prnap", "\u2ABA": "scnap", "\u2ABB": "Pr", "\u2ABC": "Sc", "\u2ABD": "subdot", "\u2ABE": "supdot", "\u2ABF": "subplus", "\u2AC0": "supplus", "\u2AC1": "submult", "\u2AC2": "supmult", "\u2AC3": "subedot", "\u2AC4": "supedot", "\u2AC5": "subE", "\u2AC5\u0338": "nsubE", "\u2AC6": "supE", "\u2AC6\u0338": "nsupE", "\u2AC7": "subsim", "\u2AC8": "supsim", "\u2ACB\uFE00": "vsubnE", "\u2ACB": "subnE", "\u2ACC\uFE00": "vsupnE", "\u2ACC": "supnE", "\u2ACF": "csub", "\u2AD0": "csup", "\u2AD1": "csube", "\u2AD2": "csupe", "\u2AD3": "subsup", "\u2AD4": "supsub", "\u2AD5": "subsub", "\u2AD6": "supsup", "\u2AD7": "suphsub", "\u2AD8": "supdsub", "\u2AD9": "forkv", "\u2ADA": "topfork", "\u2ADB": "mlcp", "\u2AE4": "Dashv", "\u2AE6": "Vdashl", "\u2AE7": "Barv", "\u2AE8": "vBar", "\u2AE9": "vBarv", "\u2AEB": "Vbar", "\u2AEC": "Not", "\u2AED": "bNot", "\u2AEE": "rnmid", "\u2AEF": "cirmid", "\u2AF0": "midcir", "\u2AF1": "topcir", "\u2AF2": "nhpar", "\u2AF3": "parsim", "\u2AFD": "parsl", "\u2AFD\u20E5": "nparsl", "\u266D": "flat", "\u266E": "natur", "\u266F": "sharp", "\xA4": "curren", "\xA2": "cent", $: "dollar", "\xA3": "pound", "\xA5": "yen", "\u20AC": "euro", "\xB9": "sup1", "\xBD": "half", "\u2153": "frac13", "\xBC": "frac14", "\u2155": "frac15", "\u2159": "frac16", "\u215B": "frac18", "\xB2": "sup2", "\u2154": "frac23", "\u2156": "frac25", "\xB3": "sup3", "\xBE": "frac34", "\u2157": "frac35", "\u215C": "frac38", "\u2158": "frac45", "\u215A": "frac56", "\u215D": "frac58", "\u215E": "frac78", "\uD835\uDCB6": "ascr", "\uD835\uDD52": "aopf", "\uD835\uDD1E": "afr", "\uD835\uDD38": "Aopf", "\uD835\uDD04": "Afr", "\uD835\uDC9C": "Ascr", "\xAA": "ordf", "\xE1": "aacute", "\xC1": "Aacute", "\xE0": "agrave", "\xC0": "Agrave", "\u0103": "abreve", "\u0102": "Abreve", "\xE2": "acirc", "\xC2": "Acirc", "\xE5": "aring", "\xC5": "angst", "\xE4": "auml", "\xC4": "Auml", "\xE3": "atilde", "\xC3": "Atilde", "\u0105": "aogon", "\u0104": "Aogon", "\u0101": "amacr", "\u0100": "Amacr", "\xE6": "aelig", "\xC6": "AElig", "\uD835\uDCB7": "bscr", "\uD835\uDD53": "bopf", "\uD835\uDD1F": "bfr", "\uD835\uDD39": "Bopf", "\u212C": "Bscr", "\uD835\uDD05": "Bfr", "\uD835\uDD20": "cfr", "\uD835\uDCB8": "cscr", "\uD835\uDD54": "copf", "\u212D": "Cfr", "\uD835\uDC9E": "Cscr", "\u2102": "Copf", "\u0107": "cacute", "\u0106": "Cacute", "\u0109": "ccirc", "\u0108": "Ccirc", "\u010D": "ccaron", "\u010C": "Ccaron", "\u010B": "cdot", "\u010A": "Cdot", "\xE7": "ccedil", "\xC7": "Ccedil", "\u2105": "incare", "\uD835\uDD21": "dfr", "\u2146": "dd", "\uD835\uDD55": "dopf", "\uD835\uDCB9": "dscr", "\uD835\uDC9F": "Dscr", "\uD835\uDD07": "Dfr", "\u2145": "DD", "\uD835\uDD3B": "Dopf", "\u010F": "dcaron", "\u010E": "Dcaron", "\u0111": "dstrok", "\u0110": "Dstrok", "\xF0": "eth", "\xD0": "ETH", "\u2147": "ee", "\u212F": "escr", "\uD835\uDD22": "efr", "\uD835\uDD56": "eopf", "\u2130": "Escr", "\uD835\uDD08": "Efr", "\uD835\uDD3C": "Eopf", "\xE9": "eacute", "\xC9": "Eacute", "\xE8": "egrave", "\xC8": "Egrave", "\xEA": "ecirc", "\xCA": "Ecirc", "\u011B": "ecaron", "\u011A": "Ecaron", "\xEB": "euml", "\xCB": "Euml", "\u0117": "edot", "\u0116": "Edot", "\u0119": "eogon", "\u0118": "Eogon", "\u0113": "emacr", "\u0112": "Emacr", "\uD835\uDD23": "ffr", "\uD835\uDD57": "fopf", "\uD835\uDCBB": "fscr", "\uD835\uDD09": "Ffr", "\uD835\uDD3D": "Fopf", "\u2131": "Fscr", "\uFB00": "fflig", "\uFB03": "ffilig", "\uFB04": "ffllig", "\uFB01": "filig", fj: "fjlig", "\uFB02": "fllig", "\u0192": "fnof", "\u210A": "gscr", "\uD835\uDD58": "gopf", "\uD835\uDD24": "gfr", "\uD835\uDCA2": "Gscr", "\uD835\uDD3E": "Gopf", "\uD835\uDD0A": "Gfr", "\u01F5": "gacute", "\u011F": "gbreve", "\u011E": "Gbreve", "\u011D": "gcirc", "\u011C": "Gcirc", "\u0121": "gdot", "\u0120": "Gdot", "\u0122": "Gcedil", "\uD835\uDD25": "hfr", "\u210E": "planckh", "\uD835\uDCBD": "hscr", "\uD835\uDD59": "hopf", "\u210B": "Hscr", "\u210C": "Hfr", "\u210D": "Hopf", "\u0125": "hcirc", "\u0124": "Hcirc", "\u210F": "hbar", "\u0127": "hstrok", "\u0126": "Hstrok", "\uD835\uDD5A": "iopf", "\uD835\uDD26": "ifr", "\uD835\uDCBE": "iscr", "\u2148": "ii", "\uD835\uDD40": "Iopf", "\u2110": "Iscr", "\u2111": "Im", "\xED": "iacute", "\xCD": "Iacute", "\xEC": "igrave", "\xCC": "Igrave", "\xEE": "icirc", "\xCE": "Icirc", "\xEF": "iuml", "\xCF": "Iuml", "\u0129": "itilde", "\u0128": "Itilde", "\u0130": "Idot", "\u012F": "iogon", "\u012E": "Iogon", "\u012B": "imacr", "\u012A": "Imacr", "\u0133": "ijlig", "\u0132": "IJlig", "\u0131": "imath", "\uD835\uDCBF": "jscr", "\uD835\uDD5B": "jopf", "\uD835\uDD27": "jfr", "\uD835\uDCA5": "Jscr", "\uD835\uDD0D": "Jfr", "\uD835\uDD41": "Jopf", "\u0135": "jcirc", "\u0134": "Jcirc", "\u0237": "jmath", "\uD835\uDD5C": "kopf", "\uD835\uDCC0": "kscr", "\uD835\uDD28": "kfr", "\uD835\uDCA6": "Kscr", "\uD835\uDD42": "Kopf", "\uD835\uDD0E": "Kfr", "\u0137": "kcedil", "\u0136": "Kcedil", "\uD835\uDD29": "lfr", "\uD835\uDCC1": "lscr", "\u2113": "ell", "\uD835\uDD5D": "lopf", "\u2112": "Lscr", "\uD835\uDD0F": "Lfr", "\uD835\uDD43": "Lopf", "\u013A": "lacute", "\u0139": "Lacute", "\u013E": "lcaron", "\u013D": "Lcaron", "\u013C": "lcedil", "\u013B": "Lcedil", "\u0142": "lstrok", "\u0141": "Lstrok", "\u0140": "lmidot", "\u013F": "Lmidot", "\uD835\uDD2A": "mfr", "\uD835\uDD5E": "mopf", "\uD835\uDCC2": "mscr", "\uD835\uDD10": "Mfr", "\uD835\uDD44": "Mopf", "\u2133": "Mscr", "\uD835\uDD2B": "nfr", "\uD835\uDD5F": "nopf", "\uD835\uDCC3": "nscr", "\u2115": "Nopf", "\uD835\uDCA9": "Nscr", "\uD835\uDD11": "Nfr", "\u0144": "nacute", "\u0143": "Nacute", "\u0148": "ncaron", "\u0147": "Ncaron", "\xF1": "ntilde", "\xD1": "Ntilde", "\u0146": "ncedil", "\u0145": "Ncedil", "\u2116": "numero", "\u014B": "eng", "\u014A": "ENG", "\uD835\uDD60": "oopf", "\uD835\uDD2C": "ofr", "\u2134": "oscr", "\uD835\uDCAA": "Oscr", "\uD835\uDD12": "Ofr", "\uD835\uDD46": "Oopf", "\xBA": "ordm", "\xF3": "oacute", "\xD3": "Oacute", "\xF2": "ograve", "\xD2": "Ograve", "\xF4": "ocirc", "\xD4": "Ocirc", "\xF6": "ouml", "\xD6": "Ouml", "\u0151": "odblac", "\u0150": "Odblac", "\xF5": "otilde", "\xD5": "Otilde", "\xF8": "oslash", "\xD8": "Oslash", "\u014D": "omacr", "\u014C": "Omacr", "\u0153": "oelig", "\u0152": "OElig", "\uD835\uDD2D": "pfr", "\uD835\uDCC5": "pscr", "\uD835\uDD61": "popf", "\u2119": "Popf", "\uD835\uDD13": "Pfr", "\uD835\uDCAB": "Pscr", "\uD835\uDD62": "qopf", "\uD835\uDD2E": "qfr", "\uD835\uDCC6": "qscr", "\uD835\uDCAC": "Qscr", "\uD835\uDD14": "Qfr", "\u211A": "Qopf", "\u0138": "kgreen", "\uD835\uDD2F": "rfr", "\uD835\uDD63": "ropf", "\uD835\uDCC7": "rscr", "\u211B": "Rscr", "\u211C": "Re", "\u211D": "Ropf", "\u0155": "racute", "\u0154": "Racute", "\u0159": "rcaron", "\u0158": "Rcaron", "\u0157": "rcedil", "\u0156": "Rcedil", "\uD835\uDD64": "sopf", "\uD835\uDCC8": "sscr", "\uD835\uDD30": "sfr", "\uD835\uDD4A": "Sopf", "\uD835\uDD16": "Sfr", "\uD835\uDCAE": "Sscr", "\u24C8": "oS", "\u015B": "sacute", "\u015A": "Sacute", "\u015D": "scirc", "\u015C": "Scirc", "\u0161": "scaron", "\u0160": "Scaron", "\u015F": "scedil", "\u015E": "Scedil", "\xDF": "szlig", "\uD835\uDD31": "tfr", "\uD835\uDCC9": "tscr", "\uD835\uDD65": "topf", "\uD835\uDCAF": "Tscr", "\uD835\uDD17": "Tfr", "\uD835\uDD4B": "Topf", "\u0165": "tcaron", "\u0164": "Tcaron", "\u0163": "tcedil", "\u0162": "Tcedil", "\u2122": "trade", "\u0167": "tstrok", "\u0166": "Tstrok", "\uD835\uDCCA": "uscr", "\uD835\uDD66": "uopf", "\uD835\uDD32": "ufr", "\uD835\uDD4C": "Uopf", "\uD835\uDD18": "Ufr", "\uD835\uDCB0": "Uscr", "\xFA": "uacute", "\xDA": "Uacute", "\xF9": "ugrave", "\xD9": "Ugrave", "\u016D": "ubreve", "\u016C": "Ubreve", "\xFB": "ucirc", "\xDB": "Ucirc", "\u016F": "uring", "\u016E": "Uring", "\xFC": "uuml", "\xDC": "Uuml", "\u0171": "udblac", "\u0170": "Udblac", "\u0169": "utilde", "\u0168": "Utilde", "\u0173": "uogon", "\u0172": "Uogon", "\u016B": "umacr", "\u016A": "Umacr", "\uD835\uDD33": "vfr", "\uD835\uDD67": "vopf", "\uD835\uDCCB": "vscr", "\uD835\uDD19": "Vfr", "\uD835\uDD4D": "Vopf", "\uD835\uDCB1": "Vscr", "\uD835\uDD68": "wopf", "\uD835\uDCCC": "wscr", "\uD835\uDD34": "wfr", "\uD835\uDCB2": "Wscr", "\uD835\uDD4E": "Wopf", "\uD835\uDD1A": "Wfr", "\u0175": "wcirc", "\u0174": "Wcirc", "\uD835\uDD35": "xfr", "\uD835\uDCCD": "xscr", "\uD835\uDD69": "xopf", "\uD835\uDD4F": "Xopf", "\uD835\uDD1B": "Xfr", "\uD835\uDCB3": "Xscr", "\uD835\uDD36": "yfr", "\uD835\uDCCE": "yscr", "\uD835\uDD6A": "yopf", "\uD835\uDCB4": "Yscr", "\uD835\uDD1C": "Yfr", "\uD835\uDD50": "Yopf", "\xFD": "yacute", "\xDD": "Yacute", "\u0177": "ycirc", "\u0176": "Ycirc", "\xFF": "yuml", "\u0178": "Yuml", "\uD835\uDCCF": "zscr", "\uD835\uDD37": "zfr", "\uD835\uDD6B": "zopf", "\u2128": "Zfr", "\u2124": "Zopf", "\uD835\uDCB5": "Zscr", "\u017A": "zacute", "\u0179": "Zacute", "\u017E": "zcaron", "\u017D": "Zcaron", "\u017C": "zdot", "\u017B": "Zdot", "\u01B5": "imped", "\xFE": "thorn", "\xDE": "THORN", "\u0149": "napos", "\u03B1": "alpha", "\u0391": "Alpha", "\u03B2": "beta", "\u0392": "Beta", "\u03B3": "gamma", "\u0393": "Gamma", "\u03B4": "delta", "\u0394": "Delta", "\u03B5": "epsi", "\u03F5": "epsiv", "\u0395": "Epsilon", "\u03DD": "gammad", "\u03DC": "Gammad", "\u03B6": "zeta", "\u0396": "Zeta", "\u03B7": "eta", "\u0397": "Eta", "\u03B8": "theta", "\u03D1": "thetav", "\u0398": "Theta", "\u03B9": "iota", "\u0399": "Iota", "\u03BA": "kappa", "\u03F0": "kappav", "\u039A": "Kappa", "\u03BB": "lambda", "\u039B": "Lambda", "\u03BC": "mu", "\xB5": "micro", "\u039C": "Mu", "\u03BD": "nu", "\u039D": "Nu", "\u03BE": "xi", "\u039E": "Xi", "\u03BF": "omicron", "\u039F": "Omicron", "\u03C0": "pi", "\u03D6": "piv", "\u03A0": "Pi", "\u03C1": "rho", "\u03F1": "rhov", "\u03A1": "Rho", "\u03C3": "sigma", "\u03A3": "Sigma", "\u03C2": "sigmaf", "\u03C4": "tau", "\u03A4": "Tau", "\u03C5": "upsi", "\u03A5": "Upsilon", "\u03D2": "Upsi", "\u03C6": "phi", "\u03D5": "phiv", "\u03A6": "Phi", "\u03C7": "chi", "\u03A7": "Chi", "\u03C8": "psi", "\u03A8": "Psi", "\u03C9": "omega", "\u03A9": "ohm", "\u0430": "acy", "\u0410": "Acy", "\u0431": "bcy", "\u0411": "Bcy", "\u0432": "vcy", "\u0412": "Vcy", "\u0433": "gcy", "\u0413": "Gcy", "\u0453": "gjcy", "\u0403": "GJcy", "\u0434": "dcy", "\u0414": "Dcy", "\u0452": "djcy", "\u0402": "DJcy", "\u0435": "iecy", "\u0415": "IEcy", "\u0451": "iocy", "\u0401": "IOcy", "\u0454": "jukcy", "\u0404": "Jukcy", "\u0436": "zhcy", "\u0416": "ZHcy", "\u0437": "zcy", "\u0417": "Zcy", "\u0455": "dscy", "\u0405": "DScy", "\u0438": "icy", "\u0418": "Icy", "\u0456": "iukcy", "\u0406": "Iukcy", "\u0457": "yicy", "\u0407": "YIcy", "\u0439": "jcy", "\u0419": "Jcy", "\u0458": "jsercy", "\u0408": "Jsercy", "\u043A": "kcy", "\u041A": "Kcy", "\u045C": "kjcy", "\u040C": "KJcy", "\u043B": "lcy", "\u041B": "Lcy", "\u0459": "ljcy", "\u0409": "LJcy", "\u043C": "mcy", "\u041C": "Mcy", "\u043D": "ncy", "\u041D": "Ncy", "\u045A": "njcy", "\u040A": "NJcy", "\u043E": "ocy", "\u041E": "Ocy", "\u043F": "pcy", "\u041F": "Pcy", "\u0440": "rcy", "\u0420": "Rcy", "\u0441": "scy", "\u0421": "Scy", "\u0442": "tcy", "\u0422": "Tcy", "\u045B": "tshcy", "\u040B": "TSHcy", "\u0443": "ucy", "\u0423": "Ucy", "\u045E": "ubrcy", "\u040E": "Ubrcy", "\u0444": "fcy", "\u0424": "Fcy", "\u0445": "khcy", "\u0425": "KHcy", "\u0446": "tscy", "\u0426": "TScy", "\u0447": "chcy", "\u0427": "CHcy", "\u045F": "dzcy", "\u040F": "DZcy", "\u0448": "shcy", "\u0428": "SHcy", "\u0449": "shchcy", "\u0429": "SHCHcy", "\u044A": "hardcy", "\u042A": "HARDcy", "\u044B": "ycy", "\u042B": "Ycy", "\u044C": "softcy", "\u042C": "SOFTcy", "\u044D": "ecy", "\u042D": "Ecy", "\u044E": "yucy", "\u042E": "YUcy", "\u044F": "yacy", "\u042F": "YAcy", "\u2135": "aleph", "\u2136": "beth", "\u2137": "gimel", "\u2138": "daleth" };
    var regexEscape = /["&'<>`]/g;
    var escapeMap = {
      '"': "&quot;",
      "&": "&amp;",
      "\'": "&#x27;",
      "<": "&lt;",
      ">": "&gt;",
      "`": "&#x60;"
    };
    var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
    var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
    var decodeMap = { aacute: "\xE1", Aacute: "\xC1", abreve: "\u0103", Abreve: "\u0102", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", acirc: "\xE2", Acirc: "\xC2", acute: "\xB4", acy: "\u0430", Acy: "\u0410", aelig: "\xE6", AElig: "\xC6", af: "\u2061", afr: "\uD835\uDD1E", Afr: "\uD835\uDD04", agrave: "\xE0", Agrave: "\xC0", alefsym: "\u2135", aleph: "\u2135", alpha: "\u03B1", Alpha: "\u0391", amacr: "\u0101", Amacr: "\u0100", amalg: "\u2A3F", amp: "&", AMP: "&", and: "\u2227", And: "\u2A53", andand: "\u2A55", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsd: "\u2221", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", aogon: "\u0105", Aogon: "\u0104", aopf: "\uD835\uDD52", Aopf: "\uD835\uDD38", ap: "\u2248", apacir: "\u2A6F", ape: "\u224A", apE: "\u2A70", apid: "\u224B", apos: "\'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", aring: "\xE5", Aring: "\xC5", ascr: "\uD835\uDCB6", Ascr: "\uD835\uDC9C", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", atilde: "\xE3", Atilde: "\xC3", auml: "\xE4", Auml: "\xC4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", barwed: "\u2305", Barwed: "\u2306", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", bcy: "\u0431", Bcy: "\u0411", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", Because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", beta: "\u03B2", Beta: "\u0392", beth: "\u2136", between: "\u226C", bfr: "\uD835\uDD1F", Bfr: "\uD835\uDD05", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bnot: "\u2310", bNot: "\u2AED", bopf: "\uD835\uDD53", Bopf: "\uD835\uDD39", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxdl: "\u2510", boxdL: "\u2555", boxDl: "\u2556", boxDL: "\u2557", boxdr: "\u250C", boxdR: "\u2552", boxDr: "\u2553", boxDR: "\u2554", boxh: "\u2500", boxH: "\u2550", boxhd: "\u252C", boxhD: "\u2565", boxHd: "\u2564", boxHD: "\u2566", boxhu: "\u2534", boxhU: "\u2568", boxHu: "\u2567", boxHU: "\u2569", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxul: "\u2518", boxuL: "\u255B", boxUl: "\u255C", boxUL: "\u255D", boxur: "\u2514", boxuR: "\u2558", boxUr: "\u2559", boxUR: "\u255A", boxv: "\u2502", boxV: "\u2551", boxvh: "\u253C", boxvH: "\u256A", boxVh: "\u256B", boxVH: "\u256C", boxvl: "\u2524", boxvL: "\u2561", boxVl: "\u2562", boxVL: "\u2563", boxvr: "\u251C", boxvR: "\u255E", boxVr: "\u255F", boxVR: "\u2560", bprime: "\u2035", breve: "\u02D8", Breve: "\u02D8", brvbar: "\xA6", bscr: "\uD835\uDCB7", Bscr: "\u212C", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsol: "\\", bsolb: "\u29C5", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpe: "\u224F", bumpE: "\u2AAE", bumpeq: "\u224F", Bumpeq: "\u224E", cacute: "\u0107", Cacute: "\u0106", cap: "\u2229", Cap: "\u22D2", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", ccaron: "\u010D", Ccaron: "\u010C", ccedil: "\xE7", Ccedil: "\xC7", ccirc: "\u0109", Ccirc: "\u0108", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", cdot: "\u010B", Cdot: "\u010A", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", CenterDot: "\xB7", cfr: "\uD835\uDD20", Cfr: "\u212D", chcy: "\u0447", CHcy: "\u0427", check: "\u2713", checkmark: "\u2713", chi: "\u03C7", Chi: "\u03A7", cir: "\u25CB", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cire: "\u2257", cirE: "\u29C3", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", colon: ":", Colon: "\u2237", colone: "\u2254", Colone: "\u2A74", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", conint: "\u222E", Conint: "\u222F", ContourIntegral: "\u222E", copf: "\uD835\uDD54", Copf: "\u2102", coprod: "\u2210", Coproduct: "\u2210", copy: "\xA9", COPY: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", cross: "\u2717", Cross: "\u2A2F", cscr: "\uD835\uDCB8", Cscr: "\uD835\uDC9E", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cup: "\u222A", Cup: "\u22D3", cupbrcap: "\u2A48", cupcap: "\u2A46", CupCap: "\u224D", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dagger: "\u2020", Dagger: "\u2021", daleth: "\u2138", darr: "\u2193", dArr: "\u21D3", Darr: "\u21A1", dash: "\u2010", dashv: "\u22A3", Dashv: "\u2AE4", dbkarow: "\u290F", dblac: "\u02DD", dcaron: "\u010F", Dcaron: "\u010E", dcy: "\u0434", Dcy: "\u0414", dd: "\u2146", DD: "\u2145", ddagger: "\u2021", ddarr: "\u21CA", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", delta: "\u03B4", Delta: "\u0394", demptyv: "\u29B1", dfisht: "\u297F", dfr: "\uD835\uDD21", Dfr: "\uD835\uDD07", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", diamond: "\u22C4", Diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", djcy: "\u0452", DJcy: "\u0402", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", dopf: "\uD835\uDD55", Dopf: "\uD835\uDD3B", dot: "\u02D9", Dot: "\xA8", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", downarrow: "\u2193", Downarrow: "\u21D3", DownArrow: "\u2193", DownArrowBar: "\u2913", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVector: "\u21BD", DownLeftVectorBar: "\u2956", DownRightTeeVector: "\u295F", DownRightVector: "\u21C1", DownRightVectorBar: "\u2957", DownTee: "\u22A4", DownTeeArrow: "\u21A7", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", dscr: "\uD835\uDCB9", Dscr: "\uD835\uDC9F", dscy: "\u0455", DScy: "\u0405", dsol: "\u29F6", dstrok: "\u0111", Dstrok: "\u0110", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", dzcy: "\u045F", DZcy: "\u040F", dzigrarr: "\u27FF", eacute: "\xE9", Eacute: "\xC9", easter: "\u2A6E", ecaron: "\u011B", Ecaron: "\u011A", ecir: "\u2256", ecirc: "\xEA", Ecirc: "\xCA", ecolon: "\u2255", ecy: "\u044D", Ecy: "\u042D", eDDot: "\u2A77", edot: "\u0117", eDot: "\u2251", Edot: "\u0116", ee: "\u2147", efDot: "\u2252", efr: "\uD835\uDD22", Efr: "\uD835\uDD08", eg: "\u2A9A", egrave: "\xE8", Egrave: "\xC8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", emacr: "\u0113", Emacr: "\u0112", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp: "\u2003", emsp13: "\u2004", emsp14: "\u2005", eng: "\u014B", ENG: "\u014A", ensp: "\u2002", eogon: "\u0119", Eogon: "\u0118", eopf: "\uD835\uDD56", Eopf: "\uD835\uDD3C", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", epsilon: "\u03B5", Epsilon: "\u0395", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", escr: "\u212F", Escr: "\u2130", esdot: "\u2250", esim: "\u2242", Esim: "\u2A73", eta: "\u03B7", Eta: "\u0397", eth: "\xF0", ETH: "\xD0", euml: "\xEB", Euml: "\xCB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", exponentiale: "\u2147", ExponentialE: "\u2147", fallingdotseq: "\u2252", fcy: "\u0444", Fcy: "\u0424", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", ffr: "\uD835\uDD23", Ffr: "\uD835\uDD09", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", fopf: "\uD835\uDD57", Fopf: "\uD835\uDD3D", forall: "\u2200", ForAll: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\uD835\uDCBB", Fscr: "\u2131", gacute: "\u01F5", gamma: "\u03B3", Gamma: "\u0393", gammad: "\u03DD", Gammad: "\u03DC", gap: "\u2A86", gbreve: "\u011F", Gbreve: "\u011E", Gcedil: "\u0122", gcirc: "\u011D", Gcirc: "\u011C", gcy: "\u0433", Gcy: "\u0413", gdot: "\u0121", Gdot: "\u0120", ge: "\u2265", gE: "\u2267", gel: "\u22DB", gEl: "\u2A8C", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", ges: "\u2A7E", gescc: "\u2AA9", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", gfr: "\uD835\uDD24", Gfr: "\uD835\uDD0A", gg: "\u226B", Gg: "\u22D9", ggg: "\u22D9", gimel: "\u2137", gjcy: "\u0453", GJcy: "\u0403", gl: "\u2277", gla: "\u2AA5", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gnE: "\u2269", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", gopf: "\uD835\uDD58", Gopf: "\uD835\uDD3E", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", gscr: "\u210A", Gscr: "\uD835\uDCA2", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gt: ">", Gt: "\u226B", GT: ">", gtcc: "\u2AA7", gtcir: "\u2A7A", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", hardcy: "\u044A", HARDcy: "\u042A", harr: "\u2194", hArr: "\u21D4", harrcir: "\u2948", harrw: "\u21AD", Hat: "^", hbar: "\u210F", hcirc: "\u0125", Hcirc: "\u0124", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\uD835\uDD25", Hfr: "\u210C", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\uD835\uDD59", Hopf: "\u210D", horbar: "\u2015", HorizontalLine: "\u2500", hscr: "\uD835\uDCBD", Hscr: "\u210B", hslash: "\u210F", hstrok: "\u0127", Hstrok: "\u0126", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", iacute: "\xED", Iacute: "\xCD", ic: "\u2063", icirc: "\xEE", Icirc: "\xCE", icy: "\u0438", Icy: "\u0418", Idot: "\u0130", iecy: "\u0435", IEcy: "\u0415", iexcl: "\xA1", iff: "\u21D4", ifr: "\uD835\uDD26", Ifr: "\u2111", igrave: "\xEC", Igrave: "\xCC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", ijlig: "\u0133", IJlig: "\u0132", Im: "\u2111", imacr: "\u012B", Imacr: "\u012A", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", in: "\u2208", incare: "\u2105", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", int: "\u222B", Int: "\u222C", intcal: "\u22BA", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", iocy: "\u0451", IOcy: "\u0401", iogon: "\u012F", Iogon: "\u012E", iopf: "\uD835\uDD5A", Iopf: "\uD835\uDD40", iota: "\u03B9", Iota: "\u0399", iprod: "\u2A3C", iquest: "\xBF", iscr: "\uD835\uDCBE", Iscr: "\u2110", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", itilde: "\u0129", Itilde: "\u0128", iukcy: "\u0456", Iukcy: "\u0406", iuml: "\xEF", Iuml: "\xCF", jcirc: "\u0135", Jcirc: "\u0134", jcy: "\u0439", Jcy: "\u0419", jfr: "\uD835\uDD27", Jfr: "\uD835\uDD0D", jmath: "\u0237", jopf: "\uD835\uDD5B", Jopf: "\uD835\uDD41", jscr: "\uD835\uDCBF", Jscr: "\uD835\uDCA5", jsercy: "\u0458", Jsercy: "\u0408", jukcy: "\u0454", Jukcy: "\u0404", kappa: "\u03BA", Kappa: "\u039A", kappav: "\u03F0", kcedil: "\u0137", Kcedil: "\u0136", kcy: "\u043A", Kcy: "\u041A", kfr: "\uD835\uDD28", Kfr: "\uD835\uDD0E", kgreen: "\u0138", khcy: "\u0445", KHcy: "\u0425", kjcy: "\u045C", KJcy: "\u040C", kopf: "\uD835\uDD5C", Kopf: "\uD835\uDD42", kscr: "\uD835\uDCC0", Kscr: "\uD835\uDCA6", lAarr: "\u21DA", lacute: "\u013A", Lacute: "\u0139", laemptyv: "\u29B4", lagran: "\u2112", lambda: "\u03BB", Lambda: "\u039B", lang: "\u27E8", Lang: "\u27EA", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", larr: "\u2190", lArr: "\u21D0", Larr: "\u219E", larrb: "\u21E4", larrbfs: "\u291F", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", lat: "\u2AAB", latail: "\u2919", lAtail: "\u291B", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lBarr: "\u290E", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", lcaron: "\u013E", Lcaron: "\u013D", lcedil: "\u013C", Lcedil: "\u013B", lceil: "\u2308", lcub: "{", lcy: "\u043B", Lcy: "\u041B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", lE: "\u2266", LeftAngleBracket: "\u27E8", leftarrow: "\u2190", Leftarrow: "\u21D0", LeftArrow: "\u2190", LeftArrowBar: "\u21E4", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVector: "\u21C3", LeftDownVectorBar: "\u2959", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", Leftrightarrow: "\u21D4", LeftRightArrow: "\u2194", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTee: "\u22A3", LeftTeeArrow: "\u21A4", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangle: "\u22B2", LeftTriangleBar: "\u29CF", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVector: "\u21BF", LeftUpVectorBar: "\u2958", LeftVector: "\u21BC", LeftVectorBar: "\u2952", leg: "\u22DA", lEg: "\u2A8B", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", les: "\u2A7D", lescc: "\u2AA8", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", lfr: "\uD835\uDD29", Lfr: "\uD835\uDD0F", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", ljcy: "\u0459", LJcy: "\u0409", ll: "\u226A", Ll: "\u22D8", llarr: "\u21C7", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", lmidot: "\u0140", Lmidot: "\u013F", lmoust: "\u23B0", lmoustache: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lnE: "\u2268", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", Longleftarrow: "\u27F8", LongLeftArrow: "\u27F5", longleftrightarrow: "\u27F7", Longleftrightarrow: "\u27FA", LongLeftRightArrow: "\u27F7", longmapsto: "\u27FC", longrightarrow: "\u27F6", Longrightarrow: "\u27F9", LongRightArrow: "\u27F6", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", lopf: "\uD835\uDD5D", Lopf: "\uD835\uDD43", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\uD835\uDCC1", Lscr: "\u2112", lsh: "\u21B0", Lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", lstrok: "\u0142", Lstrok: "\u0141", lt: "<", Lt: "\u226A", LT: "<", ltcc: "\u2AA6", ltcir: "\u2A79", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", map: "\u21A6", Map: "\u2905", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", mcy: "\u043C", Mcy: "\u041C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", mfr: "\uD835\uDD2A", Mfr: "\uD835\uDD10", mho: "\u2127", micro: "\xB5", mid: "\u2223", midast: "*", midcir: "\u2AF0", middot: "\xB7", minus: "\u2212", minusb: "\u229F", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", mopf: "\uD835\uDD5E", Mopf: "\uD835\uDD44", mp: "\u2213", mscr: "\uD835\uDCC2", Mscr: "\u2133", mstpos: "\u223E", mu: "\u03BC", Mu: "\u039C", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", nacute: "\u0144", Nacute: "\u0143", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natur: "\u266E", natural: "\u266E", naturals: "\u2115", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", ncaron: "\u0148", Ncaron: "\u0147", ncedil: "\u0146", Ncedil: "\u0145", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", ncy: "\u043D", Ncy: "\u041D", ndash: "\u2013", ne: "\u2260", nearhk: "\u2924", nearr: "\u2197", neArr: "\u21D7", nearrow: "\u2197", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: "\n", nexist: "\u2204", nexists: "\u2204", nfr: "\uD835\uDD2B", Nfr: "\uD835\uDD11", nge: "\u2271", ngE: "\u2267\u0338", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", ngt: "\u226F", nGt: "\u226B\u20D2", ngtr: "\u226F", nGtv: "\u226B\u0338", nharr: "\u21AE", nhArr: "\u21CE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", njcy: "\u045A", NJcy: "\u040A", nlarr: "\u219A", nlArr: "\u21CD", nldr: "\u2025", nle: "\u2270", nlE: "\u2266\u0338", nleftarrow: "\u219A", nLeftarrow: "\u21CD", nleftrightarrow: "\u21AE", nLeftrightarrow: "\u21CE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nlt: "\u226E", nLt: "\u226A\u20D2", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nopf: "\uD835\uDD5F", Nopf: "\u2115", not: "\xAC", Not: "\u2AEC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangle: "\u22EA", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangle: "\u22EB", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", npar: "\u2226", nparallel: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", npre: "\u2AAF\u0338", nprec: "\u2280", npreceq: "\u2AAF\u0338", nrarr: "\u219B", nrArr: "\u21CF", nrarrc: "\u2933\u0338", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nRightarrow: "\u21CF", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", nscr: "\uD835\uDCC3", Nscr: "\uD835\uDCA9", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsube: "\u2288", nsubE: "\u2AC5\u0338", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupe: "\u2289", nsupE: "\u2AC6\u0338", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", ntilde: "\xF1", Ntilde: "\xD1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", nu: "\u03BD", Nu: "\u039D", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvDash: "\u22AD", nVdash: "\u22AE", nVDash: "\u22AF", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwarr: "\u2196", nwArr: "\u21D6", nwarrow: "\u2196", nwnear: "\u2927", oacute: "\xF3", Oacute: "\xD3", oast: "\u229B", ocir: "\u229A", ocirc: "\xF4", Ocirc: "\xD4", ocy: "\u043E", Ocy: "\u041E", odash: "\u229D", odblac: "\u0151", Odblac: "\u0150", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", oelig: "\u0153", OElig: "\u0152", ofcir: "\u29BF", ofr: "\uD835\uDD2C", Ofr: "\uD835\uDD12", ogon: "\u02DB", ograve: "\xF2", Ograve: "\xD2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", omacr: "\u014D", Omacr: "\u014C", omega: "\u03C9", Omega: "\u03A9", omicron: "\u03BF", Omicron: "\u039F", omid: "\u29B6", ominus: "\u2296", oopf: "\uD835\uDD60", Oopf: "\uD835\uDD46", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", or: "\u2228", Or: "\u2A54", orarr: "\u21BB", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", oscr: "\u2134", Oscr: "\uD835\uDCAA", oslash: "\xF8", Oslash: "\xD8", osol: "\u2298", otilde: "\xF5", Otilde: "\xD5", otimes: "\u2297", Otimes: "\u2A37", otimesas: "\u2A36", ouml: "\xF6", Ouml: "\xD6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", par: "\u2225", para: "\xB6", parallel: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", pcy: "\u043F", Pcy: "\u041F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", pfr: "\uD835\uDD2D", Pfr: "\uD835\uDD13", phi: "\u03C6", Phi: "\u03A6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", pi: "\u03C0", Pi: "\u03A0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plus: "+", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", popf: "\uD835\uDD61", Popf: "\u2119", pound: "\xA3", pr: "\u227A", Pr: "\u2ABB", prap: "\u2AB7", prcue: "\u227C", pre: "\u2AAF", prE: "\u2AB3", prec: "\u227A", precapprox: "\u2AB7", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", precsim: "\u227E", prime: "\u2032", Prime: "\u2033", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportion: "\u2237", Proportional: "\u221D", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", pscr: "\uD835\uDCC5", Pscr: "\uD835\uDCAB", psi: "\u03C8", Psi: "\u03A8", puncsp: "\u2008", qfr: "\uD835\uDD2E", Qfr: "\uD835\uDD14", qint: "\u2A0C", qopf: "\uD835\uDD62", Qopf: "\u211A", qprime: "\u2057", qscr: "\uD835\uDCC6", Qscr: "\uD835\uDCAC", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', QUOT: '"', rAarr: "\u21DB", race: "\u223D\u0331", racute: "\u0155", Racute: "\u0154", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", Rang: "\u27EB", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarr: "\u2192", rArr: "\u21D2", Rarr: "\u21A0", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", rarrtl: "\u21A3", Rarrtl: "\u2916", rarrw: "\u219D", ratail: "\u291A", rAtail: "\u291C", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rBarr: "\u290F", RBarr: "\u2910", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", rcaron: "\u0159", Rcaron: "\u0158", rcedil: "\u0157", Rcedil: "\u0156", rceil: "\u2309", rcub: "}", rcy: "\u0440", Rcy: "\u0420", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", Re: "\u211C", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", rect: "\u25AD", reg: "\xAE", REG: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", rfr: "\uD835\uDD2F", Rfr: "\u211C", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", rho: "\u03C1", Rho: "\u03A1", rhov: "\u03F1", RightAngleBracket: "\u27E9", rightarrow: "\u2192", Rightarrow: "\u21D2", RightArrow: "\u2192", RightArrowBar: "\u21E5", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVector: "\u21C2", RightDownVectorBar: "\u2955", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTee: "\u22A2", RightTeeArrow: "\u21A6", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangle: "\u22B3", RightTriangleBar: "\u29D0", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVector: "\u21BE", RightUpVectorBar: "\u2954", RightVector: "\u21C0", RightVectorBar: "\u2953", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoust: "\u23B1", rmoustache: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\uD835\uDD63", Ropf: "\u211D", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", rscr: "\uD835\uDCC7", Rscr: "\u211B", rsh: "\u21B1", Rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", sacute: "\u015B", Sacute: "\u015A", sbquo: "\u201A", sc: "\u227B", Sc: "\u2ABC", scap: "\u2AB8", scaron: "\u0161", Scaron: "\u0160", sccue: "\u227D", sce: "\u2AB0", scE: "\u2AB4", scedil: "\u015F", Scedil: "\u015E", scirc: "\u015D", Scirc: "\u015C", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", scy: "\u0441", Scy: "\u0421", sdot: "\u22C5", sdotb: "\u22A1", sdote: "\u2A66", searhk: "\u2925", searr: "\u2198", seArr: "\u21D8", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", sfr: "\uD835\uDD30", Sfr: "\uD835\uDD16", sfrown: "\u2322", sharp: "\u266F", shchcy: "\u0449", SHCHcy: "\u0429", shcy: "\u0448", SHcy: "\u0428", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", sigma: "\u03C3", Sigma: "\u03A3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", softcy: "\u044C", SOFTcy: "\u042C", sol: "/", solb: "\u29C4", solbar: "\u233F", sopf: "\uD835\uDD64", Sopf: "\uD835\uDD4A", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", squ: "\u25A1", square: "\u25A1", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squf: "\u25AA", srarr: "\u2192", sscr: "\uD835\uDCC8", Sscr: "\uD835\uDCAE", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", star: "\u2606", Star: "\u22C6", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", Sub: "\u22D0", subdot: "\u2ABD", sube: "\u2286", subE: "\u2AC5", subedot: "\u2AC3", submult: "\u2AC1", subne: "\u228A", subnE: "\u2ACB", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", Subset: "\u22D0", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succ: "\u227B", succapprox: "\u2AB8", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", sum: "\u2211", Sum: "\u2211", sung: "\u266A", sup: "\u2283", Sup: "\u22D1", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", supdot: "\u2ABE", supdsub: "\u2AD8", supe: "\u2287", supE: "\u2AC6", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supne: "\u228B", supnE: "\u2ACC", supplus: "\u2AC0", supset: "\u2283", Supset: "\u22D1", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swarr: "\u2199", swArr: "\u21D9", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "\t", target: "\u2316", tau: "\u03C4", Tau: "\u03A4", tbrk: "\u23B4", tcaron: "\u0165", Tcaron: "\u0164", tcedil: "\u0163", Tcedil: "\u0162", tcy: "\u0442", Tcy: "\u0422", tdot: "\u20DB", telrec: "\u2315", tfr: "\uD835\uDD31", Tfr: "\uD835\uDD17", there4: "\u2234", therefore: "\u2234", Therefore: "\u2234", theta: "\u03B8", Theta: "\u0398", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", thinsp: "\u2009", ThinSpace: "\u2009", thkap: "\u2248", thksim: "\u223C", thorn: "\xFE", THORN: "\xDE", tilde: "\u02DC", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", times: "\xD7", timesb: "\u22A0", timesbar: "\u2A31", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", top: "\u22A4", topbot: "\u2336", topcir: "\u2AF1", topf: "\uD835\uDD65", Topf: "\uD835\uDD4B", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", TRADE: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", tscr: "\uD835\uDCC9", Tscr: "\uD835\uDCAF", tscy: "\u0446", TScy: "\u0426", tshcy: "\u045B", TSHcy: "\u040B", tstrok: "\u0167", Tstrok: "\u0166", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", uacute: "\xFA", Uacute: "\xDA", uarr: "\u2191", uArr: "\u21D1", Uarr: "\u219F", Uarrocir: "\u2949", ubrcy: "\u045E", Ubrcy: "\u040E", ubreve: "\u016D", Ubreve: "\u016C", ucirc: "\xFB", Ucirc: "\xDB", ucy: "\u0443", Ucy: "\u0423", udarr: "\u21C5", udblac: "\u0171", Udblac: "\u0170", udhar: "\u296E", ufisht: "\u297E", ufr: "\uD835\uDD32", Ufr: "\uD835\uDD18", ugrave: "\xF9", Ugrave: "\xD9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", umacr: "\u016B", Umacr: "\u016A", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", uogon: "\u0173", Uogon: "\u0172", uopf: "\uD835\uDD66", Uopf: "\uD835\uDD4C", uparrow: "\u2191", Uparrow: "\u21D1", UpArrow: "\u2191", UpArrowBar: "\u2912", UpArrowDownArrow: "\u21C5", updownarrow: "\u2195", Updownarrow: "\u21D5", UpDownArrow: "\u2195", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", upsi: "\u03C5", Upsi: "\u03D2", upsih: "\u03D2", upsilon: "\u03C5", Upsilon: "\u03A5", UpTee: "\u22A5", UpTeeArrow: "\u21A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", uring: "\u016F", Uring: "\u016E", urtri: "\u25F9", uscr: "\uD835\uDCCA", Uscr: "\uD835\uDCB0", utdot: "\u22F0", utilde: "\u0169", Utilde: "\u0168", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", uuml: "\xFC", Uuml: "\xDC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", vArr: "\u21D5", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vBar: "\u2AE8", Vbar: "\u2AEB", vBarv: "\u2AE9", vcy: "\u0432", Vcy: "\u0412", vdash: "\u22A2", vDash: "\u22A8", Vdash: "\u22A9", VDash: "\u22AB", Vdashl: "\u2AE6", vee: "\u2228", Vee: "\u22C1", veebar: "\u22BB", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", Verbar: "\u2016", vert: "|", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", vfr: "\uD835\uDD33", Vfr: "\uD835\uDD19", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", vopf: "\uD835\uDD67", Vopf: "\uD835\uDD4D", vprop: "\u221D", vrtri: "\u22B3", vscr: "\uD835\uDCCB", Vscr: "\uD835\uDCB1", vsubne: "\u228A\uFE00", vsubnE: "\u2ACB\uFE00", vsupne: "\u228B\uFE00", vsupnE: "\u2ACC\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", wcirc: "\u0175", Wcirc: "\u0174", wedbar: "\u2A5F", wedge: "\u2227", Wedge: "\u22C0", wedgeq: "\u2259", weierp: "\u2118", wfr: "\uD835\uDD34", Wfr: "\uD835\uDD1A", wopf: "\uD835\uDD68", Wopf: "\uD835\uDD4E", wp: "\u2118", wr: "\u2240", wreath: "\u2240", wscr: "\uD835\uDCCC", Wscr: "\uD835\uDCB2", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", xfr: "\uD835\uDD35", Xfr: "\uD835\uDD1B", xharr: "\u27F7", xhArr: "\u27FA", xi: "\u03BE", Xi: "\u039E", xlarr: "\u27F5", xlArr: "\u27F8", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", xopf: "\uD835\uDD69", Xopf: "\uD835\uDD4F", xoplus: "\u2A01", xotime: "\u2A02", xrarr: "\u27F6", xrArr: "\u27F9", xscr: "\uD835\uDCCD", Xscr: "\uD835\uDCB3", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", yacute: "\xFD", Yacute: "\xDD", yacy: "\u044F", YAcy: "\u042F", ycirc: "\u0177", Ycirc: "\u0176", ycy: "\u044B", Ycy: "\u042B", yen: "\xA5", yfr: "\uD835\uDD36", Yfr: "\uD835\uDD1C", yicy: "\u0457", YIcy: "\u0407", yopf: "\uD835\uDD6A", Yopf: "\uD835\uDD50", yscr: "\uD835\uDCCE", Yscr: "\uD835\uDCB4", yucy: "\u044E", YUcy: "\u042E", yuml: "\xFF", Yuml: "\u0178", zacute: "\u017A", Zacute: "\u0179", zcaron: "\u017E", Zcaron: "\u017D", zcy: "\u0437", Zcy: "\u0417", zdot: "\u017C", Zdot: "\u017B", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", zeta: "\u03B6", Zeta: "\u0396", zfr: "\uD835\uDD37", Zfr: "\u2128", zhcy: "\u0436", ZHcy: "\u0416", zigrarr: "\u21DD", zopf: "\uD835\uDD6B", Zopf: "\u2124", zscr: "\uD835\uDCCF", Zscr: "\uD835\uDCB5", zwj: "\u200D", zwnj: "\u200C" };
    var decodeMapLegacy = { aacute: "\xE1", Aacute: "\xC1", acirc: "\xE2", Acirc: "\xC2", acute: "\xB4", aelig: "\xE6", AElig: "\xC6", agrave: "\xE0", Agrave: "\xC0", amp: "&", AMP: "&", aring: "\xE5", Aring: "\xC5", atilde: "\xE3", Atilde: "\xC3", auml: "\xE4", Auml: "\xC4", brvbar: "\xA6", ccedil: "\xE7", Ccedil: "\xC7", cedil: "\xB8", cent: "\xA2", copy: "\xA9", COPY: "\xA9", curren: "\xA4", deg: "\xB0", divide: "\xF7", eacute: "\xE9", Eacute: "\xC9", ecirc: "\xEA", Ecirc: "\xCA", egrave: "\xE8", Egrave: "\xC8", eth: "\xF0", ETH: "\xD0", euml: "\xEB", Euml: "\xCB", frac12: "\xBD", frac14: "\xBC", frac34: "\xBE", gt: ">", GT: ">", iacute: "\xED", Iacute: "\xCD", icirc: "\xEE", Icirc: "\xCE", iexcl: "\xA1", igrave: "\xEC", Igrave: "\xCC", iquest: "\xBF", iuml: "\xEF", Iuml: "\xCF", laquo: "\xAB", lt: "<", LT: "<", macr: "\xAF", micro: "\xB5", middot: "\xB7", nbsp: "\xA0", not: "\xAC", ntilde: "\xF1", Ntilde: "\xD1", oacute: "\xF3", Oacute: "\xD3", ocirc: "\xF4", Ocirc: "\xD4", ograve: "\xF2", Ograve: "\xD2", ordf: "\xAA", ordm: "\xBA", oslash: "\xF8", Oslash: "\xD8", otilde: "\xF5", Otilde: "\xD5", ouml: "\xF6", Ouml: "\xD6", para: "\xB6", plusmn: "\xB1", pound: "\xA3", quot: '"', QUOT: '"', raquo: "\xBB", reg: "\xAE", REG: "\xAE", sect: "\xA7", shy: "\xAD", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", szlig: "\xDF", thorn: "\xFE", THORN: "\xDE", times: "\xD7", uacute: "\xFA", Uacute: "\xDA", ucirc: "\xFB", Ucirc: "\xDB", ugrave: "\xF9", Ugrave: "\xD9", uml: "\xA8", uuml: "\xFC", Uuml: "\xDC", yacute: "\xFD", Yacute: "\xDD", yen: "\xA5", yuml: "\xFF" };
    var decodeMapNumeric = { "0": "\uFFFD", "128": "\u20AC", "130": "\u201A", "131": "\u0192", "132": "\u201E", "133": "\u2026", "134": "\u2020", "135": "\u2021", "136": "\u02C6", "137": "\u2030", "138": "\u0160", "139": "\u2039", "140": "\u0152", "142": "\u017D", "145": "\u2018", "146": "\u2019", "147": "\u201C", "148": "\u201D", "149": "\u2022", "150": "\u2013", "151": "\u2014", "152": "\u02DC", "153": "\u2122", "154": "\u0161", "155": "\u203A", "156": "\u0153", "158": "\u017E", "159": "\u0178" };
    var invalidReferenceCodePoints = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65000, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111];
    var stringFromCharCode = String.fromCharCode;
    var object = {};
    var hasOwnProperty = object.hasOwnProperty;
    var has = function(object2, propertyName) {
      return hasOwnProperty.call(object2, propertyName);
    };
    var contains = function(array, value) {
      var index = -1;
      var length = array.length;
      while (++index < length) {
        if (array[index] == value) {
          return true;
        }
      }
      return false;
    };
    var merge = function(options, defaults2) {
      if (!options) {
        return defaults2;
      }
      var result = {};
      var key2;
      for (key2 in defaults2) {
        result[key2] = has(options, key2) ? options[key2] : defaults2[key2];
      }
      return result;
    };
    var codePointToSymbol = function(codePoint, strict) {
      var output = "";
      if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        if (strict) {
          parseError("character reference outside the permissible Unicode range");
        }
        return "\uFFFD";
      }
      if (has(decodeMapNumeric, codePoint)) {
        if (strict) {
          parseError("disallowed character reference");
        }
        return decodeMapNumeric[codePoint];
      }
      if (strict && contains(invalidReferenceCodePoints, codePoint)) {
        parseError("disallowed character reference");
      }
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += stringFromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += stringFromCharCode(codePoint);
      return output;
    };
    var hexEscape = function(codePoint) {
      return "&#x" + codePoint.toString(16).toUpperCase() + ";";
    };
    var decEscape = function(codePoint) {
      return "&#" + codePoint + ";";
    };
    var parseError = function(message) {
      throw Error("Parse error: " + message);
    };
    var encode = function(string, options) {
      options = merge(options, encode.options);
      var strict = options.strict;
      if (strict && regexInvalidRawCodePoint.test(string)) {
        parseError("forbidden code point");
      }
      var encodeEverything = options.encodeEverything;
      var useNamedReferences = options.useNamedReferences;
      var allowUnsafeSymbols = options.allowUnsafeSymbols;
      var escapeCodePoint = options.decimal ? decEscape : hexEscape;
      var escapeBmpSymbol = function(symbol) {
        return escapeCodePoint(symbol.charCodeAt(0));
      };
      if (encodeEverything) {
        string = string.replace(regexAsciiWhitelist, function(symbol) {
          if (useNamedReferences && has(encodeMap, symbol)) {
            return "&" + encodeMap[symbol] + ";";
          }
          return escapeBmpSymbol(symbol);
        });
        if (useNamedReferences) {
          string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;").replace(/&#x66;&#x6A;/g, "&fjlig;");
        }
        if (useNamedReferences) {
          string = string.replace(regexEncodeNonAscii, function(string2) {
            return "&" + encodeMap[string2] + ";";
          });
        }
      } else if (useNamedReferences) {
        if (!allowUnsafeSymbols) {
          string = string.replace(regexEscape, function(string2) {
            return "&" + encodeMap[string2] + ";";
          });
        }
        string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;");
        string = string.replace(regexEncodeNonAscii, function(string2) {
          return "&" + encodeMap[string2] + ";";
        });
      } else if (!allowUnsafeSymbols) {
        string = string.replace(regexEscape, escapeBmpSymbol);
      }
      return string.replace(regexAstralSymbols, function($0) {
        var high = $0.charCodeAt(0);
        var low = $0.charCodeAt(1);
        var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
        return escapeCodePoint(codePoint);
      }).replace(regexBmpWhitelist, escapeBmpSymbol);
    };
    encode.options = {
      allowUnsafeSymbols: false,
      encodeEverything: false,
      strict: false,
      useNamedReferences: false,
      decimal: false
    };
    var decode = function(html, options) {
      options = merge(options, decode.options);
      var strict = options.strict;
      if (strict && regexInvalidEntity.test(html)) {
        parseError("malformed character reference");
      }
      return html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7, $8) {
        var codePoint;
        var semicolon;
        var decDigits;
        var hexDigits;
        var reference;
        var next;
        if ($1) {
          reference = $1;
          return decodeMap[reference];
        }
        if ($2) {
          reference = $2;
          next = $3;
          if (next && options.isAttributeValue) {
            if (strict && next == "=") {
              parseError("`&` did not start a character reference");
            }
            return $0;
          } else {
            if (strict) {
              parseError("named character reference was not terminated by a semicolon");
            }
            return decodeMapLegacy[reference] + (next || "");
          }
        }
        if ($4) {
          decDigits = $4;
          semicolon = $5;
          if (strict && !semicolon) {
            parseError("character reference was not terminated by a semicolon");
          }
          codePoint = parseInt(decDigits, 10);
          return codePointToSymbol(codePoint, strict);
        }
        if ($6) {
          hexDigits = $6;
          semicolon = $7;
          if (strict && !semicolon) {
            parseError("character reference was not terminated by a semicolon");
          }
          codePoint = parseInt(hexDigits, 16);
          return codePointToSymbol(codePoint, strict);
        }
        if (strict) {
          parseError("named character reference was not terminated by a semicolon");
        }
        return $0;
      });
    };
    decode.options = {
      isAttributeValue: false,
      strict: false
    };
    var escape = function(string) {
      return string.replace(regexEscape, function($0) {
        return escapeMap[$0];
      });
    };
    var he = {
      version: "1.2.0",
      encode,
      decode,
      escape,
      unescape: decode
    };
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
      define(function() {
        return he;
      });
    } else if (freeExports && !freeExports.nodeType) {
      if (freeModule) {
        freeModule.exports = he;
      } else {
        for (var key in he) {
          has(he, key) && (freeExports[key] = he[key]);
        }
      }
    } else {
      root.he = he;
    }
  })(exports);
});

// node_modules/html-minifier/src/utils.js
var require_utils = __commonJS((exports) => {
  var createMap = function(values, ignoreCase) {
    var map = {};
    values.forEach(function(value) {
      map[value] = 1;
    });
    return ignoreCase ? function(value) {
      return map[value.toLowerCase()] === 1;
    } : function(value) {
      return map[value] === 1;
    };
  };
  exports.createMap = createMap;
  exports.createMapFromString = function(values, ignoreCase) {
    return createMap(values.split(/,/), ignoreCase);
  };
});

// node_modules/html-minifier/src/htmlparser.js
var require_htmlparser = __commonJS((exports) => {
  var makeMap = function(values) {
    return createMapFromString(values, true);
  };
  var attrForHandler = function(handler) {
    var pattern = singleAttrIdentifier.source + "(?:\\s*(" + joinSingleAttrAssigns(handler) + ")[ \\t\\n\\f\\r]*(?:" + singleAttrValues.join("|") + "))?";
    if (handler.customAttrSurround) {
      var attrClauses = [];
      for (var i = handler.customAttrSurround.length - 1;i >= 0; i--) {
        attrClauses[i] = "(?:(" + handler.customAttrSurround[i][0].source + ")\\s*" + pattern + "\\s*(" + handler.customAttrSurround[i][1].source + "))";
      }
      attrClauses.push("(?:" + pattern + ")");
      pattern = "(?:" + attrClauses.join("|") + ")";
    }
    return new RegExp("^\\s*" + pattern);
  };
  var joinSingleAttrAssigns = function(handler) {
    return singleAttrAssigns.concat(handler.customAttrAssign || []).map(function(assign) {
      return "(?:" + assign.source + ")";
    }).join("|");
  };
  var HTMLParser = function(html, handler) {
    var stack = [], lastTag;
    var attribute = attrForHandler(handler);
    var last, prevTag, nextTag;
    while (html) {
      last = html;
      if (!lastTag || !special(lastTag)) {
        var textEnd = html.indexOf("<");
        if (textEnd === 0) {
          if (/^<!--/.test(html)) {
            var commentEnd = html.indexOf("-->");
            if (commentEnd >= 0) {
              if (handler.comment) {
                handler.comment(html.substring(4, commentEnd));
              }
              html = html.substring(commentEnd + 3);
              prevTag = "";
              continue;
            }
          }
          if (/^<!\[/.test(html)) {
            var conditionalEnd = html.indexOf("]>");
            if (conditionalEnd >= 0) {
              if (handler.comment) {
                handler.comment(html.substring(2, conditionalEnd + 1), true);
              }
              html = html.substring(conditionalEnd + 2);
              prevTag = "";
              continue;
            }
          }
          var doctypeMatch = html.match(doctype);
          if (doctypeMatch) {
            if (handler.doctype) {
              handler.doctype(doctypeMatch[0]);
            }
            html = html.substring(doctypeMatch[0].length);
            prevTag = "";
            continue;
          }
          var endTagMatch = html.match(endTag);
          if (endTagMatch) {
            html = html.substring(endTagMatch[0].length);
            endTagMatch[0].replace(endTag, parseEndTag);
            prevTag = "/" + endTagMatch[1].toLowerCase();
            continue;
          }
          var startTagMatch = parseStartTag(html);
          if (startTagMatch) {
            html = startTagMatch.rest;
            handleStartTag(startTagMatch);
            prevTag = startTagMatch.tagName.toLowerCase();
            continue;
          }
          if (handler.continueOnParseError) {
            textEnd = html.indexOf("<", 1);
          }
        }
        var text;
        if (textEnd >= 0) {
          text = html.substring(0, textEnd);
          html = html.substring(textEnd);
        } else {
          text = html;
          html = "";
        }
        var nextTagMatch = parseStartTag(html);
        if (nextTagMatch) {
          nextTag = nextTagMatch.tagName;
        } else {
          nextTagMatch = html.match(endTag);
          if (nextTagMatch) {
            nextTag = "/" + nextTagMatch[1];
          } else {
            nextTag = "";
          }
        }
        if (handler.chars) {
          handler.chars(text, prevTag, nextTag);
        }
        prevTag = "";
      } else {
        var stackedTag = lastTag.toLowerCase();
        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp("([\\s\\S]*?)</" + stackedTag + "[^>]*>", "i"));
        html = html.replace(reStackedTag, function(all2, text2) {
          if (stackedTag !== "script" && stackedTag !== "style" && stackedTag !== "noscript") {
            text2 = text2.replace(/<!--([\s\S]*?)-->/g, "$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g, "$1");
          }
          if (handler.chars) {
            handler.chars(text2);
          }
          return "";
        });
        parseEndTag("</" + stackedTag + ">", stackedTag);
      }
      if (html === last) {
        throw new Error("Parse Error: " + html);
      }
    }
    if (!handler.partialMarkup) {
      parseEndTag();
    }
    function parseStartTag(input) {
      var start = input.match(startTagOpen);
      if (start) {
        var match = {
          tagName: start[1],
          attrs: []
        };
        input = input.slice(start[0].length);
        var end, attr;
        while (!(end = input.match(startTagClose)) && (attr = input.match(attribute))) {
          input = input.slice(attr[0].length);
          match.attrs.push(attr);
        }
        if (end) {
          match.unarySlash = end[1];
          match.rest = input.slice(end[0].length);
          return match;
        }
      }
    }
    function closeIfFound(tagName) {
      if (findTag(tagName) >= 0) {
        parseEndTag("", tagName);
        return true;
      }
    }
    function handleStartTag(match) {
      var tagName = match.tagName;
      var unarySlash = match.unarySlash;
      if (handler.html5) {
        if (lastTag === "p" && nonPhrasing(tagName)) {
          parseEndTag("", lastTag);
        } else if (tagName === "tbody") {
          closeIfFound("thead");
        } else if (tagName === "tfoot") {
          if (!closeIfFound("tbody")) {
            closeIfFound("thead");
          }
        }
        if (tagName === "col" && findTag("colgroup") < 0) {
          lastTag = "colgroup";
          stack.push({ tag: lastTag, attrs: [] });
          if (handler.start) {
            handler.start(lastTag, [], false, "");
          }
        }
      }
      if (!handler.html5 && !inline(tagName)) {
        while (lastTag && inline(lastTag)) {
          parseEndTag("", lastTag);
        }
      }
      if (closeSelf(tagName) && lastTag === tagName) {
        parseEndTag("", tagName);
      }
      var unary = empty(tagName) || tagName === "html" && lastTag === "head" || !!unarySlash;
      var attrs = match.attrs.map(function(args) {
        var name, value, customOpen, customClose, customAssign, quote;
        var ncp = 7;
        if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
          if (args[3] === "") {
            delete args[3];
          }
          if (args[4] === "") {
            delete args[4];
          }
          if (args[5] === "") {
            delete args[5];
          }
        }
        function populate(index) {
          customAssign = args[index];
          value = args[index + 1];
          if (typeof value !== "undefined") {
            return '"';
          }
          value = args[index + 2];
          if (typeof value !== "undefined") {
            return "\'";
          }
          value = args[index + 3];
          if (typeof value === "undefined" && fillAttrs(name)) {
            value = name;
          }
          return "";
        }
        var j = 1;
        if (handler.customAttrSurround) {
          for (var i = 0, l = handler.customAttrSurround.length;i < l; i++, j += ncp) {
            name = args[j + 1];
            if (name) {
              quote = populate(j + 2);
              customOpen = args[j];
              customClose = args[j + 6];
              break;
            }
          }
        }
        if (!name && (name = args[j])) {
          quote = populate(j + 1);
        }
        return {
          name,
          value,
          customAssign: customAssign || "=",
          customOpen: customOpen || "",
          customClose: customClose || "",
          quote: quote || ""
        };
      });
      if (!unary) {
        stack.push({ tag: tagName, attrs });
        lastTag = tagName;
        unarySlash = "";
      }
      if (handler.start) {
        handler.start(tagName, attrs, unary, unarySlash);
      }
    }
    function findTag(tagName) {
      var pos;
      var needle = tagName.toLowerCase();
      for (pos = stack.length - 1;pos >= 0; pos--) {
        if (stack[pos].tag.toLowerCase() === needle) {
          break;
        }
      }
      return pos;
    }
    function parseEndTag(tag, tagName) {
      var pos;
      if (tagName) {
        pos = findTag(tagName);
      } else {
        pos = 0;
      }
      if (pos >= 0) {
        for (var i = stack.length - 1;i >= pos; i--) {
          if (handler.end) {
            handler.end(stack[i].tag, stack[i].attrs, i > pos || !tag);
          }
        }
        stack.length = pos;
        lastTag = pos && stack[pos - 1].tag;
      } else if (tagName.toLowerCase() === "br") {
        if (handler.start) {
          handler.start(tagName, [], true, "");
        }
      } else if (tagName.toLowerCase() === "p") {
        if (handler.start) {
          handler.start(tagName, [], false, "", true);
        }
        if (handler.end) {
          handler.end(tagName, []);
        }
      }
    }
  };
  /*!
   * HTML Parser By John Resig (ejohn.org)
   * Modified by Juriy "kangax" Zaytsev
   * Original code by Erik Arvidsson, Mozilla Public License
   * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
   */
  var createMapFromString = require_utils().createMapFromString;
  var singleAttrIdentifier = /([^\s"'<>/=]+)/;
  var singleAttrAssigns = [/=/];
  var singleAttrValues = [
    /"([^"]*)"+/.source,
    /'([^']*)'+/.source,
    /([^ \t\n\f\r"'`=<>]+)/.source
  ];
  var qnameCapture = function() {
    var combiningChar = "\\u0300-\\u0345\\u0360\\u0361\\u0483-\\u0486\\u0591-\\u05A1\\u05A3-\\u05B9\\u05BB-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u064B-\\u0652\\u0670\\u06D6-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0901-\\u0903\\u093C\\u093E-\\u094D\\u0951-\\u0954\\u0962\\u0963\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u0A02\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A70\\u0A71\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B43\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B82\\u0B83\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0C01-\\u0C03\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C82\\u0C83\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D43\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86-\\u0F8B\\u0F90-\\u0F95\\u0F97\\u0F99-\\u0FAD\\u0FB1-\\u0FB7\\u0FB9\\u20D0-\\u20DC\\u20E1\\u302A-\\u302F\\u3099\\u309A";
    var digit = "0-9\\u0660-\\u0669\\u06F0-\\u06F9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE7-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29";
    var extender = "\\xB7\\u02D0\\u02D1\\u0387\\u0640\\u0E46\\u0EC6\\u3005\\u3031-\\u3035\\u309D\\u309E\\u30FC-\\u30FE";
    var letter = "A-Za-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u0131\\u0134-\\u013E\\u0141-\\u0148\\u014A-\\u017E\\u0180-\\u01C3\\u01CD-\\u01F0\\u01F4\\u01F5\\u01FA-\\u0217\\u0250-\\u02A8\\u02BB-\\u02C1\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03CE\\u03D0-\\u03D6\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2-\\u03F3\\u0401-\\u040C\\u040E-\\u044F\\u0451-\\u045C\\u045E-\\u0481\\u0490-\\u04C4\\u04C7\\u04C8\\u04CB\\u04CC\\u04D0-\\u04EB\\u04EE-\\u04F5\\u04F8\\u04F9\\u0531-\\u0556\\u0559\\u0561-\\u0586\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u063A\\u0641-\\u064A\\u0671-\\u06B7\\u06BA-\\u06BE\\u06C0-\\u06CE\\u06D0-\\u06D3\\u06D5\\u06E5\\u06E6\\u0905-\\u0939\\u093D\\u0958-\\u0961\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8B\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AE0\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B36-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB5\\u0BB7-\\u0BB9\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CDE\\u0CE0\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D60\\u0D61\\u0E01-\\u0E2E\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E45\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD\\u0EAE\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0F40-\\u0F47\\u0F49-\\u0F69\\u10A0-\\u10C5\\u10D0-\\u10F6\\u1100\\u1102\\u1103\\u1105-\\u1107\\u1109\\u110B\\u110C\\u110E-\\u1112\\u113C\\u113E\\u1140\\u114C\\u114E\\u1150\\u1154\\u1155\\u1159\\u115F-\\u1161\\u1163\\u1165\\u1167\\u1169\\u116D\\u116E\\u1172\\u1173\\u1175\\u119E\\u11A8\\u11AB\\u11AE\\u11AF\\u11B7\\u11B8\\u11BA\\u11BC-\\u11C2\\u11EB\\u11F0\\u11F9\\u1E00-\\u1E9B\\u1EA0-\\u1EF9\\u1F00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2126\\u212A\\u212B\\u212E\\u2180-\\u2182\\u3007\\u3021-\\u3029\\u3041-\\u3094\\u30A1-\\u30FA\\u3105-\\u312C\\u4E00-\\u9FA5\\uAC00-\\uD7A3";
    var ncname = "[" + letter + "_][" + letter + digit + "\\.\\-_" + combiningChar + extender + "]*";
    return "((?:" + ncname + "\\:)?" + ncname + ")";
  }();
  var startTagOpen = new RegExp("^<" + qnameCapture);
  var startTagClose = /^\s*(\/?)>/;
  var endTag = new RegExp("^<\\/" + qnameCapture + "[^>]*>");
  var doctype = /^<!DOCTYPE\s?[^>]+>/i;
  var IS_REGEX_CAPTURING_BROKEN = false;
  "x".replace(/x(.)?/g, function(m, g) {
    IS_REGEX_CAPTURING_BROKEN = g === "";
  });
  var empty = makeMap("area,base,basefont,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr");
  var inline = makeMap("a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,noscript,object,q,s,samp,script,select,small,span,strike,strong,sub,sup,svg,textarea,tt,u,var");
  var closeSelf = makeMap("colgroup,dd,dt,li,option,p,td,tfoot,th,thead,tr,source");
  var fillAttrs = makeMap("checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected");
  var special = makeMap("script,style");
  var nonPhrasing = makeMap("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,ol,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track,ul");
  var reCache = {};
  exports.HTMLParser = HTMLParser;
  exports.HTMLtoXML = function(html) {
    var results = "";
    new HTMLParser(html, {
      start: function(tag, attrs, unary) {
        results += "<" + tag;
        for (var i = 0, len = attrs.length;i < len; i++) {
          results += " " + attrs[i].name + '="' + (attrs[i].value || "").replace(/"/g, "&#34;") + '"';
        }
        results += (unary ? "/" : "") + ">";
      },
      end: function(tag) {
        results += "</" + tag + ">";
      },
      chars: function(text) {
        results += text;
      },
      comment: function(text) {
        results += "<!--" + text + "-->";
      },
      ignore: function(text) {
        results += text;
      }
    });
    return results;
  };
  exports.HTMLtoDOM = function(html, doc) {
    var one = {
      html: true,
      head: true,
      body: true,
      title: true
    };
    var structure = {
      link: "head",
      base: "head"
    };
    if (doc) {
      doc = doc.ownerDocument || doc.getOwnerDocument && doc.getOwnerDocument() || doc;
    } else if (typeof DOMDocument !== "undefined") {
      doc = new DOMDocument;
    } else if (typeof document !== "undefined" && document.implementation && document.implementation.createDocument) {
      doc = document.implementation.createDocument("", "", null);
    } else if (typeof ActiveX !== "undefined") {
      doc = new ActiveXObject("Msxml.DOMDocument");
    }
    var elems = [], documentElement = doc.documentElement || doc.getDocumentElement && doc.getDocumentElement();
    if (!documentElement && doc.createElement) {
      (function() {
        var html2 = doc.createElement("html");
        var head = doc.createElement("head");
        head.appendChild(doc.createElement("title"));
        html2.appendChild(head);
        html2.appendChild(doc.createElement("body"));
        doc.appendChild(html2);
      })();
    }
    if (doc.getElementsByTagName) {
      for (var i in one) {
        one[i] = doc.getElementsByTagName(i)[0];
      }
    }
    var curParentNode = one.body;
    new HTMLParser(html, {
      start: function(tagName, attrs, unary) {
        if (one[tagName]) {
          curParentNode = one[tagName];
          return;
        }
        var elem = doc.createElement(tagName);
        for (var attr in attrs) {
          elem.setAttribute(attrs[attr].name, attrs[attr].value);
        }
        if (structure[tagName] && typeof one[structure[tagName]] !== "boolean") {
          one[structure[tagName]].appendChild(elem);
        } else if (curParentNode && curParentNode.appendChild) {
          curParentNode.appendChild(elem);
        }
        if (!unary) {
          elems.push(elem);
          curParentNode = elem;
        }
      },
      end: function() {
        elems.length -= 1;
        curParentNode = elems[elems.length - 1];
      },
      chars: function(text) {
        curParentNode.appendChild(doc.createTextNode(text));
      },
      comment: function() {
      },
      ignore: function() {
      }
    });
    return doc;
  };
});

// node_modules/relateurl/lib/constants.js
var require_constants = __commonJS((exports, module) => {
  module.exports = {
    ABSOLUTE: "absolute",
    PATH_RELATIVE: "pathRelative",
    ROOT_RELATIVE: "rootRelative",
    SHORTEST: "shortest"
  };
});

// node_modules/relateurl/lib/format.js
var require_format2 = __commonJS((exports, module) => {
  var formatAuth = function(urlObj, options) {
    if (urlObj.auth && !options.removeAuth && (urlObj.extra.relation.maximumHost || options.output === constants.ABSOLUTE)) {
      return urlObj.auth + "@";
    }
    return "";
  };
  var formatHash = function(urlObj, options) {
    return urlObj.hash ? urlObj.hash : "";
  };
  var formatHost = function(urlObj, options) {
    if (urlObj.host.full && (urlObj.extra.relation.maximumAuth || options.output === constants.ABSOLUTE)) {
      return urlObj.host.full;
    }
    return "";
  };
  var formatPath = function(urlObj, options) {
    var str = "";
    var absolutePath = urlObj.path.absolute.string;
    var relativePath = urlObj.path.relative.string;
    var resource = showResource(urlObj, options);
    if (urlObj.extra.relation.maximumHost || options.output === constants.ABSOLUTE || options.output === constants.ROOT_RELATIVE) {
      str = absolutePath;
    } else if (relativePath.length <= absolutePath.length && options.output === constants.SHORTEST || options.output === constants.PATH_RELATIVE) {
      str = relativePath;
      if (str === "") {
        var query = showQuery(urlObj, options) && !!getQuery(urlObj, options);
        if (urlObj.extra.relation.maximumPath && !resource) {
          str = "./";
        } else if (urlObj.extra.relation.overridesQuery && !resource && !query) {
          str = "./";
        }
      }
    } else {
      str = absolutePath;
    }
    if (str === "/" && !resource && options.removeRootTrailingSlash && (!urlObj.extra.relation.minimumPort || options.output === constants.ABSOLUTE)) {
      str = "";
    }
    return str;
  };
  var formatPort = function(urlObj, options) {
    if (urlObj.port && !urlObj.extra.portIsDefault && urlObj.extra.relation.maximumHost) {
      return ":" + urlObj.port;
    }
    return "";
  };
  var formatQuery = function(urlObj, options) {
    return showQuery(urlObj, options) ? getQuery(urlObj, options) : "";
  };
  var formatResource = function(urlObj, options) {
    return showResource(urlObj, options) ? urlObj.resource : "";
  };
  var formatScheme = function(urlObj, options) {
    var str = "";
    if (urlObj.extra.relation.maximumHost || options.output === constants.ABSOLUTE) {
      if (!urlObj.extra.relation.minimumScheme || !options.schemeRelative || options.output === constants.ABSOLUTE) {
        str += urlObj.scheme + "://";
      } else {
        str += "//";
      }
    }
    return str;
  };
  var formatUrl = function(urlObj, options) {
    var url = "";
    url += formatScheme(urlObj, options);
    url += formatAuth(urlObj, options);
    url += formatHost(urlObj, options);
    url += formatPort(urlObj, options);
    url += formatPath(urlObj, options);
    url += formatResource(urlObj, options);
    url += formatQuery(urlObj, options);
    url += formatHash(urlObj, options);
    return url;
  };
  var getQuery = function(urlObj, options) {
    var stripQuery = options.removeEmptyQueries && urlObj.extra.relation.minimumPort;
    return urlObj.query.string[stripQuery ? "stripped" : "full"];
  };
  var showQuery = function(urlObj, options) {
    return !urlObj.extra.relation.minimumQuery || options.output === constants.ABSOLUTE || options.output === constants.ROOT_RELATIVE;
  };
  var showResource = function(urlObj, options) {
    var removeIndex = options.removeDirectoryIndexes && urlObj.extra.resourceIsIndex;
    var removeMatchingResource = urlObj.extra.relation.minimumResource && options.output !== constants.ABSOLUTE && options.output !== constants.ROOT_RELATIVE;
    return !!urlObj.resource && !removeMatchingResource && !removeIndex;
  };
  var constants = require_constants();
  module.exports = formatUrl;
});

// node_modules/relateurl/lib/util/object.js
var require_object = __commonJS((exports, module) => {
  var clone = function(obj) {
    if (obj instanceof Object) {
      var clonedObj = obj instanceof Array ? [] : {};
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          clonedObj[i] = clone(obj[i]);
        }
      }
      return clonedObj;
    }
    return obj;
  };
  var isPlainObject = function(obj) {
    return !!obj && typeof obj === "object" && obj.constructor === Object;
  };
  var shallowMerge = function(target, source) {
    if (target instanceof Object && source instanceof Object) {
      for (var i in source) {
        if (source.hasOwnProperty(i)) {
          target[i] = source[i];
        }
      }
    }
    return target;
  };
  module.exports = {
    clone,
    isPlainObject,
    shallowMerge
  };
});

// node_modules/relateurl/lib/options.js
var require_options = __commonJS((exports, module) => {
  var getOptions = function(options, defaults2) {
    if (objUtils.isPlainObject(options)) {
      var newOptions = {};
      for (var i in defaults2) {
        if (defaults2.hasOwnProperty(i)) {
          if (options[i] !== undefined) {
            newOptions[i] = mergeOption(options[i], defaults2[i]);
          } else {
            newOptions[i] = defaults2[i];
          }
        }
      }
      return newOptions;
    } else {
      return defaults2;
    }
  };
  var mergeOption = function(newValues, defaultValues) {
    if (defaultValues instanceof Object && newValues instanceof Object) {
      if (defaultValues instanceof Array && newValues instanceof Array) {
        return defaultValues.concat(newValues);
      } else {
        return objUtils.shallowMerge(newValues, defaultValues);
      }
    }
    return newValues;
  };
  var objUtils = require_object();
  module.exports = getOptions;
});

// node_modules/relateurl/lib/parse/hrefInfo.js
var require_hrefInfo = __commonJS((exports, module) => {
  var hrefInfo = function(urlObj) {
    var minimumPathOnly = !urlObj.scheme && !urlObj.auth && !urlObj.host.full && !urlObj.port;
    var minimumResourceOnly = minimumPathOnly && !urlObj.path.absolute.string;
    var minimumQueryOnly = minimumResourceOnly && !urlObj.resource;
    var minimumHashOnly = minimumQueryOnly && !urlObj.query.string.full.length;
    var empty = minimumHashOnly && !urlObj.hash;
    urlObj.extra.hrefInfo.minimumPathOnly = minimumPathOnly;
    urlObj.extra.hrefInfo.minimumResourceOnly = minimumResourceOnly;
    urlObj.extra.hrefInfo.minimumQueryOnly = minimumQueryOnly;
    urlObj.extra.hrefInfo.minimumHashOnly = minimumHashOnly;
    urlObj.extra.hrefInfo.empty = empty;
  };
  module.exports = hrefInfo;
});

// node_modules/relateurl/lib/parse/host.js
var require_host = __commonJS((exports, module) => {
  var parseHost = function(urlObj, options) {
    if (options.ignore_www) {
      var host = urlObj.host.full;
      if (host) {
        var stripped = host;
        if (host.indexOf("www.") === 0) {
          stripped = host.substr(4);
        }
        urlObj.host.stripped = stripped;
      }
    }
  };
  module.exports = parseHost;
});

// node_modules/relateurl/lib/parse/path.js
var require_path = __commonJS((exports, module) => {
  var isDirectoryIndex = function(resource, options) {
    var verdict = false;
    options.directoryIndexes.every(function(index) {
      if (index === resource) {
        verdict = true;
        return false;
      }
      return true;
    });
    return verdict;
  };
  var parsePath = function(urlObj, options) {
    var path = urlObj.path.absolute.string;
    if (path) {
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash > -1) {
        if (++lastSlash < path.length) {
          var resource = path.substr(lastSlash);
          if (resource !== "." && resource !== "..") {
            urlObj.resource = resource;
            path = path.substr(0, lastSlash);
          } else {
            path += "/";
          }
        }
        urlObj.path.absolute.string = path;
        urlObj.path.absolute.array = splitPath(path);
      } else if (path === "." || path === "..") {
        path += "/";
        urlObj.path.absolute.string = path;
        urlObj.path.absolute.array = splitPath(path);
      } else {
        urlObj.resource = path;
        urlObj.path.absolute.string = null;
      }
      urlObj.extra.resourceIsIndex = isDirectoryIndex(urlObj.resource, options);
    }
  };
  var splitPath = function(path) {
    if (path !== "/") {
      var cleaned = [];
      path.split("/").forEach(function(dir) {
        if (dir !== "") {
          cleaned.push(dir);
        }
      });
      return cleaned;
    } else {
      return [];
    }
  };
  module.exports = parsePath;
});

// node_modules/relateurl/lib/parse/port.js
var require_port = __commonJS((exports, module) => {
  var parsePort = function(urlObj, options) {
    var defaultPort = -1;
    for (var i in options.defaultPorts) {
      if (i === urlObj.scheme && options.defaultPorts.hasOwnProperty(i)) {
        defaultPort = options.defaultPorts[i];
        break;
      }
    }
    if (defaultPort > -1) {
      defaultPort = defaultPort.toString();
      if (urlObj.port === null) {
        urlObj.port = defaultPort;
      }
      urlObj.extra.portIsDefault = urlObj.port === defaultPort;
    }
  };
  module.exports = parsePort;
});

// node_modules/relateurl/lib/parse/query.js
var require_query = __commonJS((exports, module) => {
  var parseQuery = function(urlObj, options) {
    urlObj.query.string.full = stringify(urlObj.query.object, false);
    if (options.removeEmptyQueries) {
      urlObj.query.string.stripped = stringify(urlObj.query.object, true);
    }
  };
  var stringify = function(queryObj, removeEmptyQueries) {
    var count = 0;
    var str = "";
    for (var i in queryObj) {
      if (i !== "" && hasOwnProperty.call(queryObj, i) === true) {
        var value = queryObj[i];
        if (value !== "" || !removeEmptyQueries) {
          str += ++count === 1 ? "?" : "&";
          i = encodeURIComponent(i);
          if (value !== "") {
            str += i + "=" + encodeURIComponent(value).replace(/%20/g, "+");
          } else {
            str += i;
          }
        }
      }
    }
    return str;
  };
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  module.exports = parseQuery;
});

// node_modules/relateurl/lib/parse/urlstring.js
var require_urlstring = __commonJS((exports, module) => {
  var clean = function(urlObj) {
    var scheme = urlObj.protocol;
    if (scheme) {
      if (scheme.indexOf(":") === scheme.length - 1) {
        scheme = scheme.substr(0, scheme.length - 1);
      }
    }
    urlObj.host = {
      full: urlObj.hostname,
      stripped: null
    };
    urlObj.path = {
      absolute: {
        array: null,
        string: urlObj.pathname
      },
      relative: {
        array: null,
        string: null
      }
    };
    urlObj.query = {
      object: urlObj.query,
      string: {
        full: null,
        stripped: null
      }
    };
    urlObj.extra = {
      hrefInfo: {
        minimumPathOnly: null,
        minimumResourceOnly: null,
        minimumQueryOnly: null,
        minimumHashOnly: null,
        empty: null,
        separatorOnlyQuery: urlObj.search === "?"
      },
      portIsDefault: null,
      relation: {
        maximumScheme: null,
        maximumAuth: null,
        maximumHost: null,
        maximumPort: null,
        maximumPath: null,
        maximumResource: null,
        maximumQuery: null,
        maximumHash: null,
        minimumScheme: null,
        minimumAuth: null,
        minimumHost: null,
        minimumPort: null,
        minimumPath: null,
        minimumResource: null,
        minimumQuery: null,
        minimumHash: null,
        overridesQuery: null
      },
      resourceIsIndex: null,
      slashes: urlObj.slashes
    };
    urlObj.resource = null;
    urlObj.scheme = scheme;
    delete urlObj.hostname;
    delete urlObj.pathname;
    delete urlObj.protocol;
    delete urlObj.search;
    delete urlObj.slashes;
    return urlObj;
  };
  var validScheme = function(url, options) {
    var valid = true;
    options.rejectedSchemes.every(function(rejectedScheme) {
      valid = !(url.indexOf(rejectedScheme + ":") === 0);
      return valid;
    });
    return valid;
  };
  var parseUrlString = function(url, options) {
    if (validScheme(url, options)) {
      return clean(_parseUrl(url, true, options.slashesDenoteHost));
    } else {
      return { href: url, valid: false };
    }
  };
  var _parseUrl = import.meta.require("url").parse;
  module.exports = parseUrlString;
});

// node_modules/relateurl/lib/util/path.js
var require_path2 = __commonJS((exports, module) => {
  var joinPath = function(pathArray) {
    if (pathArray.length > 0) {
      return pathArray.join("/") + "/";
    } else {
      return "";
    }
  };
  var resolveDotSegments = function(pathArray) {
    var pathAbsolute = [];
    pathArray.forEach(function(dir) {
      if (dir !== "..") {
        if (dir !== ".") {
          pathAbsolute.push(dir);
        }
      } else {
        if (pathAbsolute.length > 0) {
          pathAbsolute.splice(pathAbsolute.length - 1, 1);
        }
      }
    });
    return pathAbsolute;
  };
  module.exports = {
    join: joinPath,
    resolveDotSegments
  };
});

// node_modules/relateurl/lib/parse/index.js
var require_parse = __commonJS((exports, module) => {
  var parseFromUrl = function(url, options, fallback) {
    if (url) {
      var urlObj = parseUrl(url, options);
      var pathArray = pathUtils.resolveDotSegments(urlObj.path.absolute.array);
      urlObj.path.absolute.array = pathArray;
      urlObj.path.absolute.string = "/" + pathUtils.join(pathArray);
      return urlObj;
    } else {
      return fallback;
    }
  };
  var parseUrl = function(url, options) {
    var urlObj = parseUrlString(url, options);
    if (urlObj.valid === false)
      return urlObj;
    parseHost(urlObj, options);
    parsePort(urlObj, options);
    parsePath(urlObj, options);
    parseQuery(urlObj, options);
    hrefInfo(urlObj);
    return urlObj;
  };
  var hrefInfo = require_hrefInfo();
  var parseHost = require_host();
  var parsePath = require_path();
  var parsePort = require_port();
  var parseQuery = require_query();
  var parseUrlString = require_urlstring();
  var pathUtils = require_path2();
  module.exports = {
    from: parseFromUrl,
    to: parseUrl
  };
});

// node_modules/relateurl/lib/relate/findRelation.js
var require_findRelation = __commonJS((exports, module) => {
  var findRelation_upToPath = function(urlObj, siteUrlObj, options) {
    var pathOnly = urlObj.extra.hrefInfo.minimumPathOnly;
    var minimumScheme = urlObj.scheme === siteUrlObj.scheme || !urlObj.scheme;
    var minimumAuth = minimumScheme && (urlObj.auth === siteUrlObj.auth || options.removeAuth || pathOnly);
    var www = options.ignore_www ? "stripped" : "full";
    var minimumHost = minimumAuth && (urlObj.host[www] === siteUrlObj.host[www] || pathOnly);
    var minimumPort = minimumHost && (urlObj.port === siteUrlObj.port || pathOnly);
    urlObj.extra.relation.minimumScheme = minimumScheme;
    urlObj.extra.relation.minimumAuth = minimumAuth;
    urlObj.extra.relation.minimumHost = minimumHost;
    urlObj.extra.relation.minimumPort = minimumPort;
    urlObj.extra.relation.maximumScheme = !minimumScheme || minimumScheme && !minimumAuth;
    urlObj.extra.relation.maximumAuth = !minimumScheme || minimumScheme && !minimumHost;
    urlObj.extra.relation.maximumHost = !minimumScheme || minimumScheme && !minimumPort;
  };
  var findRelation_pathOn = function(urlObj, siteUrlObj, options) {
    var queryOnly = urlObj.extra.hrefInfo.minimumQueryOnly;
    var hashOnly = urlObj.extra.hrefInfo.minimumHashOnly;
    var empty = urlObj.extra.hrefInfo.empty;
    var minimumPort = urlObj.extra.relation.minimumPort;
    var minimumScheme = urlObj.extra.relation.minimumScheme;
    var minimumPath = minimumPort && urlObj.path.absolute.string === siteUrlObj.path.absolute.string;
    var matchingResource = urlObj.resource === siteUrlObj.resource || !urlObj.resource && siteUrlObj.extra.resourceIsIndex || options.removeDirectoryIndexes && urlObj.extra.resourceIsIndex && !siteUrlObj.resource;
    var minimumResource = minimumPath && (matchingResource || queryOnly || hashOnly || empty);
    var query = options.removeEmptyQueries ? "stripped" : "full";
    var urlQuery = urlObj.query.string[query];
    var siteUrlQuery = siteUrlObj.query.string[query];
    var minimumQuery = minimumResource && !!urlQuery && urlQuery === siteUrlQuery || (hashOnly || empty) && !urlObj.extra.hrefInfo.separatorOnlyQuery;
    var minimumHash = minimumQuery && urlObj.hash === siteUrlObj.hash;
    urlObj.extra.relation.minimumPath = minimumPath;
    urlObj.extra.relation.minimumResource = minimumResource;
    urlObj.extra.relation.minimumQuery = minimumQuery;
    urlObj.extra.relation.minimumHash = minimumHash;
    urlObj.extra.relation.maximumPort = !minimumScheme || minimumScheme && !minimumPath;
    urlObj.extra.relation.maximumPath = !minimumScheme || minimumScheme && !minimumResource;
    urlObj.extra.relation.maximumResource = !minimumScheme || minimumScheme && !minimumQuery;
    urlObj.extra.relation.maximumQuery = !minimumScheme || minimumScheme && !minimumHash;
    urlObj.extra.relation.maximumHash = !minimumScheme || minimumScheme && !minimumHash;
    urlObj.extra.relation.overridesQuery = minimumPath && urlObj.extra.relation.maximumResource && !minimumQuery && !!siteUrlQuery;
  };
  module.exports = {
    pathOn: findRelation_pathOn,
    upToPath: findRelation_upToPath
  };
});

// node_modules/relateurl/lib/relate/absolutize.js
var require_absolutize = __commonJS((exports, module) => {
  var absolutize = function(urlObj, siteUrlObj, options) {
    findRelation.upToPath(urlObj, siteUrlObj, options);
    if (urlObj.extra.relation.minimumScheme)
      urlObj.scheme = siteUrlObj.scheme;
    if (urlObj.extra.relation.minimumAuth)
      urlObj.auth = siteUrlObj.auth;
    if (urlObj.extra.relation.minimumHost)
      urlObj.host = objUtils.clone(siteUrlObj.host);
    if (urlObj.extra.relation.minimumPort)
      copyPort(urlObj, siteUrlObj);
    if (urlObj.extra.relation.minimumScheme)
      copyPath(urlObj, siteUrlObj);
    findRelation.pathOn(urlObj, siteUrlObj, options);
    if (urlObj.extra.relation.minimumResource)
      copyResource(urlObj, siteUrlObj);
    if (urlObj.extra.relation.minimumQuery)
      urlObj.query = objUtils.clone(siteUrlObj.query);
    if (urlObj.extra.relation.minimumHash)
      urlObj.hash = siteUrlObj.hash;
  };
  var copyPath = function(urlObj, siteUrlObj) {
    if (urlObj.extra.relation.maximumHost || !urlObj.extra.hrefInfo.minimumResourceOnly) {
      var pathArray = urlObj.path.absolute.array;
      var pathString = "/";
      if (pathArray) {
        if (urlObj.extra.hrefInfo.minimumPathOnly && urlObj.path.absolute.string.indexOf("/") !== 0) {
          pathArray = siteUrlObj.path.absolute.array.concat(pathArray);
        }
        pathArray = pathUtils.resolveDotSegments(pathArray);
        pathString += pathUtils.join(pathArray);
      } else {
        pathArray = [];
      }
      urlObj.path.absolute.array = pathArray;
      urlObj.path.absolute.string = pathString;
    } else {
      urlObj.path = objUtils.clone(siteUrlObj.path);
    }
  };
  var copyPort = function(urlObj, siteUrlObj) {
    urlObj.port = siteUrlObj.port;
    urlObj.extra.portIsDefault = siteUrlObj.extra.portIsDefault;
  };
  var copyResource = function(urlObj, siteUrlObj) {
    urlObj.resource = siteUrlObj.resource;
    urlObj.extra.resourceIsIndex = siteUrlObj.extra.resourceIsIndex;
  };
  var findRelation = require_findRelation();
  var objUtils = require_object();
  var pathUtils = require_path2();
  module.exports = absolutize;
});

// node_modules/relateurl/lib/relate/relativize.js
var require_relativize = __commonJS((exports, module) => {
  var relatePath = function(absolutePath, siteAbsolutePath) {
    var relativePath = [];
    var related = true;
    var parentIndex = -1;
    siteAbsolutePath.forEach(function(siteAbsoluteDir, i) {
      if (related) {
        if (absolutePath[i] !== siteAbsoluteDir) {
          related = false;
        } else {
          parentIndex = i;
        }
      }
      if (!related) {
        relativePath.push("..");
      }
    });
    absolutePath.forEach(function(dir, i) {
      if (i > parentIndex) {
        relativePath.push(dir);
      }
    });
    return relativePath;
  };
  var relativize = function(urlObj, siteUrlObj, options) {
    if (urlObj.extra.relation.minimumScheme) {
      var pathArray = relatePath(urlObj.path.absolute.array, siteUrlObj.path.absolute.array);
      urlObj.path.relative.array = pathArray;
      urlObj.path.relative.string = pathUtils.join(pathArray);
    }
  };
  var pathUtils = require_path2();
  module.exports = relativize;
});

// node_modules/relateurl/lib/relate/index.js
var require_relate = __commonJS((exports, module) => {
  var relateUrl = function(siteUrlObj, urlObj, options) {
    absolutize(urlObj, siteUrlObj, options);
    relativize(urlObj, siteUrlObj, options);
    return urlObj;
  };
  var absolutize = require_absolutize();
  var relativize = require_relativize();
  module.exports = relateUrl;
});

// node_modules/relateurl/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var RelateUrl = function(from, options) {
    this.options = getOptions(options, {
      defaultPorts: { ftp: 21, http: 80, https: 443 },
      directoryIndexes: ["index.html"],
      ignore_www: false,
      output: RelateUrl.SHORTEST,
      rejectedSchemes: ["data", "javascript", "mailto"],
      removeAuth: false,
      removeDirectoryIndexes: true,
      removeEmptyQueries: false,
      removeRootTrailingSlash: true,
      schemeRelative: true,
      site: undefined,
      slashesDenoteHost: true
    });
    this.from = parseUrl.from(from, this.options, null);
  };
  var constants = require_constants();
  var formatUrl = require_format2();
  var getOptions = require_options();
  var objUtils = require_object();
  var parseUrl = require_parse();
  var relateUrl = require_relate();
  RelateUrl.prototype.relate = function(from, to, options) {
    if (objUtils.isPlainObject(to)) {
      options = to;
      to = from;
      from = null;
    } else if (!to) {
      to = from;
      from = null;
    }
    options = getOptions(options, this.options);
    from = from || options.site;
    from = parseUrl.from(from, options, this.from);
    if (!from || !from.href) {
      throw new Error("from value not defined.");
    } else if (from.extra.hrefInfo.minimumPathOnly) {
      throw new Error("from value supplied is not absolute: " + from.href);
    }
    to = parseUrl.to(to, options);
    if (to.valid === false)
      return to.href;
    to = relateUrl(from, to, options);
    to = formatUrl(to, options);
    return to;
  };
  RelateUrl.relate = function(from, to, options) {
    return new RelateUrl().relate(from, to, options);
  };
  objUtils.shallowMerge(RelateUrl, constants);
  module.exports = RelateUrl;
});

// node_modules/html-minifier/src/tokenchain.js
var require_tokenchain = __commonJS((exports, module) => {
  var Sorter = function() {
  };
  var TokenChain = function() {
  };
  Sorter.prototype.sort = function(tokens, fromIndex) {
    fromIndex = fromIndex || 0;
    for (var i = 0, len = this.keys.length;i < len; i++) {
      var key = this.keys[i];
      var token = key.slice(1);
      var index = tokens.indexOf(token, fromIndex);
      if (index !== -1) {
        do {
          if (index !== fromIndex) {
            tokens.splice(index, 1);
            tokens.splice(fromIndex, 0, token);
          }
          fromIndex++;
        } while ((index = tokens.indexOf(token, fromIndex)) !== -1);
        return this[key].sort(tokens, fromIndex);
      }
    }
    return tokens;
  };
  TokenChain.prototype = {
    add: function(tokens) {
      var self = this;
      tokens.forEach(function(token) {
        var key = "$" + token;
        if (!self[key]) {
          self[key] = [];
          self[key].processed = 0;
        }
        self[key].push(tokens);
      });
    },
    createSorter: function() {
      var self = this;
      var sorter = new Sorter;
      sorter.keys = Object.keys(self).sort(function(j, k) {
        var m = self[j].length;
        var n = self[k].length;
        return m < n ? 1 : m > n ? -1 : j < k ? -1 : j > k ? 1 : 0;
      }).filter(function(key) {
        if (self[key].processed < self[key].length) {
          var token = key.slice(1);
          var chain = new TokenChain;
          self[key].forEach(function(tokens) {
            var index;
            while ((index = tokens.indexOf(token)) !== -1) {
              tokens.splice(index, 1);
            }
            tokens.forEach(function(token2) {
              self["$" + token2].processed++;
            });
            chain.add(tokens.slice(0));
          });
          sorter[key] = chain.createSorter();
          return true;
        }
        return false;
      });
      return sorter;
    }
  };
  module.exports = TokenChain;
});

// node_modules/uglify-js/lib/utils.js
var exports_utils = {};
var configure_error_stack2, DefaultsError, Dictionary2, HOP2, List2;
var init_utils = __esm(() => {
  configure_error_stack2 = function(fn) {
    Object.defineProperty(fn.prototype, "stack", {
      get: function() {
        var err = new Error(this.message);
        err.name = this.name;
        try {
          throw err;
        } catch (e) {
          return e.stack;
        }
      }
    });
  };
  DefaultsError = function(msg, defs) {
    this.message = msg;
    this.defs = defs;
  };
  Dictionary2 = function() {
    this.values = Object.create(null);
  };
  HOP2 = function(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  };
  DefaultsError.prototype = Object.create(Error.prototype);
  DefaultsError.prototype.constructor = DefaultsError;
  DefaultsError.prototype.name = "DefaultsError";
  configure_error_stack2(DefaultsError);
  List2 = function() {
    function List3(a, f) {
      var ret = [];
      for (var i = 0;i < a.length; i++) {
        var val = f(a[i], i);
        if (val === skip)
          continue;
        if (val instanceof Splice) {
          ret.push.apply(ret, val.v);
        } else {
          ret.push(val);
        }
      }
      return ret;
    }
    List3.is_op = function(val) {
      return val === skip || val instanceof Splice;
    };
    List3.splice = function(val) {
      return new Splice(val);
    };
    var skip = List3.skip = {};
    function Splice(val) {
      this.v = val;
    }
    return List3;
  }();
  Dictionary2.prototype = {
    set: function(key, val) {
      if (key == "__proto__") {
        this.proto_value = val;
      } else {
        this.values[key] = val;
      }
      return this;
    },
    add: function(key, val) {
      var list = this.get(key);
      if (list) {
        list.push(val);
      } else {
        this.set(key, [val]);
      }
      return this;
    },
    get: function(key) {
      return key == "__proto__" ? this.proto_value : this.values[key];
    },
    del: function(key) {
      if (key == "__proto__") {
        delete this.proto_value;
      } else {
        delete this.values[key];
      }
      return this;
    },
    has: function(key) {
      return key == "__proto__" ? "proto_value" in this : (key in this.values);
    },
    all: function(predicate) {
      for (var i in this.values)
        if (!predicate(this.values[i], i))
          return false;
      if ("proto_value" in this && !predicate(this.proto_value, "__proto__"))
        return false;
      return true;
    },
    each: function(f) {
      for (var i in this.values)
        f(this.values[i], i);
      if ("proto_value" in this)
        f(this.proto_value, "__proto__");
    },
    size: function() {
      return Object.keys(this.values).length + ("proto_value" in this);
    },
    map: function(f) {
      var ret = [];
      for (var i in this.values)
        ret.push(f(this.values[i], i));
      if ("proto_value" in this)
        ret.push(f(this.proto_value, "__proto__"));
      return ret;
    },
    clone: function() {
      var ret = new Dictionary2;
      this.each(function(value, i) {
        ret.set(i, value);
      });
      return ret;
    },
    toObject: function() {
      var obj = {};
      this.each(function(value, i) {
        obj["$" + i] = value;
      });
      return obj;
    }
  };
  Dictionary2.fromObject = function(obj) {
    var dict = new Dictionary2;
    for (var i in obj)
      if (HOP2(obj, i))
        dict.set(i.slice(1), obj[i]);
    return dict;
  };
});

// node_modules/uglify-js/lib/ast.js
var require_ast = __commonJS((exports) => {
  var DEFNODE = function(type, props, methods, base) {
    if (typeof base === "undefined")
      base = AST_Node2;
    props = props ? props.split(/\s+/) : [];
    var self_props = props;
    if (base && base.PROPS)
      props = props.concat(base.PROPS);
    var code = [
      "return function AST_",
      type,
      "(props){",
      "this._bits=0;",
      "if(props){"
    ];
    props.forEach(function(prop) {
      code.push("this.", prop, "=props.", prop, ";");
    });
    code.push("}");
    var proto = Object.create(base && base.prototype);
    if (methods.initialize || proto.initialize)
      code.push("this.initialize();");
    code.push("};");
    var ctor = new Function(code.join(""))();
    ctor.prototype = proto;
    ctor.prototype.CTOR = ctor;
    ctor.prototype.TYPE = ctor.TYPE = type;
    if (base) {
      ctor.BASE = base;
      base.SUBCLASSES.push(ctor);
    }
    ctor.DEFMETHOD = function(name2, method) {
      this.prototype[name2] = method;
    };
    ctor.PROPS = props;
    ctor.SELF_PROPS = self_props;
    ctor.SUBCLASSES = [];
    for (var name in methods)
      if (HOP(methods, name)) {
        if (/^\$/.test(name)) {
          ctor[name.substr(1)] = methods[name];
        } else {
          ctor.DEFMETHOD(name, methods[name]);
        }
      }
    if (typeof exports !== "undefined")
      exports["AST_" + type] = ctor;
    return ctor;
  };
  var all_equals = function(k, l) {
    return k.length == l.length && all(k, function(m, i) {
      return m.equals(l[i]);
    });
  };
  var list_equals = function(s, t) {
    return s.length == t.length && all(s, function(u, i) {
      return u == t[i];
    });
  };
  var prop_equals = function(u, v) {
    if (u === v)
      return true;
    if (u == null)
      return v == null;
    return u instanceof AST_Node2 && v instanceof AST_Node2 && u.equals(v);
  };
  var is_statement2 = function(node) {
    return node instanceof AST_Statement2 && !(node instanceof AST_ClassExpression2) && !(node instanceof AST_LambdaExpression2);
  };
  var validate_expression = function(value, prop, multiple, allow_spread, allow_hole) {
    multiple = multiple ? "contain" : "be";
    if (!(value instanceof AST_Node2))
      throw new Error(prop + " must " + multiple + " AST_Node");
    if (value instanceof AST_DefaultValue2)
      throw new Error(prop + " cannot " + multiple + " AST_DefaultValue");
    if (value instanceof AST_Destructured2)
      throw new Error(prop + " cannot " + multiple + " AST_Destructured");
    if (value instanceof AST_Hole2 && !allow_hole)
      throw new Error(prop + " cannot " + multiple + " AST_Hole");
    if (value instanceof AST_Spread2 && !allow_spread)
      throw new Error(prop + " cannot " + multiple + " AST_Spread");
    if (is_statement2(value))
      throw new Error(prop + " cannot " + multiple + " AST_Statement");
    if (value instanceof AST_SymbolDeclaration2) {
      throw new Error(prop + " cannot " + multiple + " AST_SymbolDeclaration");
    }
  };
  var must_be_expression = function(node, prop) {
    validate_expression(node[prop], prop);
  };
  var walk_body2 = function(node, visitor) {
    node.body.forEach(function(node2) {
      node2.walk(visitor);
    });
  };
  var is_arrow2 = function(node) {
    return node instanceof AST_Arrow2 || node instanceof AST_AsyncArrow2;
  };
  var must_be_expressions = function(node, prop, allow_spread, allow_hole) {
    node[prop].forEach(function(node2) {
      validate_expression(node2, prop, true, allow_spread, allow_hole);
    });
  };
  var validate_destructured = function(node, check, allow_default) {
    if (node instanceof AST_DefaultValue2 && allow_default)
      return validate_destructured(node.name, check);
    if (node instanceof AST_Destructured2) {
      if (node.rest != null)
        validate_destructured(node.rest, check);
      if (node instanceof AST_DestructuredArray2)
        return node.elements.forEach(function(node2) {
          if (!(node2 instanceof AST_Hole2))
            validate_destructured(node2, check, true);
        });
      if (node instanceof AST_DestructuredObject2)
        return node.properties.forEach(function(prop) {
          validate_destructured(prop.value, check, true);
        });
    }
    check(node);
  };
  var TreeWalker2 = function(callback) {
    this.callback = callback;
    this.directives = Object.create(null);
    this.stack = [];
  };
  var AST_Token2 = DEFNODE("Token", "type value line col pos endline endcol endpos nlb comments_before comments_after file raw", {}, null);
  var AST_Node2 = DEFNODE("Node", "start end", {
    _clone: function(deep) {
      if (deep) {
        var self = this.clone();
        return self.transform(new TreeTransformer(function(node) {
          if (node !== self) {
            return node.clone(true);
          }
        }));
      }
      return new this.CTOR(this);
    },
    clone: function(deep) {
      return this._clone(deep);
    },
    $documentation: "Base class of all AST nodes",
    $propdoc: {
      start: "[AST_Token] The first token of this node",
      end: "[AST_Token] The last token of this node"
    },
    equals: function(node) {
      return this.TYPE == node.TYPE && this._equals(node);
    },
    walk: function(visitor) {
      visitor.visit(this);
    },
    _validate: function() {
      if (this.TYPE == "Node")
        throw new Error("should not instantiate AST_Node");
    },
    validate: function() {
      var ctor = this.CTOR;
      do {
        ctor.prototype._validate.call(this);
      } while (ctor = ctor.BASE);
    },
    validate_ast: function() {
      var marker = {};
      this.walk(new TreeWalker2(function(node) {
        if (node.validate_visited === marker) {
          throw new Error(string_template("cannot reuse AST_{TYPE} from [{start}]", node));
        }
        node.validate_visited = marker;
      }));
    }
  }, null);
  DEF_BITPROPS(AST_Node2, [
    "_optimized",
    "_squeezed",
    "call_only",
    "collapse_scanning",
    "defined",
    "evaluating",
    "falsy",
    "in_arg",
    "in_bool",
    "is_undefined",
    "inlined",
    "length_read",
    "nested",
    "new",
    "optional",
    "private",
    "pure",
    "redundant",
    "single_use",
    "static",
    "terminal",
    "truthy",
    "uses_eval",
    "uses_with"
  ]);
  (AST_Node2.log_function = function(fn, verbose) {
    if (typeof fn != "function") {
      AST_Node2.info = AST_Node2.warn = noop;
      return;
    }
    var printed = Object.create(null);
    AST_Node2.info = verbose ? function(text, props) {
      log("INFO: " + string_template(text, props));
    } : noop;
    AST_Node2.warn = function(text, props) {
      log("WARN: " + string_template(text, props));
    };
    function log(msg) {
      if (printed[msg])
        return;
      printed[msg] = true;
      fn(msg);
    }
  })();
  var restore_transforms = [];
  AST_Node2.enable_validation = function() {
    AST_Node2.disable_validation();
    (function validate_transform(ctor) {
      ctor.SUBCLASSES.forEach(validate_transform);
      if (!HOP(ctor.prototype, "transform"))
        return;
      var transform = ctor.prototype.transform;
      ctor.prototype.transform = function(tw, in_list) {
        var node = transform.call(this, tw, in_list);
        if (node instanceof AST_Node2) {
          node.validate();
        } else if (!(node === null || in_list && List.is_op(node))) {
          throw new Error("invalid transformed value: " + node);
        }
        return node;
      };
      restore_transforms.push(function() {
        ctor.prototype.transform = transform;
      });
    })(this);
  };
  AST_Node2.disable_validation = function() {
    var restore;
    while (restore = restore_transforms.pop())
      restore();
  };
  var AST_Statement2 = DEFNODE("Statement", null, {
    $documentation: "Base class of all statements",
    _validate: function() {
      if (this.TYPE == "Statement")
        throw new Error("should not instantiate AST_Statement");
    }
  });
  var AST_Debugger2 = DEFNODE("Debugger", null, {
    $documentation: "Represents a debugger statement",
    _equals: return_true
  }, AST_Statement2);
  var AST_Directive2 = DEFNODE("Directive", "quote value", {
    $documentation: "Represents a directive, like \"use strict\";",
    $propdoc: {
      quote: "[string?] the original quote character",
      value: "[string] The value of this directive as a plain string (it's not an AST_String!)"
    },
    _equals: function(node) {
      return this.value == node.value;
    },
    _validate: function() {
      if (this.quote != null) {
        if (typeof this.quote != "string")
          throw new Error("quote must be string");
        if (!/^["']$/.test(this.quote))
          throw new Error("invalid quote: " + this.quote);
      }
      if (typeof this.value != "string")
        throw new Error("value must be string");
    }
  }, AST_Statement2);
  var AST_EmptyStatement2 = DEFNODE("EmptyStatement", null, {
    $documentation: "The empty statement (empty block or simply a semicolon)",
    _equals: return_true
  }, AST_Statement2);
  var AST_SimpleStatement2 = DEFNODE("SimpleStatement", "body", {
    $documentation: "A statement consisting of an expression, i.e. a = 1 + 2",
    $propdoc: {
      body: "[AST_Node] an expression node (should not be instanceof AST_Statement)"
    },
    _equals: function(node) {
      return this.body.equals(node.body);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.body.walk(visitor);
      });
    },
    _validate: function() {
      must_be_expression(this, "body");
    }
  }, AST_Statement2);
  var AST_BlockScope2 = DEFNODE("BlockScope", "_var_names enclosed functions make_def parent_scope variables", {
    $documentation: "Base class for all statements introducing a lexical scope",
    $propdoc: {
      enclosed: "[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any inner scopes",
      functions: "[Dictionary/S] like `variables`, but only lists function declarations",
      parent_scope: "[AST_Scope?/S] link to the parent scope",
      variables: "[Dictionary/S] a map of name ---> SymbolDef for all variables/functions defined in this scope"
    },
    clone: function(deep) {
      var node = this._clone(deep);
      if (this.enclosed)
        node.enclosed = this.enclosed.slice();
      if (this.functions)
        node.functions = this.functions.clone();
      if (this.variables)
        node.variables = this.variables.clone();
      return node;
    },
    pinned: function() {
      return this.resolve().pinned();
    },
    resolve: function() {
      return this.parent_scope.resolve();
    },
    _validate: function() {
      if (this.TYPE == "BlockScope")
        throw new Error("should not instantiate AST_BlockScope");
      if (this.parent_scope == null)
        return;
      if (!(this.parent_scope instanceof AST_BlockScope2))
        throw new Error("parent_scope must be AST_BlockScope");
      if (!(this.resolve() instanceof AST_Scope2))
        throw new Error("must be contained within AST_Scope");
    }
  }, AST_Statement2);
  var AST_Block2 = DEFNODE("Block", "body", {
    $documentation: "A body of statements (usually braced)",
    $propdoc: {
      body: "[AST_Statement*] an array of statements"
    },
    _equals: function(node) {
      return all_equals(this.body, node.body);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        walk_body2(node, visitor);
      });
    },
    _validate: function() {
      if (this.TYPE == "Block")
        throw new Error("should not instantiate AST_Block");
      this.body.forEach(function(node) {
        if (!is_statement2(node))
          throw new Error("body must contain AST_Statement");
      });
    }
  }, AST_BlockScope2);
  var AST_BlockStatement2 = DEFNODE("BlockStatement", null, {
    $documentation: "A block statement"
  }, AST_Block2);
  var AST_StatementWithBody2 = DEFNODE("StatementWithBody", "body", {
    $documentation: "Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",
    $propdoc: {
      body: "[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"
    },
    _validate: function() {
      if (this.TYPE == "StatementWithBody")
        throw new Error("should not instantiate AST_StatementWithBody");
      if (!is_statement2(this.body))
        throw new Error("body must be AST_Statement");
    }
  }, AST_BlockScope2);
  var AST_LabeledStatement2 = DEFNODE("LabeledStatement", "label", {
    $documentation: "Statement with a label",
    $propdoc: {
      label: "[AST_Label] a label definition"
    },
    _equals: function(node) {
      return this.label.equals(node.label) && this.body.equals(node.body);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.label.walk(visitor);
        node.body.walk(visitor);
      });
    },
    clone: function(deep) {
      var node = this._clone(deep);
      if (deep) {
        var label = node.label;
        var def = this.label;
        node.walk(new TreeWalker2(function(node2) {
          if (node2 instanceof AST_LoopControl2) {
            if (!node2.label || node2.label.thedef !== def)
              return;
            node2.label.thedef = label;
            label.references.push(node2);
            return true;
          }
          if (node2 instanceof AST_Scope2)
            return true;
        }));
      }
      return node;
    },
    _validate: function() {
      if (!(this.label instanceof AST_Label2))
        throw new Error("label must be AST_Label");
    }
  }, AST_StatementWithBody2);
  var AST_IterationStatement2 = DEFNODE("IterationStatement", null, {
    $documentation: "Internal class.  All loops inherit from it.",
    _validate: function() {
      if (this.TYPE == "IterationStatement")
        throw new Error("should not instantiate AST_IterationStatement");
    }
  }, AST_StatementWithBody2);
  var AST_DWLoop2 = DEFNODE("DWLoop", "condition", {
    $documentation: "Base class for do/while statements",
    $propdoc: {
      condition: "[AST_Node] the loop condition.  Should not be instanceof AST_Statement"
    },
    _equals: function(node) {
      return this.body.equals(node.body) && this.condition.equals(node.condition);
    },
    _validate: function() {
      if (this.TYPE == "DWLoop")
        throw new Error("should not instantiate AST_DWLoop");
      must_be_expression(this, "condition");
    }
  }, AST_IterationStatement2);
  var AST_Do2 = DEFNODE("Do", null, {
    $documentation: "A `do` statement",
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.body.walk(visitor);
        node.condition.walk(visitor);
      });
    }
  }, AST_DWLoop2);
  var AST_While2 = DEFNODE("While", null, {
    $documentation: "A `while` statement",
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.condition.walk(visitor);
        node.body.walk(visitor);
      });
    }
  }, AST_DWLoop2);
  var AST_For2 = DEFNODE("For", "init condition step", {
    $documentation: "A `for` statement",
    $propdoc: {
      init: "[AST_Node?] the `for` initialization code, or null if empty",
      condition: "[AST_Node?] the `for` termination clause, or null if empty",
      step: "[AST_Node?] the `for` update clause, or null if empty"
    },
    _equals: function(node) {
      return prop_equals(this.init, node.init) && prop_equals(this.condition, node.condition) && prop_equals(this.step, node.step) && this.body.equals(node.body);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        if (node.init)
          node.init.walk(visitor);
        if (node.condition)
          node.condition.walk(visitor);
        if (node.step)
          node.step.walk(visitor);
        node.body.walk(visitor);
      });
    },
    _validate: function() {
      if (this.init != null) {
        if (!(this.init instanceof AST_Node2))
          throw new Error("init must be AST_Node");
        if (is_statement2(this.init) && !(this.init instanceof AST_Definitions2)) {
          throw new Error("init cannot be AST_Statement");
        }
      }
      if (this.condition != null)
        must_be_expression(this, "condition");
      if (this.step != null)
        must_be_expression(this, "step");
    }
  }, AST_IterationStatement2);
  var AST_ForEnumeration2 = DEFNODE("ForEnumeration", "init object", {
    $documentation: "Base class for enumeration loops, i.e. `for ... in`, `for ... of` & `for await ... of`",
    $propdoc: {
      init: "[AST_Node] the assignment target during iteration",
      object: "[AST_Node] the object to iterate over"
    },
    _equals: function(node) {
      return this.init.equals(node.init) && this.object.equals(node.object) && this.body.equals(node.body);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.init.walk(visitor);
        node.object.walk(visitor);
        node.body.walk(visitor);
      });
    },
    _validate: function() {
      if (this.TYPE == "ForEnumeration")
        throw new Error("should not instantiate AST_ForEnumeration");
      if (this.init instanceof AST_Definitions2) {
        if (this.init.definitions.length != 1)
          throw new Error("init must have single declaration");
      } else {
        validate_destructured(this.init, function(node) {
          if (!(node instanceof AST_PropAccess2 || node instanceof AST_SymbolRef2)) {
            throw new Error("init must be assignable: " + node.TYPE);
          }
        });
      }
      must_be_expression(this, "object");
    }
  }, AST_IterationStatement2);
  var AST_ForIn2 = DEFNODE("ForIn", null, {
    $documentation: "A `for ... in` statement"
  }, AST_ForEnumeration2);
  var AST_ForOf2 = DEFNODE("ForOf", null, {
    $documentation: "A `for ... of` statement"
  }, AST_ForEnumeration2);
  var AST_ForAwaitOf2 = DEFNODE("ForAwaitOf", null, {
    $documentation: "A `for await ... of` statement"
  }, AST_ForOf2);
  var AST_With2 = DEFNODE("With", "expression", {
    $documentation: "A `with` statement",
    $propdoc: {
      expression: "[AST_Node] the `with` expression"
    },
    _equals: function(node) {
      return this.expression.equals(node.expression) && this.body.equals(node.body);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.expression.walk(visitor);
        node.body.walk(visitor);
      });
    },
    _validate: function() {
      must_be_expression(this, "expression");
    }
  }, AST_StatementWithBody2);
  var AST_Scope2 = DEFNODE("Scope", "fn_defs may_call_this uses_eval uses_with", {
    $documentation: "Base class for all statements introducing a lambda scope",
    $propdoc: {
      uses_eval: "[boolean/S] tells whether this scope contains a direct call to the global `eval`",
      uses_with: "[boolean/S] tells whether this scope uses the `with` statement"
    },
    pinned: function() {
      return this.uses_eval || this.uses_with;
    },
    resolve: return_this,
    _validate: function() {
      if (this.TYPE == "Scope")
        throw new Error("should not instantiate AST_Scope");
    }
  }, AST_Block2);
  var AST_Toplevel2 = DEFNODE("Toplevel", "globals", {
    $documentation: "The toplevel scope",
    $propdoc: {
      globals: "[Dictionary/S] a map of name ---> SymbolDef for all undeclared names"
    },
    wrap: function(name) {
      var body = this.body;
      return parse([
        "(function(exports){'$ORIG';})(typeof ",
        name,
        "=='undefined'?(",
        name,
        "={}):",
        name,
        ");"
      ].join(""), {
        filename: "wrap=" + JSON.stringify(name)
      }).transform(new TreeTransformer(function(node) {
        if (node instanceof AST_Directive2 && node.value == "$ORIG") {
          return List.splice(body);
        }
      }));
    },
    enclose: function(args_values) {
      if (typeof args_values != "string")
        args_values = "";
      var index = args_values.indexOf(":");
      if (index < 0)
        index = args_values.length;
      var body = this.body;
      return parse([
        "(function(",
        args_values.slice(0, index),
        '){"$ORIG"})(',
        args_values.slice(index + 1),
        ")"
      ].join(""), {
        filename: "enclose=" + JSON.stringify(args_values)
      }).transform(new TreeTransformer(function(node) {
        if (node instanceof AST_Directive2 && node.value == "$ORIG") {
          return List.splice(body);
        }
      }));
    }
  }, AST_Scope2);
  var AST_ClassInitBlock2 = DEFNODE("ClassInitBlock", null, {
    $documentation: "Value for `class` static initialization blocks"
  }, AST_Scope2);
  var AST_Lambda2 = DEFNODE("Lambda", "argnames length_read rest safe_ids uses_arguments", {
    $documentation: "Base class for functions",
    $propdoc: {
      argnames: "[(AST_DefaultValue|AST_Destructured|AST_SymbolFunarg)*] array of function arguments and/or destructured literals",
      length_read: "[boolean/S] whether length property of this function is accessed",
      rest: "[(AST_Destructured|AST_SymbolFunarg)?] rest parameter, or null if absent",
      uses_arguments: "[boolean|number/S] whether this function accesses the arguments array"
    },
    each_argname: function(visit) {
      var tw = new TreeWalker2(function(node) {
        if (node instanceof AST_DefaultValue2) {
          node.name.walk(tw);
          return true;
        }
        if (node instanceof AST_DestructuredKeyVal2) {
          node.value.walk(tw);
          return true;
        }
        if (node instanceof AST_SymbolFunarg2)
          visit(node);
      });
      this.argnames.forEach(function(argname) {
        argname.walk(tw);
      });
      if (this.rest)
        this.rest.walk(tw);
    },
    _equals: function(node) {
      return prop_equals(this.rest, node.rest) && prop_equals(this.name, node.name) && prop_equals(this.value, node.value) && all_equals(this.argnames, node.argnames) && all_equals(this.body, node.body);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        if (node.name)
          node.name.walk(visitor);
        node.argnames.forEach(function(argname) {
          argname.walk(visitor);
        });
        if (node.rest)
          node.rest.walk(visitor);
        walk_body2(node, visitor);
      });
    },
    _validate: function() {
      if (this.TYPE == "Lambda")
        throw new Error("should not instantiate AST_Lambda");
      this.argnames.forEach(function(node) {
        validate_destructured(node, function(node2) {
          if (!(node2 instanceof AST_SymbolFunarg2))
            throw new Error("argnames must be AST_SymbolFunarg[]");
        }, true);
      });
      if (this.rest != null)
        validate_destructured(this.rest, function(node) {
          if (!(node instanceof AST_SymbolFunarg2))
            throw new Error("rest must be AST_SymbolFunarg");
        });
    }
  }, AST_Scope2);
  var AST_Accessor2 = DEFNODE("Accessor", null, {
    $documentation: "A getter/setter function",
    _validate: function() {
      if (this.name != null)
        throw new Error("name must be null");
    }
  }, AST_Lambda2);
  var AST_LambdaExpression2 = DEFNODE("LambdaExpression", "inlined", {
    $documentation: "Base class for function expressions",
    $propdoc: {
      inlined: "[boolean/S] whether this function has been inlined"
    },
    _validate: function() {
      if (this.TYPE == "LambdaExpression")
        throw new Error("should not instantiate AST_LambdaExpression");
    }
  }, AST_Lambda2);
  var AST_Arrow2 = DEFNODE("Arrow", "value", {
    $documentation: "An arrow function expression",
    $propdoc: {
      value: "[AST_Node?] simple return expression, or null if using function body."
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.argnames.forEach(function(argname) {
          argname.walk(visitor);
        });
        if (node.rest)
          node.rest.walk(visitor);
        if (node.value) {
          node.value.walk(visitor);
        } else {
          walk_body2(node, visitor);
        }
      });
    },
    _validate: function() {
      if (this.name != null)
        throw new Error("name must be null");
      if (this.uses_arguments)
        throw new Error("uses_arguments must be false");
      if (this.value != null) {
        must_be_expression(this, "value");
        if (this.body.length)
          throw new Error("body must be empty if value exists");
      }
    }
  }, AST_LambdaExpression2);
  var AST_AsyncArrow2 = DEFNODE("AsyncArrow", "value", {
    $documentation: "An asynchronous arrow function expression",
    $propdoc: {
      value: "[AST_Node?] simple return expression, or null if using function body."
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.argnames.forEach(function(argname) {
          argname.walk(visitor);
        });
        if (node.rest)
          node.rest.walk(visitor);
        if (node.value) {
          node.value.walk(visitor);
        } else {
          walk_body2(node, visitor);
        }
      });
    },
    _validate: function() {
      if (this.name != null)
        throw new Error("name must be null");
      if (this.uses_arguments)
        throw new Error("uses_arguments must be false");
      if (this.value != null) {
        must_be_expression(this, "value");
        if (this.body.length)
          throw new Error("body must be empty if value exists");
      }
    }
  }, AST_LambdaExpression2);
  var AST_AsyncFunction2 = DEFNODE("AsyncFunction", "name", {
    $documentation: "An asynchronous function expression",
    $propdoc: {
      name: "[AST_SymbolLambda?] the name of this function, or null if not specified"
    },
    _validate: function() {
      if (this.name != null) {
        if (!(this.name instanceof AST_SymbolLambda2))
          throw new Error("name must be AST_SymbolLambda");
      }
    }
  }, AST_LambdaExpression2);
  var AST_AsyncGeneratorFunction2 = DEFNODE("AsyncGeneratorFunction", "name", {
    $documentation: "An asynchronous generator function expression",
    $propdoc: {
      name: "[AST_SymbolLambda?] the name of this function, or null if not specified"
    },
    _validate: function() {
      if (this.name != null) {
        if (!(this.name instanceof AST_SymbolLambda2))
          throw new Error("name must be AST_SymbolLambda");
      }
    }
  }, AST_LambdaExpression2);
  var AST_Function2 = DEFNODE("Function", "name", {
    $documentation: "A function expression",
    $propdoc: {
      name: "[AST_SymbolLambda?] the name of this function, or null if not specified"
    },
    _validate: function() {
      if (this.name != null) {
        if (!(this.name instanceof AST_SymbolLambda2))
          throw new Error("name must be AST_SymbolLambda");
      }
    }
  }, AST_LambdaExpression2);
  var AST_GeneratorFunction2 = DEFNODE("GeneratorFunction", "name", {
    $documentation: "A generator function expression",
    $propdoc: {
      name: "[AST_SymbolLambda?] the name of this function, or null if not specified"
    },
    _validate: function() {
      if (this.name != null) {
        if (!(this.name instanceof AST_SymbolLambda2))
          throw new Error("name must be AST_SymbolLambda");
      }
    }
  }, AST_LambdaExpression2);
  var AST_LambdaDefinition2 = DEFNODE("LambdaDefinition", "inlined name", {
    $documentation: "Base class for function definitions",
    $propdoc: {
      inlined: "[boolean/S] whether this function has been inlined",
      name: "[AST_SymbolDefun] the name of this function"
    },
    _validate: function() {
      if (this.TYPE == "LambdaDefinition")
        throw new Error("should not instantiate AST_LambdaDefinition");
      if (!(this.name instanceof AST_SymbolDefun2))
        throw new Error("name must be AST_SymbolDefun");
    }
  }, AST_Lambda2);
  var AST_AsyncDefun2 = DEFNODE("AsyncDefun", null, {
    $documentation: "An asynchronous function definition"
  }, AST_LambdaDefinition2);
  var AST_AsyncGeneratorDefun2 = DEFNODE("AsyncGeneratorDefun", null, {
    $documentation: "An asynchronous generator function definition"
  }, AST_LambdaDefinition2);
  var AST_Defun2 = DEFNODE("Defun", null, {
    $documentation: "A function definition"
  }, AST_LambdaDefinition2);
  var AST_GeneratorDefun2 = DEFNODE("GeneratorDefun", null, {
    $documentation: "A generator function definition"
  }, AST_LambdaDefinition2);
  var AST_Class2 = DEFNODE("Class", "extends name properties", {
    $documentation: "Base class for class literals",
    $propdoc: {
      extends: "[AST_Node?] the super class, or null if not specified",
      properties: "[AST_ClassProperty*] array of class properties"
    },
    _equals: function(node) {
      return prop_equals(this.name, node.name) && prop_equals(this.extends, node.extends) && all_equals(this.properties, node.properties);
    },
    resolve: function(def_class) {
      return def_class ? this : this.parent_scope.resolve();
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        if (node.name)
          node.name.walk(visitor);
        if (node.extends)
          node.extends.walk(visitor);
        node.properties.forEach(function(prop) {
          prop.walk(visitor);
        });
      });
    },
    _validate: function() {
      if (this.TYPE == "Class")
        throw new Error("should not instantiate AST_Class");
      if (this.extends != null)
        must_be_expression(this, "extends");
      this.properties.forEach(function(node) {
        if (!(node instanceof AST_ClassProperty2))
          throw new Error("properties must contain AST_ClassProperty");
      });
    }
  }, AST_BlockScope2);
  var AST_DefClass2 = DEFNODE("DefClass", null, {
    $documentation: "A class definition",
    $propdoc: {
      name: "[AST_SymbolDefClass] the name of this class"
    },
    _validate: function() {
      if (!(this.name instanceof AST_SymbolDefClass2))
        throw new Error("name must be AST_SymbolDefClass");
    }
  }, AST_Class2);
  var AST_ClassExpression2 = DEFNODE("ClassExpression", null, {
    $documentation: "A class expression",
    $propdoc: {
      name: "[AST_SymbolClass?] the name of this class, or null if not specified"
    },
    _validate: function() {
      if (this.name != null) {
        if (!(this.name instanceof AST_SymbolClass2))
          throw new Error("name must be AST_SymbolClass");
      }
    }
  }, AST_Class2);
  var AST_ClassProperty2 = DEFNODE("ClassProperty", "key private static value", {
    $documentation: "Base class for `class` properties",
    $propdoc: {
      key: "[string|AST_Node?] property name (AST_Node for computed property, null for initialization block)",
      private: "[boolean] whether this is a private property",
      static: "[boolean] whether this is a static property",
      value: "[AST_Node?] property value (AST_Accessor for getters/setters, AST_LambdaExpression for methods, null if not specified for fields)"
    },
    _equals: function(node) {
      return !this.private == !node.private && !this.static == !node.static && prop_equals(this.key, node.key) && prop_equals(this.value, node.value);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        if (node.key instanceof AST_Node2)
          node.key.walk(visitor);
        if (node.value)
          node.value.walk(visitor);
      });
    },
    _validate: function() {
      if (this.TYPE == "ClassProperty")
        throw new Error("should not instantiate AST_ClassProperty");
      if (this instanceof AST_ClassInit2) {
        if (this.key != null)
          throw new Error("key must be null");
      } else if (typeof this.key != "string") {
        if (!(this.key instanceof AST_Node2))
          throw new Error("key must be string or AST_Node");
        must_be_expression(this, "key");
      }
      if (this.value != null) {
        if (!(this.value instanceof AST_Node2))
          throw new Error("value must be AST_Node");
      }
    }
  });
  var AST_ClassField2 = DEFNODE("ClassField", null, {
    $documentation: "A `class` field",
    _validate: function() {
      if (this.value != null)
        must_be_expression(this, "value");
    }
  }, AST_ClassProperty2);
  var AST_ClassGetter2 = DEFNODE("ClassGetter", null, {
    $documentation: "A `class` getter",
    _validate: function() {
      if (!(this.value instanceof AST_Accessor2))
        throw new Error("value must be AST_Accessor");
    }
  }, AST_ClassProperty2);
  var AST_ClassSetter2 = DEFNODE("ClassSetter", null, {
    $documentation: "A `class` setter",
    _validate: function() {
      if (!(this.value instanceof AST_Accessor2))
        throw new Error("value must be AST_Accessor");
    }
  }, AST_ClassProperty2);
  var AST_ClassMethod2 = DEFNODE("ClassMethod", null, {
    $documentation: "A `class` method",
    _validate: function() {
      if (!(this.value instanceof AST_LambdaExpression2))
        throw new Error("value must be AST_LambdaExpression");
      if (is_arrow2(this.value))
        throw new Error("value cannot be AST_Arrow or AST_AsyncArrow");
      if (this.value.name != null)
        throw new Error("name of class method's lambda must be null");
    }
  }, AST_ClassProperty2);
  var AST_ClassInit2 = DEFNODE("ClassInit", null, {
    $documentation: "A `class` static initialization block",
    _validate: function() {
      if (!this.static)
        throw new Error("static must be true");
      if (!(this.value instanceof AST_ClassInitBlock2))
        throw new Error("value must be AST_ClassInitBlock");
    },
    initialize: function() {
      this.static = true;
    }
  }, AST_ClassProperty2);
  var AST_Jump2 = DEFNODE("Jump", null, {
    $documentation: "Base class for \u201Cjumps\u201D (for now that's `return`, `throw`, `break` and `continue`)",
    _validate: function() {
      if (this.TYPE == "Jump")
        throw new Error("should not instantiate AST_Jump");
    }
  }, AST_Statement2);
  var AST_Exit2 = DEFNODE("Exit", "value", {
    $documentation: "Base class for \u201Cexits\u201D (`return` and `throw`)",
    $propdoc: {
      value: "[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"
    },
    _equals: function(node) {
      return prop_equals(this.value, node.value);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        if (node.value)
          node.value.walk(visitor);
      });
    },
    _validate: function() {
      if (this.TYPE == "Exit")
        throw new Error("should not instantiate AST_Exit");
    }
  }, AST_Jump2);
  var AST_Return2 = DEFNODE("Return", null, {
    $documentation: "A `return` statement",
    _validate: function() {
      if (this.value != null)
        must_be_expression(this, "value");
    }
  }, AST_Exit2);
  var AST_Throw2 = DEFNODE("Throw", null, {
    $documentation: "A `throw` statement",
    _validate: function() {
      must_be_expression(this, "value");
    }
  }, AST_Exit2);
  var AST_LoopControl2 = DEFNODE("LoopControl", "label", {
    $documentation: "Base class for loop control statements (`break` and `continue`)",
    $propdoc: {
      label: "[AST_LabelRef?] the label, or null if none"
    },
    _equals: function(node) {
      return prop_equals(this.label, node.label);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        if (node.label)
          node.label.walk(visitor);
      });
    },
    _validate: function() {
      if (this.TYPE == "LoopControl")
        throw new Error("should not instantiate AST_LoopControl");
      if (this.label != null) {
        if (!(this.label instanceof AST_LabelRef2))
          throw new Error("label must be AST_LabelRef");
      }
    }
  }, AST_Jump2);
  var AST_Break2 = DEFNODE("Break", null, {
    $documentation: "A `break` statement"
  }, AST_LoopControl2);
  var AST_Continue2 = DEFNODE("Continue", null, {
    $documentation: "A `continue` statement"
  }, AST_LoopControl2);
  var AST_If2 = DEFNODE("If", "condition alternative", {
    $documentation: "A `if` statement",
    $propdoc: {
      condition: "[AST_Node] the `if` condition",
      alternative: "[AST_Statement?] the `else` part, or null if not present"
    },
    _equals: function(node) {
      return this.body.equals(node.body) && this.condition.equals(node.condition) && prop_equals(this.alternative, node.alternative);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.condition.walk(visitor);
        node.body.walk(visitor);
        if (node.alternative)
          node.alternative.walk(visitor);
      });
    },
    _validate: function() {
      must_be_expression(this, "condition");
      if (this.alternative != null) {
        if (!is_statement2(this.alternative))
          throw new Error("alternative must be AST_Statement");
      }
    }
  }, AST_StatementWithBody2);
  var AST_Switch2 = DEFNODE("Switch", "expression", {
    $documentation: "A `switch` statement",
    $propdoc: {
      expression: "[AST_Node] the `switch` \u201Cdiscriminant\u201D"
    },
    _equals: function(node) {
      return this.expression.equals(node.expression) && all_equals(this.body, node.body);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.expression.walk(visitor);
        walk_body2(node, visitor);
      });
    },
    _validate: function() {
      must_be_expression(this, "expression");
      this.body.forEach(function(node) {
        if (!(node instanceof AST_SwitchBranch2))
          throw new Error("body must be AST_SwitchBranch[]");
      });
    }
  }, AST_Block2);
  var AST_SwitchBranch2 = DEFNODE("SwitchBranch", null, {
    $documentation: "Base class for `switch` branches",
    _validate: function() {
      if (this.TYPE == "SwitchBranch")
        throw new Error("should not instantiate AST_SwitchBranch");
    }
  }, AST_Block2);
  var AST_Default2 = DEFNODE("Default", null, {
    $documentation: "A `default` switch branch"
  }, AST_SwitchBranch2);
  var AST_Case2 = DEFNODE("Case", "expression", {
    $documentation: "A `case` switch branch",
    $propdoc: {
      expression: "[AST_Node] the `case` expression"
    },
    _equals: function(node) {
      return this.expression.equals(node.expression) && all_equals(this.body, node.body);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.expression.walk(visitor);
        walk_body2(node, visitor);
      });
    },
    _validate: function() {
      must_be_expression(this, "expression");
    }
  }, AST_SwitchBranch2);
  var AST_Try2 = DEFNODE("Try", "bcatch bfinally", {
    $documentation: "A `try` statement",
    $propdoc: {
      bcatch: "[AST_Catch?] the catch block, or null if not present",
      bfinally: "[AST_Finally?] the finally block, or null if not present"
    },
    _equals: function(node) {
      return all_equals(this.body, node.body) && prop_equals(this.bcatch, node.bcatch) && prop_equals(this.bfinally, node.bfinally);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        walk_body2(node, visitor);
        if (node.bcatch)
          node.bcatch.walk(visitor);
        if (node.bfinally)
          node.bfinally.walk(visitor);
      });
    },
    _validate: function() {
      if (this.bcatch != null) {
        if (!(this.bcatch instanceof AST_Catch2))
          throw new Error("bcatch must be AST_Catch");
      }
      if (this.bfinally != null) {
        if (!(this.bfinally instanceof AST_Finally2))
          throw new Error("bfinally must be AST_Finally");
      }
    }
  }, AST_Block2);
  var AST_Catch2 = DEFNODE("Catch", "argname", {
    $documentation: "A `catch` node; only makes sense as part of a `try` statement",
    $propdoc: {
      argname: "[(AST_Destructured|AST_SymbolCatch)?] symbol for the exception, or null if not present"
    },
    _equals: function(node) {
      return prop_equals(this.argname, node.argname) && all_equals(this.body, node.body);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        if (node.argname)
          node.argname.walk(visitor);
        walk_body2(node, visitor);
      });
    },
    _validate: function() {
      if (this.argname != null)
        validate_destructured(this.argname, function(node) {
          if (!(node instanceof AST_SymbolCatch2))
            throw new Error("argname must be AST_SymbolCatch");
        });
    }
  }, AST_Block2);
  var AST_Finally2 = DEFNODE("Finally", null, {
    $documentation: "A `finally` node; only makes sense as part of a `try` statement"
  }, AST_Block2);
  var AST_Definitions2 = DEFNODE("Definitions", "definitions", {
    $documentation: "Base class for `var` nodes (variable declarations/initializations)",
    $propdoc: {
      definitions: "[AST_VarDef*] array of variable definitions"
    },
    _equals: function(node) {
      return all_equals(this.definitions, node.definitions);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.definitions.forEach(function(defn) {
          defn.walk(visitor);
        });
      });
    },
    _validate: function() {
      if (this.TYPE == "Definitions")
        throw new Error("should not instantiate AST_Definitions");
      if (this.definitions.length < 1)
        throw new Error("must have at least one definition");
    }
  }, AST_Statement2);
  var AST_Const2 = DEFNODE("Const", null, {
    $documentation: "A `const` statement",
    _validate: function() {
      this.definitions.forEach(function(node) {
        if (!(node instanceof AST_VarDef2))
          throw new Error("definitions must be AST_VarDef[]");
        validate_destructured(node.name, function(node2) {
          if (!(node2 instanceof AST_SymbolConst2))
            throw new Error("name must be AST_SymbolConst");
        });
      });
    }
  }, AST_Definitions2);
  var AST_Let2 = DEFNODE("Let", null, {
    $documentation: "A `let` statement",
    _validate: function() {
      this.definitions.forEach(function(node) {
        if (!(node instanceof AST_VarDef2))
          throw new Error("definitions must be AST_VarDef[]");
        validate_destructured(node.name, function(node2) {
          if (!(node2 instanceof AST_SymbolLet2))
            throw new Error("name must be AST_SymbolLet");
        });
      });
    }
  }, AST_Definitions2);
  var AST_Var2 = DEFNODE("Var", null, {
    $documentation: "A `var` statement",
    _validate: function() {
      this.definitions.forEach(function(node) {
        if (!(node instanceof AST_VarDef2))
          throw new Error("definitions must be AST_VarDef[]");
        validate_destructured(node.name, function(node2) {
          if (!(node2 instanceof AST_SymbolVar2))
            throw new Error("name must be AST_SymbolVar");
        });
      });
    }
  }, AST_Definitions2);
  var AST_VarDef2 = DEFNODE("VarDef", "name value", {
    $documentation: "A variable declaration; only appears in a AST_Definitions node",
    $propdoc: {
      name: "[AST_Destructured|AST_SymbolVar] name of the variable",
      value: "[AST_Node?] initializer, or null of there's no initializer"
    },
    _equals: function(node) {
      return this.name.equals(node.name) && prop_equals(this.value, node.value);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.name.walk(visitor);
        if (node.value)
          node.value.walk(visitor);
      });
    },
    _validate: function() {
      if (this.value != null)
        must_be_expression(this, "value");
    }
  });
  var AST_ExportDeclaration2 = DEFNODE("ExportDeclaration", "body", {
    $documentation: "An `export` statement",
    $propdoc: {
      body: "[AST_DefClass|AST_Definitions|AST_LambdaDefinition] the statement to export"
    },
    _equals: function(node) {
      return this.body.equals(node.body);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.body.walk(visitor);
      });
    },
    _validate: function() {
      if (!(this.body instanceof AST_DefClass2 || this.body instanceof AST_Definitions2 || this.body instanceof AST_LambdaDefinition2)) {
        throw new Error("body must be AST_DefClass, AST_Definitions or AST_LambdaDefinition");
      }
    }
  }, AST_Statement2);
  var AST_ExportDefault2 = DEFNODE("ExportDefault", "body", {
    $documentation: "An `export default` statement",
    $propdoc: {
      body: "[AST_Node] the default export"
    },
    _equals: function(node) {
      return this.body.equals(node.body);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.body.walk(visitor);
      });
    },
    _validate: function() {
      if (!(this.body instanceof AST_DefClass2 || this.body instanceof AST_LambdaDefinition2)) {
        must_be_expression(this, "body");
      }
    }
  }, AST_Statement2);
  var AST_ExportForeign2 = DEFNODE("ExportForeign", "aliases keys path", {
    $documentation: "An `export ... from '...'` statement",
    $propdoc: {
      aliases: "[AST_String*] array of aliases to export",
      keys: "[AST_String*] array of keys to import",
      path: "[AST_String] the path to import module"
    },
    _equals: function(node) {
      return this.path.equals(node.path) && all_equals(this.aliases, node.aliases) && all_equals(this.keys, node.keys);
    },
    _validate: function() {
      if (this.aliases.length != this.keys.length) {
        throw new Error("aliases:key length mismatch: " + this.aliases.length + " != " + this.keys.length);
      }
      this.aliases.forEach(function(name) {
        if (!(name instanceof AST_String2))
          throw new Error("aliases must contain AST_String");
      });
      this.keys.forEach(function(name) {
        if (!(name instanceof AST_String2))
          throw new Error("keys must contain AST_String");
      });
      if (!(this.path instanceof AST_String2))
        throw new Error("path must be AST_String");
    }
  }, AST_Statement2);
  var AST_ExportReferences2 = DEFNODE("ExportReferences", "properties", {
    $documentation: "An `export { ... }` statement",
    $propdoc: {
      properties: "[AST_SymbolExport*] array of aliases to export"
    },
    _equals: function(node) {
      return all_equals(this.properties, node.properties);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.properties.forEach(function(prop) {
          prop.walk(visitor);
        });
      });
    },
    _validate: function() {
      this.properties.forEach(function(prop) {
        if (!(prop instanceof AST_SymbolExport2))
          throw new Error("properties must contain AST_SymbolExport");
      });
    }
  }, AST_Statement2);
  var AST_Import2 = DEFNODE("Import", "all default path properties", {
    $documentation: "An `import` statement",
    $propdoc: {
      all: "[AST_SymbolImport?] the imported namespace, or null if not specified",
      default: "[AST_SymbolImport?] the alias for default `export`, or null if not specified",
      path: "[AST_String] the path to import module",
      properties: "[(AST_SymbolImport*)?] array of aliases, or null if not specified"
    },
    _equals: function(node) {
      return this.path.equals(node.path) && prop_equals(this.all, node.all) && prop_equals(this.default, node.default) && !this.properties == !node.properties && (!this.properties || all_equals(this.properties, node.properties));
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        if (node.all)
          node.all.walk(visitor);
        if (node.default)
          node.default.walk(visitor);
        if (node.properties)
          node.properties.forEach(function(prop) {
            prop.walk(visitor);
          });
      });
    },
    _validate: function() {
      if (this.all != null) {
        if (!(this.all instanceof AST_SymbolImport2))
          throw new Error("all must be AST_SymbolImport");
        if (this.properties != null)
          throw new Error("cannot import both * and {} in the same statement");
      }
      if (this.default != null) {
        if (!(this.default instanceof AST_SymbolImport2))
          throw new Error("default must be AST_SymbolImport");
        if (this.default.key.value !== "")
          throw new Error("invalid default key: " + this.default.key.value);
      }
      if (!(this.path instanceof AST_String2))
        throw new Error("path must be AST_String");
      if (this.properties != null)
        this.properties.forEach(function(node) {
          if (!(node instanceof AST_SymbolImport2))
            throw new Error("properties must contain AST_SymbolImport");
        });
    }
  }, AST_Statement2);
  var AST_DefaultValue2 = DEFNODE("DefaultValue", "name value", {
    $documentation: "A default value declaration",
    $propdoc: {
      name: "[AST_Destructured|AST_SymbolDeclaration] name of the variable",
      value: "[AST_Node] value to assign if variable is `undefined`"
    },
    _equals: function(node) {
      return this.name.equals(node.name) && this.value.equals(node.value);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.name.walk(visitor);
        node.value.walk(visitor);
      });
    },
    _validate: function() {
      must_be_expression(this, "value");
    }
  });
  var AST_Call2 = DEFNODE("Call", "args expression optional pure terminal", {
    $documentation: "A function call expression",
    $propdoc: {
      args: "[AST_Node*] array of arguments",
      expression: "[AST_Node] expression to invoke as function",
      optional: "[boolean] whether the expression is optional chaining",
      pure: "[boolean/S] marker for side-effect-free call expression",
      terminal: "[boolean] whether the chain has ended"
    },
    _equals: function(node) {
      return !this.optional == !node.optional && this.expression.equals(node.expression) && all_equals(this.args, node.args);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.expression.walk(visitor);
        node.args.forEach(function(arg) {
          arg.walk(visitor);
        });
      });
    },
    _validate: function() {
      must_be_expression(this, "expression");
      must_be_expressions(this, "args", true);
    }
  });
  var AST_New2 = DEFNODE("New", null, {
    $documentation: "An object instantiation.  Derives from a function call since it has exactly the same properties",
    _validate: function() {
      if (this.optional)
        throw new Error("optional must be false");
      if (this.terminal)
        throw new Error("terminal must be false");
    }
  }, AST_Call2);
  var AST_Sequence2 = DEFNODE("Sequence", "expressions", {
    $documentation: "A sequence expression (comma-separated expressions)",
    $propdoc: {
      expressions: "[AST_Node*] array of expressions (at least two)"
    },
    _equals: function(node) {
      return all_equals(this.expressions, node.expressions);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.expressions.forEach(function(expr) {
          expr.walk(visitor);
        });
      });
    },
    _validate: function() {
      if (this.expressions.length < 2)
        throw new Error("expressions must contain multiple elements");
      must_be_expressions(this, "expressions");
    }
  });
  var AST_PropAccess2 = DEFNODE("PropAccess", "expression optional property terminal", {
    $documentation: "Base class for property access expressions, i.e. `a.foo` or `a[\"foo\"]`",
    $propdoc: {
      expression: "[AST_Node] the \u201Ccontainer\u201D expression",
      optional: "[boolean] whether the expression is optional chaining",
      property: "[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node",
      terminal: "[boolean] whether the chain has ended"
    },
    _equals: function(node) {
      return !this.optional == !node.optional && prop_equals(this.property, node.property) && this.expression.equals(node.expression);
    },
    get_property: function() {
      var p = this.property;
      if (p instanceof AST_Constant2)
        return p.value;
      if (p instanceof AST_UnaryPrefix2 && p.operator == "void" && p.expression instanceof AST_Constant2)
        return;
      return p;
    },
    _validate: function() {
      if (this.TYPE == "PropAccess")
        throw new Error("should not instantiate AST_PropAccess");
      must_be_expression(this, "expression");
    }
  });
  var AST_Dot2 = DEFNODE("Dot", "quoted", {
    $documentation: "A dotted property access expression",
    $propdoc: {
      quoted: "[boolean] whether property is transformed from a quoted string"
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.expression.walk(visitor);
      });
    },
    _validate: function() {
      if (typeof this.property != "string")
        throw new Error("property must be string");
    }
  }, AST_PropAccess2);
  var AST_Sub2 = DEFNODE("Sub", null, {
    $documentation: "Index-style property access, i.e. `a[\"foo\"]`",
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.expression.walk(visitor);
        node.property.walk(visitor);
      });
    },
    _validate: function() {
      must_be_expression(this, "property");
    }
  }, AST_PropAccess2);
  var AST_Spread2 = DEFNODE("Spread", "expression", {
    $documentation: "Spread expression in array/object literals or function calls",
    $propdoc: {
      expression: "[AST_Node] expression to be expanded"
    },
    _equals: function(node) {
      return this.expression.equals(node.expression);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.expression.walk(visitor);
      });
    },
    _validate: function() {
      must_be_expression(this, "expression");
    }
  });
  var AST_Unary2 = DEFNODE("Unary", "operator expression", {
    $documentation: "Base class for unary expressions",
    $propdoc: {
      operator: "[string] the operator",
      expression: "[AST_Node] expression that this unary operator applies to"
    },
    _equals: function(node) {
      return this.operator == node.operator && this.expression.equals(node.expression);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.expression.walk(visitor);
      });
    },
    _validate: function() {
      if (this.TYPE == "Unary")
        throw new Error("should not instantiate AST_Unary");
      if (typeof this.operator != "string")
        throw new Error("operator must be string");
      must_be_expression(this, "expression");
    }
  });
  var AST_UnaryPrefix2 = DEFNODE("UnaryPrefix", null, {
    $documentation: "Unary prefix expression, i.e. `typeof i` or `++i`"
  }, AST_Unary2);
  var AST_UnaryPostfix2 = DEFNODE("UnaryPostfix", null, {
    $documentation: "Unary postfix expression, i.e. `i++`"
  }, AST_Unary2);
  var AST_Binary2 = DEFNODE("Binary", "operator left right", {
    $documentation: "Binary expression, i.e. `a + b`",
    $propdoc: {
      left: "[AST_Node] left-hand side expression",
      operator: "[string] the operator",
      right: "[AST_Node] right-hand side expression"
    },
    _equals: function(node) {
      return this.operator == node.operator && this.left.equals(node.left) && this.right.equals(node.right);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.left.walk(visitor);
        node.right.walk(visitor);
      });
    },
    _validate: function() {
      if (!(this instanceof AST_Assign2))
        must_be_expression(this, "left");
      if (typeof this.operator != "string")
        throw new Error("operator must be string");
      must_be_expression(this, "right");
    }
  });
  var AST_Conditional2 = DEFNODE("Conditional", "condition consequent alternative", {
    $documentation: "Conditional expression using the ternary operator, i.e. `a ? b : c`",
    $propdoc: {
      condition: "[AST_Node]",
      consequent: "[AST_Node]",
      alternative: "[AST_Node]"
    },
    _equals: function(node) {
      return this.condition.equals(node.condition) && this.consequent.equals(node.consequent) && this.alternative.equals(node.alternative);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.condition.walk(visitor);
        node.consequent.walk(visitor);
        node.alternative.walk(visitor);
      });
    },
    _validate: function() {
      must_be_expression(this, "condition");
      must_be_expression(this, "consequent");
      must_be_expression(this, "alternative");
    }
  });
  var AST_Assign2 = DEFNODE("Assign", null, {
    $documentation: "An assignment expression \u2014 `a = b + 5`",
    _validate: function() {
      if (this.operator.indexOf("=") < 0)
        throw new Error('operator must contain "="');
      if (this.left instanceof AST_Destructured2) {
        if (this.operator != "=")
          throw new Error("invalid destructuring operator: " + this.operator);
        validate_destructured(this.left, function(node) {
          if (!(node instanceof AST_PropAccess2 || node instanceof AST_SymbolRef2)) {
            throw new Error("left must be assignable: " + node.TYPE);
          }
        });
      } else if (!(this.left instanceof AST_Infinity2 || this.left instanceof AST_NaN2 || this.left instanceof AST_PropAccess2 && !this.left.optional || this.left instanceof AST_SymbolRef2 || this.left instanceof AST_Undefined2)) {
        throw new Error("left must be assignable");
      }
    }
  }, AST_Binary2);
  var AST_Await2 = DEFNODE("Await", "expression", {
    $documentation: "An await expression",
    $propdoc: {
      expression: "[AST_Node] expression with Promise to resolve on"
    },
    _equals: function(node) {
      return this.expression.equals(node.expression);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.expression.walk(visitor);
      });
    },
    _validate: function() {
      must_be_expression(this, "expression");
    }
  });
  var AST_Yield2 = DEFNODE("Yield", "expression nested", {
    $documentation: "A yield expression",
    $propdoc: {
      expression: "[AST_Node?] return value for iterator, or null if undefined",
      nested: "[boolean] whether to iterate over expression as generator"
    },
    _equals: function(node) {
      return !this.nested == !node.nested && prop_equals(this.expression, node.expression);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        if (node.expression)
          node.expression.walk(visitor);
      });
    },
    _validate: function() {
      if (this.expression != null) {
        must_be_expression(this, "expression");
      } else if (this.nested) {
        throw new Error("yield* must contain expression");
      }
    }
  });
  var AST_Array2 = DEFNODE("Array", "elements", {
    $documentation: "An array literal",
    $propdoc: {
      elements: "[AST_Node*] array of elements"
    },
    _equals: function(node) {
      return all_equals(this.elements, node.elements);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.elements.forEach(function(element) {
          element.walk(visitor);
        });
      });
    },
    _validate: function() {
      must_be_expressions(this, "elements", true, true);
    }
  });
  var AST_Destructured2 = DEFNODE("Destructured", "rest", {
    $documentation: "Base class for destructured literal",
    $propdoc: {
      rest: "[(AST_Destructured|AST_SymbolDeclaration|AST_SymbolRef)?] rest parameter, or null if absent"
    },
    _validate: function() {
      if (this.TYPE == "Destructured")
        throw new Error("should not instantiate AST_Destructured");
    }
  });
  var AST_DestructuredArray2 = DEFNODE("DestructuredArray", "elements", {
    $documentation: "A destructured array literal",
    $propdoc: {
      elements: "[(AST_DefaultValue|AST_Destructured|AST_SymbolDeclaration|AST_SymbolRef)*] array of elements"
    },
    _equals: function(node) {
      return prop_equals(this.rest, node.rest) && all_equals(this.elements, node.elements);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.elements.forEach(function(element) {
          element.walk(visitor);
        });
        if (node.rest)
          node.rest.walk(visitor);
      });
    }
  }, AST_Destructured2);
  var AST_DestructuredKeyVal2 = DEFNODE("DestructuredKeyVal", "key value", {
    $documentation: "A key: value destructured property",
    $propdoc: {
      key: "[string|AST_Node] property name.  For computed property this is an AST_Node.",
      value: "[AST_DefaultValue|AST_Destructured|AST_SymbolDeclaration|AST_SymbolRef] property value"
    },
    _equals: function(node) {
      return prop_equals(this.key, node.key) && this.value.equals(node.value);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        if (node.key instanceof AST_Node2)
          node.key.walk(visitor);
        node.value.walk(visitor);
      });
    },
    _validate: function() {
      if (typeof this.key != "string") {
        if (!(this.key instanceof AST_Node2))
          throw new Error("key must be string or AST_Node");
        must_be_expression(this, "key");
      }
      if (!(this.value instanceof AST_Node2))
        throw new Error("value must be AST_Node");
    }
  });
  var AST_DestructuredObject2 = DEFNODE("DestructuredObject", "properties", {
    $documentation: "A destructured object literal",
    $propdoc: {
      properties: "[AST_DestructuredKeyVal*] array of properties"
    },
    _equals: function(node) {
      return prop_equals(this.rest, node.rest) && all_equals(this.properties, node.properties);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.properties.forEach(function(prop) {
          prop.walk(visitor);
        });
        if (node.rest)
          node.rest.walk(visitor);
      });
    },
    _validate: function() {
      this.properties.forEach(function(node) {
        if (!(node instanceof AST_DestructuredKeyVal2))
          throw new Error("properties must be AST_DestructuredKeyVal[]");
      });
    }
  }, AST_Destructured2);
  var AST_Object2 = DEFNODE("Object", "properties", {
    $documentation: "An object literal",
    $propdoc: {
      properties: "[(AST_ObjectProperty|AST_Spread)*] array of properties"
    },
    _equals: function(node) {
      return all_equals(this.properties, node.properties);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        node.properties.forEach(function(prop) {
          prop.walk(visitor);
        });
      });
    },
    _validate: function() {
      this.properties.forEach(function(node) {
        if (!(node instanceof AST_ObjectProperty2 || node instanceof AST_Spread2)) {
          throw new Error("properties must contain AST_ObjectProperty and/or AST_Spread only");
        }
      });
    }
  });
  var AST_ObjectProperty2 = DEFNODE("ObjectProperty", "key value", {
    $documentation: "Base class for literal object properties",
    $propdoc: {
      key: "[string|AST_Node] property name.  For computed property this is an AST_Node.",
      value: "[AST_Node] property value.  For getters and setters this is an AST_Accessor."
    },
    _equals: function(node) {
      return prop_equals(this.key, node.key) && this.value.equals(node.value);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        if (node.key instanceof AST_Node2)
          node.key.walk(visitor);
        node.value.walk(visitor);
      });
    },
    _validate: function() {
      if (this.TYPE == "ObjectProperty")
        throw new Error("should not instantiate AST_ObjectProperty");
      if (typeof this.key != "string") {
        if (!(this.key instanceof AST_Node2))
          throw new Error("key must be string or AST_Node");
        must_be_expression(this, "key");
      }
      if (!(this.value instanceof AST_Node2))
        throw new Error("value must be AST_Node");
    }
  });
  var AST_ObjectKeyVal2 = DEFNODE("ObjectKeyVal", null, {
    $documentation: "A key: value object property",
    _validate: function() {
      must_be_expression(this, "value");
    }
  }, AST_ObjectProperty2);
  var AST_ObjectMethod2 = DEFNODE("ObjectMethod", null, {
    $documentation: "A key(){} object property",
    _validate: function() {
      if (!(this.value instanceof AST_LambdaExpression2))
        throw new Error("value must be AST_LambdaExpression");
      if (is_arrow2(this.value))
        throw new Error("value cannot be AST_Arrow or AST_AsyncArrow");
      if (this.value.name != null)
        throw new Error("name of object method's lambda must be null");
    }
  }, AST_ObjectKeyVal2);
  var AST_ObjectSetter2 = DEFNODE("ObjectSetter", null, {
    $documentation: "An object setter property",
    _validate: function() {
      if (!(this.value instanceof AST_Accessor2))
        throw new Error("value must be AST_Accessor");
    }
  }, AST_ObjectProperty2);
  var AST_ObjectGetter2 = DEFNODE("ObjectGetter", null, {
    $documentation: "An object getter property",
    _validate: function() {
      if (!(this.value instanceof AST_Accessor2))
        throw new Error("value must be AST_Accessor");
    }
  }, AST_ObjectProperty2);
  var AST_Symbol2 = DEFNODE("Symbol", "scope name thedef", {
    $documentation: "Base class for all symbols",
    $propdoc: {
      name: "[string] name of this symbol",
      scope: "[AST_Scope/S] the current scope (not necessarily the definition scope)",
      thedef: "[SymbolDef/S] the definition of this symbol"
    },
    _equals: function(node) {
      return this.thedef ? this.thedef === node.thedef : this.name == node.name;
    },
    _validate: function() {
      if (this.TYPE == "Symbol")
        throw new Error("should not instantiate AST_Symbol");
      if (typeof this.name != "string")
        throw new Error("name must be string");
    }
  });
  var AST_SymbolDeclaration2 = DEFNODE("SymbolDeclaration", "init", {
    $documentation: "A declaration symbol (symbol in var, function name or argument, symbol in catch)"
  }, AST_Symbol2);
  var AST_SymbolConst2 = DEFNODE("SymbolConst", null, {
    $documentation: "Symbol defining a constant"
  }, AST_SymbolDeclaration2);
  var AST_SymbolImport2 = DEFNODE("SymbolImport", "key", {
    $documentation: "Symbol defined by an `import` statement",
    $propdoc: {
      key: "[AST_String] the original `export` name"
    },
    _equals: function(node) {
      return this.name == node.name && this.key.equals(node.key);
    },
    _validate: function() {
      if (!(this.key instanceof AST_String2))
        throw new Error("key must be AST_String");
    }
  }, AST_SymbolConst2);
  var AST_SymbolLet2 = DEFNODE("SymbolLet", null, {
    $documentation: "Symbol defining a lexical-scoped variable"
  }, AST_SymbolDeclaration2);
  var AST_SymbolVar2 = DEFNODE("SymbolVar", null, {
    $documentation: "Symbol defining a variable"
  }, AST_SymbolDeclaration2);
  var AST_SymbolFunarg2 = DEFNODE("SymbolFunarg", "unused", {
    $documentation: "Symbol naming a function argument"
  }, AST_SymbolVar2);
  var AST_SymbolDefun2 = DEFNODE("SymbolDefun", null, {
    $documentation: "Symbol defining a function"
  }, AST_SymbolDeclaration2);
  var AST_SymbolLambda2 = DEFNODE("SymbolLambda", null, {
    $documentation: "Symbol naming a function expression"
  }, AST_SymbolDeclaration2);
  var AST_SymbolDefClass2 = DEFNODE("SymbolDefClass", null, {
    $documentation: "Symbol defining a class"
  }, AST_SymbolConst2);
  var AST_SymbolClass2 = DEFNODE("SymbolClass", null, {
    $documentation: "Symbol naming a class expression"
  }, AST_SymbolConst2);
  var AST_SymbolCatch2 = DEFNODE("SymbolCatch", null, {
    $documentation: "Symbol naming the exception in catch"
  }, AST_SymbolDeclaration2);
  var AST_Label2 = DEFNODE("Label", "references", {
    $documentation: "Symbol naming a label (declaration)",
    $propdoc: {
      references: "[AST_LoopControl*] a list of nodes referring to this label"
    },
    initialize: function() {
      this.references = [];
      this.thedef = this;
    }
  }, AST_Symbol2);
  var AST_SymbolRef2 = DEFNODE("SymbolRef", "fixed in_arg redef", {
    $documentation: "Reference to some symbol (not definition/declaration)"
  }, AST_Symbol2);
  var AST_SymbolExport2 = DEFNODE("SymbolExport", "alias", {
    $documentation: "Reference in an `export` statement",
    $propdoc: {
      alias: "[AST_String] the `export` alias"
    },
    _equals: function(node) {
      return this.name == node.name && this.alias.equals(node.alias);
    },
    _validate: function() {
      if (!(this.alias instanceof AST_String2))
        throw new Error("alias must be AST_String");
    }
  }, AST_SymbolRef2);
  var AST_LabelRef2 = DEFNODE("LabelRef", null, {
    $documentation: "Reference to a label symbol"
  }, AST_Symbol2);
  var AST_ObjectIdentity2 = DEFNODE("ObjectIdentity", null, {
    $documentation: "Base class for `super` & `this`",
    _equals: return_true,
    _validate: function() {
      if (this.TYPE == "ObjectIdentity")
        throw new Error("should not instantiate AST_ObjectIdentity");
    }
  }, AST_Symbol2);
  var AST_Super2 = DEFNODE("Super", null, {
    $documentation: "The `super` symbol",
    _validate: function() {
      if (this.name !== "super")
        throw new Error('name must be "super"');
    }
  }, AST_ObjectIdentity2);
  var AST_This2 = DEFNODE("This", null, {
    $documentation: "The `this` symbol",
    _validate: function() {
      if (this.TYPE == "This" && this.name !== "this")
        throw new Error('name must be "this"');
    }
  }, AST_ObjectIdentity2);
  var AST_NewTarget2 = DEFNODE("NewTarget", null, {
    $documentation: "The `new.target` symbol",
    initialize: function() {
      this.name = "new.target";
    },
    _validate: function() {
      if (this.name !== "new.target")
        throw new Error('name must be "new.target": ' + this.name);
    }
  }, AST_This2);
  var AST_Template2 = DEFNODE("Template", "expressions strings tag", {
    $documentation: "A template literal, i.e. tag`str1${expr1}...strN${exprN}strN+1`",
    $propdoc: {
      expressions: "[AST_Node*] the placeholder expressions",
      strings: "[string*] the raw text segments",
      tag: "[AST_Node?] tag function, or null if absent"
    },
    _equals: function(node) {
      return prop_equals(this.tag, node.tag) && list_equals(this.strings, node.strings) && all_equals(this.expressions, node.expressions);
    },
    walk: function(visitor) {
      var node = this;
      visitor.visit(node, function() {
        if (node.tag)
          node.tag.walk(visitor);
        node.expressions.forEach(function(expr) {
          expr.walk(visitor);
        });
      });
    },
    _validate: function() {
      if (this.expressions.length + 1 != this.strings.length) {
        throw new Error("malformed template with " + this.expressions.length + " placeholder(s) but " + this.strings.length + " text segment(s)");
      }
      must_be_expressions(this, "expressions");
      this.strings.forEach(function(string) {
        if (typeof string != "string")
          throw new Error("strings must contain string");
      });
      if (this.tag != null)
        must_be_expression(this, "tag");
    }
  });
  var AST_Constant2 = DEFNODE("Constant", null, {
    $documentation: "Base class for all constants",
    _equals: function(node) {
      return this.value === node.value;
    },
    _validate: function() {
      if (this.TYPE == "Constant")
        throw new Error("should not instantiate AST_Constant");
    }
  });
  var AST_String2 = DEFNODE("String", "quote value", {
    $documentation: "A string literal",
    $propdoc: {
      quote: "[string?] the original quote character",
      value: "[string] the contents of this string"
    },
    _validate: function() {
      if (this.quote != null) {
        if (typeof this.quote != "string")
          throw new Error("quote must be string");
        if (!/^["']$/.test(this.quote))
          throw new Error("invalid quote: " + this.quote);
      }
      if (typeof this.value != "string")
        throw new Error("value must be string");
    }
  }, AST_Constant2);
  var AST_Number2 = DEFNODE("Number", "value", {
    $documentation: "A number literal",
    $propdoc: {
      value: "[number] the numeric value"
    },
    _validate: function() {
      if (typeof this.value != "number")
        throw new Error("value must be number");
      if (!isFinite(this.value))
        throw new Error("value must be finite");
      if (this.value < 0)
        throw new Error("value cannot be negative");
    }
  }, AST_Constant2);
  var AST_BigInt2 = DEFNODE("BigInt", "value", {
    $documentation: "A BigInt literal",
    $propdoc: {
      value: "[string] the numeric representation"
    },
    _validate: function() {
      if (typeof this.value != "string")
        throw new Error("value must be string");
      if (this.value[0] == "-")
        throw new Error("value cannot be negative");
    }
  }, AST_Constant2);
  var AST_RegExp2 = DEFNODE("RegExp", "value", {
    $documentation: "A regexp literal",
    $propdoc: {
      value: "[RegExp] the actual regexp"
    },
    _equals: function(node) {
      return "" + this.value == "" + node.value;
    },
    _validate: function() {
      if (!(this.value instanceof RegExp))
        throw new Error("value must be RegExp");
    }
  }, AST_Constant2);
  var AST_Atom2 = DEFNODE("Atom", null, {
    $documentation: "Base class for atoms",
    _equals: return_true,
    _validate: function() {
      if (this.TYPE == "Atom")
        throw new Error("should not instantiate AST_Atom");
    }
  }, AST_Constant2);
  var AST_Null2 = DEFNODE("Null", null, {
    $documentation: "The `null` atom",
    value: null
  }, AST_Atom2);
  var AST_NaN2 = DEFNODE("NaN", null, {
    $documentation: "The impossible value",
    value: 0 / 0
  }, AST_Atom2);
  var AST_Undefined2 = DEFNODE("Undefined", null, {
    $documentation: "The `undefined` value",
    value: function() {
    }()
  }, AST_Atom2);
  var AST_Hole2 = DEFNODE("Hole", null, {
    $documentation: "A hole in an array",
    value: function() {
    }()
  }, AST_Atom2);
  var AST_Infinity2 = DEFNODE("Infinity", null, {
    $documentation: "The `Infinity` value",
    value: 1 / 0
  }, AST_Atom2);
  var AST_Boolean2 = DEFNODE("Boolean", null, {
    $documentation: "Base class for booleans",
    _validate: function() {
      if (this.TYPE == "Boolean")
        throw new Error("should not instantiate AST_Boolean");
    }
  }, AST_Atom2);
  var AST_False2 = DEFNODE("False", null, {
    $documentation: "The `false` atom",
    value: false
  }, AST_Boolean2);
  var AST_True2 = DEFNODE("True", null, {
    $documentation: "The `true` atom",
    value: true
  }, AST_Boolean2);
  TreeWalker2.prototype = {
    visit: function(node, descend) {
      this.push(node);
      var done = this.callback(node, descend || noop);
      if (!done && descend)
        descend();
      this.pop();
    },
    parent: function(n) {
      return this.stack[this.stack.length - 2 - (n || 0)];
    },
    push: function(node) {
      var value;
      if (node instanceof AST_Class2) {
        this.directives = Object.create(this.directives);
        value = "use strict";
      } else if (node instanceof AST_Directive2) {
        value = node.value;
      } else if (node instanceof AST_Lambda2) {
        this.directives = Object.create(this.directives);
      }
      if (value && !this.directives[value])
        this.directives[value] = node;
      this.stack.push(node);
    },
    pop: function() {
      var node = this.stack.pop();
      if (node instanceof AST_Class2 || node instanceof AST_Lambda2) {
        this.directives = Object.getPrototypeOf(this.directives);
      }
    },
    self: function() {
      return this.stack[this.stack.length - 1];
    },
    find_parent: function(type) {
      var stack = this.stack;
      for (var i = stack.length - 1;--i >= 0; ) {
        var x = stack[i];
        if (x instanceof type)
          return x;
      }
    },
    has_directive: function(type) {
      var dir = this.directives[type];
      if (dir)
        return dir;
      var node = this.stack[this.stack.length - 1];
      if (node instanceof AST_Scope2) {
        for (var i = 0;i < node.body.length; ++i) {
          var st = node.body[i];
          if (!(st instanceof AST_Directive2))
            break;
          if (st.value == type)
            return st;
        }
      }
    },
    loopcontrol_target: function(node) {
      var stack = this.stack;
      if (node.label)
        for (var i = stack.length;--i >= 0; ) {
          var x = stack[i];
          if (x instanceof AST_LabeledStatement2 && x.label.name == node.label.name)
            return x.body;
        }
      else
        for (var i = stack.length;--i >= 0; ) {
          var x = stack[i];
          if (x instanceof AST_IterationStatement2 || node instanceof AST_Break2 && x instanceof AST_Switch2)
            return x;
        }
    },
    in_boolean_context: function() {
      for (var drop = true, level = 0, parent, self = this.self();parent = this.parent(level++); self = parent) {
        if (parent instanceof AST_Binary2)
          switch (parent.operator) {
            case "&&":
            case "||":
              if (parent.left === self)
                drop = false;
              continue;
            default:
              return false;
          }
        if (parent instanceof AST_Conditional2) {
          if (parent.condition === self)
            return true;
          continue;
        }
        if (parent instanceof AST_DWLoop2)
          return parent.condition === self;
        if (parent instanceof AST_For2)
          return parent.condition === self;
        if (parent instanceof AST_If2)
          return parent.condition === self;
        if (parent instanceof AST_Return2) {
          if (parent.in_bool)
            return true;
          while (parent = this.parent(level++)) {
            if (parent instanceof AST_Lambda2) {
              if (parent.name)
                return false;
              parent = this.parent(level++);
              if (parent.TYPE != "Call")
                return false;
              break;
            }
          }
        }
        if (parent instanceof AST_Sequence2) {
          if (parent.tail_node() === self)
            continue;
          return drop ? "d" : true;
        }
        if (parent instanceof AST_SimpleStatement2)
          return drop ? "d" : true;
        if (parent instanceof AST_UnaryPrefix2)
          return parent.operator == "!";
        return false;
      }
    }
  };
});

// node_modules/uglify-js/lib/transform.js
var exports_transform = {};
var TreeTransformer2;
var init_transform = __esm(() => {
  TreeTransformer2 = function(before, after) {
    TreeWalker.call(this);
    this.before = before;
    this.after = after;
  };
  TreeTransformer2.prototype = new TreeWalker;
  (function(DEF) {
    function do_list(list, tw) {
      return List(list, function(node) {
        return node.transform(tw, true);
      });
    }
    DEF(AST_Node, noop);
    DEF(AST_LabeledStatement, function(self, tw) {
      self.label = self.label.transform(tw);
      self.body = self.body.transform(tw);
    });
    DEF(AST_SimpleStatement, function(self, tw) {
      self.body = self.body.transform(tw);
    });
    DEF(AST_Block, function(self, tw) {
      self.body = do_list(self.body, tw);
    });
    DEF(AST_Do, function(self, tw) {
      self.body = self.body.transform(tw);
      self.condition = self.condition.transform(tw);
    });
    DEF(AST_While, function(self, tw) {
      self.condition = self.condition.transform(tw);
      self.body = self.body.transform(tw);
    });
    DEF(AST_For, function(self, tw) {
      if (self.init)
        self.init = self.init.transform(tw);
      if (self.condition)
        self.condition = self.condition.transform(tw);
      if (self.step)
        self.step = self.step.transform(tw);
      self.body = self.body.transform(tw);
    });
    DEF(AST_ForEnumeration, function(self, tw) {
      self.init = self.init.transform(tw);
      self.object = self.object.transform(tw);
      self.body = self.body.transform(tw);
    });
    DEF(AST_With, function(self, tw) {
      self.expression = self.expression.transform(tw);
      self.body = self.body.transform(tw);
    });
    DEF(AST_Exit, function(self, tw) {
      if (self.value)
        self.value = self.value.transform(tw);
    });
    DEF(AST_LoopControl, function(self, tw) {
      if (self.label)
        self.label = self.label.transform(tw);
    });
    DEF(AST_If, function(self, tw) {
      self.condition = self.condition.transform(tw);
      self.body = self.body.transform(tw);
      if (self.alternative)
        self.alternative = self.alternative.transform(tw);
    });
    DEF(AST_Switch, function(self, tw) {
      self.expression = self.expression.transform(tw);
      self.body = do_list(self.body, tw);
    });
    DEF(AST_Case, function(self, tw) {
      self.expression = self.expression.transform(tw);
      self.body = do_list(self.body, tw);
    });
    DEF(AST_Try, function(self, tw) {
      self.body = do_list(self.body, tw);
      if (self.bcatch)
        self.bcatch = self.bcatch.transform(tw);
      if (self.bfinally)
        self.bfinally = self.bfinally.transform(tw);
    });
    DEF(AST_Catch, function(self, tw) {
      if (self.argname)
        self.argname = self.argname.transform(tw);
      self.body = do_list(self.body, tw);
    });
    DEF(AST_Definitions, function(self, tw) {
      self.definitions = do_list(self.definitions, tw);
    });
    DEF(AST_VarDef, function(self, tw) {
      self.name = self.name.transform(tw);
      if (self.value)
        self.value = self.value.transform(tw);
    });
    DEF(AST_DefaultValue, function(self, tw) {
      self.name = self.name.transform(tw);
      self.value = self.value.transform(tw);
    });
    DEF(AST_Lambda, function(self, tw) {
      if (self.name)
        self.name = self.name.transform(tw);
      self.argnames = do_list(self.argnames, tw);
      if (self.rest)
        self.rest = self.rest.transform(tw);
      self.body = do_list(self.body, tw);
    });
    function transform_arrow(self, tw) {
      self.argnames = do_list(self.argnames, tw);
      if (self.rest)
        self.rest = self.rest.transform(tw);
      if (self.value) {
        self.value = self.value.transform(tw);
      } else {
        self.body = do_list(self.body, tw);
      }
    }
    DEF(AST_Arrow, transform_arrow);
    DEF(AST_AsyncArrow, transform_arrow);
    DEF(AST_Class, function(self, tw) {
      if (self.name)
        self.name = self.name.transform(tw);
      if (self.extends)
        self.extends = self.extends.transform(tw);
      self.properties = do_list(self.properties, tw);
    });
    DEF(AST_ClassProperty, function(self, tw) {
      if (self.key instanceof AST_Node)
        self.key = self.key.transform(tw);
      if (self.value)
        self.value = self.value.transform(tw);
    });
    DEF(AST_Call, function(self, tw) {
      self.expression = self.expression.transform(tw);
      self.args = do_list(self.args, tw);
    });
    DEF(AST_Sequence, function(self, tw) {
      self.expressions = do_list(self.expressions, tw);
    });
    DEF(AST_Await, function(self, tw) {
      self.expression = self.expression.transform(tw);
    });
    DEF(AST_Yield, function(self, tw) {
      if (self.expression)
        self.expression = self.expression.transform(tw);
    });
    DEF(AST_Dot, function(self, tw) {
      self.expression = self.expression.transform(tw);
    });
    DEF(AST_Sub, function(self, tw) {
      self.expression = self.expression.transform(tw);
      self.property = self.property.transform(tw);
    });
    DEF(AST_Spread, function(self, tw) {
      self.expression = self.expression.transform(tw);
    });
    DEF(AST_Unary, function(self, tw) {
      self.expression = self.expression.transform(tw);
    });
    DEF(AST_Binary, function(self, tw) {
      self.left = self.left.transform(tw);
      self.right = self.right.transform(tw);
    });
    DEF(AST_Conditional, function(self, tw) {
      self.condition = self.condition.transform(tw);
      self.consequent = self.consequent.transform(tw);
      self.alternative = self.alternative.transform(tw);
    });
    DEF(AST_Array, function(self, tw) {
      self.elements = do_list(self.elements, tw);
    });
    DEF(AST_DestructuredArray, function(self, tw) {
      self.elements = do_list(self.elements, tw);
      if (self.rest)
        self.rest = self.rest.transform(tw);
    });
    DEF(AST_DestructuredKeyVal, function(self, tw) {
      if (self.key instanceof AST_Node)
        self.key = self.key.transform(tw);
      self.value = self.value.transform(tw);
    });
    DEF(AST_DestructuredObject, function(self, tw) {
      self.properties = do_list(self.properties, tw);
      if (self.rest)
        self.rest = self.rest.transform(tw);
    });
    DEF(AST_Object, function(self, tw) {
      self.properties = do_list(self.properties, tw);
    });
    DEF(AST_ObjectProperty, function(self, tw) {
      if (self.key instanceof AST_Node)
        self.key = self.key.transform(tw);
      self.value = self.value.transform(tw);
    });
    DEF(AST_ExportDeclaration, function(self, tw) {
      self.body = self.body.transform(tw);
    });
    DEF(AST_ExportDefault, function(self, tw) {
      self.body = self.body.transform(tw);
    });
    DEF(AST_ExportReferences, function(self, tw) {
      self.properties = do_list(self.properties, tw);
    });
    DEF(AST_Import, function(self, tw) {
      if (self.all)
        self.all = self.all.transform(tw);
      if (self.default)
        self.default = self.default.transform(tw);
      if (self.properties)
        self.properties = do_list(self.properties, tw);
    });
    DEF(AST_Template, function(self, tw) {
      if (self.tag)
        self.tag = self.tag.transform(tw);
      self.expressions = do_list(self.expressions, tw);
    });
  })(function(node, descend) {
    node.DEFMETHOD("transform", function(tw, in_list) {
      var x, y;
      tw.push(this);
      if (tw.before)
        x = tw.before(this, descend, in_list);
      if (typeof x === "undefined") {
        x = this;
        descend(x, tw);
        if (tw.after) {
          y = tw.after(x, in_list);
          if (typeof y !== "undefined")
            x = y;
        }
      }
      tw.pop();
      return x;
    });
  });
});

// node_modules/uglify-js/lib/parse.js
var exports_parse = {};
var JS_Parse_Error2, KEYWORDS, KEYWORDS_ATOM, RESERVED_WORDS2, KEYWORDS_BEFORE_EXPRESSION, OPERATORS, NEWLINE_CHARS, OPERATOR_CHARS, PUNC_OPENERS, PUNC_SEPARATORS, PUNC_CLOSERS, PUNC_AFTER_EXPRESSION, PUNC_BEFORE_EXPRESSION, PUNC_CHARS, WHITESPACE_CHARS, NON_IDENTIFIER_CHARS, UNARY_PREFIX, UNARY_POSTFIX2, ASSIGNMENT, PRECEDENCE2, ATOMIC_START_TOKEN;
var init_parse = __esm(() => {
  JS_Parse_Error2 = function(message, filename, line, col, pos) {
    this.message = message;
    this.filename = filename;
    this.line = line;
    this.col = col;
    this.pos = pos;
  };
  KEYWORDS = "break case catch class const continue debugger default delete do else extends finally for function if in instanceof new return switch throw try typeof var void while with";
  KEYWORDS_ATOM = "false null true";
  RESERVED_WORDS2 = [
    "abstract async await boolean byte char double enum export final float goto implements import int interface let long native package private protected public short static super synchronized this throws transient volatile yield",
    KEYWORDS_ATOM,
    KEYWORDS
  ].join(" ");
  KEYWORDS_BEFORE_EXPRESSION = "return new delete throw else case";
  KEYWORDS = makePredicate(KEYWORDS);
  RESERVED_WORDS2 = makePredicate(RESERVED_WORDS2);
  KEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);
  KEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);
  OPERATORS = makePredicate([
    "in",
    "instanceof",
    "typeof",
    "new",
    "void",
    "delete",
    "++",
    "--",
    "+",
    "-",
    "!",
    "~",
    "&",
    "|",
    "^",
    "*",
    "/",
    "%",
    "**",
    ">>",
    "<<",
    ">>>",
    "<",
    ">",
    "<=",
    ">=",
    "==",
    "===",
    "!=",
    "!==",
    "?",
    "=",
    "+=",
    "-=",
    "/=",
    "*=",
    "%=",
    "**=",
    ">>=",
    "<<=",
    ">>>=",
    "&=",
    "|=",
    "^=",
    "&&",
    "||",
    "??",
    "&&=",
    "||=",
    "??="
  ]);
  NEWLINE_CHARS = `
\r\u2028\u2029`;
  OPERATOR_CHARS = "+-*&%=<>!?|~^";
  PUNC_OPENERS = "[{(";
  PUNC_SEPARATORS = ",;:";
  PUNC_CLOSERS = ")}]";
  PUNC_AFTER_EXPRESSION = PUNC_SEPARATORS + PUNC_CLOSERS;
  PUNC_BEFORE_EXPRESSION = PUNC_OPENERS + PUNC_SEPARATORS;
  PUNC_CHARS = PUNC_BEFORE_EXPRESSION + "`" + PUNC_CLOSERS;
  WHITESPACE_CHARS = NEWLINE_CHARS + " \xA0\t\f\v\u200B\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\uFEFF";
  NON_IDENTIFIER_CHARS = makePredicate(characters("./'\"#" + OPERATOR_CHARS + PUNC_CHARS + WHITESPACE_CHARS));
  NEWLINE_CHARS = makePredicate(characters(NEWLINE_CHARS));
  OPERATOR_CHARS = makePredicate(characters(OPERATOR_CHARS));
  PUNC_AFTER_EXPRESSION = makePredicate(characters(PUNC_AFTER_EXPRESSION));
  PUNC_BEFORE_EXPRESSION = makePredicate(characters(PUNC_BEFORE_EXPRESSION));
  PUNC_CHARS = makePredicate(characters(PUNC_CHARS));
  WHITESPACE_CHARS = makePredicate(characters(WHITESPACE_CHARS));
  JS_Parse_Error2.prototype = Object.create(Error.prototype);
  JS_Parse_Error2.prototype.constructor = JS_Parse_Error2;
  JS_Parse_Error2.prototype.name = "SyntaxError";
  configure_error_stack(JS_Parse_Error2);
  UNARY_PREFIX = makePredicate("typeof void delete -- ++ ! ~ - +");
  UNARY_POSTFIX2 = makePredicate("-- ++");
  ASSIGNMENT = makePredicate("= += -= /= *= %= **= >>= <<= >>>= &= |= ^= &&= ||= ??=");
  PRECEDENCE2 = function(a, ret) {
    for (var i = 0;i < a.length; ) {
      var b = a[i++];
      for (var j = 0;j < b.length; j++) {
        ret[b[j]] = i;
      }
    }
    return ret;
  }([
    ["??"],
    ["||"],
    ["&&"],
    ["|"],
    ["^"],
    ["&"],
    ["==", "===", "!=", "!=="],
    ["<", ">", "<=", ">=", "in", "instanceof"],
    [">>", "<<", ">>>"],
    ["+", "-"],
    ["*", "/", "%"],
    ["**"]
  ], {});
  ATOMIC_START_TOKEN = makePredicate("atom bigint num regexp string");
});

// node_modules/uglify-js/lib/scope.js
var exports_scope = {};
var SymbolDef, is_funarg2, is_lhs2, init_block_vars, init_scope_vars, names_in_use, next_mangled_name, _default_mangler_options, unary_side_effects2, base542;
var init_scope = __esm(() => {
  SymbolDef = function(id, scope, orig, init) {
    this._bits = 0;
    this.defun = undefined;
    this.eliminated = 0;
    this.id = id;
    this.init = init;
    this.mangled_name = null;
    this.name = orig.name;
    this.orig = [orig];
    this.references = [];
    this.replaced = 0;
    this.safe_ids = undefined;
    this.scope = scope;
  };
  is_funarg2 = function(def) {
    return def.orig[0] instanceof AST_SymbolFunarg || def.orig[1] instanceof AST_SymbolFunarg;
  };
  is_lhs2 = function(node, parent) {
    if (parent instanceof AST_Assign)
      return parent.left === node && node;
    if (parent instanceof AST_DefaultValue)
      return parent.name === node && node;
    if (parent instanceof AST_Destructured)
      return node;
    if (parent instanceof AST_DestructuredKeyVal)
      return node;
    if (parent instanceof AST_ForEnumeration)
      return parent.init === node && node;
    if (parent instanceof AST_Unary)
      return unary_side_effects2[parent.operator] && parent.expression;
  };
  init_block_vars = function(scope, parent) {
    scope.enclosed = [];
    scope.parent_scope = parent;
    scope.functions = new Dictionary;
    scope.variables = new Dictionary;
    if (parent)
      scope.make_def = parent.make_def;
  };
  init_scope_vars = function(scope, parent) {
    init_block_vars(scope, parent);
    scope.uses_eval = false;
    scope.uses_with = false;
  };
  names_in_use = function(scope, options) {
    var names = scope.names_in_use;
    if (!names) {
      scope.cname = -1;
      scope.cname_holes = [];
      scope.names_in_use = names = new Dictionary;
      var cache = options.cache && options.cache.props;
      scope.enclosed.forEach(function(def) {
        if (def.unmangleable(options))
          names.set(def.name, true);
        if (def.global && cache && cache.has(def.name)) {
          names.set(cache.get(def.name), true);
        }
      });
    }
    return names;
  };
  next_mangled_name = function(def, options) {
    var scope = def.scope;
    var in_use = names_in_use(scope, options);
    var holes = scope.cname_holes;
    var names = new Dictionary;
    var scopes = [scope];
    def.forEach(function(sym) {
      var scope2 = sym.scope;
      do {
        if (member(scope2, scopes))
          break;
        names_in_use(scope2, options).each(function(marker, name2) {
          names.set(name2, marker);
        });
        scopes.push(scope2);
      } while (scope2 = scope2.parent_scope);
    });
    var name;
    for (var i = 0;i < holes.length; i++) {
      name = base542(holes[i]);
      if (names.has(name))
        continue;
      holes.splice(i, 1);
      in_use.set(name, true);
      return name;
    }
    while (true) {
      name = base542(++scope.cname);
      if (in_use.has(name) || RESERVED_WORDS[name] || options.reserved.has[name])
        continue;
      if (!names.has(name))
        break;
      holes.push(scope.cname);
    }
    in_use.set(name, true);
    return name;
  };
  _default_mangler_options = function(options) {
    options = defaults(options, {
      eval: false,
      ie: false,
      keep_fargs: false,
      keep_fnames: false,
      reserved: [],
      toplevel: false,
      v8: false,
      webkit: false
    });
    if (!Array.isArray(options.reserved))
      options.reserved = [];
    push_uniq(options.reserved, "arguments");
    options.reserved.has = makePredicate(options.reserved);
    return options;
  };
  SymbolDef.prototype = {
    forEach: function(fn) {
      this.orig.forEach(fn);
      this.references.forEach(fn);
    },
    mangle: function(options) {
      if (this.mangled_name)
        return;
      var cache = this.global && options.cache && options.cache.props;
      if (cache && cache.has(this.name)) {
        this.mangled_name = cache.get(this.name);
      } else if (this.unmangleable(options)) {
        names_in_use(this.scope, options).set(this.name, true);
      } else {
        var def = this.redefined();
        if (def) {
          this.mangled_name = def.mangled_name || def.name;
        } else {
          this.mangled_name = next_mangled_name(this, options);
        }
        if (cache)
          cache.set(this.name, this.mangled_name);
      }
    },
    redefined: function() {
      var self = this;
      var scope = self.defun;
      if (!scope)
        return;
      var name = self.name;
      var def = scope.variables.get(name) || scope instanceof AST_Toplevel && scope.globals.get(name) || self.orig[0] instanceof AST_SymbolConst && find_if(function(def2) {
        return def2.name == name;
      }, scope.enclosed);
      if (def && def !== self)
        return def.redefined() || def;
    },
    unmangleable: function(options) {
      if (this.exported)
        return true;
      if (this.undeclared)
        return true;
      if (!options.eval && this.scope.pinned())
        return true;
      if (options.keep_fargs && is_funarg2(this))
        return true;
      if (options.keep_fnames) {
        var sym = this.orig[0];
        if (sym instanceof AST_SymbolClass)
          return true;
        if (sym instanceof AST_SymbolDefClass)
          return true;
        if (sym instanceof AST_SymbolDefun)
          return true;
        if (sym instanceof AST_SymbolLambda)
          return true;
      }
      if (!options.toplevel && this.global)
        return true;
      return false;
    }
  };
  DEF_BITPROPS(SymbolDef, [
    "const_redefs",
    "cross_loop",
    "direct_access",
    "exported",
    "global",
    "undeclared"
  ]);
  unary_side_effects2 = makePredicate("delete ++ --");
  AST_Toplevel.DEFMETHOD("figure_out_scope", function(options) {
    options = defaults(options, {
      cache: null,
      ie: false
    });
    var self = this;
    var defun = null;
    var exported = false;
    var next_def_id = 0;
    var scope = self.parent_scope = null;
    var tw = new TreeWalker(function(node, descend) {
      if (node instanceof AST_DefClass) {
        var save_exported = exported;
        exported = tw.parent() instanceof AST_ExportDeclaration;
        node.name.walk(tw);
        exported = save_exported;
        walk_scope(function() {
          if (node.extends)
            node.extends.walk(tw);
          node.properties.forEach(function(prop) {
            prop.walk(tw);
          });
        });
        return true;
      }
      if (node instanceof AST_Definitions) {
        var save_exported = exported;
        exported = tw.parent() instanceof AST_ExportDeclaration;
        descend();
        exported = save_exported;
        return true;
      }
      if (node instanceof AST_LambdaDefinition) {
        var save_exported = exported;
        exported = tw.parent() instanceof AST_ExportDeclaration;
        node.name.walk(tw);
        exported = save_exported;
        walk_scope(function() {
          node.argnames.forEach(function(argname) {
            argname.walk(tw);
          });
          if (node.rest)
            node.rest.walk(tw);
          walk_body(node, tw);
        });
        return true;
      }
      if (node instanceof AST_SwitchBranch) {
        node.init_vars(scope);
        descend();
        return true;
      }
      if (node instanceof AST_Try) {
        walk_scope(function() {
          walk_body(node, tw);
        });
        if (node.bcatch)
          node.bcatch.walk(tw);
        if (node.bfinally)
          node.bfinally.walk(tw);
        return true;
      }
      if (node instanceof AST_With) {
        var s = scope;
        do {
          s = s.resolve();
          if (s.uses_with)
            break;
          s.uses_with = true;
        } while (s = s.parent_scope);
        walk_scope(descend);
        return true;
      }
      if (node instanceof AST_BlockScope) {
        walk_scope(descend);
        return true;
      }
      if (node instanceof AST_Symbol) {
        node.scope = scope;
      }
      if (node instanceof AST_Label) {
        node.thedef = node;
        node.references = [];
      }
      if (node instanceof AST_SymbolCatch) {
        scope.def_variable(node).defun = defun;
      } else if (node instanceof AST_SymbolConst) {
        var def = scope.def_variable(node);
        def.defun = defun;
        if (exported)
          def.exported = true;
      } else if (node instanceof AST_SymbolDefun) {
        var def = defun.def_function(node, tw.parent());
        if (exported)
          def.exported = true;
      } else if (node instanceof AST_SymbolFunarg) {
        defun.def_variable(node);
      } else if (node instanceof AST_SymbolLambda) {
        var def = defun.def_function(node, node.name == "arguments" ? undefined : defun);
        if (options.ie && node.name != "arguments")
          def.defun = defun.parent_scope.resolve();
      } else if (node instanceof AST_SymbolLet) {
        var def = scope.def_variable(node);
        if (exported)
          def.exported = true;
      } else if (node instanceof AST_SymbolVar) {
        var def = defun.def_variable(node, node instanceof AST_SymbolImport ? undefined : null);
        if (exported)
          def.exported = true;
      }
      function walk_scope(descend2) {
        node.init_vars(scope);
        var save_defun = defun;
        var save_scope = scope;
        if (node instanceof AST_Scope)
          defun = node;
        scope = node;
        descend2();
        scope = save_scope;
        defun = save_defun;
      }
    });
    self.make_def = function(orig, init) {
      return new SymbolDef(++next_def_id, this, orig, init);
    };
    self.walk(tw);
    self.globals = new Dictionary;
    var in_arg = [];
    var tw = new TreeWalker(function(node) {
      if (node instanceof AST_Catch) {
        if (!(node.argname instanceof AST_Destructured))
          return;
        in_arg.push(node);
        node.argname.walk(tw);
        in_arg.pop();
        walk_body(node, tw);
        return true;
      }
      if (node instanceof AST_Lambda) {
        in_arg.push(node);
        if (node.name)
          node.name.walk(tw);
        node.argnames.forEach(function(argname) {
          argname.walk(tw);
        });
        if (node.rest)
          node.rest.walk(tw);
        in_arg.pop();
        walk_lambda(node, tw);
        return true;
      }
      if (node instanceof AST_LoopControl) {
        if (node.label)
          node.label.thedef.references.push(node);
        return true;
      }
      if (node instanceof AST_SymbolDeclaration) {
        var def = node.definition();
        def.preinit = def.references.length;
        if (node instanceof AST_SymbolCatch) {
          var redef = def.redefined();
          if (redef)
            for (var s = node.scope;s; s = s.parent_scope) {
              if (!push_uniq(s.enclosed, redef))
                break;
              if (s === redef.scope)
                break;
            }
        } else if (node instanceof AST_SymbolConst) {
          var redef = def.redefined();
          if (redef)
            redef.const_redefs = true;
        } else if (def.scope !== node.scope && (node instanceof AST_SymbolDefun || node instanceof AST_SymbolFunarg || node instanceof AST_SymbolVar)) {
          node.mark_enclosed(options);
          var redef = node.scope.find_variable(node.name);
          if (node.thedef !== redef) {
            node.thedef = redef;
            redef.orig.push(node);
            node.mark_enclosed(options);
          }
        }
        if (node.name != "arguments")
          return true;
        var parent = node instanceof AST_SymbolVar && tw.parent();
        if (parent instanceof AST_VarDef && !parent.value)
          return true;
        var sym = node.scope.resolve().find_variable("arguments");
        if (sym && is_arguments(sym))
          sym.scope.uses_arguments = 3;
        return true;
      }
      if (node instanceof AST_SymbolRef) {
        var name = node.name;
        var sym = node.scope.find_variable(name);
        for (var i = in_arg.length;i > 0 && sym; ) {
          i = in_arg.lastIndexOf(sym.scope, i - 1);
          if (i < 0)
            break;
          var decl = sym.orig[0];
          if (decl instanceof AST_SymbolCatch || decl instanceof AST_SymbolFunarg || decl instanceof AST_SymbolLambda) {
            node.in_arg = true;
            break;
          }
          sym = sym.scope.parent_scope.find_variable(name);
        }
        if (!sym) {
          sym = self.def_global(node);
        } else if (name == "arguments" && is_arguments(sym)) {
          var parent = tw.parent();
          if (is_lhs2(node, parent)) {
            sym.scope.uses_arguments = 3;
          } else if (sym.scope.uses_arguments < 2 && !(parent instanceof AST_PropAccess && parent.expression === node)) {
            sym.scope.uses_arguments = 2;
          } else if (!sym.scope.uses_arguments) {
            sym.scope.uses_arguments = true;
          }
        }
        if (name == "eval") {
          var parent = tw.parent();
          if (parent.TYPE == "Call" && parent.expression === node) {
            var s = node.scope;
            do {
              s = s.resolve();
              if (s.uses_eval)
                break;
              s.uses_eval = true;
            } while (s = s.parent_scope);
          } else if (sym.undeclared) {
            self.uses_eval = true;
          }
        }
        if (sym.init instanceof AST_LambdaDefinition && sym.scope !== sym.init.name.scope) {
          var scope2 = node.scope;
          do {
            if (scope2 === sym.init.name.scope)
              break;
          } while (scope2 = scope2.parent_scope);
          if (!scope2)
            sym.init = undefined;
        }
        node.thedef = sym;
        node.reference(options);
        return true;
      }
    });
    self.walk(tw);
    if (options.ie)
      self.walk(new TreeWalker(function(node) {
        if (node instanceof AST_SymbolCatch) {
          var def = node.thedef;
          var scope2 = def.defun;
          if (def.name != "arguments" && scope2.name instanceof AST_SymbolLambda && scope2.name.name == def.name) {
            scope2 = scope2.parent_scope.resolve();
          }
          redefine(node, scope2);
          return true;
        }
        if (node instanceof AST_SymbolLambda) {
          var def = node.thedef;
          if (!redefine(node, node.scope.parent_scope.resolve())) {
            def.defun = undefined;
          } else if (typeof node.thedef.init !== "undefined") {
            node.thedef.init = false;
          } else if (def.init) {
            node.thedef.init = def.init;
          }
          return true;
        }
      }));
    function is_arguments(sym) {
      return sym.orig[0] instanceof AST_SymbolFunarg && !(sym.orig[1] instanceof AST_SymbolFunarg || sym.orig[2] instanceof AST_SymbolFunarg) && !is_arrow(sym.scope);
    }
    function redefine(node, scope2) {
      var name = node.name;
      var old_def = node.thedef;
      if (!all(old_def.orig, function(sym) {
        return !(sym instanceof AST_SymbolConst || sym instanceof AST_SymbolLet);
      }))
        return false;
      var new_def = scope2.find_variable(name);
      if (new_def) {
        var redef = new_def.redefined();
        if (redef)
          new_def = redef;
      } else {
        new_def = self.globals.get(name);
      }
      if (new_def) {
        new_def.orig.push(node);
      } else {
        new_def = scope2.def_variable(node);
      }
      if (new_def.undeclared)
        self.variables.set(name, new_def);
      if (name == "arguments" && is_arguments(old_def) && node instanceof AST_SymbolLambda)
        return true;
      old_def.defun = new_def.scope;
      old_def.forEach(function(node2) {
        node2.redef = old_def;
        node2.thedef = new_def;
        node2.reference(options);
      });
      return true;
    }
  });
  AST_Toplevel.DEFMETHOD("def_global", function(node) {
    var globals = this.globals, name = node.name;
    if (globals.has(name)) {
      return globals.get(name);
    } else {
      var g = this.make_def(node);
      g.undeclared = true;
      g.global = true;
      globals.set(name, g);
      return g;
    }
  });
  AST_BlockScope.DEFMETHOD("init_vars", function(parent_scope) {
    init_block_vars(this, parent_scope);
  });
  AST_Scope.DEFMETHOD("init_vars", function(parent_scope) {
    init_scope_vars(this, parent_scope);
  });
  AST_Arrow.DEFMETHOD("init_vars", function(parent_scope) {
    init_scope_vars(this, parent_scope);
    return this;
  });
  AST_AsyncArrow.DEFMETHOD("init_vars", function(parent_scope) {
    init_scope_vars(this, parent_scope);
  });
  AST_Lambda.DEFMETHOD("init_vars", function(parent_scope) {
    init_scope_vars(this, parent_scope);
    this.uses_arguments = false;
    this.def_variable(new AST_SymbolFunarg({
      name: "arguments",
      scope: this,
      start: this.start,
      end: this.end
    }));
    return this;
  });
  AST_Symbol.DEFMETHOD("mark_enclosed", function(options) {
    var def = this.definition();
    for (var s = this.scope;s; s = s.parent_scope) {
      if (!push_uniq(s.enclosed, def))
        break;
      if (!options) {
        s._var_names = undefined;
      } else {
        if (options.keep_fargs && s instanceof AST_Lambda)
          s.each_argname(function(arg) {
            push_uniq(def.scope.enclosed, arg.definition());
          });
        if (options.keep_fnames)
          s.functions.each(function(d) {
            push_uniq(def.scope.enclosed, d);
          });
      }
      if (s === def.scope)
        break;
    }
  });
  AST_Symbol.DEFMETHOD("reference", function(options) {
    this.definition().references.push(this);
    this.mark_enclosed(options);
  });
  AST_BlockScope.DEFMETHOD("find_variable", function(name) {
    return this.variables.get(name) || this.parent_scope && this.parent_scope.find_variable(name);
  });
  AST_BlockScope.DEFMETHOD("def_function", function(symbol, init) {
    var def = this.def_variable(symbol, init);
    if (!def.init || def.init instanceof AST_LambdaDefinition)
      def.init = init;
    this.functions.set(symbol.name, def);
    return def;
  });
  AST_BlockScope.DEFMETHOD("def_variable", function(symbol, init) {
    var def = this.variables.get(symbol.name);
    if (def) {
      def.orig.push(symbol);
      if (def.init instanceof AST_LambdaExpression)
        def.init = init;
    } else {
      def = this.make_def(symbol, init);
      this.variables.set(symbol.name, def);
      def.global = !this.parent_scope;
    }
    return symbol.thedef = def;
  });
  AST_Symbol.DEFMETHOD("unmangleable", function(options) {
    var def = this.definition();
    return !def || def.unmangleable(options);
  });
  AST_Label.DEFMETHOD("unmangleable", return_false);
  AST_Symbol.DEFMETHOD("definition", function() {
    return this.thedef;
  });
  AST_Toplevel.DEFMETHOD("mangle_names", function(options) {
    options = _default_mangler_options(options);
    if (options.cache && options.cache.props) {
      var mangled_names = names_in_use(this, options);
      options.cache.props.each(function(mangled_name) {
        mangled_names.set(mangled_name, true);
      });
    }
    var cutoff = 36;
    var lname = -1;
    var redefined = [];
    var tw = new TreeWalker(function(node, descend) {
      var save_nesting;
      if (node instanceof AST_BlockScope) {
        if (node instanceof AST_LabeledStatement)
          save_nesting = lname;
        if (options.webkit && node instanceof AST_IterationStatement && node.init instanceof AST_Let) {
          node.init.definitions.forEach(function(defn) {
            defn.name.match_symbol(function(sym2) {
              if (!(sym2 instanceof AST_SymbolLet))
                return;
              var def = sym2.definition();
              var scope = sym2.scope.parent_scope;
              var redef = scope.def_variable(sym2);
              sym2.thedef = def;
              scope.to_mangle.push(redef);
              def.redefined = function() {
                return redef;
              };
            });
          }, true);
        }
        var to_mangle = node.to_mangle = [];
        node.variables.each(function(def) {
          if (!defer_redef(def))
            to_mangle.push(def);
        });
        descend();
        if (options.cache && node instanceof AST_Toplevel) {
          node.globals.each(mangle);
        }
        if (node instanceof AST_Defun && tw.has_directive("use asm")) {
          var sym = new AST_SymbolRef(node.name);
          sym.scope = node;
          sym.reference(options);
        }
        if (to_mangle.length > cutoff) {
          var indices = to_mangle.map(function(def, index) {
            return index;
          }).sort(function(i, j) {
            return to_mangle[j].references.length - to_mangle[i].references.length || i - j;
          });
          to_mangle = indices.slice(0, cutoff).sort(function(i, j) {
            return i - j;
          }).map(function(index) {
            return to_mangle[index];
          }).concat(indices.slice(cutoff).sort(function(i, j) {
            return i - j;
          }).map(function(index) {
            return to_mangle[index];
          }));
        }
        to_mangle.forEach(mangle);
        if (node instanceof AST_LabeledStatement && !(options.v8 && in_label(tw)))
          lname = save_nesting;
        return true;
      }
      if (node instanceof AST_Label) {
        var name;
        do {
          name = base542(++lname);
        } while (RESERVED_WORDS[name]);
        node.mangled_name = name;
        return true;
      }
    });
    this.walk(tw);
    redefined.forEach(mangle);
    function mangle(def) {
      if (options.reserved.has[def.name])
        return;
      def.mangle(options);
    }
    function defer_redef(def) {
      var sym = def.orig[0];
      var redef = def.redefined();
      if (!redef) {
        if (!(sym instanceof AST_SymbolConst))
          return false;
        var scope = def.scope.resolve();
        if (def.scope === scope)
          return false;
        if (def.scope.parent_scope.find_variable(sym.name))
          return false;
        redef = scope.def_variable(sym);
        scope.to_mangle.push(redef);
      }
      redefined.push(def);
      def.references.forEach(reference);
      if (sym instanceof AST_SymbolCatch || sym instanceof AST_SymbolConst) {
        reference(sym);
        def.redefined = function() {
          return redef;
        };
      }
      return true;
      function reference(sym2) {
        sym2.thedef = redef;
        sym2.reference(options);
        sym2.thedef = def;
      }
    }
    function in_label(tw2) {
      var level = 0, parent;
      while (parent = tw2.parent(level++)) {
        if (parent instanceof AST_Block)
          return parent instanceof AST_Toplevel && !options.toplevel;
        if (parent instanceof AST_LabeledStatement)
          return true;
      }
    }
  });
  AST_Toplevel.DEFMETHOD("find_colliding_names", function(options) {
    var cache = options.cache && options.cache.props;
    var avoid = Object.create(RESERVED_WORDS);
    options.reserved.forEach(to_avoid);
    this.globals.each(add_def);
    this.walk(new TreeWalker(function(node) {
      if (node instanceof AST_BlockScope)
        node.variables.each(add_def);
    }));
    return avoid;
    function to_avoid(name) {
      avoid[name] = true;
    }
    function add_def(def) {
      var name = def.name;
      if (def.global && cache && cache.has(name))
        name = cache.get(name);
      else if (!def.unmangleable(options))
        return;
      to_avoid(name);
    }
  });
  AST_Toplevel.DEFMETHOD("expand_names", function(options) {
    base542.reset();
    base542.sort();
    options = _default_mangler_options(options);
    var avoid = this.find_colliding_names(options);
    var cname = 0;
    this.globals.each(rename);
    this.walk(new TreeWalker(function(node) {
      if (node instanceof AST_BlockScope)
        node.variables.each(rename);
    }));
    function next_name() {
      var name;
      do {
        name = base542(cname++);
      } while (avoid[name]);
      return name;
    }
    function rename(def) {
      if (def.global && options.cache)
        return;
      if (def.unmangleable(options))
        return;
      if (options.reserved.has[def.name])
        return;
      var redef = def.redefined();
      var name = redef ? redef.rename || redef.name : next_name();
      def.rename = name;
      def.forEach(function(sym) {
        if (sym.definition() === def)
          sym.name = name;
      });
    }
  });
  AST_Node.DEFMETHOD("tail_node", return_this);
  AST_Sequence.DEFMETHOD("tail_node", function() {
    return this.expressions[this.expressions.length - 1];
  });
  AST_Toplevel.DEFMETHOD("compute_char_frequency", function(options) {
    options = _default_mangler_options(options);
    base542.reset();
    var fn = AST_Symbol.prototype.add_source_map;
    try {
      AST_Symbol.prototype.add_source_map = function() {
        if (!this.unmangleable(options))
          base542.consider(this.name, -1);
      };
      if (options.properties) {
        AST_Dot.prototype.add_source_map = function() {
          base542.consider(this.property, -1);
        };
        AST_Sub.prototype.add_source_map = function() {
          skip_string(this.property);
        };
      }
      base542.consider(this.print_to_string(), 1);
    } finally {
      AST_Symbol.prototype.add_source_map = fn;
      delete AST_Dot.prototype.add_source_map;
      delete AST_Sub.prototype.add_source_map;
    }
    base542.sort();
    function skip_string(node) {
      if (node instanceof AST_String) {
        base542.consider(node.value, -1);
      } else if (node instanceof AST_Conditional) {
        skip_string(node.consequent);
        skip_string(node.alternative);
      } else if (node instanceof AST_Sequence) {
        skip_string(node.tail_node());
      }
    }
  });
  base542 = function() {
    var freq = Object.create(null);
    function init(chars2) {
      var array = [];
      for (var i = 0;i < chars2.length; i++) {
        var ch = chars2[i];
        array.push(ch);
        freq[ch] = -0.01 * i;
      }
      return array;
    }
    var digits = init("0123456789");
    var leading = init("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_");
    var chars, frequency;
    function reset() {
      chars = null;
      frequency = Object.create(freq);
    }
    base543.consider = function(str, delta) {
      for (var i = str.length;--i >= 0; ) {
        frequency[str[i]] += delta;
      }
    };
    function compare(a, b) {
      return frequency[b] - frequency[a];
    }
    base543.sort = function() {
      chars = leading.sort(compare).concat(digits).sort(compare);
    };
    base543.reset = reset;
    reset();
    function base543(num) {
      var ret = leading[num % 54];
      for (num = Math.floor(num / 54);--num >= 0; num >>= 6) {
        ret += chars[num & 63];
      }
      return ret;
    }
    return base543;
  }();
});

// node_modules/uglify-js/lib/compress.js
var exports_compress = {};
var Compressor2;
var init_compress = __esm(() => {
  Compressor2 = function(options, false_by_default) {
    if (!(this instanceof Compressor2))
      return new Compressor2(options, false_by_default);
    TreeTransformer.call(this, this.before, this.after);
    this.options = defaults(options, {
      annotations: !false_by_default,
      arguments: !false_by_default,
      arrows: !false_by_default,
      assignments: !false_by_default,
      awaits: !false_by_default,
      booleans: !false_by_default,
      collapse_vars: !false_by_default,
      comparisons: !false_by_default,
      conditionals: !false_by_default,
      dead_code: !false_by_default,
      default_values: !false_by_default,
      directives: !false_by_default,
      drop_console: false,
      drop_debugger: !false_by_default,
      evaluate: !false_by_default,
      expression: false,
      functions: !false_by_default,
      global_defs: false,
      hoist_exports: !false_by_default,
      hoist_funs: false,
      hoist_props: !false_by_default,
      hoist_vars: false,
      ie: false,
      if_return: !false_by_default,
      imports: !false_by_default,
      inline: !false_by_default,
      join_vars: !false_by_default,
      keep_fargs: false_by_default,
      keep_fnames: false,
      keep_infinity: false,
      loops: !false_by_default,
      merge_vars: !false_by_default,
      module: false,
      negate_iife: !false_by_default,
      objects: !false_by_default,
      optional_chains: !false_by_default,
      passes: 1,
      properties: !false_by_default,
      pure_funcs: null,
      pure_getters: !false_by_default && "strict",
      reduce_funcs: !false_by_default,
      reduce_vars: !false_by_default,
      rests: !false_by_default,
      sequences: !false_by_default,
      side_effects: !false_by_default,
      spreads: !false_by_default,
      strings: !false_by_default,
      switches: !false_by_default,
      templates: !false_by_default,
      top_retain: null,
      toplevel: !!(options && (options["module"] || options["top_retain"])),
      typeofs: !false_by_default,
      unsafe: false,
      unsafe_comps: false,
      unsafe_Function: false,
      unsafe_math: false,
      unsafe_proto: false,
      unsafe_regexp: false,
      unsafe_undefined: false,
      unused: !false_by_default,
      varify: !false_by_default,
      webkit: false,
      yields: !false_by_default
    }, true);
    var evaluate = this.options["evaluate"];
    this.eval_threshold = /eager/.test(evaluate) ? 1 / 0 : +evaluate;
    var global_defs = this.options["global_defs"];
    if (typeof global_defs == "object")
      for (var key in global_defs) {
        if (/^@/.test(key) && HOP(global_defs, key)) {
          global_defs[key.slice(1)] = parse(global_defs[key], { expression: true });
        }
      }
    if (this.options["inline"] === true)
      this.options["inline"] = 4;
    this.drop_fargs = this.options["keep_fargs"] ? return_false : function(lambda, parent) {
      if (lambda.length_read)
        return false;
      var name = lambda.name;
      if (!name)
        return parent && parent.TYPE == "Call" && parent.expression === lambda;
      if (name.fixed_value() !== lambda)
        return false;
      var def = name.definition();
      if (def.direct_access)
        return false;
      var escaped = def.escaped;
      return escaped && escaped.depth != 1;
    };
    if (this.options["module"])
      this.directives["use strict"] = true;
    var pure_funcs = this.options["pure_funcs"];
    if (typeof pure_funcs == "function") {
      this.pure_funcs = pure_funcs;
    } else if (typeof pure_funcs == "string") {
      this.pure_funcs = function(node) {
        var expr;
        if (node instanceof AST_Call) {
          expr = node.expression;
        } else if (node instanceof AST_Template) {
          expr = node.tag;
        }
        return !(expr && pure_funcs === expr.print_to_string());
      };
    } else if (Array.isArray(pure_funcs)) {
      this.pure_funcs = function(node) {
        var expr;
        if (node instanceof AST_Call) {
          expr = node.expression;
        } else if (node instanceof AST_Template) {
          expr = node.tag;
        }
        return !(expr && member(expr.print_to_string(), pure_funcs));
      };
    } else {
      this.pure_funcs = return_true;
    }
    var sequences = this.options["sequences"];
    this.sequences_limit = sequences == 1 ? 800 : sequences | 0;
    var top_retain = this.options["top_retain"];
    if (top_retain instanceof RegExp) {
      this.top_retain = function(def) {
        return top_retain.test(def.name);
      };
    } else if (typeof top_retain == "function") {
      this.top_retain = top_retain;
    } else if (top_retain) {
      if (typeof top_retain == "string") {
        top_retain = top_retain.split(/,/);
      }
      this.top_retain = function(def) {
        return member(def.name, top_retain);
      };
    }
    var toplevel = this.options["toplevel"];
    this.toplevel = typeof toplevel == "string" ? {
      funcs: /funcs/.test(toplevel),
      vars: /vars/.test(toplevel)
    } : {
      funcs: toplevel,
      vars: toplevel
    };
  };
  Compressor2.prototype = new TreeTransformer(function(node, descend, in_list) {
    if (node._squeezed)
      return node;
    var is_scope = node instanceof AST_Scope;
    if (is_scope) {
      if (this.option("arrows") && is_arrow(node) && node.value) {
        node.body = [node.first_statement()];
        node.value = null;
      }
      node.hoist_properties(this);
      node.hoist_declarations(this);
      node.process_returns(this);
    }
    descend(node, this);
    descend(node, this);
    var opt = node.optimize(this);
    if (is_scope && opt === node && !this.has_directive("use asm") && !opt.pinned()) {
      opt.drop_unused(this);
      if (opt.merge_variables(this))
        opt.drop_unused(this);
      descend(opt, this);
    }
    if (opt === node)
      opt._squeezed = true;
    return opt;
  });
  Compressor2.prototype.option = function(key) {
    return this.options[key];
  };
  Compressor2.prototype.exposed = function(def) {
    if (def.exported)
      return true;
    if (def.undeclared)
      return true;
    if (!(def.global || def.scope.resolve() instanceof AST_Toplevel))
      return false;
    var toplevel = this.toplevel;
    return !all(def.orig, function(sym) {
      return toplevel[sym instanceof AST_SymbolDefun ? "funcs" : "vars"];
    });
  };
  Compressor2.prototype.compress = function(node) {
    node = node.resolve_defines(this);
    node.hoist_exports(this);
    if (this.option("expression"))
      node.process_expression(true);
    var merge_vars = this.options.merge_vars;
    var passes = +this.options.passes || 1;
    var min_count = 1 / 0;
    var stopping = false;
    var mangle = { ie: this.option("ie") };
    for (var pass = 0;pass < passes; pass++) {
      node.figure_out_scope(mangle);
      if (pass > 0 || this.option("reduce_vars"))
        node.reset_opt_flags(this);
      this.options.merge_vars = merge_vars && (stopping || pass == passes - 1);
      node = node.transform(this);
      if (passes > 1) {
        var count = 0;
        node.walk(new TreeWalker(function() {
          count++;
        }));
        AST_Node.info("pass {pass}: last_count: {min_count}, count: {count}", {
          pass,
          min_count,
          count
        });
        if (count < min_count) {
          min_count = count;
          stopping = false;
        } else if (stopping) {
          break;
        } else {
          stopping = true;
        }
      }
    }
    if (this.option("expression"))
      node.process_expression(false);
    return node;
  };
  (function(OPT) {
    OPT(AST_Node, function(self, compressor) {
      return self;
    });
    AST_Toplevel.DEFMETHOD("hoist_exports", function(compressor) {
      if (!compressor.option("hoist_exports"))
        return;
      var body = this.body, props = [];
      for (var i = 0;i < body.length; i++) {
        var stat = body[i];
        if (stat instanceof AST_ExportDeclaration) {
          body[i] = stat = stat.body;
          if (stat instanceof AST_Definitions) {
            stat.definitions.forEach(function(defn) {
              defn.name.match_symbol(export_symbol, true);
            });
          } else {
            export_symbol(stat.name);
          }
        } else if (stat instanceof AST_ExportReferences) {
          body.splice(i--, 1);
          [].push.apply(props, stat.properties);
        }
      }
      if (props.length)
        body.push(make_node(AST_ExportReferences, this, { properties: props }));
      function export_symbol(sym) {
        if (!(sym instanceof AST_SymbolDeclaration))
          return;
        var node = make_node(AST_SymbolExport, sym);
        node.alias = make_node(AST_String, node, { value: node.name });
        props.push(node);
      }
    });
    AST_Scope.DEFMETHOD("process_expression", function(insert, transform) {
      var self = this;
      var tt = new TreeTransformer(function(node) {
        if (insert) {
          if (node instanceof AST_Directive)
            node = make_node(AST_SimpleStatement, node, {
              body: make_node(AST_String, node)
            });
          if (node instanceof AST_SimpleStatement) {
            return transform ? transform(node) : make_node(AST_Return, node, { value: node.body });
          }
        } else if (node instanceof AST_Return) {
          if (transform)
            return transform(node);
          var value = node.value;
          if (value instanceof AST_String)
            return make_node(AST_Directive, value);
          return make_node(AST_SimpleStatement, node, {
            body: value || make_node(AST_UnaryPrefix, node, {
              operator: "void",
              expression: make_node(AST_Number, node, { value: 0 })
            })
          });
        }
        if (node instanceof AST_Block) {
          if (node instanceof AST_Lambda) {
            if (node !== self)
              return node;
          } else if (insert === "awaits" && node instanceof AST_Try) {
            if (node.bfinally)
              return node;
          }
          for (var index = node.body.length;--index >= 0; ) {
            var stat = node.body[index];
            if (!is_declaration(stat, true)) {
              node.body[index] = stat.transform(tt);
              break;
            }
          }
        } else if (node instanceof AST_If) {
          node.body = node.body.transform(tt);
          if (node.alternative)
            node.alternative = node.alternative.transform(tt);
        } else if (node instanceof AST_With) {
          node.body = node.body.transform(tt);
        }
        return node;
      });
      self.transform(tt);
    });
    AST_Toplevel.DEFMETHOD("unwrap_expression", function() {
      var self = this;
      switch (self.body.length) {
        case 0:
          return make_node(AST_UnaryPrefix, self, {
            operator: "void",
            expression: make_node(AST_Number, self, { value: 0 })
          });
        case 1:
          var stat = self.body[0];
          if (stat instanceof AST_Directive)
            return make_node(AST_String, stat);
          if (stat instanceof AST_SimpleStatement)
            return stat.body;
        default:
          return make_node(AST_Call, self, {
            expression: make_node(AST_Function, self, {
              argnames: [],
              body: self.body
            }).init_vars(self),
            args: []
          });
      }
    });
    AST_Node.DEFMETHOD("wrap_expression", function() {
      var self = this;
      if (!is_statement(self))
        self = make_node(AST_SimpleStatement, self, { body: self });
      if (!(self instanceof AST_Toplevel))
        self = make_node(AST_Toplevel, self, { body: [self] });
      return self;
    });
    function read_property(obj, node) {
      var key = node.get_property();
      if (key instanceof AST_Node)
        return;
      var value;
      if (obj instanceof AST_Array) {
        var elements = obj.elements;
        if (key == "length")
          return make_node_from_constant(elements.length, obj);
        if (typeof key == "number" && key in elements)
          value = elements[key];
      } else if (obj instanceof AST_Lambda) {
        if (key == "length") {
          obj.length_read = true;
          return make_node_from_constant(obj.argnames.length, obj);
        }
      } else if (obj instanceof AST_Object) {
        key = "" + key;
        var props = obj.properties;
        for (var i = props.length;--i >= 0; ) {
          var prop = props[i];
          if (!can_hoist_property(prop))
            return;
          if (!value && props[i].key === key)
            value = props[i].value;
        }
      }
      return value instanceof AST_SymbolRef && value.fixed_value() || value;
    }
    function is_read_only_fn(value, name) {
      if (value instanceof AST_Boolean)
        return native_fns.Boolean[name];
      if (value instanceof AST_Number)
        return native_fns.Number[name];
      if (value instanceof AST_String)
        return native_fns.String[name];
      if (name == "valueOf")
        return false;
      if (value instanceof AST_Array)
        return native_fns.Array[name];
      if (value instanceof AST_Lambda)
        return native_fns.Function[name];
      if (value instanceof AST_Object)
        return native_fns.Object[name];
      if (value instanceof AST_RegExp)
        return native_fns.RegExp[name] && !value.value.global;
    }
    function is_modified(compressor, tw, node, value, level, immutable, recursive) {
      var parent = tw.parent(level);
      if (compressor.option("unsafe") && parent instanceof AST_Dot && is_read_only_fn(value, parent.property)) {
        return;
      }
      var lhs = is_lhs(node, parent);
      if (lhs)
        return lhs;
      if (level == 0 && value && value.is_constant())
        return;
      if (parent instanceof AST_Array)
        return is_modified(compressor, tw, parent, parent, level + 1);
      if (parent instanceof AST_Assign)
        switch (parent.operator) {
          case "=":
            return is_modified(compressor, tw, parent, value, level + 1, immutable, recursive);
          case "&&=":
          case "||=":
          case "??=":
            return is_modified(compressor, tw, parent, parent, level + 1);
          default:
            return;
        }
      if (parent instanceof AST_Binary) {
        if (!lazy_op[parent.operator])
          return;
        return is_modified(compressor, tw, parent, parent, level + 1);
      }
      if (parent instanceof AST_Call) {
        return !immutable && parent.expression === node && !parent.is_expr_pure(compressor) && (!(value instanceof AST_LambdaExpression) || !(parent instanceof AST_New) && value.contains_this());
      }
      if (parent instanceof AST_Conditional) {
        if (parent.condition === node)
          return;
        return is_modified(compressor, tw, parent, parent, level + 1);
      }
      if (parent instanceof AST_ForEnumeration)
        return parent.init === node;
      if (parent instanceof AST_ObjectKeyVal) {
        if (parent.value !== node)
          return;
        var obj = tw.parent(level + 1);
        return is_modified(compressor, tw, obj, obj, level + 2);
      }
      if (parent instanceof AST_PropAccess) {
        if (parent.expression !== node)
          return;
        var prop = read_property(value, parent);
        return (!immutable || recursive) && is_modified(compressor, tw, parent, prop, level + 1);
      }
      if (parent instanceof AST_Sequence) {
        if (parent.tail_node() !== node)
          return;
        return is_modified(compressor, tw, parent, value, level + 1, immutable, recursive);
      }
    }
    function is_lambda(node) {
      return node instanceof AST_Class || node instanceof AST_Lambda;
    }
    function safe_for_extends(node) {
      return node instanceof AST_Class || node instanceof AST_Defun || node instanceof AST_Function;
    }
    function is_arguments(def) {
      return def.name == "arguments" && def.scope.uses_arguments;
    }
    function cross_scope(def, sym) {
      do {
        if (def === sym)
          return false;
        if (sym instanceof AST_Scope)
          return true;
      } while (sym = sym.parent_scope);
    }
    function can_drop_symbol(ref, compressor, keep_lambda) {
      var def = ref.redef || ref.definition();
      if (ref.in_arg && is_funarg(def))
        return false;
      return all(def.orig, function(sym) {
        if (sym instanceof AST_SymbolConst || sym instanceof AST_SymbolLet) {
          if (sym instanceof AST_SymbolImport)
            return true;
          return compressor && can_varify(compressor, sym);
        }
        return !(keep_lambda && sym instanceof AST_SymbolLambda);
      });
    }
    function has_escaped(d, scope, node, parent) {
      if (parent instanceof AST_Assign)
        return parent.operator == "=" && parent.right === node;
      if (parent instanceof AST_Call)
        return parent.expression !== node || parent instanceof AST_New;
      if (parent instanceof AST_ClassField)
        return parent.value === node && !parent.static;
      if (parent instanceof AST_Exit)
        return parent.value === node && scope.resolve() !== d.scope.resolve();
      if (parent instanceof AST_VarDef)
        return parent.value === node;
    }
    function make_ref(ref, fixed) {
      var node = make_node(AST_SymbolRef, ref);
      node.fixed = fixed || make_node(AST_Undefined, ref);
      return node;
    }
    function replace_ref(resolve, fixed) {
      return function(node) {
        var ref = resolve(node);
        var node = make_ref(ref, fixed);
        var def = ref.definition();
        def.references.push(node);
        def.replaced++;
        return node;
      };
    }
    var RE_POSITIVE_INTEGER = /^(0|[1-9][0-9]*)$/;
    (function(def) {
      def(AST_Node, noop);
      function reset_def(tw, compressor, def2) {
        def2.assignments = 0;
        def2.bool_return = 0;
        def2.drop_return = 0;
        def2.cross_loop = false;
        def2.direct_access = false;
        def2.escaped = [];
        def2.fixed = !def2.const_redefs && !def2.scope.pinned() && !compressor.exposed(def2) && !(def2.init instanceof AST_LambdaExpression && def2.init !== def2.scope) && def2.init;
        def2.reassigned = 0;
        def2.recursive_refs = 0;
        def2.references = [];
        def2.single_use = undefined;
      }
      function reset_block_variables(tw, compressor, scope) {
        scope.variables.each(function(def2) {
          reset_def(tw, compressor, def2);
        });
      }
      function reset_variables(tw, compressor, scope) {
        scope.fn_defs = [];
        scope.variables.each(function(def2) {
          reset_def(tw, compressor, def2);
          var init = def2.init;
          if (init instanceof AST_LambdaDefinition) {
            scope.fn_defs.push(init);
            init.safe_ids = null;
          }
          if (def2.fixed === null) {
            def2.safe_ids = tw.safe_ids;
            mark(tw, def2);
          } else if (def2.fixed) {
            tw.loop_ids[def2.id] = tw.in_loop;
            mark(tw, def2);
          }
        });
        scope.may_call_this = function() {
          scope.may_call_this = scope.contains_this() ? return_true : return_false;
        };
        if (scope.uses_arguments)
          scope.each_argname(function(node) {
            node.definition().last_ref = false;
          });
        if (compressor.option("ie"))
          scope.variables.each(function(def2) {
            var d = def2.orig[0].definition();
            if (d !== def2)
              d.fixed = false;
          });
      }
      function safe_to_visit(tw, fn) {
        var marker = fn.safe_ids;
        return marker === undefined || marker === tw.safe_ids;
      }
      function walk_fn_def(tw, fn) {
        var was_scanning = tw.fn_scanning;
        tw.fn_scanning = fn;
        fn.walk(tw);
        tw.fn_scanning = was_scanning;
      }
      function revisit_fn_def(tw, fn) {
        fn.enclosed.forEach(function(d) {
          if (fn.variables.get(d.name) === d)
            return;
          if (safe_to_read(tw, d))
            return;
          d.single_use = false;
          var fixed = d.fixed;
          if (typeof fixed == "function")
            fixed = fixed();
          if (fixed instanceof AST_Lambda && fixed.safe_ids !== undefined)
            return;
          d.fixed = false;
        });
      }
      function mark_fn_def(tw, def2, fn) {
        var marker = fn.safe_ids;
        if (marker === undefined)
          return;
        if (marker === false)
          return;
        if (fn.parent_scope.resolve().may_call_this === return_true) {
          if (member(fn, tw.fn_visited))
            revisit_fn_def(tw, fn);
        } else if (marker) {
          var visited = member(fn, tw.fn_visited);
          if (marker === tw.safe_ids) {
            if (!visited)
              walk_fn_def(tw, fn);
          } else if (visited) {
            revisit_fn_def(tw, fn);
          } else {
            fn.safe_ids = false;
          }
        } else if (tw.fn_scanning && tw.fn_scanning !== def2.scope.resolve()) {
          fn.safe_ids = false;
        } else {
          fn.safe_ids = tw.safe_ids;
          walk_fn_def(tw, fn);
        }
      }
      function pop_scope(tw, scope) {
        var fn_defs = scope.fn_defs;
        var tangled = scope.may_call_this === return_true ? fn_defs : fn_defs.filter(function(fn) {
          if (fn.safe_ids === false)
            return true;
          fn.safe_ids = tw.safe_ids;
          walk_fn_def(tw, fn);
          return false;
        });
        pop(tw);
        tangled.forEach(function(fn) {
          fn.safe_ids = tw.safe_ids;
          walk_fn_def(tw, fn);
        });
        fn_defs.forEach(function(fn) {
          fn.safe_ids = undefined;
        });
        scope.fn_defs = undefined;
        scope.may_call_this = undefined;
      }
      function push(tw, sequential) {
        var safe_ids = Object.create(tw.safe_ids);
        if (!sequential)
          safe_ids.seq = {};
        tw.safe_ids = safe_ids;
      }
      function pop(tw) {
        tw.safe_ids = Object.getPrototypeOf(tw.safe_ids);
      }
      function mark(tw, def2) {
        tw.safe_ids[def2.id] = {};
      }
      function push_ref(def2, ref) {
        def2.references.push(ref);
        if (def2.last_ref !== false)
          def2.last_ref = ref;
      }
      function safe_to_read(tw, def2) {
        if (def2.single_use == "m")
          return false;
        var safe = tw.safe_ids[def2.id];
        if (safe) {
          var in_order = HOP(tw.safe_ids, def2.id);
          if (!in_order) {
            var seq = tw.safe_ids.seq;
            if (!safe.read) {
              safe.read = seq;
            } else if (safe.read !== seq) {
              safe.read = true;
            }
          }
          if (def2.fixed == null) {
            if (is_arguments(def2))
              return false;
            if (def2.global && def2.name == "arguments")
              return false;
            tw.loop_ids[def2.id] = null;
            def2.fixed = make_node(AST_Undefined, def2.orig[0]);
            if (in_order)
              def2.safe_ids = undefined;
            return true;
          }
          return !safe.assign || safe.assign === tw.safe_ids;
        }
        return def2.fixed instanceof AST_LambdaDefinition;
      }
      function safe_to_assign(tw, def2, declare) {
        if (!declare) {
          if (is_funarg(def2) && def2.scope.uses_arguments && !tw.has_directive("use strict"))
            return false;
          if (!all(def2.orig, function(sym) {
            return !(sym instanceof AST_SymbolConst);
          }))
            return false;
        }
        if (def2.fixed === undefined)
          return declare || all(def2.orig, function(sym) {
            return !(sym instanceof AST_SymbolLet);
          });
        if (def2.fixed === false || def2.fixed === 0)
          return false;
        var safe = tw.safe_ids[def2.id];
        if (def2.safe_ids) {
          def2.safe_ids[def2.id] = false;
          def2.safe_ids = undefined;
          return def2.fixed === null || HOP(tw.safe_ids, def2.id) && !safe.read;
        }
        if (!HOP(tw.safe_ids, def2.id)) {
          if (!safe)
            return false;
          if (safe.read || tw.in_loop) {
            var scope = tw.find_parent(AST_BlockScope);
            if (scope instanceof AST_Class)
              return false;
            if (def2.scope.resolve() !== scope.resolve())
              return false;
          }
          safe.assign = safe.assign && safe.assign !== tw.safe_ids ? true : tw.safe_ids;
        }
        if (def2.fixed != null && safe.read) {
          if (safe.read !== tw.safe_ids.seq)
            return false;
          if (tw.loop_ids[def2.id] !== tw.in_loop)
            return false;
        }
        return safe_to_read(tw, def2) && all(def2.orig, function(sym) {
          return !(sym instanceof AST_SymbolLambda);
        });
      }
      function ref_once(compressor, def2) {
        return compressor.option("unused") && !def2.scope.pinned() && def2.single_use !== false && def2.references.length - def2.recursive_refs == 1 && !(is_funarg(def2) && def2.scope.uses_arguments);
      }
      function is_immutable(value) {
        if (!value)
          return false;
        if (value instanceof AST_Assign) {
          var op = value.operator;
          return op == "=" ? is_immutable(value.right) : !lazy_op[op.slice(0, -1)];
        }
        if (value instanceof AST_Sequence)
          return is_immutable(value.tail_node());
        return value.is_constant() || is_lambda(value) || value instanceof AST_ObjectIdentity;
      }
      function value_in_use(node, parent) {
        if (parent instanceof AST_Array)
          return true;
        if (parent instanceof AST_Binary)
          return lazy_op[parent.operator];
        if (parent instanceof AST_Conditional)
          return parent.condition !== node;
        if (parent instanceof AST_Sequence)
          return parent.tail_node() === node;
        if (parent instanceof AST_Spread)
          return true;
      }
      function mark_escaped(tw, d, scope, node, value, level, depth) {
        var parent = tw.parent(level);
        if (value && value.is_constant())
          return;
        if (has_escaped(d, scope, node, parent)) {
          d.escaped.push(parent);
          if (depth > 1 && !(value && value.is_constant_expression(scope)))
            depth = 1;
          if (!d.escaped.depth || d.escaped.depth > depth)
            d.escaped.depth = depth;
          if (d.scope.resolve() !== scope.resolve())
            d.escaped.cross_scope = true;
          if (d.fixed)
            d.fixed.escaped = d.escaped;
          return;
        } else if (value_in_use(node, parent)) {
          mark_escaped(tw, d, scope, parent, parent, level + 1, depth);
        } else if (parent instanceof AST_ObjectKeyVal && parent.value === node) {
          var obj = tw.parent(level + 1);
          mark_escaped(tw, d, scope, obj, obj, level + 2, depth);
        } else if (parent instanceof AST_PropAccess && parent.expression === node) {
          value = read_property(value, parent);
          mark_escaped(tw, d, scope, parent, value, level + 1, depth + 1);
          if (value)
            return;
        }
        if (level > 0)
          return;
        if (parent instanceof AST_Call && parent.expression === node)
          return;
        if (parent instanceof AST_Sequence && parent.tail_node() !== node)
          return;
        if (parent instanceof AST_SimpleStatement)
          return;
        if (parent instanceof AST_Unary && !unary_side_effects[parent.operator])
          return;
        d.direct_access = true;
        if (d.fixed)
          d.fixed.direct_access = true;
      }
      function mark_assignment_to_arguments(node) {
        if (!(node instanceof AST_Sub))
          return;
        var expr = node.expression;
        if (!(expr instanceof AST_SymbolRef))
          return;
        var def2 = expr.definition();
        if (!is_arguments(def2))
          return;
        var key = node.property;
        if (key.is_constant())
          key = key.value;
        if (!(key instanceof AST_Node) && !RE_POSITIVE_INTEGER.test(key))
          return;
        def2.reassigned++;
        (key instanceof AST_Node ? def2.scope.argnames : [def2.scope.argnames[key]]).forEach(function(argname) {
          if (argname instanceof AST_SymbolFunarg)
            argname.definition().fixed = false;
        });
      }
      function make_fixed(save, fn) {
        var prev_save, prev_value;
        return function() {
          var current = save();
          if (prev_save !== current) {
            prev_save = current;
            prev_value = fn(current);
          }
          return prev_value;
        };
      }
      function make_fixed_default(compressor, node, save) {
        var prev_save, prev_seq;
        return function() {
          if (prev_seq === node)
            return node;
          var current = save();
          var ev = fuzzy_eval(compressor, current, true);
          if (ev instanceof AST_Node) {
            prev_seq = node;
          } else if (prev_save !== current) {
            prev_save = current;
            prev_seq = ev === undefined ? make_sequence(node, [current, node.value]) : current;
          }
          return prev_seq;
        };
      }
      function scan_declaration(tw, compressor, lhs, fixed, visit) {
        var scanner = new TreeWalker(function(node) {
          if (node instanceof AST_DefaultValue) {
            reset_flags(node);
            push(tw, true);
            node.value.walk(tw);
            pop(tw);
            var save = fixed;
            if (save)
              fixed = make_fixed_default(compressor, node, save);
            node.name.walk(scanner);
            fixed = save;
            return true;
          }
          if (node instanceof AST_DestructuredArray) {
            reset_flags(node);
            var save = fixed;
            node.elements.forEach(function(node2, index) {
              if (node2 instanceof AST_Hole)
                return reset_flags(node2);
              if (save)
                fixed = make_fixed(save, function(value) {
                  return make_node(AST_Sub, node2, {
                    expression: value,
                    property: make_node(AST_Number, node2, { value: index })
                  });
                });
              node2.walk(scanner);
            });
            if (node.rest) {
              var fixed_node;
              if (save)
                fixed = compressor.option("rests") && make_fixed(save, function(value) {
                  if (!(value instanceof AST_Array))
                    return node;
                  for (var i = 0, len = node.elements.length;i < len; i++) {
                    if (value.elements[i] instanceof AST_Spread)
                      return node;
                  }
                  if (!fixed_node)
                    fixed_node = make_node(AST_Array, node, {});
                  fixed_node.elements = value.elements.slice(len);
                  return fixed_node;
                });
              node.rest.walk(scanner);
            }
            fixed = save;
            return true;
          }
          if (node instanceof AST_DestructuredObject) {
            reset_flags(node);
            var save = fixed;
            node.properties.forEach(function(node2) {
              reset_flags(node2);
              if (node2.key instanceof AST_Node) {
                push(tw);
                node2.key.walk(tw);
                pop(tw);
              }
              if (save)
                fixed = make_fixed(save, function(value) {
                  var key = node2.key;
                  var type = AST_Sub;
                  if (typeof key == "string") {
                    if (is_identifier_string(key)) {
                      type = AST_Dot;
                    } else {
                      key = make_node_from_constant(key, node2);
                    }
                  }
                  return make_node(type, node2, {
                    expression: value,
                    property: key
                  });
                });
              node2.value.walk(scanner);
            });
            if (node.rest) {
              fixed = false;
              node.rest.walk(scanner);
            }
            fixed = save;
            return true;
          }
          visit(node, fixed, function() {
            var save_len = tw.stack.length;
            for (var i = 0, len = scanner.stack.length - 1;i < len; i++) {
              tw.stack.push(scanner.stack[i]);
            }
            node.walk(tw);
            tw.stack.length = save_len;
          });
          return true;
        });
        lhs.walk(scanner);
      }
      function reduce_iife(tw, descend, compressor) {
        var fn = this;
        fn.inlined = false;
        var iife = tw.parent();
        var sequential = !is_async(fn) && !is_generator(fn);
        var hit = !sequential;
        var aborts2 = false;
        fn.walk(new TreeWalker(function(node) {
          if (hit)
            return aborts2 = true;
          if (node instanceof AST_Return)
            return hit = true;
          if (node instanceof AST_Scope && node !== fn)
            return true;
        }));
        if (aborts2)
          push(tw, sequential);
        reset_variables(tw, compressor, fn);
        var safe = !fn.uses_arguments || tw.has_directive("use strict");
        fn.argnames.forEach(function(argname, i) {
          var value = iife.args[i];
          scan_declaration(tw, compressor, argname, function() {
            var j = fn.argnames.indexOf(argname);
            var arg = j < 0 ? value : iife.args[j];
            if (arg instanceof AST_Sequence && arg.expressions.length < 2)
              arg = arg.expressions[0];
            return arg || make_node(AST_Undefined, iife);
          }, visit);
        });
        var rest = fn.rest, fixed_node;
        if (rest)
          scan_declaration(tw, compressor, rest, compressor.option("rests") && function() {
            if (fn.rest !== rest)
              return rest;
            if (!fixed_node)
              fixed_node = make_node(AST_Array, fn, {});
            fixed_node.elements = iife.args.slice(fn.argnames.length);
            return fixed_node;
          }, visit);
        walk_lambda(fn, tw);
        var safe_ids = tw.safe_ids;
        pop_scope(tw, fn);
        if (!aborts2)
          tw.safe_ids = safe_ids;
        return true;
        function visit(node, fixed) {
          var d = node.definition();
          if (fixed && safe && d.fixed === undefined) {
            mark(tw, d);
            tw.loop_ids[d.id] = tw.in_loop;
            d.fixed = fixed;
            d.fixed.assigns = [node];
          } else {
            d.fixed = false;
          }
        }
      }
      def(AST_Assign, function(tw, descend, compressor) {
        var node = this;
        var left = node.left;
        var right = node.right;
        var ld = left instanceof AST_SymbolRef && left.definition();
        var scan = ld || left instanceof AST_Destructured;
        switch (node.operator) {
          case "=":
            if (left.equals(right) && !left.has_side_effects(compressor)) {
              right.walk(tw);
              walk_prop(left);
              node.redundant = true;
              return true;
            }
            if (ld && right instanceof AST_LambdaExpression) {
              walk_assign();
              right.parent_scope.resolve().fn_defs.push(right);
              right.safe_ids = null;
              if (!ld.fixed || !node.write_only)
                mark_fn_def(tw, ld, right);
              return true;
            }
            if (scan) {
              right.walk(tw);
              walk_assign();
              return true;
            }
            mark_assignment_to_arguments(left);
            return;
          case "&&=":
          case "||=":
          case "??=":
            var lazy = true;
          default:
            if (!scan) {
              mark_assignment_to_arguments(left);
              return walk_lazy();
            }
            ld.assignments++;
            var fixed = ld.fixed;
            if (is_modified(compressor, tw, node, node, 0)) {
              ld.fixed = false;
              return walk_lazy();
            }
            var safe = safe_to_read(tw, ld);
            if (lazy)
              push(tw, true);
            right.walk(tw);
            if (lazy)
              pop(tw);
            if (safe && !left.in_arg && safe_to_assign(tw, ld)) {
              push_ref(ld, left);
              mark(tw, ld);
              if (ld.single_use)
                ld.single_use = false;
              left.fixed = ld.fixed = function() {
                return make_node(AST_Binary, node, {
                  operator: node.operator.slice(0, -1),
                  left: make_ref(left, fixed),
                  right: node.right
                });
              };
              left.fixed.assigns = !fixed || !fixed.assigns ? [ld.orig[0]] : fixed.assigns.slice();
              left.fixed.assigns.push(node);
              left.fixed.to_binary = replace_ref(function(node2) {
                return node2.left;
              }, fixed);
            } else {
              left.walk(tw);
              ld.fixed = false;
            }
            return true;
        }
        function walk_prop(lhs) {
          reset_flags(lhs);
          if (lhs instanceof AST_Dot) {
            walk_prop(lhs.expression);
          } else if (lhs instanceof AST_Sub) {
            walk_prop(lhs.expression);
            lhs.property.walk(tw);
          } else if (lhs instanceof AST_SymbolRef) {
            var d = lhs.definition();
            push_ref(d, lhs);
            if (d.fixed) {
              lhs.fixed = d.fixed;
              if (lhs.fixed.assigns) {
                lhs.fixed.assigns.push(node);
              } else {
                lhs.fixed.assigns = [node];
              }
            }
          } else {
            lhs.walk(tw);
          }
        }
        function walk_assign() {
          var recursive = ld && recursive_ref(tw, ld);
          var modified = is_modified(compressor, tw, node, right, 0, is_immutable(right), recursive);
          scan_declaration(tw, compressor, left, function() {
            return node.right;
          }, function(sym, fixed2, walk) {
            if (!(sym instanceof AST_SymbolRef)) {
              mark_assignment_to_arguments(sym);
              walk();
              return;
            }
            var d = sym.definition();
            d.assignments++;
            if (!fixed2 || sym.in_arg || !safe_to_assign(tw, d)) {
              walk();
              d.fixed = false;
            } else {
              push_ref(d, sym);
              mark(tw, d);
              if (left instanceof AST_Destructured || d.orig.length == 1 && d.orig[0] instanceof AST_SymbolDefun) {
                d.single_use = false;
              }
              tw.loop_ids[d.id] = tw.in_loop;
              d.fixed = modified ? 0 : fixed2;
              sym.fixed = fixed2;
              sym.fixed.assigns = [node];
              mark_escaped(tw, d, sym.scope, node, right, 0, 1);
            }
          });
        }
        function walk_lazy() {
          if (!lazy)
            return;
          left.walk(tw);
          push(tw, true);
          right.walk(tw);
          pop(tw);
          return true;
        }
      });
      def(AST_Binary, function(tw) {
        if (!lazy_op[this.operator])
          return;
        this.left.walk(tw);
        push(tw, true);
        this.right.walk(tw);
        pop(tw);
        return true;
      });
      def(AST_BlockScope, function(tw, descend, compressor) {
        reset_block_variables(tw, compressor, this);
      });
      def(AST_Call, function(tw, descend) {
        var node = this;
        var exp = node.expression;
        if (exp instanceof AST_LambdaExpression) {
          var iife = is_iife_single(node);
          node.args.forEach(function(arg) {
            arg.walk(tw);
            if (arg instanceof AST_Spread)
              iife = false;
          });
          if (iife)
            exp.reduce_vars = reduce_iife;
          exp.walk(tw);
          if (iife)
            delete exp.reduce_vars;
          return true;
        }
        if (node.TYPE == "Call")
          switch (tw.in_boolean_context()) {
            case "d":
              var drop = true;
            case true:
              mark_refs(exp, drop);
          }
        exp.walk(tw);
        var optional = node.optional;
        if (optional)
          push(tw, true);
        node.args.forEach(function(arg) {
          arg.walk(tw);
        });
        if (optional)
          pop(tw);
        var fixed = exp instanceof AST_SymbolRef && exp.fixed_value();
        if (fixed instanceof AST_Lambda) {
          mark_fn_def(tw, exp.definition(), fixed);
        } else {
          tw.find_parent(AST_Scope).may_call_this();
        }
        return true;
        function mark_refs(node2, drop2) {
          if (node2 instanceof AST_Assign) {
            if (node2.operator != "=")
              return;
            mark_refs(node2.left, drop2);
            mark_refs(node2.right, drop2);
          } else if (node2 instanceof AST_Binary) {
            if (!lazy_op[node2.operator])
              return;
            mark_refs(node2.left, drop2);
            mark_refs(node2.right, drop2);
          } else if (node2 instanceof AST_Conditional) {
            mark_refs(node2.consequent, drop2);
            mark_refs(node2.alternative, drop2);
          } else if (node2 instanceof AST_SymbolRef) {
            var def2 = node2.definition();
            def2.bool_return++;
            if (drop2)
              def2.drop_return++;
          }
        }
      });
      def(AST_Class, function(tw, descend, compressor) {
        var node = this;
        reset_block_variables(tw, compressor, node);
        if (node.extends)
          node.extends.walk(tw);
        var props = node.properties.filter(function(prop) {
          reset_flags(prop);
          if (prop.key instanceof AST_Node) {
            tw.push(prop);
            prop.key.walk(tw);
            tw.pop();
          }
          return prop.value;
        });
        if (node.name) {
          var d = node.name.definition();
          var parent = tw.parent();
          if (parent instanceof AST_ExportDeclaration || parent instanceof AST_ExportDefault)
            d.single_use = false;
          if (safe_to_assign(tw, d, true)) {
            mark(tw, d);
            tw.loop_ids[d.id] = tw.in_loop;
            d.fixed = function() {
              return node;
            };
            d.fixed.assigns = [node];
            if (!is_safe_lexical(d))
              d.single_use = false;
          } else {
            d.fixed = false;
          }
        }
        props.forEach(function(prop) {
          tw.push(prop);
          if (!prop.static || is_static_field_or_init(prop) && prop.value.contains_this()) {
            push(tw);
            prop.value.walk(tw);
            pop(tw);
          } else {
            prop.value.walk(tw);
          }
          tw.pop();
        });
        return true;
      });
      def(AST_ClassInitBlock, function(tw, descend, compressor) {
        var node = this;
        push(tw, true);
        reset_variables(tw, compressor, node);
        descend();
        pop_scope(tw, node);
        return true;
      });
      def(AST_Conditional, function(tw) {
        this.condition.walk(tw);
        push(tw, true);
        this.consequent.walk(tw);
        pop(tw);
        push(tw, true);
        this.alternative.walk(tw);
        pop(tw);
        return true;
      });
      def(AST_DefaultValue, function(tw) {
        push(tw, true);
        this.value.walk(tw);
        pop(tw);
        this.name.walk(tw);
        return true;
      });
      def(AST_Do, function(tw) {
        var save_loop = tw.in_loop;
        tw.in_loop = this;
        push(tw);
        this.body.walk(tw);
        if (has_loop_control(this, tw.parent())) {
          pop(tw);
          push(tw);
        }
        this.condition.walk(tw);
        pop(tw);
        tw.in_loop = save_loop;
        return true;
      });
      def(AST_For, function(tw, descend, compressor) {
        var node = this;
        reset_block_variables(tw, compressor, node);
        if (node.init)
          node.init.walk(tw);
        var save_loop = tw.in_loop;
        tw.in_loop = node;
        push(tw);
        if (node.condition)
          node.condition.walk(tw);
        node.body.walk(tw);
        if (node.step) {
          if (has_loop_control(node, tw.parent())) {
            pop(tw);
            push(tw);
          }
          node.step.walk(tw);
        }
        pop(tw);
        tw.in_loop = save_loop;
        return true;
      });
      def(AST_ForEnumeration, function(tw, descend, compressor) {
        var node = this;
        reset_block_variables(tw, compressor, node);
        node.object.walk(tw);
        var save_loop = tw.in_loop;
        tw.in_loop = node;
        push(tw);
        var init = node.init;
        if (init instanceof AST_Definitions) {
          init.definitions[0].name.mark_symbol(function(node2) {
            if (node2 instanceof AST_SymbolDeclaration) {
              var def2 = node2.definition();
              def2.assignments++;
              def2.fixed = false;
            }
          }, tw);
        } else if (init instanceof AST_Destructured || init instanceof AST_SymbolRef) {
          init.mark_symbol(function(node2) {
            if (node2 instanceof AST_SymbolRef) {
              var def2 = node2.definition();
              push_ref(def2, node2);
              def2.assignments++;
              if (!node2.is_immutable())
                def2.fixed = false;
            }
          }, tw);
        } else {
          init.walk(tw);
        }
        node.body.walk(tw);
        pop(tw);
        tw.in_loop = save_loop;
        return true;
      });
      def(AST_If, function(tw) {
        this.condition.walk(tw);
        push(tw, true);
        this.body.walk(tw);
        pop(tw);
        if (this.alternative) {
          push(tw, true);
          this.alternative.walk(tw);
          pop(tw);
        }
        return true;
      });
      def(AST_LabeledStatement, function(tw) {
        push(tw, true);
        this.body.walk(tw);
        pop(tw);
        return true;
      });
      def(AST_Lambda, function(tw, descend, compressor) {
        var fn = this;
        if (!safe_to_visit(tw, fn))
          return true;
        if (!push_uniq(tw.fn_visited, fn))
          return true;
        fn.inlined = false;
        push(tw);
        reset_variables(tw, compressor, fn);
        descend();
        pop_scope(tw, fn);
        if (fn.name)
          mark_escaped(tw, fn.name.definition(), fn, fn.name, fn, 0, 1);
        return true;
      });
      def(AST_LambdaDefinition, function(tw, descend, compressor) {
        var fn = this;
        var def2 = fn.name.definition();
        var parent = tw.parent();
        if (parent instanceof AST_ExportDeclaration || parent instanceof AST_ExportDefault)
          def2.single_use = false;
        if (!safe_to_visit(tw, fn))
          return true;
        if (!push_uniq(tw.fn_visited, fn))
          return true;
        fn.inlined = false;
        push(tw);
        reset_variables(tw, compressor, fn);
        descend();
        pop_scope(tw, fn);
        return true;
      });
      def(AST_Sub, function(tw) {
        if (!this.optional)
          return;
        this.expression.walk(tw);
        push(tw, true);
        this.property.walk(tw);
        pop(tw);
        return true;
      });
      def(AST_Switch, function(tw, descend, compressor) {
        var node = this;
        reset_block_variables(tw, compressor, node);
        node.expression.walk(tw);
        var first = true;
        node.body.forEach(function(branch) {
          if (branch instanceof AST_Default)
            return;
          branch.expression.walk(tw);
          if (first) {
            first = false;
            push(tw, true);
          }
        });
        if (!first)
          pop(tw);
        walk_body(node, tw);
        return true;
      });
      def(AST_SwitchBranch, function(tw) {
        push(tw, true);
        walk_body(this, tw);
        pop(tw);
        return true;
      });
      def(AST_SymbolCatch, function() {
        this.definition().fixed = false;
      });
      def(AST_SymbolImport, function() {
        this.definition().fixed = false;
      });
      def(AST_SymbolRef, function(tw, descend, compressor) {
        var ref = this;
        var d = ref.definition();
        var fixed = d.fixed || d.last_ref && d.last_ref.fixed;
        push_ref(d, ref);
        if (d.references.length == 1 && !d.fixed && d.orig[0] instanceof AST_SymbolDefun) {
          tw.loop_ids[d.id] = tw.in_loop;
        }
        var recursive = recursive_ref(tw, d);
        if (recursive)
          recursive.enclosed.forEach(function(def2) {
            if (d === def2)
              return;
            if (def2.scope.resolve() === recursive)
              return;
            var assigns = def2.fixed && def2.fixed.assigns;
            if (!assigns)
              return;
            if (assigns[assigns.length - 1] instanceof AST_VarDef)
              return;
            var safe = tw.safe_ids[def2.id];
            if (!safe)
              return;
            safe.assign = true;
          });
        if (d.single_use == "m" && d.fixed) {
          d.fixed = 0;
          d.single_use = false;
        }
        switch (d.fixed) {
          case 0:
            if (!safe_to_read(tw, d))
              d.fixed = false;
          case false:
            var redef = d.redefined();
            if (redef && cross_scope(d.scope, ref.scope))
              redef.single_use = false;
            break;
          case undefined:
            d.fixed = false;
            break;
          default:
            if (!safe_to_read(tw, d)) {
              d.fixed = false;
              break;
            }
            if (ref.in_arg && d.orig[0] instanceof AST_SymbolLambda)
              ref.fixed = d.scope;
            var value = ref.fixed_value();
            if (recursive) {
              d.recursive_refs++;
            } else if (value && ref_once(compressor, d)) {
              d.in_loop = tw.loop_ids[d.id] !== tw.in_loop;
              d.single_use = is_lambda(value) && !value.pinned() && (!d.in_loop || tw.parent() instanceof AST_Call) || !d.in_loop && d.scope === ref.scope.resolve() && value.is_constant_expression();
            } else {
              d.single_use = false;
            }
            if (is_modified(compressor, tw, ref, value, 0, is_immutable(value), recursive)) {
              if (d.single_use) {
                d.single_use = "m";
              } else {
                d.fixed = 0;
              }
            }
            if (d.fixed && tw.loop_ids[d.id] !== tw.in_loop)
              d.cross_loop = true;
            mark_escaped(tw, d, ref.scope, ref, value, 0, 1);
            break;
        }
        if (!ref.fixed)
          ref.fixed = d.fixed === 0 ? fixed : d.fixed;
        var parent;
        if (value instanceof AST_Lambda && !((parent = tw.parent()) instanceof AST_Call && parent.expression === ref)) {
          mark_fn_def(tw, d, value);
        }
      });
      def(AST_Template, function(tw, descend) {
        var node = this;
        var tag = node.tag;
        if (!tag)
          return;
        if (tag instanceof AST_LambdaExpression) {
          node.expressions.forEach(function(exp) {
            exp.walk(tw);
          });
          tag.walk(tw);
          return true;
        }
        tag.walk(tw);
        node.expressions.forEach(function(exp) {
          exp.walk(tw);
        });
        var fixed = tag instanceof AST_SymbolRef && tag.fixed_value();
        if (fixed instanceof AST_Lambda) {
          mark_fn_def(tw, tag.definition(), fixed);
        } else {
          tw.find_parent(AST_Scope).may_call_this();
        }
        return true;
      });
      def(AST_Toplevel, function(tw, descend, compressor) {
        var node = this;
        node.globals.each(function(def2) {
          reset_def(tw, compressor, def2);
        });
        push(tw, true);
        reset_variables(tw, compressor, node);
        descend();
        pop_scope(tw, node);
        return true;
      });
      def(AST_Try, function(tw, descend, compressor) {
        var node = this;
        reset_block_variables(tw, compressor, node);
        push(tw, true);
        walk_body(node, tw);
        pop(tw);
        if (node.bcatch) {
          push(tw, true);
          node.bcatch.walk(tw);
          pop(tw);
        }
        if (node.bfinally)
          node.bfinally.walk(tw);
        return true;
      });
      def(AST_Unary, function(tw, descend) {
        var node = this;
        if (!UNARY_POSTFIX[node.operator])
          return;
        var exp = node.expression;
        if (!(exp instanceof AST_SymbolRef)) {
          mark_assignment_to_arguments(exp);
          return;
        }
        var d = exp.definition();
        d.assignments++;
        var fixed = d.fixed;
        if (safe_to_read(tw, d) && !exp.in_arg && safe_to_assign(tw, d)) {
          push_ref(d, exp);
          mark(tw, d);
          if (d.single_use)
            d.single_use = false;
          d.fixed = function() {
            return make_node(AST_Binary, node, {
              operator: node.operator.slice(0, -1),
              left: make_node(AST_UnaryPrefix, node, {
                operator: "+",
                expression: make_ref(exp, fixed)
              }),
              right: make_node(AST_Number, node, { value: 1 })
            });
          };
          d.fixed.assigns = fixed && fixed.assigns ? fixed.assigns.slice() : [];
          d.fixed.assigns.push(node);
          if (node instanceof AST_UnaryPrefix) {
            exp.fixed = d.fixed;
          } else {
            exp.fixed = function() {
              return make_node(AST_UnaryPrefix, node, {
                operator: "+",
                expression: make_ref(exp, fixed)
              });
            };
            exp.fixed.assigns = fixed && fixed.assigns;
            exp.fixed.to_prefix = replace_ref(function(node2) {
              return node2.expression;
            }, d.fixed);
          }
        } else {
          exp.walk(tw);
          d.fixed = false;
        }
        return true;
      });
      def(AST_VarDef, function(tw, descend, compressor) {
        var node = this;
        var value = node.value;
        if (value instanceof AST_LambdaExpression && node.name instanceof AST_SymbolDeclaration) {
          walk_defn();
          value.parent_scope.resolve().fn_defs.push(value);
          value.safe_ids = null;
          var ld = node.name.definition();
          if (!ld.fixed)
            mark_fn_def(tw, ld, value);
        } else if (value) {
          value.walk(tw);
          walk_defn();
        } else if (tw.parent() instanceof AST_Let) {
          walk_defn();
        }
        return true;
        function walk_defn() {
          scan_declaration(tw, compressor, node.name, function() {
            return node.value || make_node(AST_Undefined, node);
          }, function(name, fixed) {
            var d = name.definition();
            if (fixed && safe_to_assign(tw, d, true)) {
              mark(tw, d);
              tw.loop_ids[d.id] = tw.in_loop;
              d.fixed = fixed;
              d.fixed.assigns = [node];
              if (name instanceof AST_SymbolConst && d.redefined() || !(can_drop_symbol(name) || is_safe_lexical(d))) {
                d.single_use = false;
              }
            } else {
              d.fixed = false;
            }
          });
        }
      });
      def(AST_While, function(tw, descend) {
        var save_loop = tw.in_loop;
        tw.in_loop = this;
        push(tw);
        descend();
        pop(tw);
        tw.in_loop = save_loop;
        return true;
      });
    })(function(node, func) {
      node.DEFMETHOD("reduce_vars", func);
    });
    function reset_flags(node) {
      node._squeezed = false;
      node._optimized = false;
      if (node instanceof AST_BlockScope)
        node._var_names = undefined;
      if (node instanceof AST_SymbolRef)
        node.fixed = undefined;
    }
    AST_Toplevel.DEFMETHOD("reset_opt_flags", function(compressor) {
      var tw = new TreeWalker(compressor.option("reduce_vars") ? function(node, descend) {
        reset_flags(node);
        return node.reduce_vars(tw, descend, compressor);
      } : reset_flags);
      tw.fn_scanning = null;
      tw.fn_visited = [];
      tw.in_loop = null;
      tw.loop_ids = Object.create(null);
      tw.safe_ids = Object.create(null);
      tw.safe_ids.seq = {};
      this.walk(tw);
    });
    AST_Symbol.DEFMETHOD("fixed_value", function(ref_only) {
      var def = this.definition();
      var fixed = def.fixed;
      if (fixed) {
        if (this.fixed)
          fixed = this.fixed;
        return (fixed instanceof AST_Node ? fixed : fixed()).tail_node();
      }
      fixed = fixed === 0 && this.fixed;
      if (!fixed)
        return fixed;
      var value = (fixed instanceof AST_Node ? fixed : fixed()).tail_node();
      if (ref_only && def.escaped.depth != 1 && is_object(value, true))
        return value;
      if (value.is_constant())
        return value;
    });
    AST_SymbolRef.DEFMETHOD("is_immutable", function() {
      var def = this.redef || this.definition();
      if (!(def.orig[0] instanceof AST_SymbolLambda))
        return false;
      if (def.orig.length == 1)
        return true;
      if (!this.in_arg)
        return false;
      return !(def.orig[1] instanceof AST_SymbolFunarg);
    });
    AST_Node.DEFMETHOD("convert_symbol", noop);
    function convert_destructured(type, process2) {
      return this.transform(new TreeTransformer(function(node, descend) {
        if (node instanceof AST_DefaultValue) {
          node = node.clone();
          node.name = node.name.transform(this);
          return node;
        }
        if (node instanceof AST_Destructured) {
          node = node.clone();
          descend(node, this);
          return node;
        }
        if (node instanceof AST_DestructuredKeyVal) {
          node = node.clone();
          node.value = node.value.transform(this);
          return node;
        }
        return node.convert_symbol(type, process2);
      }));
    }
    AST_DefaultValue.DEFMETHOD("convert_symbol", convert_destructured);
    AST_Destructured.DEFMETHOD("convert_symbol", convert_destructured);
    function convert_symbol(type, process2) {
      var node = make_node(type, this);
      return process2(node, this) || node;
    }
    AST_SymbolDeclaration.DEFMETHOD("convert_symbol", convert_symbol);
    AST_SymbolRef.DEFMETHOD("convert_symbol", convert_symbol);
    function process_to_assign(ref) {
      var def = ref.definition();
      def.assignments++;
      def.references.push(ref);
    }
    function mark_destructured(process2, tw) {
      var marker = new TreeWalker(function(node) {
        if (node instanceof AST_DefaultValue) {
          node.value.walk(tw);
          node.name.walk(marker);
          return true;
        }
        if (node instanceof AST_DestructuredKeyVal) {
          if (node.key instanceof AST_Node)
            node.key.walk(tw);
          node.value.walk(marker);
          return true;
        }
        return process2(node);
      });
      this.walk(marker);
    }
    AST_DefaultValue.DEFMETHOD("mark_symbol", mark_destructured);
    AST_Destructured.DEFMETHOD("mark_symbol", mark_destructured);
    function mark_symbol(process2) {
      return process2(this);
    }
    AST_SymbolDeclaration.DEFMETHOD("mark_symbol", mark_symbol);
    AST_SymbolRef.DEFMETHOD("mark_symbol", mark_symbol);
    AST_Node.DEFMETHOD("match_symbol", function(predicate) {
      return predicate(this);
    });
    function match_destructured(predicate, ignore_side_effects) {
      var found = false;
      var tw = new TreeWalker(function(node) {
        if (found)
          return true;
        if (node instanceof AST_DefaultValue) {
          if (!ignore_side_effects)
            return found = true;
          node.name.walk(tw);
          return true;
        }
        if (node instanceof AST_DestructuredKeyVal) {
          if (!ignore_side_effects && node.key instanceof AST_Node)
            return found = true;
          node.value.walk(tw);
          return true;
        }
        if (predicate(node))
          return found = true;
      });
      this.walk(tw);
      return found;
    }
    AST_DefaultValue.DEFMETHOD("match_symbol", match_destructured);
    AST_Destructured.DEFMETHOD("match_symbol", match_destructured);
    function in_async_generator(scope) {
      return scope instanceof AST_AsyncGeneratorDefun || scope instanceof AST_AsyncGeneratorFunction;
    }
    function find_scope(compressor) {
      var level = 0, node = compressor.self();
      do {
        if (node.variables)
          return node;
      } while (node = compressor.parent(level++));
    }
    function find_try(compressor, level, node, scope, may_throw, sync) {
      for (var parent;parent = compressor.parent(level++); node = parent) {
        if (parent === scope)
          return false;
        if (sync && parent instanceof AST_Lambda) {
          if (parent.name || is_async(parent) || is_generator(parent))
            return true;
        } else if (parent instanceof AST_Try) {
          if (parent.bfinally && parent.bfinally !== node)
            return true;
          if (may_throw && parent.bcatch && parent.bcatch !== node)
            return true;
        }
      }
      return false;
    }
    var identifier_atom = makePredicate("Infinity NaN undefined");
    function is_lhs_read_only(lhs, compressor) {
      if (lhs instanceof AST_Atom)
        return true;
      if (lhs instanceof AST_ObjectIdentity)
        return true;
      if (lhs instanceof AST_PropAccess) {
        if (lhs.property === "__proto__")
          return true;
        lhs = lhs.expression;
        if (lhs instanceof AST_SymbolRef) {
          if (lhs.is_immutable())
            return false;
          lhs = lhs.fixed_value();
        }
        if (!lhs)
          return true;
        if (lhs.tail_node().is_constant())
          return true;
        return is_lhs_read_only(lhs, compressor);
      }
      if (lhs instanceof AST_SymbolRef) {
        if (lhs.is_immutable())
          return true;
        var def = lhs.definition();
        return compressor.exposed(def) && identifier_atom[def.name];
      }
      return false;
    }
    function make_node(ctor, orig, props) {
      if (props) {
        props.start = orig.start;
        props.end = orig.end;
      } else {
        props = orig;
      }
      return new ctor(props);
    }
    function make_sequence(orig, expressions) {
      if (expressions.length == 1)
        return expressions[0];
      return make_node(AST_Sequence, orig, { expressions: expressions.reduce(merge_sequence, []) });
    }
    function make_node_from_constant(val, orig) {
      switch (typeof val) {
        case "string":
          return make_node(AST_String, orig, { value: val });
        case "number":
          if (isNaN(val))
            return make_node(AST_NaN, orig);
          if (isFinite(val)) {
            return 1 / val < 0 ? make_node(AST_UnaryPrefix, orig, {
              operator: "-",
              expression: make_node(AST_Number, orig, { value: -val })
            }) : make_node(AST_Number, orig, { value: val });
          }
          return val < 0 ? make_node(AST_UnaryPrefix, orig, {
            operator: "-",
            expression: make_node(AST_Infinity, orig)
          }) : make_node(AST_Infinity, orig);
        case "boolean":
          return make_node(val ? AST_True : AST_False, orig);
        case "undefined":
          return make_node(AST_Undefined, orig);
        default:
          if (val === null) {
            return make_node(AST_Null, orig);
          }
          if (val instanceof RegExp) {
            return make_node(AST_RegExp, orig, { value: val });
          }
          throw new Error(string_template("Can't handle constant of type: {type}", { type: typeof val }));
      }
    }
    function needs_unbinding(val) {
      return val instanceof AST_PropAccess || is_undeclared_ref(val) && val.name == "eval";
    }
    function maintain_this_binding(parent, orig, val) {
      var wrap = false;
      if (parent.TYPE == "Call") {
        wrap = parent.expression === orig && needs_unbinding(val);
      } else if (parent instanceof AST_Template) {
        wrap = parent.tag === orig && needs_unbinding(val);
      } else if (parent instanceof AST_UnaryPrefix) {
        wrap = parent.operator == "delete" || parent.operator == "typeof" && is_undeclared_ref(val);
      }
      return wrap ? make_sequence(orig, [make_node(AST_Number, orig, { value: 0 }), val]) : val;
    }
    function merge_expression(base, target) {
      var fixed_by_id = new Dictionary;
      base.walk(new TreeWalker(function(node) {
        if (!(node instanceof AST_SymbolRef))
          return;
        var def = node.definition();
        var fixed = node.fixed;
        if (!fixed || !fixed_by_id.has(def.id)) {
          fixed_by_id.set(def.id, fixed);
        } else if (fixed_by_id.get(def.id) !== fixed) {
          fixed_by_id.set(def.id, false);
        }
      }));
      if (fixed_by_id.size() > 0)
        target.walk(new TreeWalker(function(node) {
          if (!(node instanceof AST_SymbolRef))
            return;
          var def = node.definition();
          var fixed = node.fixed;
          if (!fixed || !fixed_by_id.has(def.id))
            return;
          if (fixed_by_id.get(def.id) !== fixed)
            node.fixed = false;
        }));
      return target;
    }
    function merge_sequence(array, node) {
      if (node instanceof AST_Sequence) {
        [].push.apply(array, node.expressions);
      } else {
        array.push(node);
      }
      return array;
    }
    function is_lexical_definition(stat) {
      return stat instanceof AST_Const || stat instanceof AST_DefClass || stat instanceof AST_Let;
    }
    function safe_to_trim(stat) {
      if (stat instanceof AST_LambdaDefinition) {
        var def = stat.name.definition();
        var scope = stat.name.scope;
        return def.scope === scope || all(def.references, function(ref) {
          var s = ref.scope;
          do {
            if (s === scope)
              return true;
          } while (s = s.parent_scope);
        });
      }
      return !is_lexical_definition(stat);
    }
    function as_statement_array(thing) {
      if (thing === null)
        return [];
      if (thing instanceof AST_BlockStatement)
        return all(thing.body, safe_to_trim) ? thing.body : [thing];
      if (thing instanceof AST_EmptyStatement)
        return [];
      if (is_statement(thing))
        return [thing];
      throw new Error("Can't convert thing to statement array");
    }
    function is_empty(thing) {
      if (thing === null)
        return true;
      if (thing instanceof AST_EmptyStatement)
        return true;
      if (thing instanceof AST_BlockStatement)
        return thing.body.length == 0;
      return false;
    }
    function has_declarations_only(block) {
      return all(block.body, function(stat) {
        return is_empty(stat) || stat instanceof AST_Defun || stat instanceof AST_Var && declarations_only(stat);
      });
    }
    function loop_body(x) {
      if (x instanceof AST_IterationStatement) {
        return x.body instanceof AST_BlockStatement ? x.body : x;
      }
      return x;
    }
    function is_iife_call(node) {
      if (node.TYPE != "Call")
        return false;
      do {
        node = node.expression;
      } while (node instanceof AST_PropAccess);
      return node instanceof AST_LambdaExpression ? !is_arrow(node) : is_iife_call(node);
    }
    function is_iife_single(call) {
      var exp = call.expression;
      if (exp.name)
        return false;
      if (!(call instanceof AST_New))
        return true;
      var found = false;
      exp.walk(new TreeWalker(function(node) {
        if (found)
          return true;
        if (node instanceof AST_NewTarget)
          return found = true;
        if (node instanceof AST_Scope && node !== exp)
          return true;
      }));
      return !found;
    }
    function is_undeclared_ref(node) {
      return node instanceof AST_SymbolRef && node.definition().undeclared;
    }
    var global_names = makePredicate("Array Boolean clearInterval clearTimeout console Date decodeURI decodeURIComponent encodeURI encodeURIComponent Error escape eval EvalError Function isFinite isNaN JSON Map Math Number parseFloat parseInt RangeError ReferenceError RegExp Object Set setInterval setTimeout String SyntaxError TypeError unescape URIError WeakMap WeakSet");
    AST_SymbolRef.DEFMETHOD("is_declared", function(compressor) {
      return this.defined || !this.definition().undeclared || compressor.option("unsafe") && global_names[this.name];
    });
    function is_static_field_or_init(prop) {
      return prop.static && prop.value && (prop instanceof AST_ClassField || prop instanceof AST_ClassInit);
    }
    function declarations_only(node) {
      return all(node.definitions, function(var_def) {
        return !var_def.value;
      });
    }
    function is_declaration(stat, lexical) {
      if (stat instanceof AST_DefClass)
        return lexical && !stat.extends && all(stat.properties, function(prop) {
          if (prop.key instanceof AST_Node)
            return false;
          return !is_static_field_or_init(prop);
        });
      if (stat instanceof AST_Definitions)
        return (lexical || stat instanceof AST_Var) && declarations_only(stat);
      if (stat instanceof AST_ExportDeclaration)
        return is_declaration(stat.body, lexical);
      if (stat instanceof AST_ExportDefault)
        return is_declaration(stat.body, lexical);
      return stat instanceof AST_LambdaDefinition;
    }
    function is_last_statement(body, stat) {
      var index = body.lastIndexOf(stat);
      if (index < 0)
        return false;
      while (++index < body.length) {
        if (!is_declaration(body[index], true))
          return false;
      }
      return true;
    }
    function patch_for_init(node, in_list) {
      var block;
      if (node.init instanceof AST_BlockStatement) {
        block = node.init;
        node.init = block.body.pop();
        block.body.push(node);
      }
      if (node.init instanceof AST_Defun) {
        if (!block)
          block = make_node(AST_BlockStatement, node, { body: [node] });
        block.body.splice(-1, 0, node.init);
        node.init = null;
      } else if (node.init instanceof AST_SimpleStatement) {
        node.init = node.init.body;
      } else if (is_empty(node.init)) {
        node.init = null;
      }
      if (!block)
        return;
      return in_list ? List.splice(block.body) : block;
    }
    function tighten_body(statements, compressor) {
      var in_lambda = last_of(compressor, function(node) {
        return node instanceof AST_Lambda;
      });
      var block_scope, iife_in_try, in_iife_single, in_loop, in_try, scope;
      find_loop_scope_try();
      var changed, last_changed, max_iter = 10;
      do {
        last_changed = changed;
        changed = 0;
        if (eliminate_spurious_blocks(statements))
          changed = 1;
        if (!changed && last_changed == 1)
          break;
        if (compressor.option("dead_code")) {
          if (eliminate_dead_code(statements, compressor))
            changed = 2;
          if (!changed && last_changed == 2)
            break;
        }
        if (compressor.option("if_return")) {
          if (handle_if_return(statements, compressor))
            changed = 3;
          if (!changed && last_changed == 3)
            break;
        }
        if (compressor.option("awaits") && compressor.option("side_effects")) {
          if (trim_awaits(statements, compressor))
            changed = 4;
          if (!changed && last_changed == 4)
            break;
        }
        if (compressor.option("inline") >= 4) {
          if (inline_iife(statements, compressor))
            changed = 5;
          if (!changed && last_changed == 5)
            break;
        }
        if (compressor.sequences_limit > 0) {
          if (sequencesize(statements, compressor))
            changed = 6;
          if (!changed && last_changed == 6)
            break;
          if (sequencesize_2(statements, compressor))
            changed = 7;
          if (!changed && last_changed == 7)
            break;
        }
        if (compressor.option("join_vars")) {
          if (join_consecutive_vars(statements))
            changed = 8;
          if (!changed && last_changed == 8)
            break;
        }
        if (compressor.option("collapse_vars")) {
          if (collapse(statements, compressor))
            changed = 9;
        }
      } while (changed && max_iter-- > 0);
      return statements;
      function last_of(compressor2, predicate) {
        var block = compressor2.self(), level = 0, stat;
        do {
          if (block instanceof AST_Catch) {
            block = compressor2.parent(level++);
          } else if (block instanceof AST_LabeledStatement) {
            block = block.body;
          } else if (block instanceof AST_SwitchBranch) {
            var branches = compressor2.parent(level);
            if (branches.body[branches.body.length - 1] === block || has_break(block.body)) {
              level++;
              block = branches;
            }
          }
          do {
            stat = block;
            if (predicate(stat))
              return stat;
            block = compressor2.parent(level++);
          } while (block instanceof AST_If);
        } while (stat && (block instanceof AST_BlockStatement || block instanceof AST_Catch || block instanceof AST_Scope || block instanceof AST_SwitchBranch || block instanceof AST_Try) && is_last_statement(block.body, stat));
        function has_break(stats) {
          for (var i = stats.length;--i >= 0; ) {
            if (stats[i] instanceof AST_Break)
              return true;
          }
          return false;
        }
      }
      function find_loop_scope_try() {
        var node = compressor.self(), level = 0;
        do {
          if (!block_scope && node.variables)
            block_scope = node;
          if (node instanceof AST_Catch) {
            if (compressor.parent(level).bfinally) {
              if (!in_try)
                in_try = {};
              in_try.bfinally = true;
            }
            level++;
          } else if (node instanceof AST_Finally) {
            level++;
          } else if (node instanceof AST_IterationStatement) {
            in_loop = true;
          } else if (node instanceof AST_Scope) {
            scope = node;
            break;
          } else if (node instanceof AST_Try) {
            if (!in_try)
              in_try = {};
            if (node.bcatch)
              in_try.bcatch = true;
            if (node.bfinally)
              in_try.bfinally = true;
          }
        } while (node = compressor.parent(level++));
      }
      function collapse(statements2, compressor2) {
        if (scope.pinned())
          return;
        var args;
        var assignments = new Dictionary;
        var candidates = [];
        var changed2 = false;
        var declare_only = new Dictionary;
        var force_single;
        var stat_index = statements2.length;
        var scanner = new TreeTransformer(function(node, descend) {
          if (abort)
            return node;
          if (!hit) {
            if (node !== hit_stack[hit_index])
              return node;
            hit_index++;
            if (hit_index < hit_stack.length)
              return handle_custom_scan_order(node, scanner);
            hit = true;
            stop_after = (value_def ? find_stop_value : find_stop)(node, 0);
            if (stop_after === node)
              abort = true;
            return node;
          }
          var parent = scanner.parent();
          if (!stop_if_hit && in_conditional(node, parent)) {
            stop_if_hit = parent;
          }
          if (compound && scan_lhs && can_replace && !stop_if_hit && node instanceof AST_Assign && node.operator != "=" && node.left.equals(lhs)) {
            replaced++;
            changed2 = true;
            AST_Node.info("Cascading {this} [{start}]", node);
            can_replace = false;
            lvalues = get_lvalues(lhs);
            node.right.transform(scanner);
            clear_write_only(candidate);
            var folded;
            if (abort) {
              folded = candidate;
            } else {
              abort = true;
              folded = make_node(AST_Binary, candidate, {
                operator: compound,
                left: lhs.fixed && lhs.definition().fixed ? lhs.fixed.to_binary(candidate) : lhs,
                right: rvalue
              });
            }
            return make_node(AST_Assign, node, {
              operator: "=",
              left: node.left,
              right: make_node(AST_Binary, node, {
                operator: node.operator.slice(0, -1),
                left: folded,
                right: node.right
              })
            });
          }
          if (should_stop(node, parent)) {
            abort = true;
            return node;
          }
          if (node.single_use)
            return node;
          var hit_rhs;
          if (!(node instanceof AST_SymbolDeclaration) && (scan_lhs && lhs.equals(node) || scan_rhs && (hit_rhs = scan_rhs(node, this)))) {
            if (!can_replace || stop_if_hit && (hit_rhs || !lhs_local || !replace_all)) {
              if (!hit_rhs && !value_def)
                abort = true;
              return node;
            }
            if (is_lhs(node, parent)) {
              if (value_def && !hit_rhs)
                assign_used = true;
              return node;
            }
            if (!hit_rhs && verify_ref && node.fixed !== lhs.fixed) {
              abort = true;
              return node;
            }
            if (value_def) {
              if (stop_if_hit && assign_pos == 0)
                assign_pos = remaining - replaced;
              if (!hit_rhs)
                replaced++;
              return node;
            }
            replaced++;
            changed2 = abort = true;
            AST_Node.info("Collapsing {this} [{start}]", node);
            if (candidate.TYPE == "Binary") {
              update_symbols(candidate, node);
              return make_node(AST_Assign, candidate, {
                operator: "=",
                left: candidate.right.left,
                right: candidate.operator == "&&" ? make_node(AST_Conditional, candidate, {
                  condition: candidate.left,
                  consequent: candidate.right.right,
                  alternative: node
                }) : make_node(AST_Conditional, candidate, {
                  condition: candidate.left,
                  consequent: node,
                  alternative: candidate.right.right
                })
              });
            }
            if (candidate instanceof AST_UnaryPostfix)
              return make_node(AST_UnaryPrefix, candidate, {
                operator: candidate.operator,
                expression: lhs.fixed && lhs.definition().fixed ? lhs.fixed.to_prefix(candidate) : lhs
              });
            if (candidate instanceof AST_UnaryPrefix) {
              clear_write_only(candidate);
              return candidate;
            }
            update_symbols(rvalue, node);
            if (candidate instanceof AST_VarDef) {
              var def2 = candidate.name.definition();
              if (def2.references.length - def2.replaced == 1 && !compressor2.exposed(def2)) {
                def2.replaced++;
                return maintain_this_binding(parent, node, rvalue);
              }
              return make_node(AST_Assign, candidate, {
                operator: "=",
                left: node,
                right: rvalue
              });
            }
            clear_write_only(rvalue);
            var assign = candidate.clone();
            assign.right = rvalue;
            return assign;
          }
          if (should_stop_ref(node, parent)) {
            abort = true;
            return node;
          }
          if (is_last_node(node, parent) || may_throw(node)) {
            stop_after = node;
            if (node instanceof AST_Scope)
              abort = true;
          }
          if (node instanceof AST_Accessor) {
            var replace = can_replace;
            can_replace = false;
            descend(node, scanner);
            can_replace = replace;
            return signal_abort(node);
          }
          if (node instanceof AST_Destructured) {
            var replace = can_replace;
            can_replace = false;
            descend(node, scanner);
            can_replace = replace;
            return signal_abort(node);
          }
          if (node instanceof AST_DefaultValue) {
            node.name = node.name.transform(scanner);
            var replace = can_replace;
            can_replace = false;
            node.value = node.value.transform(scanner);
            can_replace = replace;
            return signal_abort(node);
          }
          if (node instanceof AST_BlockScope && !(node instanceof AST_Scope) && !(node.variables && node.variables.all(function(def3) {
            return !enclosed.has(def3.name) && !lvalues.has(def3.name);
          }))) {
            var replace = can_replace;
            can_replace = false;
            if (!handle_custom_scan_order(node, scanner))
              descend(node, scanner);
            can_replace = replace;
            return signal_abort(node);
          }
          if (handle_custom_scan_order(node, scanner))
            return signal_abort(node);
        }, signal_abort);
        var multi_replacer = new TreeTransformer(function(node) {
          if (abort)
            return node;
          if (!hit) {
            if (node !== hit_stack[hit_index])
              return node;
            hit_index++;
            switch (hit_stack.length - hit_index) {
              case 0:
                hit = true;
                if (assign_used)
                  return node;
                if (node !== candidate)
                  return node;
                if (node instanceof AST_VarDef)
                  return node;
                def.replaced++;
                var parent = multi_replacer.parent();
                if (parent instanceof AST_Sequence && parent.tail_node() !== node) {
                  value_def.replaced++;
                  if (rvalue === rhs_value)
                    return List.skip;
                  return make_sequence(rhs_value, rhs_value.expressions.slice(0, -1));
                }
                return rvalue;
              case 1:
                if (!assign_used && node.body === candidate) {
                  hit = true;
                  def.replaced++;
                  value_def.replaced++;
                  return null;
                }
              default:
                return handle_custom_scan_order(node, multi_replacer);
            }
          }
          if (node instanceof AST_SymbolRef && node.definition() === def) {
            if (is_lhs(node, multi_replacer.parent()))
              return node;
            if (!--replaced)
              abort = true;
            AST_Node.info("Replacing {this} [{start}]", node);
            var ref = rvalue.clone();
            ref.scope = node.scope;
            ref.reference();
            if (replaced == assign_pos) {
              abort = true;
              return make_node(AST_Assign, candidate, {
                operator: "=",
                left: node,
                right: ref
              });
            }
            def.replaced++;
            return ref;
          }
          if (node instanceof AST_Default || node instanceof AST_Scope)
            return node;
        }, function(node) {
          return patch_sequence(node, multi_replacer);
        });
        while (--stat_index >= 0) {
          if (stat_index == 0 && compressor2.option("unused"))
            extract_args();
          var hit_stack = [];
          extract_candidates(statements2[stat_index]);
          while (candidates.length > 0) {
            hit_stack = candidates.pop();
            var hit_index = 0;
            var candidate = hit_stack[hit_stack.length - 1];
            var assign_pos = -1;
            var assign_used = false;
            var verify_ref = false;
            var remaining;
            var value_def = null;
            var stop_after = null;
            var stop_if_hit = null;
            var lhs = get_lhs(candidate);
            var side_effects = lhs && lhs.has_side_effects(compressor2);
            var scan_lhs = lhs && (!side_effects || lhs instanceof AST_SymbolRef) && !is_lhs_read_only(lhs, compressor2);
            var scan_rhs = foldable(candidate);
            if (!scan_lhs && !scan_rhs)
              continue;
            var compound = candidate instanceof AST_Assign && candidate.operator.slice(0, -1);
            var funarg = candidate.name instanceof AST_SymbolFunarg;
            var may_throw = return_false;
            if (candidate.may_throw(compressor2)) {
              if (funarg && is_async(scope))
                continue;
              may_throw = in_try ? function(node) {
                return node.has_side_effects(compressor2);
              } : side_effects_external;
            }
            var read_toplevel = false;
            var modify_toplevel = false;
            var enclosed = new Dictionary;
            var well_defined = true;
            var lvalues = get_lvalues(candidate);
            var lhs_local = is_lhs_local(lhs);
            var rhs_value = get_rvalue(candidate);
            var rvalue = rhs_value;
            if (!side_effects) {
              if (!compound && rvalue instanceof AST_Sequence)
                rvalue = rvalue.tail_node();
              side_effects = value_has_side_effects();
            }
            var check_destructured = in_try || !lhs_local ? function(node) {
              return node instanceof AST_Destructured;
            } : return_false;
            var replace_all = replace_all_symbols(candidate);
            var hit = funarg;
            var abort = false;
            var replaced = 0;
            var can_replace = !args || !hit;
            if (!can_replace) {
              for (var j = candidate.arg_index + 1;!abort && j < args.length; j++) {
                if (args[j])
                  args[j].transform(scanner);
              }
              can_replace = true;
            }
            for (var i = stat_index;!abort && i < statements2.length; i++) {
              statements2[i].transform(scanner);
            }
            if (value_def) {
              if (!replaced || remaining > replaced + assign_used) {
                candidates.push(hit_stack);
                force_single = true;
                continue;
              }
              if (replaced == assign_pos)
                assign_used = true;
              var def = lhs.definition();
              abort = false;
              hit_index = 0;
              hit = funarg;
              for (var i = stat_index;!abort && i < statements2.length; i++) {
                if (!statements2[i].transform(multi_replacer))
                  statements2.splice(i--, 1);
              }
              replaced = candidate instanceof AST_VarDef && candidate === hit_stack[hit_stack.length - 1] && def.references.length == def.replaced && !compressor2.exposed(def);
              value_def.last_ref = false;
              value_def.single_use = false;
              changed2 = true;
            }
            if (replaced)
              remove_candidate(candidate);
          }
        }
        return changed2;
        function signal_abort(node) {
          if (abort)
            return node;
          if (stop_after === node)
            abort = true;
          if (stop_if_hit === node)
            stop_if_hit = null;
          return node;
        }
        function handle_custom_scan_order(node, tt) {
          if (!(node instanceof AST_BlockScope))
            return;
          if (node instanceof AST_Scope)
            return node;
          if (node instanceof AST_Class) {
            if (node.name)
              node.name = node.name.transform(tt);
            if (!abort && node.extends)
              node.extends = node.extends.transform(tt);
            var fields = [], stats = [];
            for (var i2 = 0;!abort && i2 < node.properties.length; i2++) {
              var prop = node.properties[i2];
              if (prop.key instanceof AST_Node)
                prop.key = prop.key.transform(tt);
              if (!prop.static)
                continue;
              if (prop instanceof AST_ClassField) {
                if (prop.value)
                  fields.push(prop);
              } else if (prop instanceof AST_ClassInit) {
                [].push.apply(stats, prop.value.body);
              }
            }
            for (var i2 = 0;!abort && i2 < stats.length; i2++) {
              stats[i2].transform(tt);
            }
            for (var i2 = 0;!abort && i2 < fields.length; i2++) {
              var prop = fields[i2];
              prop.value = prop.value.transform(tt);
            }
            return node;
          }
          if (node instanceof AST_ForEnumeration) {
            node.object = node.object.transform(tt);
            abort = true;
            return node;
          }
          if (node instanceof AST_Switch) {
            node.expression = node.expression.transform(tt);
            for (var i2 = 0;!abort && i2 < node.body.length; i2++) {
              var branch = node.body[i2];
              if (branch instanceof AST_Case) {
                if (!hit) {
                  if (branch !== hit_stack[hit_index])
                    continue;
                  hit_index++;
                }
                branch.expression = branch.expression.transform(tt);
                if (!replace_all)
                  break;
                scan_rhs = false;
              }
            }
            abort = true;
            return node;
          }
        }
        function is_direct_assignment(node, parent) {
          if (parent instanceof AST_Assign)
            return parent.operator == "=" && parent.left === node;
          if (parent instanceof AST_DefaultValue)
            return parent.name === node;
          if (parent instanceof AST_DestructuredArray)
            return true;
          if (parent instanceof AST_DestructuredKeyVal)
            return parent.value === node;
        }
        function should_stop(node, parent) {
          if (node === rvalue)
            return true;
          if (parent instanceof AST_For) {
            if (node !== parent.init)
              return true;
          }
          if (node instanceof AST_Assign) {
            return node.operator != "=" && lhs.equals(node.left);
          }
          if (node instanceof AST_Call) {
            if (!(lhs instanceof AST_PropAccess))
              return false;
            if (!lhs.equals(node.expression))
              return false;
            return !(rvalue instanceof AST_LambdaExpression && !rvalue.contains_this());
          }
          if (node instanceof AST_Class)
            return !compressor2.has_directive("use strict");
          if (node instanceof AST_Debugger)
            return true;
          if (node instanceof AST_Defun)
            return funarg && lhs.name === node.name.name;
          if (node instanceof AST_DestructuredKeyVal)
            return node.key instanceof AST_Node;
          if (node instanceof AST_DWLoop)
            return true;
          if (node instanceof AST_LoopControl)
            return true;
          if (node instanceof AST_Try)
            return true;
          if (node instanceof AST_With)
            return true;
          return false;
        }
        function should_stop_ref(node, parent) {
          if (!(node instanceof AST_SymbolRef))
            return false;
          if (node.is_declared(compressor2)) {
            if (node.fixed_value())
              return false;
            if (can_drop_symbol(node)) {
              return !(parent instanceof AST_PropAccess && parent.expression === node) && is_arguments(node.definition());
            }
          } else if (is_direct_assignment(node, parent)) {
            return false;
          }
          if (!replace_all)
            return true;
          scan_rhs = false;
          return false;
        }
        function in_conditional(node, parent) {
          if (parent instanceof AST_Assign)
            return parent.left !== node && lazy_op[parent.operator.slice(0, -1)];
          if (parent instanceof AST_Binary)
            return parent.left !== node && lazy_op[parent.operator];
          if (parent instanceof AST_Call)
            return parent.optional && parent.expression !== node;
          if (parent instanceof AST_Case)
            return parent.expression !== node;
          if (parent instanceof AST_Conditional)
            return parent.condition !== node;
          if (parent instanceof AST_If)
            return parent.condition !== node;
          if (parent instanceof AST_Sub)
            return parent.optional && parent.expression !== node;
        }
        function is_last_node(node, parent) {
          if (node instanceof AST_Await)
            return true;
          if (node.TYPE == "Binary")
            return !can_drop_op(node.operator, node.right, compressor2);
          if (node instanceof AST_Call) {
            var def2, fn = node.expression;
            if (fn instanceof AST_SymbolRef) {
              def2 = fn.definition();
              fn = fn.fixed_value();
            }
            if (!(fn instanceof AST_Lambda))
              return !node.is_expr_pure(compressor2);
            if (def2 && recursive_ref(compressor2, def2, fn))
              return true;
            if (fn.collapse_scanning)
              return false;
            fn.collapse_scanning = true;
            var replace = can_replace;
            can_replace = false;
            var after = stop_after;
            var if_hit = stop_if_hit;
            for (var i2 = 0;!abort && i2 < fn.argnames.length; i2++) {
              if (arg_may_throw(reject, fn.argnames[i2], node.args[i2]))
                abort = true;
            }
            if (!abort) {
              if (fn.rest && arg_may_throw(reject, fn.rest, make_node(AST_Array, node, {
                elements: node.args.slice(i2)
              }))) {
                abort = true;
              } else if (is_arrow(fn) && fn.value) {
                fn.value.transform(scanner);
              } else
                for (var i2 = 0;!abort && i2 < fn.body.length; i2++) {
                  var stat = fn.body[i2];
                  if (stat instanceof AST_Return) {
                    if (stat.value)
                      stat.value.transform(scanner);
                    break;
                  }
                  stat.transform(scanner);
                }
            }
            stop_if_hit = if_hit;
            stop_after = after;
            can_replace = replace;
            fn.collapse_scanning = false;
            if (!abort)
              return false;
            abort = false;
            return true;
          }
          if (node instanceof AST_Class) {
            if (!in_try)
              return false;
            var base = node.extends;
            if (!base)
              return false;
            if (base instanceof AST_SymbolRef)
              base = base.fixed_value();
            return !safe_for_extends(base);
          }
          if (node instanceof AST_Exit) {
            if (in_try) {
              if (in_try.bfinally)
                return true;
              if (in_try.bcatch && node instanceof AST_Throw)
                return true;
            }
            return side_effects || lhs instanceof AST_PropAccess || may_modify(lhs);
          }
          if (node instanceof AST_Function) {
            return compressor2.option("ie") && node.name && lvalues.has(node.name.name);
          }
          if (node instanceof AST_ObjectIdentity)
            return symbol_in_lvalues(node, parent);
          if (node instanceof AST_PropAccess) {
            if (side_effects)
              return true;
            var exp = node.expression;
            if (exp instanceof AST_SymbolRef && is_arguments(exp.definition()))
              return true;
            if (compressor2.option("unsafe")) {
              if (is_undeclared_ref(exp) && global_names[exp.name])
                return false;
              if (is_static_fn(exp))
                return false;
            }
            if (!well_defined)
              return true;
            if (value_def)
              return false;
            if (!in_try && lhs_local)
              return false;
            if (node.optional)
              return false;
            return exp.may_throw_on_access(compressor2);
          }
          if (node instanceof AST_Spread)
            return true;
          if (node instanceof AST_SymbolRef) {
            if (symbol_in_lvalues(node, parent))
              return !is_direct_assignment(node, parent);
            if (side_effects && may_modify(node))
              return true;
            var def2 = node.definition();
            return (in_try || def2.scope.resolve() !== scope) && !can_drop_symbol(node);
          }
          if (node instanceof AST_Template)
            return !node.is_expr_pure(compressor2);
          if (node instanceof AST_VarDef) {
            if (check_destructured(node.name))
              return true;
            return (node.value || parent instanceof AST_Let) && node.name.match_symbol(function(node2) {
              return node2 instanceof AST_SymbolDeclaration && (lvalues.has(node2.name) || side_effects && may_modify(node2));
            }, true);
          }
          if (node instanceof AST_Yield)
            return true;
          var sym = is_lhs(node.left, node);
          if (!sym)
            return false;
          if (sym instanceof AST_PropAccess)
            return true;
          if (check_destructured(sym))
            return true;
          return sym.match_symbol(function(node2) {
            return node2 instanceof AST_SymbolRef && (lvalues.has(node2.name) || read_toplevel && compressor2.exposed(node2.definition()));
          }, true);
          function reject(node2) {
            node2.transform(scanner);
            return abort;
          }
        }
        function arg_may_throw(reject, node, value) {
          if (node instanceof AST_DefaultValue) {
            return reject(node.value) || arg_may_throw(reject, node.name, node.value) || !is_undefined(value) && arg_may_throw(reject, node.name, value);
          }
          if (!value)
            return !(node instanceof AST_Symbol);
          if (node instanceof AST_Destructured) {
            if (node.rest && arg_may_throw(reject, node.rest))
              return true;
            if (node instanceof AST_DestructuredArray) {
              if (value instanceof AST_Array)
                return !all(node.elements, function(element, index) {
                  return !arg_may_throw(reject, element, value[index]);
                });
              if (!value.is_string(compressor2))
                return true;
              return !all(node.elements, function(element) {
                return !arg_may_throw(reject, element);
              });
            }
            if (node instanceof AST_DestructuredObject) {
              if (value.may_throw_on_access(compressor2))
                return true;
              return !all(node.properties, function(prop) {
                if (prop.key instanceof AST_Node && reject(prop.key))
                  return false;
                return !arg_may_throw(reject, prop.value);
              });
            }
          }
        }
        function extract_args() {
          if (in_iife_single === false)
            return;
          var iife = compressor2.parent(), fn = compressor2.self();
          if (in_iife_single === undefined) {
            if (!(fn instanceof AST_LambdaExpression) || is_generator(fn) || fn.uses_arguments || fn.pinned() || !(iife instanceof AST_Call) || iife.expression !== fn || !all(iife.args, function(arg2) {
              return !(arg2 instanceof AST_Spread);
            })) {
              in_iife_single = false;
              return;
            }
            if (!is_iife_single(iife))
              return;
            in_iife_single = true;
          }
          var fn_strict = fn.in_strict_mode(compressor2) && !fn.parent_scope.resolve(true).in_strict_mode(compressor2);
          var has_await;
          if (is_async(fn)) {
            has_await = function(node) {
              return node instanceof AST_Symbol && node.name == "await";
            };
            iife_in_try = true;
          } else {
            has_await = function(node) {
              return node instanceof AST_Await && !tw.find_parent(AST_Scope);
            };
            if (iife_in_try === undefined)
              iife_in_try = find_try(compressor2, 1, iife, null, true, true);
          }
          var arg_scope = null;
          var tw = new TreeWalker(function(node, descend) {
            if (!arg)
              return true;
            if (has_await(node) || node instanceof AST_Yield) {
              arg = null;
              return true;
            }
            if (node instanceof AST_ObjectIdentity) {
              if (fn_strict || !arg_scope)
                arg = null;
              return true;
            }
            if (node instanceof AST_SymbolRef) {
              var def2;
              if (node.in_arg && !is_safe_lexical(node.definition()) || (def2 = fn.variables.get(node.name)) && def2 !== node.definition()) {
                arg = null;
              }
              return true;
            }
            if (node instanceof AST_Scope && !is_arrow(node)) {
              var save_scope = arg_scope;
              arg_scope = node;
              descend();
              arg_scope = save_scope;
              return true;
            }
          });
          args = iife.args.slice();
          var len = args.length;
          var names = new Dictionary;
          for (var i2 = fn.argnames.length;--i2 >= 0; ) {
            var sym = fn.argnames[i2];
            var arg = args[i2];
            var value = null;
            if (sym instanceof AST_DefaultValue) {
              value = sym.value;
              sym = sym.name;
              args[len + i2] = value;
            }
            if (sym instanceof AST_Destructured) {
              if (iife_in_try && arg_may_throw(function(node) {
                return node.has_side_effects(compressor2);
              }, sym, arg)) {
                candidates.length = 0;
                break;
              }
              args[len + i2] = fn.argnames[i2];
              continue;
            }
            if (names.has(sym.name))
              continue;
            names.set(sym.name, true);
            if (value)
              arg = is_undefined(arg) ? value : null;
            if (!arg && !value) {
              arg = make_node(AST_Undefined, sym).transform(compressor2);
            } else if (arg instanceof AST_Lambda && arg.pinned()) {
              arg = null;
            } else if (arg) {
              arg.walk(tw);
            }
            if (!arg)
              continue;
            var candidate2 = make_node(AST_VarDef, sym, {
              name: sym,
              value: arg
            });
            candidate2.name_index = i2;
            candidate2.arg_index = value ? len + i2 : i2;
            candidates.unshift([candidate2]);
          }
          if (fn.rest)
            args.push(fn.rest);
        }
        function extract_candidates(expr, unused) {
          hit_stack.push(expr);
          if (expr instanceof AST_Array) {
            expr.elements.forEach(function(node) {
              extract_candidates(node, unused);
            });
          } else if (expr instanceof AST_Assign) {
            var lhs2 = expr.left;
            if (!(lhs2 instanceof AST_Destructured))
              candidates.push(hit_stack.slice());
            extract_candidates(lhs2);
            extract_candidates(expr.right);
            if (lhs2 instanceof AST_SymbolRef && expr.operator == "=") {
              assignments.set(lhs2.name, (assignments.get(lhs2.name) || 0) + 1);
            }
          } else if (expr instanceof AST_Await) {
            extract_candidates(expr.expression, unused);
          } else if (expr instanceof AST_Binary) {
            var lazy = lazy_op[expr.operator];
            if (unused && lazy && expr.operator != "??" && expr.right instanceof AST_Assign && expr.right.operator == "=" && !(expr.right.left instanceof AST_Destructured)) {
              candidates.push(hit_stack.slice());
            }
            extract_candidates(expr.left, !lazy && unused);
            extract_candidates(expr.right, unused);
          } else if (expr instanceof AST_Call) {
            extract_candidates(expr.expression);
            expr.args.forEach(extract_candidates);
          } else if (expr instanceof AST_Case) {
            extract_candidates(expr.expression);
          } else if (expr instanceof AST_Conditional) {
            extract_candidates(expr.condition);
            extract_candidates(expr.consequent, unused);
            extract_candidates(expr.alternative, unused);
          } else if (expr instanceof AST_Definitions) {
            expr.definitions.forEach(extract_candidates);
          } else if (expr instanceof AST_Dot) {
            extract_candidates(expr.expression);
          } else if (expr instanceof AST_DWLoop) {
            extract_candidates(expr.condition);
            if (!(expr.body instanceof AST_Block)) {
              extract_candidates(expr.body);
            }
          } else if (expr instanceof AST_Exit) {
            if (expr.value)
              extract_candidates(expr.value);
          } else if (expr instanceof AST_For) {
            if (expr.init)
              extract_candidates(expr.init, true);
            if (expr.condition)
              extract_candidates(expr.condition);
            if (expr.step)
              extract_candidates(expr.step, true);
            if (!(expr.body instanceof AST_Block)) {
              extract_candidates(expr.body);
            }
          } else if (expr instanceof AST_ForEnumeration) {
            extract_candidates(expr.object);
            if (!(expr.body instanceof AST_Block)) {
              extract_candidates(expr.body);
            }
          } else if (expr instanceof AST_If) {
            extract_candidates(expr.condition);
            if (!(expr.body instanceof AST_Block)) {
              extract_candidates(expr.body);
            }
            if (expr.alternative && !(expr.alternative instanceof AST_Block)) {
              extract_candidates(expr.alternative);
            }
          } else if (expr instanceof AST_Object) {
            expr.properties.forEach(function(prop) {
              hit_stack.push(prop);
              if (prop.key instanceof AST_Node)
                extract_candidates(prop.key);
              if (prop instanceof AST_ObjectKeyVal)
                extract_candidates(prop.value, unused);
              hit_stack.pop();
            });
          } else if (expr instanceof AST_Sequence) {
            var end = expr.expressions.length - (unused ? 0 : 1);
            expr.expressions.forEach(function(node, index) {
              extract_candidates(node, index < end);
            });
          } else if (expr instanceof AST_SimpleStatement) {
            extract_candidates(expr.body, true);
          } else if (expr instanceof AST_Spread) {
            extract_candidates(expr.expression);
          } else if (expr instanceof AST_Sub) {
            extract_candidates(expr.expression);
            extract_candidates(expr.property);
          } else if (expr instanceof AST_Switch) {
            extract_candidates(expr.expression);
            expr.body.forEach(extract_candidates);
          } else if (expr instanceof AST_Unary) {
            if (UNARY_POSTFIX[expr.operator]) {
              candidates.push(hit_stack.slice());
            } else {
              extract_candidates(expr.expression);
            }
          } else if (expr instanceof AST_VarDef) {
            if (expr.name instanceof AST_SymbolVar) {
              if (expr.value) {
                var def2 = expr.name.definition();
                if (def2.references.length > def2.replaced) {
                  candidates.push(hit_stack.slice());
                }
              } else {
                declare_only.set(expr.name.name, (declare_only.get(expr.name.name) || 0) + 1);
              }
            }
            if (expr.value)
              extract_candidates(expr.value);
          } else if (expr instanceof AST_Yield) {
            if (expr.expression)
              extract_candidates(expr.expression);
          }
          hit_stack.pop();
        }
        function find_stop(node, level) {
          var parent = scanner.parent(level);
          if (parent instanceof AST_Array)
            return node;
          if (parent instanceof AST_Assign)
            return node;
          if (parent instanceof AST_Await)
            return node;
          if (parent instanceof AST_Binary)
            return node;
          if (parent instanceof AST_Call)
            return node;
          if (parent instanceof AST_Case)
            return node;
          if (parent instanceof AST_Conditional)
            return node;
          if (parent instanceof AST_Definitions)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_Exit)
            return node;
          if (parent instanceof AST_If)
            return node;
          if (parent instanceof AST_IterationStatement)
            return node;
          if (parent instanceof AST_ObjectProperty)
            return node;
          if (parent instanceof AST_PropAccess)
            return node;
          if (parent instanceof AST_Sequence) {
            return (parent.tail_node() === node ? find_stop : find_stop_unused)(parent, level + 1);
          }
          if (parent instanceof AST_SimpleStatement)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_Spread)
            return node;
          if (parent instanceof AST_Switch)
            return node;
          if (parent instanceof AST_Unary)
            return node;
          if (parent instanceof AST_VarDef)
            return node;
          if (parent instanceof AST_Yield)
            return node;
          return null;
        }
        function find_stop_logical(parent, op, level) {
          var node;
          do {
            node = parent;
            parent = scanner.parent(++level);
          } while (parent instanceof AST_Assign && parent.operator.slice(0, -1) == op || parent instanceof AST_Binary && parent.operator == op);
          return node;
        }
        function find_stop_expr(expr, cont, node, parent, level) {
          var replace = can_replace;
          can_replace = false;
          var after = stop_after;
          var if_hit = stop_if_hit;
          var stack = scanner.stack;
          scanner.stack = [parent];
          expr.transform(scanner);
          scanner.stack = stack;
          stop_if_hit = if_hit;
          stop_after = after;
          can_replace = replace;
          if (abort) {
            abort = false;
            return node;
          }
          return cont(parent, level + 1);
        }
        function find_stop_value(node, level) {
          var parent = scanner.parent(level);
          if (parent instanceof AST_Array)
            return find_stop_value(parent, level + 1);
          if (parent instanceof AST_Assign) {
            if (may_throw(parent))
              return node;
            if (parent.left.match_symbol(function(ref) {
              return ref instanceof AST_SymbolRef && (lhs.name == ref.name || value_def.name == ref.name);
            }))
              return node;
            var op;
            if (parent.left === node || !lazy_op[op = parent.operator.slice(0, -1)]) {
              return find_stop_value(parent, level + 1);
            }
            return find_stop_logical(parent, op, level);
          }
          if (parent instanceof AST_Await)
            return find_stop_value(parent, level + 1);
          if (parent instanceof AST_Binary) {
            var op;
            if (parent.left === node || !lazy_op[op = parent.operator]) {
              return find_stop_value(parent, level + 1);
            }
            return find_stop_logical(parent, op, level);
          }
          if (parent instanceof AST_Call)
            return parent;
          if (parent instanceof AST_Case) {
            if (parent.expression !== node)
              return node;
            return find_stop_value(parent, level + 1);
          }
          if (parent instanceof AST_Conditional) {
            if (parent.condition !== node)
              return node;
            return find_stop_value(parent, level + 1);
          }
          if (parent instanceof AST_Definitions)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_Do)
            return node;
          if (parent instanceof AST_Exit)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_For) {
            if (parent.init !== node && parent.condition !== node)
              return node;
            return find_stop_value(parent, level + 1);
          }
          if (parent instanceof AST_ForEnumeration) {
            if (parent.init !== node)
              return node;
            return find_stop_value(parent, level + 1);
          }
          if (parent instanceof AST_If) {
            if (parent.condition !== node)
              return node;
            return find_stop_value(parent, level + 1);
          }
          if (parent instanceof AST_ObjectProperty) {
            var obj = scanner.parent(level + 1);
            return all(obj.properties, function(prop) {
              return prop instanceof AST_ObjectKeyVal;
            }) ? find_stop_value(obj, level + 2) : obj;
          }
          if (parent instanceof AST_PropAccess) {
            var exp = parent.expression;
            return exp === node ? find_stop_value(parent, level + 1) : node;
          }
          if (parent instanceof AST_Sequence) {
            return (parent.tail_node() === node ? find_stop_value : find_stop_unused)(parent, level + 1);
          }
          if (parent instanceof AST_SimpleStatement)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_Spread)
            return find_stop_value(parent, level + 1);
          if (parent instanceof AST_Switch) {
            if (parent.expression !== node)
              return node;
            return find_stop_value(parent, level + 1);
          }
          if (parent instanceof AST_Unary) {
            if (parent.operator == "delete")
              return node;
            return find_stop_value(parent, level + 1);
          }
          if (parent instanceof AST_VarDef)
            return parent.name.match_symbol(function(sym) {
              return sym instanceof AST_SymbolDeclaration && (lhs.name == sym.name || value_def.name == sym.name);
            }) ? node : find_stop_value(parent, level + 1);
          if (parent instanceof AST_While) {
            if (parent.condition !== node)
              return node;
            return find_stop_value(parent, level + 1);
          }
          if (parent instanceof AST_Yield)
            return find_stop_value(parent, level + 1);
          return null;
        }
        function find_stop_unused(node, level) {
          var parent = scanner.parent(level);
          if (is_last_node(node, parent))
            return node;
          if (in_conditional(node, parent))
            return node;
          if (parent instanceof AST_Array)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_Assign)
            return check_assignment(parent.left);
          if (parent instanceof AST_Await)
            return node;
          if (parent instanceof AST_Binary)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_Call)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_Case)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_Conditional)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_Definitions)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_Exit)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_If)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_IterationStatement)
            return node;
          if (parent instanceof AST_ObjectProperty) {
            var obj = scanner.parent(level + 1);
            return all(obj.properties, function(prop) {
              return prop instanceof AST_ObjectKeyVal;
            }) ? find_stop_unused(obj, level + 2) : obj;
          }
          if (parent instanceof AST_PropAccess) {
            var exp = parent.expression;
            if (exp === node)
              return find_stop_unused(parent, level + 1);
            return find_stop_expr(exp, find_stop_unused, node, parent, level);
          }
          if (parent instanceof AST_Sequence)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_SimpleStatement)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_Spread)
            return node;
          if (parent instanceof AST_Switch)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_Unary)
            return find_stop_unused(parent, level + 1);
          if (parent instanceof AST_VarDef)
            return check_assignment(parent.name);
          if (parent instanceof AST_Yield)
            return node;
          return null;
          function check_assignment(lhs2) {
            if (may_throw(parent))
              return node;
            if (lhs2 !== node && lhs2 instanceof AST_Destructured) {
              return find_stop_expr(lhs2, find_stop_unused, node, parent, level);
            }
            return find_stop_unused(parent, level + 1);
          }
        }
        function mangleable_var(rhs) {
          if (force_single) {
            force_single = false;
            return;
          }
          if (remaining < 1)
            return;
          rhs = rhs.tail_node();
          var value = rhs instanceof AST_Assign && rhs.operator == "=" ? rhs.left : rhs;
          if (!(value instanceof AST_SymbolRef))
            return;
          var def2 = value.definition();
          if (def2.undeclared)
            return;
          if (is_arguments(def2))
            return;
          if (value !== rhs) {
            if (is_lhs_read_only(value, compressor2))
              return;
            var referenced = def2.references.length - def2.replaced;
            if (referenced < 2)
              return;
            var expr = candidate.clone();
            expr[expr instanceof AST_Assign ? "right" : "value"] = value;
            if (candidate.name_index >= 0) {
              expr.name_index = candidate.name_index;
              expr.arg_index = candidate.arg_index;
            }
            candidate = expr;
          }
          return value_def = def2;
        }
        function remaining_refs(def2) {
          return def2.references.length - def2.replaced - (assignments.get(def2.name) || 0);
        }
        function get_lhs(expr) {
          if (expr instanceof AST_Assign) {
            var lhs2 = expr.left;
            if (!(lhs2 instanceof AST_SymbolRef))
              return lhs2;
            var def2 = lhs2.definition();
            if (scope.uses_arguments && is_funarg(def2))
              return lhs2;
            if (compressor2.exposed(def2))
              return lhs2;
            remaining = remaining_refs(def2);
            if (def2.fixed && lhs2.fixed) {
              var matches = def2.references.filter(function(ref) {
                return ref.fixed === lhs2.fixed;
              }).length - 1;
              if (matches < remaining) {
                remaining = matches;
                assign_pos = 0;
                verify_ref = true;
              }
            }
            if (expr.operator == "=")
              mangleable_var(expr.right);
            return lhs2;
          }
          if (expr instanceof AST_Binary)
            return expr.right.left;
          if (expr instanceof AST_Unary)
            return expr.expression;
          if (expr instanceof AST_VarDef) {
            var lhs2 = expr.name;
            var def2 = lhs2.definition();
            if (def2.const_redefs)
              return;
            if (!member(lhs2, def2.orig))
              return;
            if (scope.uses_arguments && is_funarg(def2))
              return;
            var declared = def2.orig.length - def2.eliminated - (declare_only.get(def2.name) || 0);
            remaining = remaining_refs(def2);
            if (def2.fixed)
              remaining = Math.min(remaining, def2.references.filter(function(ref) {
                if (!ref.fixed)
                  return true;
                if (!ref.fixed.assigns)
                  return true;
                var assign = ref.fixed.assigns[0];
                return assign === lhs2 || get_rvalue(assign) === expr.value;
              }).length);
            if (declared > 1 && !(lhs2 instanceof AST_SymbolFunarg)) {
              mangleable_var(expr.value);
              return make_node(AST_SymbolRef, lhs2);
            }
            if (mangleable_var(expr.value) || remaining == 1 && !compressor2.exposed(def2)) {
              return make_node(AST_SymbolRef, lhs2);
            }
            return;
          }
        }
        function get_rvalue(expr) {
          if (expr instanceof AST_Assign)
            return expr.right;
          if (expr instanceof AST_Binary) {
            var node = expr.clone();
            node.right = expr.right.right;
            return node;
          }
          if (expr instanceof AST_VarDef)
            return expr.value;
        }
        function invariant(expr) {
          if (expr instanceof AST_Array)
            return false;
          if (expr instanceof AST_Binary && lazy_op[expr.operator]) {
            return invariant(expr.left) && invariant(expr.right);
          }
          if (expr instanceof AST_Call)
            return false;
          if (expr instanceof AST_Conditional) {
            return invariant(expr.consequent) && invariant(expr.alternative);
          }
          if (expr instanceof AST_Object)
            return false;
          return !expr.has_side_effects(compressor2);
        }
        function foldable(expr) {
          if (expr instanceof AST_Assign && expr.right.single_use)
            return;
          var lhs_ids = Object.create(null);
          var marker = new TreeWalker(function(node) {
            if (node instanceof AST_SymbolRef)
              lhs_ids[node.definition().id] = true;
          });
          while (expr instanceof AST_Assign && expr.operator == "=") {
            expr.left.walk(marker);
            expr = expr.right;
          }
          if (expr instanceof AST_ObjectIdentity)
            return rhs_exact_match;
          if (expr instanceof AST_SymbolRef) {
            var value = expr.evaluate(compressor2);
            if (value === expr)
              return rhs_exact_match;
            return rhs_fuzzy_match(value, rhs_exact_match);
          }
          if (expr.is_truthy())
            return rhs_fuzzy_match(true, return_false);
          if (expr.is_constant()) {
            var ev = expr.evaluate(compressor2);
            if (!(ev instanceof AST_Node))
              return rhs_fuzzy_match(ev, rhs_exact_match);
          }
          if (!(lhs instanceof AST_SymbolRef))
            return false;
          if (!invariant(expr))
            return false;
          var circular;
          expr.walk(new TreeWalker(function(node) {
            if (circular)
              return true;
            if (node instanceof AST_SymbolRef && lhs_ids[node.definition().id])
              circular = true;
          }));
          return !circular && rhs_exact_match;
          function rhs_exact_match(node) {
            return expr.equals(node);
          }
        }
        function rhs_fuzzy_match(value, fallback) {
          return function(node, tw) {
            if (tw.in_boolean_context()) {
              if (value && node.is_truthy() && !node.has_side_effects(compressor2)) {
                return true;
              }
              if (node.is_constant()) {
                var ev = node.evaluate(compressor2);
                if (!(ev instanceof AST_Node))
                  return !ev == !value;
              }
            }
            return fallback(node);
          };
        }
        function clear_write_only(assign) {
          while (assign.write_only) {
            assign.write_only = false;
            if (!(assign instanceof AST_Assign))
              break;
            assign = assign.right;
          }
        }
        function update_symbols(value, node) {
          var scope2 = node.scope || find_scope(scanner) || block_scope;
          value.walk(new TreeWalker(function(node2) {
            if (node2 instanceof AST_BlockScope)
              return true;
            if (node2 instanceof AST_Symbol)
              node2.scope = scope2;
          }));
        }
        function may_be_global(node) {
          if (node instanceof AST_SymbolRef) {
            node = node.fixed_value();
            if (!node)
              return true;
          }
          if (node instanceof AST_Assign)
            return node.operator == "=" && may_be_global(node.right);
          return node instanceof AST_PropAccess || node instanceof AST_ObjectIdentity;
        }
        function get_lvalues(expr) {
          var lvalues2 = new Dictionary;
          if (expr instanceof AST_VarDef) {
            if (!expr.name.definition().fixed)
              well_defined = false;
            lvalues2.add(expr.name.name, lhs);
          }
          var find_arguments = scope.uses_arguments && !compressor2.has_directive("use strict");
          var scan_toplevel = scope instanceof AST_Toplevel;
          var tw = new TreeWalker(function(node) {
            var value;
            if (node instanceof AST_SymbolRef) {
              value = node.fixed_value();
              if (!value) {
                value = node;
                var def2 = node.definition();
                var escaped = node.fixed && node.fixed.escaped || def2.escaped;
                if (!def2.undeclared && (def2.assignments || !escaped || escaped.cross_scope) && (has_escaped(def2, node.scope, node, tw.parent()) || !same_scope(def2))) {
                  well_defined = false;
                }
              }
            } else if (node instanceof AST_ObjectIdentity) {
              value = node;
            }
            if (value) {
              lvalues2.add(node.name, is_modified(compressor2, tw, node, value, 0));
            } else if (node instanceof AST_Lambda) {
              for (var level = 0, parent, child = node;parent = tw.parent(level++); child = parent) {
                if (parent instanceof AST_Assign) {
                  if (parent.left === child)
                    break;
                  if (parent.operator == "=")
                    continue;
                  if (lazy_op[parent.operator.slice(0, -1)])
                    continue;
                  break;
                }
                if (parent instanceof AST_Binary) {
                  if (lazy_op[parent.operator])
                    continue;
                  break;
                }
                if (parent instanceof AST_Call)
                  return;
                if (parent instanceof AST_Scope)
                  return;
                if (parent instanceof AST_Sequence) {
                  if (parent.tail_node() === child)
                    continue;
                  break;
                }
                if (parent instanceof AST_Template) {
                  if (parent.tag)
                    return;
                  break;
                }
              }
              node.enclosed.forEach(function(def3) {
                if (def3.scope !== node)
                  enclosed.set(def3.name, true);
              });
              return true;
            } else if (find_arguments && node instanceof AST_Sub) {
              scope.each_argname(function(argname) {
                if (!compressor2.option("reduce_vars") || argname.definition().assignments) {
                  if (!argname.definition().fixed)
                    well_defined = false;
                  lvalues2.add(argname.name, true);
                }
              });
              find_arguments = false;
            }
            if (!scan_toplevel)
              return;
            if (node.TYPE == "Call") {
              if (modify_toplevel)
                return;
              var exp = node.expression;
              if (exp instanceof AST_PropAccess)
                return;
              if (exp instanceof AST_LambdaExpression && !exp.contains_this())
                return;
              modify_toplevel = true;
            } else if (node instanceof AST_PropAccess && may_be_global(node.expression)) {
              if (node === lhs && !(expr instanceof AST_Unary)) {
                modify_toplevel = true;
              } else {
                read_toplevel = true;
              }
            }
          });
          expr.walk(tw);
          return lvalues2;
        }
        function remove_candidate(expr) {
          var value = rvalue === rhs_value ? null : make_sequence(rhs_value, rhs_value.expressions.slice(0, -1));
          var index = expr.name_index;
          if (index >= 0) {
            var args2, argname = scope.argnames[index];
            if (argname instanceof AST_DefaultValue) {
              scope.argnames[index] = argname = argname.clone();
              argname.value = value || make_node(AST_Number, argname, { value: 0 });
            } else if ((args2 = compressor2.parent().args)[index]) {
              scope.argnames[index] = argname.clone();
              args2[index] = value || make_node(AST_Number, args2[index], { value: 0 });
            }
            return;
          }
          var end = hit_stack.length - 1;
          var last = hit_stack[end];
          if (last instanceof AST_VarDef || hit_stack[end - 1].body === last)
            end--;
          var tt = new TreeTransformer(function(node, descend, in_list) {
            if (hit)
              return node;
            if (node !== hit_stack[hit_index])
              return node;
            hit_index++;
            if (hit_index <= end)
              return handle_custom_scan_order(node, tt);
            hit = true;
            if (node instanceof AST_Definitions) {
              declare_only.set(last.name.name, (declare_only.get(last.name.name) || 0) + 1);
              if (value_def)
                value_def.replaced++;
              var defns = node.definitions;
              var index2 = defns.indexOf(last);
              var defn = last.clone();
              defn.value = null;
              if (!value) {
                node.definitions[index2] = defn;
                return node;
              }
              var body = [make_node(AST_SimpleStatement, value, { body: value })];
              if (index2 > 0) {
                var head = node.clone();
                head.definitions = defns.slice(0, index2);
                body.unshift(head);
                node = node.clone();
                node.definitions = defns.slice(index2);
              }
              body.push(node);
              node.definitions[0] = defn;
              return in_list ? List.splice(body) : make_node(AST_BlockStatement, node, { body });
            }
            if (!value)
              return in_list ? List.skip : null;
            return is_statement(node) ? make_node(AST_SimpleStatement, value, { body: value }) : value;
          }, function(node, in_list) {
            if (node instanceof AST_For)
              return patch_for_init(node, in_list);
            return patch_sequence(node, tt);
          });
          abort = false;
          hit = false;
          hit_index = 0;
          if (!(statements2[stat_index] = statements2[stat_index].transform(tt)))
            statements2.splice(stat_index, 1);
        }
        function patch_sequence(node, tt) {
          if (node instanceof AST_Sequence)
            switch (node.expressions.length) {
              case 0:
                return null;
              case 1:
                return maintain_this_binding(tt.parent(), node, node.expressions[0]);
            }
        }
        function is_lhs_local(lhs2) {
          var sym = root_expr(lhs2);
          if (!(sym instanceof AST_SymbolRef))
            return false;
          if (sym.definition().scope.resolve() !== scope)
            return false;
          if (!in_loop)
            return true;
          if (compound)
            return false;
          if (candidate instanceof AST_Unary)
            return false;
          var lvalue = lvalues.get(sym.name);
          return !lvalue || lvalue[0] === lhs2;
        }
        function value_has_side_effects() {
          if (candidate instanceof AST_Unary)
            return false;
          return rvalue.has_side_effects(compressor2);
        }
        function replace_all_symbols(expr) {
          if (expr instanceof AST_Unary)
            return false;
          if (side_effects)
            return false;
          if (value_def)
            return true;
          if (!(lhs instanceof AST_SymbolRef))
            return false;
          var referenced;
          if (expr instanceof AST_VarDef) {
            referenced = 1;
          } else if (expr.operator == "=") {
            referenced = 2;
          } else {
            return false;
          }
          var def2 = lhs.definition();
          if (def2.references.length - def2.replaced == referenced)
            return true;
          if (!def2.fixed)
            return false;
          if (!lhs.fixed)
            return false;
          var assigns = lhs.fixed.assigns;
          var matched = 0;
          if (!all(def2.references, function(ref, index) {
            var fixed = ref.fixed;
            if (!fixed)
              return false;
            if (fixed.to_binary || fixed.to_prefix)
              return false;
            if (fixed === lhs.fixed) {
              matched++;
              return true;
            }
            return assigns && fixed.assigns && assigns[0] !== fixed.assigns[0];
          }))
            return false;
          if (matched != referenced)
            return false;
          verify_ref = true;
          return true;
        }
        function symbol_in_lvalues(sym, parent) {
          var lvalue = lvalues.get(sym.name);
          if (!lvalue || all(lvalue, function(lhs2) {
            return !lhs2;
          }))
            return;
          if (lvalue[0] !== lhs)
            return true;
          scan_rhs = false;
        }
        function may_modify(sym) {
          var def2 = sym.definition();
          if (def2.orig.length == 1 && def2.orig[0] instanceof AST_SymbolDefun)
            return false;
          if (def2.scope.resolve() !== scope)
            return true;
          if (modify_toplevel && compressor2.exposed(def2))
            return true;
          return !all(def2.references, function(ref) {
            return ref.scope.resolve(true) === scope;
          });
        }
        function side_effects_external(node, lhs2) {
          if (node instanceof AST_Assign)
            return side_effects_external(node.left, true);
          if (node instanceof AST_Unary)
            return side_effects_external(node.expression, true);
          if (node instanceof AST_VarDef)
            return node.value && side_effects_external(node.value);
          if (lhs2) {
            if (node instanceof AST_Dot)
              return side_effects_external(node.expression, true);
            if (node instanceof AST_Sub)
              return side_effects_external(node.expression, true);
            if (node instanceof AST_SymbolRef)
              return node.definition().scope.resolve() !== scope;
          }
          return false;
        }
      }
      function eliminate_spurious_blocks(statements2) {
        var changed2 = false, seen_dirs = [];
        for (var i = 0;i < statements2.length; ) {
          var stat = statements2[i];
          if (stat instanceof AST_BlockStatement) {
            if (all(stat.body, safe_to_trim)) {
              changed2 = true;
              eliminate_spurious_blocks(stat.body);
              [].splice.apply(statements2, [i, 1].concat(stat.body));
              i += stat.body.length;
              continue;
            }
          }
          if (stat instanceof AST_Directive) {
            if (member(stat.value, seen_dirs)) {
              changed2 = true;
              statements2.splice(i, 1);
              continue;
            }
            seen_dirs.push(stat.value);
          }
          if (stat instanceof AST_EmptyStatement) {
            changed2 = true;
            statements2.splice(i, 1);
            continue;
          }
          i++;
        }
        return changed2;
      }
      function handle_if_return(statements2, compressor2) {
        var changed2 = false;
        var parent = compressor2.parent();
        var self = compressor2.self();
        var declare_only, jump, merge_jump;
        var in_iife = in_lambda && parent && parent.TYPE == "Call" && parent.expression === self;
        var chain_if_returns = in_lambda && compressor2.option("conditionals") && compressor2.option("sequences");
        var drop_return_void = !(in_try && in_try.bfinally && in_async_generator(scope));
        var multiple_if_returns = has_multiple_if_returns(statements2);
        for (var i = statements2.length;--i >= 0; ) {
          var stat = statements2[i];
          var j = next_index(i);
          var next = statements2[j];
          if (in_lambda && declare_only && !next && stat instanceof AST_Return && drop_return_void && !(self instanceof AST_SwitchBranch)) {
            var body = stat.value;
            if (!body) {
              changed2 = true;
              statements2.splice(i, 1);
              continue;
            }
            var tail = body.tail_node();
            if (is_undefined(tail)) {
              changed2 = true;
              if (body instanceof AST_UnaryPrefix) {
                body = body.expression;
              } else if (tail instanceof AST_UnaryPrefix) {
                body = body.clone();
                body.expressions[body.expressions.length - 1] = tail.expression;
              }
              statements2[i] = make_node(AST_SimpleStatement, stat, { body });
              continue;
            }
          }
          if (stat instanceof AST_If) {
            var ab = aborts(stat.body);
            if (can_merge_flow(ab)) {
              if (ab.label)
                remove(ab.label.thedef.references, ab);
              changed2 = true;
              stat = stat.clone();
              stat.body = make_node(AST_BlockStatement, stat, {
                body: as_statement_array_with_return(stat.body, ab)
              });
              stat.alternative = make_node(AST_BlockStatement, stat, {
                body: as_statement_array(stat.alternative).concat(extract_functions(merge_jump, jump))
              });
              adjust_refs(ab.value, merge_jump);
              statements2[i] = stat;
              statements2[i] = stat.transform(compressor2);
              continue;
            }
            if (ab && !stat.alternative && next instanceof AST_Jump) {
              var cond = stat.condition;
              var preference = i + 1 == j && stat.body instanceof AST_BlockStatement;
              cond = best_of_expression(cond, cond.negate(compressor2), preference);
              if (cond !== stat.condition) {
                changed2 = true;
                stat = stat.clone();
                stat.condition = cond;
                var body = stat.body;
                stat.body = make_node(AST_BlockStatement, next, {
                  body: extract_functions(true, null, j + 1)
                });
                statements2.splice(i, 1, stat, body);
                if (!in_lambda || self instanceof AST_Block && self.body === statements2) {
                  statements2[i] = stat.transform(compressor2);
                }
                continue;
              }
            }
            var alt = aborts(stat.alternative);
            if (can_merge_flow(alt)) {
              if (alt.label)
                remove(alt.label.thedef.references, alt);
              changed2 = true;
              stat = stat.clone();
              stat.body = make_node(AST_BlockStatement, stat.body, {
                body: as_statement_array(stat.body).concat(extract_functions(merge_jump, jump))
              });
              stat.alternative = make_node(AST_BlockStatement, stat.alternative, {
                body: as_statement_array_with_return(stat.alternative, alt)
              });
              adjust_refs(alt.value, merge_jump);
              statements2[i] = stat;
              statements2[i] = stat.transform(compressor2);
              continue;
            }
            if (compressor2.option("typeofs")) {
              if (ab && !alt) {
                var stats = make_node(AST_BlockStatement, self, { body: statements2.slice(i + 1) });
                mark_locally_defined(stat.condition, null, stats);
              }
              if (!ab && alt) {
                var stats = make_node(AST_BlockStatement, self, { body: statements2.slice(i + 1) });
                mark_locally_defined(stat.condition, stats);
              }
            }
          }
          if (stat instanceof AST_If && stat.body instanceof AST_Return) {
            var value = stat.body.value;
            var in_bool = stat.body.in_bool || next instanceof AST_Return && next.in_bool;
            if (!stat.alternative && next instanceof AST_Return && (drop_return_void || !value == !next.value)) {
              changed2 = true;
              stat = stat.clone();
              stat.alternative = make_node(AST_BlockStatement, next, {
                body: extract_functions(true, null, j + 1)
              });
              statements2[i] = stat;
              statements2[i] = stat.transform(compressor2);
              continue;
            }
            if (in_lambda && declare_only && !next && !stat.alternative && (in_bool || value && multiple_if_returns || value instanceof AST_Conditional && (is_undefined(value.consequent, compressor2) || is_undefined(value.alternative, compressor2)))) {
              changed2 = true;
              stat = stat.clone();
              stat.alternative = make_node(AST_Return, stat, { value: null });
              statements2[i] = stat;
              statements2[i] = stat.transform(compressor2);
              continue;
            }
            var prev, prev_stat;
            if (chain_if_returns && !stat.alternative && (!(prev_stat = statements2[prev = prev_index(i)]) && in_iife || prev_stat instanceof AST_If && prev_stat.body instanceof AST_Return) && (!next ? !declare_only : next instanceof AST_SimpleStatement && next_index(j) == statements2.length)) {
              changed2 = true;
              var exprs = [];
              stat = stat.clone();
              exprs.push(stat.condition);
              stat.condition = make_sequence(stat, exprs);
              stat.alternative = make_node(AST_BlockStatement, self, {
                body: extract_functions().concat(make_node(AST_Return, self, { value: null }))
              });
              statements2[i] = stat.transform(compressor2);
              i = prev + 1;
              continue;
            }
          }
          if (stat instanceof AST_Break || stat instanceof AST_Exit) {
            jump = stat;
            continue;
          }
          if (declare_only && jump && jump === next)
            eliminate_returns(stat);
        }
        return changed2;
        function has_multiple_if_returns(statements3) {
          var n = 0;
          for (var i2 = statements3.length;--i2 >= 0; ) {
            var stat2 = statements3[i2];
            if (stat2 instanceof AST_If && stat2.body instanceof AST_Return) {
              if (++n > 1)
                return true;
            }
          }
          return false;
        }
        function match_target(target) {
          return last_of(compressor2, function(node) {
            return node === target;
          });
        }
        function match_return(ab2, exact) {
          if (!jump)
            return false;
          if (jump.TYPE != ab2.TYPE)
            return false;
          var value2 = ab2.value;
          if (!value2)
            return false;
          var equals = jump.equals(ab2);
          if (!equals && value2 instanceof AST_Sequence) {
            value2 = value2.tail_node();
            if (jump.value && jump.value.equals(value2))
              equals = 2;
          }
          if (!equals && !exact && jump.value instanceof AST_Sequence) {
            if (jump.value.tail_node().equals(value2))
              equals = 3;
          }
          return equals;
        }
        function can_drop_abort(ab2) {
          if (ab2 instanceof AST_Exit) {
            if (merge_jump = match_return(ab2))
              return true;
            if (!in_lambda)
              return false;
            if (!(ab2 instanceof AST_Return))
              return false;
            var value2 = ab2.value;
            if (value2 && !is_undefined(value2.tail_node()))
              return false;
            if (!(self instanceof AST_SwitchBranch))
              return true;
            if (!jump)
              return false;
            if (jump instanceof AST_Exit && jump.value)
              return false;
            merge_jump = 4;
            return true;
          }
          if (!(ab2 instanceof AST_LoopControl))
            return false;
          if (self instanceof AST_SwitchBranch) {
            if (jump instanceof AST_Exit) {
              if (!in_lambda)
                return false;
              if (jump.value)
                return false;
              merge_jump = true;
            } else if (jump) {
              if (compressor2.loopcontrol_target(jump) !== parent)
                return false;
              merge_jump = true;
            } else if (jump === false) {
              return false;
            }
          }
          var lct = compressor2.loopcontrol_target(ab2);
          if (ab2 instanceof AST_Continue)
            return match_target(loop_body(lct));
          if (lct instanceof AST_IterationStatement)
            return false;
          return match_target(lct);
        }
        function can_merge_flow(ab2) {
          merge_jump = false;
          if (!can_drop_abort(ab2))
            return false;
          for (var j2 = statements2.length;--j2 > i; ) {
            var stat2 = statements2[j2];
            if (stat2 instanceof AST_DefClass) {
              if (stat2.name.definition().preinit)
                return false;
            } else if (stat2 instanceof AST_Const || stat2 instanceof AST_Let) {
              if (!all(stat2.definitions, function(defn) {
                return !defn.name.match_symbol(function(node) {
                  return node instanceof AST_SymbolDeclaration && node.definition().preinit;
                });
              }))
                return false;
            }
          }
          return true;
        }
        function extract_functions(mode, stop, end) {
          var defuns = [];
          var lexical = false;
          var start = i + 1;
          if (!mode) {
            end = statements2.length;
            jump = null;
          } else if (stop) {
            end = statements2.lastIndexOf(stop);
          } else {
            stop = statements2[end];
            if (stop !== jump)
              jump = false;
          }
          var tail2 = statements2.splice(start, end - start).filter(function(stat2) {
            if (stat2 instanceof AST_LambdaDefinition) {
              defuns.push(stat2);
              return false;
            }
            if (is_lexical_definition(stat2))
              lexical = true;
            return true;
          });
          if (mode === 3) {
            tail2.push(make_node(AST_SimpleStatement, stop.value, {
              body: make_sequence(stop.value, stop.value.expressions.slice(0, -1))
            }));
            stop.value = stop.value.tail_node();
          }
          [].push.apply(lexical ? tail2 : statements2, defuns);
          return tail2;
        }
        function trim_return(value2, mode) {
          if (value2)
            switch (mode) {
              case 4:
                return value2;
              case 3:
                if (!(value2 instanceof AST_Sequence))
                  break;
              case 2:
                return make_sequence(value2, value2.expressions.slice(0, -1));
            }
        }
        function as_statement_array_with_return(node, ab2) {
          var body2 = as_statement_array(node);
          var block = body2, last;
          while ((last = block[block.length - 1]) !== ab2) {
            block = last.body;
          }
          block.pop();
          var value2 = ab2.value;
          if (merge_jump)
            value2 = trim_return(value2, merge_jump);
          if (value2)
            block.push(make_node(AST_SimpleStatement, value2, { body: value2 }));
          return body2;
        }
        function adjust_refs(value2, mode) {
          if (!mode)
            return;
          if (!value2)
            return;
          switch (mode) {
            case 4:
              return;
            case 3:
            case 2:
              value2 = value2.tail_node();
          }
          merge_expression(value2, jump.value);
        }
        function next_index(i2) {
          declare_only = true;
          for (var j2 = i2;++j2 < statements2.length; ) {
            var stat2 = statements2[j2];
            if (is_declaration(stat2))
              continue;
            if (stat2 instanceof AST_Var) {
              declare_only = false;
              continue;
            }
            break;
          }
          return j2;
        }
        function prev_index(i2) {
          for (var j2 = i2;--j2 >= 0; ) {
            var stat2 = statements2[j2];
            if (stat2 instanceof AST_Var)
              continue;
            if (is_declaration(stat2))
              continue;
            break;
          }
          return j2;
        }
        function eliminate_returns(stat2, keep_throws, in_block) {
          if (stat2 instanceof AST_Exit) {
            var mode = !(keep_throws && stat2 instanceof AST_Throw) && match_return(stat2, true);
            if (mode) {
              changed2 = true;
              var value2 = trim_return(stat2.value, mode);
              if (value2)
                return make_node(AST_SimpleStatement, value2, { body: value2 });
              return in_block ? null : make_node(AST_EmptyStatement, stat2);
            }
          } else if (stat2 instanceof AST_If) {
            stat2.body = eliminate_returns(stat2.body, keep_throws);
            if (stat2.alternative)
              stat2.alternative = eliminate_returns(stat2.alternative, keep_throws);
          } else if (stat2 instanceof AST_LabeledStatement) {
            stat2.body = eliminate_returns(stat2.body, keep_throws);
          } else if (stat2 instanceof AST_Try) {
            if (!stat2.bfinally || !jump.value || jump.value.is_constant()) {
              if (stat2.bcatch)
                eliminate_returns(stat2.bcatch, keep_throws);
              var trimmed = eliminate_returns(stat2.body.pop(), true, true);
              if (trimmed)
                stat2.body.push(trimmed);
            }
          } else if (stat2 instanceof AST_Block && !(stat2 instanceof AST_Scope || stat2 instanceof AST_Switch)) {
            var trimmed = eliminate_returns(stat2.body.pop(), keep_throws, true);
            if (trimmed)
              stat2.body.push(trimmed);
          }
          return stat2;
        }
      }
      function eliminate_dead_code(statements2, compressor2) {
        var has_quit;
        var self = compressor2.self();
        if (self instanceof AST_Catch) {
          self = compressor2.parent();
        } else if (self instanceof AST_LabeledStatement) {
          self = self.body;
        }
        for (var i = 0, n = 0, len = statements2.length;i < len; i++) {
          var stat = statements2[i];
          if (stat instanceof AST_LoopControl) {
            var lct = compressor2.loopcontrol_target(stat);
            if (loop_body(lct) !== self || stat instanceof AST_Break && lct instanceof AST_IterationStatement) {
              statements2[n++] = stat;
            } else if (stat.label) {
              remove(stat.label.thedef.references, stat);
            }
          } else {
            statements2[n++] = stat;
          }
          if (aborts(stat)) {
            has_quit = statements2.slice(i + 1);
            break;
          }
        }
        statements2.length = n;
        if (has_quit)
          has_quit.forEach(function(stat2) {
            extract_declarations_from_unreachable_code(compressor2, stat2, statements2);
          });
        return statements2.length != len;
      }
      function trim_awaits(statements2, compressor2) {
        if (!in_lambda || in_try && in_try.bfinally)
          return;
        var changed2 = false;
        for (var index = statements2.length;--index >= 0; ) {
          var stat = statements2[index];
          if (!(stat instanceof AST_SimpleStatement))
            break;
          var node = stat.body;
          if (!(node instanceof AST_Await))
            break;
          var exp = node.expression;
          if (!needs_enqueuing(compressor2, exp))
            break;
          changed2 = true;
          exp = exp.drop_side_effect_free(compressor2, true);
          if (exp) {
            stat.body = exp;
            break;
          }
        }
        statements2.length = index + 1;
        return changed2;
      }
      function inline_iife(statements2, compressor2) {
        var changed2 = false;
        var index = statements2.length - 1;
        if (in_lambda && index >= 0) {
          var no_return = in_try && in_try.bfinally && in_async_generator(scope);
          var inlined = statements2[index].try_inline(compressor2, block_scope, no_return);
          if (inlined) {
            statements2[index--] = inlined;
            changed2 = true;
          }
        }
        var loop = in_loop && in_try && in_try.bfinally ? "try" : in_loop;
        for (;index >= 0; index--) {
          var inlined = statements2[index].try_inline(compressor2, block_scope, true, loop);
          if (!inlined)
            continue;
          statements2[index] = inlined;
          changed2 = true;
        }
        return changed2;
      }
      function sequencesize(statements2, compressor2) {
        if (statements2.length < 2)
          return;
        var seq = [], n = 0;
        function push_seq() {
          if (!seq.length)
            return;
          var body = make_sequence(seq[0], seq);
          statements2[n++] = make_node(AST_SimpleStatement, body, { body });
          seq = [];
        }
        for (var i = 0, len = statements2.length;i < len; i++) {
          var stat = statements2[i];
          if (stat instanceof AST_SimpleStatement) {
            if (seq.length >= compressor2.sequences_limit)
              push_seq();
            merge_sequence(seq, stat.body);
          } else if (is_declaration(stat)) {
            statements2[n++] = stat;
          } else {
            push_seq();
            statements2[n++] = stat;
          }
        }
        push_seq();
        statements2.length = n;
        return n != len;
      }
      function to_simple_statement(block, decls) {
        if (!(block instanceof AST_BlockStatement))
          return block;
        var stat = null;
        for (var i = 0;i < block.body.length; i++) {
          var line = block.body[i];
          if (line instanceof AST_Var && declarations_only(line)) {
            decls.push(line);
          } else if (stat || is_lexical_definition(line)) {
            return false;
          } else {
            stat = line;
          }
        }
        return stat;
      }
      function sequencesize_2(statements2, compressor2) {
        var changed2 = false, n = 0, prev;
        for (var i = 0;i < statements2.length; i++) {
          var stat = statements2[i];
          if (prev) {
            if (stat instanceof AST_Exit) {
              if (stat.value || !in_async_generator(scope)) {
                stat.value = cons_seq(stat.value || make_node(AST_Undefined, stat)).optimize(compressor2);
              }
            } else if (stat instanceof AST_For) {
              if (!(stat.init instanceof AST_Definitions)) {
                var abort = false;
                prev.body.walk(new TreeWalker(function(node) {
                  if (abort || node instanceof AST_Scope)
                    return true;
                  if (node instanceof AST_Binary && node.operator == "in") {
                    abort = true;
                    return true;
                  }
                }));
                if (!abort) {
                  if (stat.init)
                    stat.init = cons_seq(stat.init);
                  else {
                    stat.init = prev.body;
                    n--;
                    changed2 = true;
                  }
                }
              }
            } else if (stat instanceof AST_ForIn) {
              if (!is_lexical_definition(stat.init))
                stat.object = cons_seq(stat.object);
            } else if (stat instanceof AST_If) {
              stat.condition = cons_seq(stat.condition);
            } else if (stat instanceof AST_Switch) {
              stat.expression = cons_seq(stat.expression);
            } else if (stat instanceof AST_With) {
              stat.expression = cons_seq(stat.expression);
            }
          }
          if (compressor2.option("conditionals") && stat instanceof AST_If) {
            var decls = [];
            var body = to_simple_statement(stat.body, decls);
            var alt = to_simple_statement(stat.alternative, decls);
            if (body !== false && alt !== false && decls.length > 0) {
              var len = decls.length;
              decls.push(make_node(AST_If, stat, {
                condition: stat.condition,
                body: body || make_node(AST_EmptyStatement, stat.body),
                alternative: alt
              }));
              decls.unshift(n, 1);
              [].splice.apply(statements2, decls);
              i += len;
              n += len + 1;
              prev = null;
              changed2 = true;
              continue;
            }
          }
          statements2[n++] = stat;
          prev = stat instanceof AST_SimpleStatement ? stat : null;
        }
        statements2.length = n;
        return changed2;
        function cons_seq(right) {
          n--;
          changed2 = true;
          var left = prev.body;
          return make_sequence(left, [left, right]);
        }
      }
      function extract_exprs(body) {
        if (body instanceof AST_Assign)
          return [body];
        if (body instanceof AST_Sequence)
          return body.expressions.slice();
      }
      function join_assigns(defn, body, keep) {
        var exprs = extract_exprs(body);
        if (!exprs)
          return;
        keep = keep || 0;
        var trimmed = false;
        for (var i = exprs.length - keep;--i >= 0; ) {
          var expr = exprs[i];
          if (!can_trim(expr))
            continue;
          var tail;
          if (expr.left instanceof AST_SymbolRef) {
            tail = exprs.slice(i + 1);
          } else if (expr.left instanceof AST_PropAccess && can_trim(expr.left.expression)) {
            tail = exprs.slice(i + 1);
            var flattened = expr.clone();
            expr = expr.left.expression;
            flattened.left = flattened.left.clone();
            flattened.left.expression = expr.left.clone();
            tail.unshift(flattened);
          } else {
            continue;
          }
          if (tail.length == 0)
            continue;
          if (!trim_assigns(expr.left, expr.right, tail))
            continue;
          trimmed = true;
          exprs = exprs.slice(0, i).concat(expr, tail);
        }
        if (defn instanceof AST_Definitions) {
          for (var i = defn.definitions.length;--i >= 0; ) {
            var def = defn.definitions[i];
            if (!def.value)
              continue;
            if (trim_assigns(def.name, def.value, exprs))
              trimmed = true;
            if (merge_conditional_assignments(def, exprs, keep))
              trimmed = true;
            break;
          }
          if (defn instanceof AST_Var && join_var_assign(defn.definitions, exprs, keep))
            trimmed = true;
        }
        return trimmed && exprs;
        function can_trim(node) {
          return node instanceof AST_Assign && node.operator == "=";
        }
      }
      function merge_assigns(prev, defn) {
        if (!(prev instanceof AST_SimpleStatement))
          return;
        if (declarations_only(defn))
          return;
        var exprs = extract_exprs(prev.body);
        if (!exprs)
          return;
        var definitions = [];
        if (!join_var_assign(definitions, exprs.reverse(), 0))
          return;
        defn.definitions = definitions.reverse().concat(defn.definitions);
        return exprs.reverse();
      }
      function merge_conditional_assignments(var_def, exprs, keep) {
        if (!compressor.option("conditionals"))
          return;
        if (var_def.name instanceof AST_Destructured)
          return;
        var trimmed = false;
        var def = var_def.name.definition();
        while (exprs.length > keep) {
          var cond = to_conditional_assignment(compressor, def, var_def.value, exprs[0]);
          if (!cond)
            break;
          var_def.value = cond;
          exprs.shift();
          trimmed = true;
        }
        return trimmed;
      }
      function join_var_assign(definitions, exprs, keep) {
        var trimmed = false;
        while (exprs.length > keep) {
          var expr = exprs[0];
          if (!(expr instanceof AST_Assign))
            break;
          if (expr.operator != "=")
            break;
          var lhs = expr.left;
          if (!(lhs instanceof AST_SymbolRef))
            break;
          if (is_undeclared_ref(lhs))
            break;
          if (lhs.scope.resolve() !== scope)
            break;
          var def = lhs.definition();
          if (def.scope !== scope)
            break;
          if (def.orig.length > def.eliminated + 1)
            break;
          if (def.orig[0].TYPE != "SymbolVar")
            break;
          var name = make_node(AST_SymbolVar, lhs);
          definitions.push(make_node(AST_VarDef, expr, {
            name,
            value: expr.right
          }));
          def.orig.push(name);
          def.replaced++;
          exprs.shift();
          trimmed = true;
        }
        return trimmed;
      }
      function trim_assigns(name, value, exprs) {
        var names = new Dictionary;
        names.set(name.name, true);
        while (value instanceof AST_Assign && value.operator == "=") {
          if (value.left instanceof AST_SymbolRef)
            names.set(value.left.name, true);
          value = value.right;
        }
        if (!(value instanceof AST_Object))
          return;
        var trimmed = false;
        do {
          if (!try_join(exprs[0]))
            break;
          exprs.shift();
          trimmed = true;
        } while (exprs.length);
        return trimmed;
        function try_join(node) {
          if (!(node instanceof AST_Assign))
            return;
          if (node.operator != "=")
            return;
          if (!(node.left instanceof AST_PropAccess))
            return;
          var sym = node.left.expression;
          if (!(sym instanceof AST_SymbolRef))
            return;
          if (!names.has(sym.name))
            return;
          if (!node.right.is_constant_expression(scope))
            return;
          var prop = node.left.property;
          if (prop instanceof AST_Node) {
            if (try_join(prop))
              prop = node.left.property = prop.right.clone();
            prop = prop.evaluate(compressor);
          }
          if (prop instanceof AST_Node)
            return;
          prop = "" + prop;
          var diff = prop == "__proto__" || compressor.has_directive("use strict") ? function(node2) {
            var key = node2.key;
            return typeof key == "string" && key != prop && key != "__proto__";
          } : function(node2) {
            var key = node2.key;
            if (node2 instanceof AST_ObjectGetter || node2 instanceof AST_ObjectSetter) {
              return typeof key == "string" && key != prop;
            }
            return key !== "__proto__";
          };
          if (!all(value.properties, diff))
            return;
          value.properties.push(make_node(AST_ObjectKeyVal, node, {
            key: prop,
            value: node.right
          }));
          return true;
        }
      }
      function join_consecutive_vars(statements2) {
        var changed2 = false, defs;
        for (var i = 0, j = -1;i < statements2.length; i++) {
          var stat = statements2[i];
          var prev = statements2[j];
          if (stat instanceof AST_Definitions) {
            if (prev && prev.TYPE == stat.TYPE) {
              prev.definitions = prev.definitions.concat(stat.definitions);
              changed2 = true;
            } else if (defs && defs.TYPE == stat.TYPE && declarations_only(stat)) {
              defs.definitions = defs.definitions.concat(stat.definitions);
              changed2 = true;
            } else if (stat instanceof AST_Var) {
              var exprs = merge_assigns(prev, stat);
              if (exprs) {
                if (exprs.length) {
                  prev.body = make_sequence(prev, exprs);
                  j++;
                }
                changed2 = true;
              } else {
                j++;
              }
              statements2[j] = defs = stat;
            } else {
              statements2[++j] = stat;
            }
            continue;
          } else if (stat instanceof AST_Exit) {
            stat.value = join_assigns_expr(stat.value);
          } else if (stat instanceof AST_For) {
            var exprs = join_assigns(prev, stat.init);
            if (exprs) {
              changed2 = true;
              stat.init = exprs.length ? make_sequence(stat.init, exprs) : null;
            } else if (prev instanceof AST_Var && (!stat.init || stat.init.TYPE == prev.TYPE)) {
              if (stat.init) {
                prev.definitions = prev.definitions.concat(stat.init.definitions);
              }
              stat = stat.clone();
              defs = stat.init = prev;
              statements2[j] = merge_defns(stat);
              changed2 = true;
              continue;
            } else if (defs && stat.init && defs.TYPE == stat.init.TYPE && declarations_only(stat.init)) {
              defs.definitions = defs.definitions.concat(stat.init.definitions);
              stat.init = null;
              changed2 = true;
            } else if (stat.init instanceof AST_Var) {
              defs = stat.init;
              exprs = merge_assigns(prev, stat.init);
              if (exprs) {
                changed2 = true;
                if (exprs.length == 0) {
                  statements2[j] = merge_defns(stat);
                  continue;
                }
                prev.body = make_sequence(prev, exprs);
              }
            }
          } else if (stat instanceof AST_ForEnumeration) {
            if (defs && defs.TYPE == stat.init.TYPE) {
              var defns = defs.definitions.slice();
              stat.init = stat.init.definitions[0].name.convert_symbol(AST_SymbolRef, function(ref, name) {
                defns.push(make_node(AST_VarDef, name, {
                  name,
                  value: null
                }));
                name.definition().references.push(ref);
              });
              defs.definitions = defns;
              changed2 = true;
            }
            stat.object = join_assigns_expr(stat.object);
          } else if (stat instanceof AST_If) {
            stat.condition = join_assigns_expr(stat.condition);
          } else if (stat instanceof AST_SimpleStatement) {
            var exprs = join_assigns(prev, stat.body), next;
            if (exprs) {
              changed2 = true;
              if (!exprs.length)
                continue;
              stat.body = make_sequence(stat.body, exprs);
            } else if (prev instanceof AST_Definitions && (next = statements2[i + 1]) && prev.TYPE == next.TYPE && (next = next.definitions[0]).value) {
              changed2 = true;
              next.value = make_sequence(stat, [stat.body, next.value]);
              continue;
            }
          } else if (stat instanceof AST_Switch) {
            stat.expression = join_assigns_expr(stat.expression);
          } else if (stat instanceof AST_With) {
            stat.expression = join_assigns_expr(stat.expression);
          }
          statements2[++j] = defs ? merge_defns(stat) : stat;
        }
        statements2.length = j + 1;
        return changed2;
        function join_assigns_expr(value) {
          var exprs2 = join_assigns(prev, value, 1);
          if (!exprs2)
            return value;
          changed2 = true;
          var tail = value.tail_node();
          if (exprs2[exprs2.length - 1] !== tail)
            exprs2.push(tail.left);
          return make_sequence(value, exprs2);
        }
        function merge_defns(stat2) {
          return stat2.transform(new TreeTransformer(function(node, descend, in_list) {
            if (node instanceof AST_Definitions) {
              if (defs === node)
                return node;
              if (defs.TYPE != node.TYPE)
                return node;
              var parent = this.parent();
              if (parent instanceof AST_ForEnumeration && parent.init === node)
                return node;
              if (!declarations_only(node))
                return node;
              defs.definitions = defs.definitions.concat(node.definitions);
              changed2 = true;
              if (parent instanceof AST_For && parent.init === node)
                return null;
              return in_list ? List.skip : make_node(AST_EmptyStatement, node);
            }
            if (node instanceof AST_ExportDeclaration)
              return node;
            if (node instanceof AST_Scope)
              return node;
            if (!is_statement(node))
              return node;
          }));
        }
      }
    }
    function extract_declarations_from_unreachable_code(compressor, stat, target) {
      var block;
      var dropped = false;
      stat.walk(new TreeWalker(function(node, descend) {
        if (node instanceof AST_DefClass) {
          node.extends = null;
          node.properties = [];
          push(node);
          return true;
        }
        if (node instanceof AST_Definitions) {
          var defns = [];
          if (node.remove_initializers(compressor, defns)) {
            AST_Node.warn("Dropping initialization in unreachable code [{start}]", node);
          }
          if (defns.length > 0) {
            node.definitions = defns;
            push(node);
          }
          return true;
        }
        if (node instanceof AST_LambdaDefinition) {
          push(node);
          return true;
        }
        if (node instanceof AST_Scope)
          return true;
        if (node instanceof AST_BlockScope) {
          var save = block;
          block = [];
          descend();
          if (block.required) {
            target.push(make_node(AST_BlockStatement, stat, { body: block }));
          } else if (block.length) {
            [].push.apply(target, block);
          }
          block = save;
          return true;
        }
        if (!(node instanceof AST_LoopControl))
          dropped = true;
      }));
      if (dropped)
        AST_Node.warn("Dropping unreachable code [{start}]", stat);
      function push(node) {
        if (block) {
          block.push(node);
          if (!safe_to_trim(node))
            block.required = true;
        } else {
          target.push(node);
        }
      }
    }
    function is_undefined(node, compressor) {
      return node == null || node.is_undefined || node instanceof AST_Undefined || node instanceof AST_UnaryPrefix && node.operator == "void" && !(compressor && node.expression.has_side_effects(compressor));
    }
    (function(def) {
      def(AST_Class, return_true);
      def(AST_Scope, function(compressor) {
        var body = this.body;
        for (var i = 0;i < body.length; i++) {
          var stat = body[i];
          if (!(stat instanceof AST_Directive))
            break;
          if (stat.value == "use strict")
            return true;
        }
        var parent = this.parent_scope;
        if (!parent)
          return compressor.option("module");
        return parent.resolve(true).in_strict_mode(compressor);
      });
    })(function(node, func) {
      node.DEFMETHOD("in_strict_mode", func);
    });
    (function(def) {
      def(AST_Node, return_false);
      def(AST_Array, return_true);
      def(AST_Assign, function() {
        return this.operator == "=" && this.right.is_truthy();
      });
      def(AST_Lambda, return_true);
      def(AST_Object, return_true);
      def(AST_RegExp, return_true);
      def(AST_Sequence, function() {
        return this.tail_node().is_truthy();
      });
      def(AST_SymbolRef, function() {
        var fixed = this.fixed_value();
        if (!fixed)
          return false;
        this.is_truthy = return_false;
        var result = fixed.is_truthy();
        delete this.is_truthy;
        return result;
      });
    })(function(node, func) {
      node.DEFMETHOD("is_truthy", func);
    });
    (function(def) {
      def(AST_Node, return_true);
      def(AST_Array, return_false);
      function binary(op, left, right) {
        switch (op) {
          case "-":
            return left.is_negative_zero() && (!(right instanceof AST_Constant) || right.value == 0);
          case "&&":
          case "||":
            return left.is_negative_zero() || right.is_negative_zero();
          case "*":
          case "/":
          case "%":
          case "**":
            return true;
          default:
            return false;
        }
      }
      def(AST_Assign, function() {
        var op = this.operator;
        if (op == "=")
          return this.right.is_negative_zero();
        return binary(op.slice(0, -1), this.left, this.right);
      });
      def(AST_Binary, function() {
        return binary(this.operator, this.left, this.right);
      });
      def(AST_Constant, function() {
        return this.value == 0 && 1 / this.value < 0;
      });
      def(AST_Lambda, return_false);
      def(AST_Object, return_false);
      def(AST_RegExp, return_false);
      def(AST_Sequence, function() {
        return this.tail_node().is_negative_zero();
      });
      def(AST_SymbolRef, function() {
        var fixed = this.fixed_value();
        if (!fixed)
          return true;
        this.is_negative_zero = return_true;
        var result = fixed.is_negative_zero();
        delete this.is_negative_zero;
        return result;
      });
      def(AST_UnaryPrefix, function() {
        return this.operator == "+" && this.expression.is_negative_zero() || this.operator == "-";
      });
    })(function(node, func) {
      node.DEFMETHOD("is_negative_zero", func);
    });
    (function(def) {
      AST_Node.DEFMETHOD("may_throw_on_access", function(compressor, force) {
        return !compressor.option("pure_getters") || this._dot_throw(compressor, force);
      });
      function is_strict(compressor, force) {
        return force || /strict/.test(compressor.option("pure_getters"));
      }
      def(AST_Node, is_strict);
      def(AST_Array, return_false);
      def(AST_Assign, function(compressor) {
        var op = this.operator;
        var sym = this.left;
        var rhs = this.right;
        if (op != "=") {
          return lazy_op[op.slice(0, -1)] && (sym._dot_throw(compressor) || rhs._dot_throw(compressor));
        }
        if (!rhs._dot_throw(compressor))
          return false;
        if (!(sym instanceof AST_SymbolRef))
          return true;
        if (rhs instanceof AST_Binary && rhs.operator == "||" && sym.name == rhs.left.name) {
          return rhs.right._dot_throw(compressor);
        }
        return true;
      });
      def(AST_Binary, function(compressor) {
        return lazy_op[this.operator] && (this.left._dot_throw(compressor) || this.right._dot_throw(compressor));
      });
      def(AST_Class, function(compressor, force) {
        return is_strict(compressor, force) && !all(this.properties, function(prop) {
          if (prop.private)
            return true;
          if (!prop.static)
            return true;
          return !(prop instanceof AST_ClassGetter || prop instanceof AST_ClassSetter);
        });
      });
      def(AST_Conditional, function(compressor) {
        return this.consequent._dot_throw(compressor) || this.alternative._dot_throw(compressor);
      });
      def(AST_Constant, return_false);
      def(AST_Dot, function(compressor, force) {
        if (!is_strict(compressor, force))
          return false;
        var exp = this.expression;
        if (exp instanceof AST_SymbolRef)
          exp = exp.fixed_value();
        return !(this.property == "prototype" && is_lambda(exp));
      });
      def(AST_Lambda, return_false);
      def(AST_Null, return_true);
      def(AST_Object, function(compressor, force) {
        return is_strict(compressor, force) && !all(this.properties, function(prop) {
          if (prop instanceof AST_ObjectGetter || prop instanceof AST_ObjectSetter)
            return false;
          return !(prop.key === "__proto__" && prop.value._dot_throw(compressor, force));
        });
      });
      def(AST_ObjectIdentity, function(compressor, force) {
        return is_strict(compressor, force) && !this.scope.resolve().new;
      });
      def(AST_Sequence, function(compressor) {
        return this.tail_node()._dot_throw(compressor);
      });
      def(AST_SymbolRef, function(compressor, force) {
        if (this.is_undefined)
          return true;
        if (!is_strict(compressor, force))
          return false;
        if (is_undeclared_ref(this) && this.is_declared(compressor))
          return false;
        if (this.is_immutable())
          return false;
        var def2 = this.definition();
        if (is_arguments(def2) && !def2.scope.rest && all(def2.scope.argnames, function(argname) {
          return argname instanceof AST_SymbolFunarg;
        }))
          return def2.scope.uses_arguments > 2;
        var fixed = this.fixed_value(true);
        if (!fixed)
          return true;
        this._dot_throw = return_true;
        if (fixed._dot_throw(compressor)) {
          delete this._dot_throw;
          return true;
        }
        this._dot_throw = return_false;
        return false;
      });
      def(AST_UnaryPrefix, function() {
        return this.operator == "void";
      });
      def(AST_UnaryPostfix, return_false);
      def(AST_Undefined, return_true);
    })(function(node, func) {
      node.DEFMETHOD("_dot_throw", func);
    });
    (function(def) {
      def(AST_Node, return_false);
      def(AST_Array, return_true);
      function is_binary_defined(compressor, op, node) {
        switch (op) {
          case "&&":
            return node.left.is_defined(compressor) && node.right.is_defined(compressor);
          case "||":
            return node.left.is_truthy() || node.right.is_defined(compressor);
          case "??":
            return node.left.is_defined(compressor) || node.right.is_defined(compressor);
          default:
            return true;
        }
      }
      def(AST_Assign, function(compressor) {
        var op = this.operator;
        if (op == "=")
          return this.right.is_defined(compressor);
        return is_binary_defined(compressor, op.slice(0, -1), this);
      });
      def(AST_Binary, function(compressor) {
        return is_binary_defined(compressor, this.operator, this);
      });
      def(AST_Conditional, function(compressor) {
        return this.consequent.is_defined(compressor) && this.alternative.is_defined(compressor);
      });
      def(AST_Constant, return_true);
      def(AST_Hole, return_false);
      def(AST_Lambda, return_true);
      def(AST_Object, return_true);
      def(AST_Sequence, function(compressor) {
        return this.tail_node().is_defined(compressor);
      });
      def(AST_SymbolRef, function(compressor) {
        if (this.is_undefined)
          return false;
        if (is_undeclared_ref(this) && this.is_declared(compressor))
          return true;
        if (this.is_immutable())
          return true;
        var fixed = this.fixed_value();
        if (!fixed)
          return false;
        this.is_defined = return_false;
        var result = fixed.is_defined(compressor);
        delete this.is_defined;
        return result;
      });
      def(AST_UnaryPrefix, function() {
        return this.operator != "void";
      });
      def(AST_UnaryPostfix, return_true);
      def(AST_Undefined, return_false);
    })(function(node, func) {
      node.DEFMETHOD("is_defined", func);
    });
    (function(def) {
      def(AST_Node, return_false);
      def(AST_Assign, function(compressor) {
        return this.operator == "=" && this.right.is_boolean(compressor);
      });
      var binary = makePredicate("in instanceof == != === !== < <= >= >");
      def(AST_Binary, function(compressor) {
        return binary[this.operator] || lazy_op[this.operator] && this.left.is_boolean(compressor) && this.right.is_boolean(compressor);
      });
      def(AST_Boolean, return_true);
      var fn = makePredicate("every hasOwnProperty isPrototypeOf propertyIsEnumerable some");
      def(AST_Call, function(compressor) {
        if (!compressor.option("unsafe"))
          return false;
        var exp = this.expression;
        return exp instanceof AST_Dot && (fn[exp.property] || exp.property == "test" && exp.expression instanceof AST_RegExp);
      });
      def(AST_Conditional, function(compressor) {
        return this.consequent.is_boolean(compressor) && this.alternative.is_boolean(compressor);
      });
      def(AST_New, return_false);
      def(AST_Sequence, function(compressor) {
        return this.tail_node().is_boolean(compressor);
      });
      def(AST_SymbolRef, function(compressor) {
        var fixed = this.fixed_value();
        if (!fixed)
          return false;
        this.is_boolean = return_false;
        var result = fixed.is_boolean(compressor);
        delete this.is_boolean;
        return result;
      });
      var unary = makePredicate("! delete");
      def(AST_UnaryPrefix, function() {
        return unary[this.operator];
      });
    })(function(node, func) {
      node.DEFMETHOD("is_boolean", func);
    });
    (function(def) {
      def(AST_Node, return_false);
      var binary = makePredicate("- * / % ** & | ^ << >> >>>");
      def(AST_Assign, function(compressor) {
        return binary[this.operator.slice(0, -1)] || this.operator == "=" && this.right.is_number(compressor);
      });
      def(AST_Binary, function(compressor) {
        if (binary[this.operator])
          return true;
        if (this.operator != "+")
          return false;
        return (this.left.is_boolean(compressor) || this.left.is_number(compressor)) && (this.right.is_boolean(compressor) || this.right.is_number(compressor));
      });
      var fn = makePredicate([
        "charCodeAt",
        "getDate",
        "getDay",
        "getFullYear",
        "getHours",
        "getMilliseconds",
        "getMinutes",
        "getMonth",
        "getSeconds",
        "getTime",
        "getTimezoneOffset",
        "getUTCDate",
        "getUTCDay",
        "getUTCFullYear",
        "getUTCHours",
        "getUTCMilliseconds",
        "getUTCMinutes",
        "getUTCMonth",
        "getUTCSeconds",
        "getYear",
        "indexOf",
        "lastIndexOf",
        "localeCompare",
        "push",
        "search",
        "setDate",
        "setFullYear",
        "setHours",
        "setMilliseconds",
        "setMinutes",
        "setMonth",
        "setSeconds",
        "setTime",
        "setUTCDate",
        "setUTCFullYear",
        "setUTCHours",
        "setUTCMilliseconds",
        "setUTCMinutes",
        "setUTCMonth",
        "setUTCSeconds",
        "setYear"
      ]);
      def(AST_Call, function(compressor) {
        if (!compressor.option("unsafe"))
          return false;
        var exp = this.expression;
        return exp instanceof AST_Dot && (fn[exp.property] || is_undeclared_ref(exp.expression) && exp.expression.name == "Math");
      });
      def(AST_Conditional, function(compressor) {
        return this.consequent.is_number(compressor) && this.alternative.is_number(compressor);
      });
      def(AST_New, return_false);
      def(AST_Number, return_true);
      def(AST_Sequence, function(compressor) {
        return this.tail_node().is_number(compressor);
      });
      def(AST_SymbolRef, function(compressor, keep_unary) {
        var fixed = this.fixed_value();
        if (!fixed)
          return false;
        if (keep_unary && fixed instanceof AST_UnaryPrefix && fixed.operator == "+" && fixed.expression.equals(this)) {
          return false;
        }
        this.is_number = return_false;
        var result = fixed.is_number(compressor);
        delete this.is_number;
        return result;
      });
      var unary = makePredicate("+ - ~ ++ --");
      def(AST_Unary, function() {
        return unary[this.operator];
      });
    })(function(node, func) {
      node.DEFMETHOD("is_number", func);
    });
    (function(def) {
      def(AST_Node, return_false);
      def(AST_Assign, function(compressor) {
        switch (this.operator) {
          case "+=":
            if (this.left.is_string(compressor))
              return true;
          case "=":
            return this.right.is_string(compressor);
        }
      });
      def(AST_Binary, function(compressor) {
        return this.operator == "+" && (this.left.is_string(compressor) || this.right.is_string(compressor));
      });
      var fn = makePredicate([
        "charAt",
        "substr",
        "substring",
        "toExponential",
        "toFixed",
        "toLowerCase",
        "toPrecision",
        "toString",
        "toUpperCase",
        "trim"
      ]);
      def(AST_Call, function(compressor) {
        if (!compressor.option("unsafe"))
          return false;
        var exp = this.expression;
        return exp instanceof AST_Dot && fn[exp.property];
      });
      def(AST_Conditional, function(compressor) {
        return this.consequent.is_string(compressor) && this.alternative.is_string(compressor);
      });
      def(AST_Sequence, function(compressor) {
        return this.tail_node().is_string(compressor);
      });
      def(AST_String, return_true);
      def(AST_SymbolRef, function(compressor) {
        var fixed = this.fixed_value();
        if (!fixed)
          return false;
        this.is_string = return_false;
        var result = fixed.is_string(compressor);
        delete this.is_string;
        return result;
      });
      def(AST_Template, function(compressor) {
        return !this.tag || is_raw_tag(compressor, this.tag);
      });
      def(AST_UnaryPrefix, function() {
        return this.operator == "typeof";
      });
    })(function(node, func) {
      node.DEFMETHOD("is_string", func);
    });
    var lazy_op = makePredicate("&& || ??");
    (function(def) {
      function to_node(value, orig) {
        if (value instanceof AST_Node)
          return value.clone(true);
        if (Array.isArray(value))
          return make_node(AST_Array, orig, {
            elements: value.map(function(value2) {
              return to_node(value2, orig);
            })
          });
        if (value && typeof value == "object") {
          var props = [];
          for (var key in value)
            if (HOP(value, key)) {
              props.push(make_node(AST_ObjectKeyVal, orig, {
                key,
                value: to_node(value[key], orig)
              }));
            }
          return make_node(AST_Object, orig, { properties: props });
        }
        return make_node_from_constant(value, orig);
      }
      function warn(node) {
        AST_Node.warn("global_defs {this} redefined [{start}]", node);
      }
      AST_Toplevel.DEFMETHOD("resolve_defines", function(compressor) {
        if (!compressor.option("global_defs"))
          return this;
        this.figure_out_scope({ ie: compressor.option("ie") });
        return this.transform(new TreeTransformer(function(node) {
          var def2 = node._find_defs(compressor, "");
          if (!def2)
            return;
          var level = 0, child = node, parent;
          while (parent = this.parent(level++)) {
            if (!(parent instanceof AST_PropAccess))
              break;
            if (parent.expression !== child)
              break;
            child = parent;
          }
          if (is_lhs(child, parent)) {
            warn(node);
            return;
          }
          return def2;
        }));
      });
      def(AST_Node, noop);
      def(AST_Dot, function(compressor, suffix) {
        return this.expression._find_defs(compressor, "." + this.property + suffix);
      });
      def(AST_SymbolDeclaration, function(compressor) {
        if (!this.definition().global)
          return;
        if (HOP(compressor.option("global_defs"), this.name))
          warn(this);
      });
      def(AST_SymbolRef, function(compressor, suffix) {
        if (!this.definition().global)
          return;
        var defines = compressor.option("global_defs");
        var name = this.name + suffix;
        if (HOP(defines, name))
          return to_node(defines[name], this);
      });
    })(function(node, func) {
      node.DEFMETHOD("_find_defs", func);
    });
    function best_of_expression(ast1, ast2, threshold) {
      var delta = ast2.print_to_string().length - ast1.print_to_string().length;
      return delta < (threshold || 0) ? ast2 : ast1;
    }
    function best_of_statement(ast1, ast2, threshold) {
      return best_of_expression(make_node(AST_SimpleStatement, ast1, {
        body: ast1
      }), make_node(AST_SimpleStatement, ast2, {
        body: ast2
      }), threshold).body;
    }
    function best_of(compressor, ast1, ast2, threshold) {
      return (first_in_statement(compressor) ? best_of_statement : best_of_expression)(ast1, ast2, threshold);
    }
    function convert_to_predicate(obj) {
      var map = Object.create(null);
      Object.keys(obj).forEach(function(key) {
        map[key] = makePredicate(obj[key]);
      });
      return map;
    }
    function skip_directives(body) {
      for (var i = 0;i < body.length; i++) {
        var stat = body[i];
        if (!(stat instanceof AST_Directive))
          return stat;
      }
    }
    function arrow_first_statement() {
      if (this.value)
        return make_node(AST_Return, this.value, { value: this.value });
      return skip_directives(this.body);
    }
    AST_Arrow.DEFMETHOD("first_statement", arrow_first_statement);
    AST_AsyncArrow.DEFMETHOD("first_statement", arrow_first_statement);
    AST_Lambda.DEFMETHOD("first_statement", function() {
      return skip_directives(this.body);
    });
    AST_Lambda.DEFMETHOD("length", function() {
      var argnames = this.argnames;
      for (var i = 0;i < argnames.length; i++) {
        if (argnames[i] instanceof AST_DefaultValue)
          break;
      }
      return i;
    });
    function try_evaluate(compressor, node) {
      var ev = node.evaluate(compressor);
      if (ev === node)
        return node;
      ev = make_node_from_constant(ev, node).optimize(compressor);
      return best_of(compressor, node, ev, compressor.eval_threshold);
    }
    var object_fns = [
      "constructor",
      "toString",
      "valueOf"
    ];
    var native_fns = convert_to_predicate({
      Array: [
        "indexOf",
        "join",
        "lastIndexOf",
        "slice"
      ].concat(object_fns),
      Boolean: object_fns,
      Function: object_fns,
      Number: [
        "toExponential",
        "toFixed",
        "toPrecision"
      ].concat(object_fns),
      Object: object_fns,
      RegExp: [
        "exec",
        "test"
      ].concat(object_fns),
      String: [
        "charAt",
        "charCodeAt",
        "concat",
        "indexOf",
        "italics",
        "lastIndexOf",
        "match",
        "replace",
        "search",
        "slice",
        "split",
        "substr",
        "substring",
        "toLowerCase",
        "toUpperCase",
        "trim"
      ].concat(object_fns)
    });
    var static_fns = convert_to_predicate({
      Array: [
        "isArray"
      ],
      Math: [
        "abs",
        "acos",
        "asin",
        "atan",
        "ceil",
        "cos",
        "exp",
        "floor",
        "log",
        "round",
        "sin",
        "sqrt",
        "tan",
        "atan2",
        "pow",
        "max",
        "min"
      ],
      Number: [
        "isFinite",
        "isNaN"
      ],
      Object: [
        "create",
        "getOwnPropertyDescriptor",
        "getOwnPropertyNames",
        "getPrototypeOf",
        "isExtensible",
        "isFrozen",
        "isSealed",
        "keys"
      ],
      String: [
        "fromCharCode",
        "raw"
      ]
    });
    function is_static_fn(node) {
      if (!(node instanceof AST_Dot))
        return false;
      var expr = node.expression;
      if (!is_undeclared_ref(expr))
        return false;
      var static_fn = static_fns[expr.name];
      return static_fn && (static_fn[node.property] || expr.name == "Math" && node.property == "random");
    }
    (function(def) {
      def(AST_Node, return_false);
      def(AST_Constant, return_true);
      def(AST_RegExp, return_false);
      var unaryPrefix = makePredicate("! ~ - + void");
      def(AST_UnaryPrefix, function() {
        return unaryPrefix[this.operator] && this.expression instanceof AST_Constant;
      });
    })(function(node, func) {
      node.DEFMETHOD("is_constant", func);
    });
    (function(def) {
      AST_Node.DEFMETHOD("evaluate", function(compressor, ignore_side_effects) {
        if (!compressor.option("evaluate"))
          return this;
        var cached = [];
        var val = this._eval(compressor, ignore_side_effects, cached, 1);
        cached.forEach(function(node) {
          delete node._eval;
        });
        if (ignore_side_effects)
          return val;
        if (!val || val instanceof RegExp)
          return val;
        if (typeof val == "function" || typeof val == "object")
          return this;
        return val;
      });
      var scan_modified = new TreeWalker(function(node) {
        if (node instanceof AST_Assign)
          modified(node.left);
        if (node instanceof AST_ForEnumeration)
          modified(node.init);
        if (node instanceof AST_Unary && UNARY_POSTFIX[node.operator])
          modified(node.expression);
      });
      function modified(node) {
        if (node instanceof AST_DestructuredArray) {
          node.elements.forEach(modified);
        } else if (node instanceof AST_DestructuredObject) {
          node.properties.forEach(function(prop) {
            modified(prop.value);
          });
        } else if (node instanceof AST_PropAccess) {
          modified(node.expression);
        } else if (node instanceof AST_SymbolRef) {
          node.definition().references.forEach(function(ref) {
            delete ref._eval;
          });
        }
      }
      def(AST_Statement, function() {
        throw new Error(string_template("Cannot evaluate a statement [{start}]", this));
      });
      def(AST_Accessor, return_this);
      def(AST_BigInt, return_this);
      def(AST_Class, return_this);
      def(AST_Node, return_this);
      def(AST_Constant, function() {
        return this.value;
      });
      def(AST_Assign, function(compressor, ignore_side_effects, cached, depth) {
        var lhs = this.left;
        if (!ignore_side_effects) {
          if (!(lhs instanceof AST_SymbolRef))
            return this;
          if (!HOP(lhs, "_eval")) {
            if (!lhs.fixed)
              return this;
            var def2 = lhs.definition();
            if (!def2.fixed)
              return this;
            if (def2.undeclared)
              return this;
            if (def2.last_ref !== lhs)
              return this;
            if (def2.single_use == "m")
              return this;
            if (this.right.has_side_effects(compressor))
              return this;
          }
        }
        var op = this.operator;
        var node;
        if (!HOP(lhs, "_eval") && lhs instanceof AST_SymbolRef && lhs.fixed && lhs.definition().fixed) {
          node = lhs;
        } else if (op == "=") {
          node = this.right;
        } else {
          node = make_node(AST_Binary, this, {
            operator: op.slice(0, -1),
            left: lhs,
            right: this.right
          });
        }
        lhs.walk(scan_modified);
        var value = node._eval(compressor, ignore_side_effects, cached, depth);
        if (typeof value == "object")
          return this;
        modified(lhs);
        return value;
      });
      def(AST_Sequence, function(compressor, ignore_side_effects, cached, depth) {
        if (!ignore_side_effects)
          return this;
        var exprs = this.expressions;
        for (var i = 0, last = exprs.length - 1;i < last; i++) {
          exprs[i].walk(scan_modified);
        }
        var tail = exprs[last];
        var value = tail._eval(compressor, ignore_side_effects, cached, depth);
        return value === tail ? this : value;
      });
      def(AST_Lambda, function(compressor) {
        if (compressor.option("unsafe")) {
          var fn = function() {
          };
          fn.node = this;
          fn.toString = function() {
            return "function(){}";
          };
          return fn;
        }
        return this;
      });
      def(AST_Array, function(compressor, ignore_side_effects, cached, depth) {
        if (compressor.option("unsafe")) {
          var elements = [];
          for (var i = 0;i < this.elements.length; i++) {
            var element = this.elements[i];
            if (element instanceof AST_Hole)
              return this;
            var value = element._eval(compressor, ignore_side_effects, cached, depth);
            if (element === value)
              return this;
            elements.push(value);
          }
          return elements;
        }
        return this;
      });
      def(AST_Object, function(compressor, ignore_side_effects, cached, depth) {
        if (compressor.option("unsafe")) {
          var val = {};
          for (var i = 0;i < this.properties.length; i++) {
            var prop = this.properties[i];
            if (!(prop instanceof AST_ObjectKeyVal))
              return this;
            var key = prop.key;
            if (key instanceof AST_Node) {
              key = key._eval(compressor, ignore_side_effects, cached, depth);
              if (key === prop.key)
                return this;
            }
            switch (key) {
              case "__proto__":
              case "toString":
              case "valueOf":
                return this;
            }
            val[key] = prop.value._eval(compressor, ignore_side_effects, cached, depth);
            if (val[key] === prop.value)
              return this;
          }
          return val;
        }
        return this;
      });
      var non_converting_unary = makePredicate("! typeof void");
      def(AST_UnaryPrefix, function(compressor, ignore_side_effects, cached, depth) {
        var e = this.expression;
        var op = this.operator;
        if (compressor.option("typeofs") && op == "typeof" && (e instanceof AST_Lambda || e instanceof AST_SymbolRef && e.fixed_value() instanceof AST_Lambda)) {
          return "function";
        }
        var def2 = e instanceof AST_SymbolRef && e.definition();
        if (!non_converting_unary[op] && !(def2 && def2.fixed))
          depth++;
        e.walk(scan_modified);
        var v = e._eval(compressor, ignore_side_effects, cached, depth);
        if (v === e) {
          if (ignore_side_effects && op == "void")
            return;
          return this;
        }
        switch (op) {
          case "!":
            return !v;
          case "typeof":
            if (v instanceof RegExp)
              return this;
            return typeof v;
          case "void":
            return;
          case "~":
            return ~v;
          case "-":
            return -v;
          case "+":
            return +v;
          case "++":
          case "--":
            if (!def2)
              return this;
            if (!ignore_side_effects) {
              if (def2.undeclared)
                return this;
              if (def2.last_ref !== e)
                return this;
            }
            if (HOP(e, "_eval"))
              v = +(op[0] + 1) + +v;
            modified(e);
            return v;
        }
        return this;
      });
      def(AST_UnaryPostfix, function(compressor, ignore_side_effects, cached, depth) {
        var e = this.expression;
        if (!(e instanceof AST_SymbolRef)) {
          if (!ignore_side_effects)
            return this;
        } else if (!HOP(e, "_eval")) {
          if (!e.fixed)
            return this;
          if (!ignore_side_effects) {
            var def2 = e.definition();
            if (!def2.fixed)
              return this;
            if (def2.undeclared)
              return this;
            if (def2.last_ref !== e)
              return this;
          }
        }
        if (!(e instanceof AST_SymbolRef && e.definition().fixed))
          depth++;
        e.walk(scan_modified);
        var v = e._eval(compressor, ignore_side_effects, cached, depth);
        if (v === e)
          return this;
        modified(e);
        return +v;
      });
      var non_converting_binary = makePredicate("&& || === !==");
      def(AST_Binary, function(compressor, ignore_side_effects, cached, depth) {
        if (!non_converting_binary[this.operator])
          depth++;
        var left = this.left._eval(compressor, ignore_side_effects, cached, depth);
        if (left === this.left)
          return this;
        if (this.operator == (left ? "||" : "&&"))
          return left;
        var rhs_ignore_side_effects = ignore_side_effects && !(left && typeof left == "object");
        var right = this.right._eval(compressor, rhs_ignore_side_effects, cached, depth);
        if (right === this.right)
          return this;
        var result;
        switch (this.operator) {
          case "&&":
            result = left && right;
            break;
          case "||":
            result = left || right;
            break;
          case "??":
            result = left == null ? right : left;
            break;
          case "|":
            result = left | right;
            break;
          case "&":
            result = left & right;
            break;
          case "^":
            result = left ^ right;
            break;
          case "+":
            result = left + right;
            break;
          case "-":
            result = left - right;
            break;
          case "*":
            result = left * right;
            break;
          case "/":
            result = left / right;
            break;
          case "%":
            result = left % right;
            break;
          case "<<":
            result = left << right;
            break;
          case ">>":
            result = left >> right;
            break;
          case ">>>":
            result = left >>> right;
            break;
          case "==":
            result = left == right;
            break;
          case "===":
            result = left === right;
            break;
          case "!=":
            result = left != right;
            break;
          case "!==":
            result = left !== right;
            break;
          case "<":
            result = left < right;
            break;
          case "<=":
            result = left <= right;
            break;
          case ">":
            result = left > right;
            break;
          case ">=":
            result = left >= right;
            break;
          case "**":
            result = Math.pow(left, right);
            break;
          case "in":
            if (right && typeof right == "object" && HOP(right, left)) {
              result = true;
              break;
            }
          default:
            return this;
        }
        if (isNaN(result))
          return compressor.find_parent(AST_With) ? this : result;
        if (compressor.option("unsafe_math") && !ignore_side_effects && result && typeof result == "number" && (this.operator == "+" || this.operator == "-")) {
          var digits = Math.max(0, decimals(left), decimals(right));
          if (digits < 16)
            return +result.toFixed(digits);
        }
        return result;
        function decimals(operand) {
          var match = /(\.[0-9]*)?(e[^e]+)?$/.exec(+operand);
          return (match[1] || ".").length - 1 - (match[2] || "").slice(1);
        }
      });
      def(AST_Conditional, function(compressor, ignore_side_effects, cached, depth) {
        var condition = this.condition._eval(compressor, ignore_side_effects, cached, depth);
        if (condition === this.condition)
          return this;
        var node = condition ? this.consequent : this.alternative;
        var value = node._eval(compressor, ignore_side_effects, cached, depth);
        return value === node ? this : value;
      });
      function verify_escaped(ref, depth) {
        var escaped = ref.definition().escaped;
        switch (escaped.length) {
          case 0:
            return true;
          case 1:
            var found = false;
            escaped[0].walk(new TreeWalker(function(node) {
              if (found)
                return true;
              if (node === ref)
                return found = true;
              if (node instanceof AST_Scope)
                return true;
            }));
            return found;
          default:
            return depth <= escaped.depth;
        }
      }
      def(AST_SymbolRef, function(compressor, ignore_side_effects, cached, depth) {
        var fixed = this.fixed_value();
        if (!fixed)
          return this;
        var value;
        if (HOP(fixed, "_eval")) {
          value = fixed._eval();
        } else {
          this._eval = return_this;
          value = fixed._eval(compressor, ignore_side_effects, cached, depth);
          delete this._eval;
          if (value === fixed)
            return this;
          fixed._eval = function() {
            return value;
          };
          cached.push(fixed);
        }
        return value && typeof value == "object" && !verify_escaped(this, depth) ? this : value;
      });
      var global_objs = {
        Array,
        Math,
        Number,
        Object,
        String
      };
      var static_values = convert_to_predicate({
        Math: [
          "E",
          "LN10",
          "LN2",
          "LOG2E",
          "LOG10E",
          "PI",
          "SQRT1_2",
          "SQRT2"
        ],
        Number: [
          "MAX_VALUE",
          "MIN_VALUE",
          "NaN",
          "NEGATIVE_INFINITY",
          "POSITIVE_INFINITY"
        ]
      });
      var regexp_props = makePredicate("global ignoreCase multiline source");
      def(AST_PropAccess, function(compressor, ignore_side_effects, cached, depth) {
        if (compressor.option("unsafe")) {
          var val;
          var exp = this.expression;
          if (!is_undeclared_ref(exp)) {
            val = exp._eval(compressor, ignore_side_effects, cached, depth + 1);
            if (val == null || val === exp)
              return this;
          }
          var key = this.property;
          if (key instanceof AST_Node) {
            key = key._eval(compressor, ignore_side_effects, cached, depth);
            if (key === this.property)
              return this;
          }
          if (val === undefined) {
            var static_value = static_values[exp.name];
            if (!static_value || !static_value[key])
              return this;
            val = global_objs[exp.name];
          } else if (val instanceof RegExp) {
            if (!regexp_props[key])
              return this;
          } else if (typeof val == "object") {
            if (!HOP(val, key))
              return this;
          } else if (typeof val == "function")
            switch (key) {
              case "name":
                return val.node.name ? val.node.name.name : "";
              case "length":
                return val.node.length();
              default:
                return this;
            }
          return val[key];
        }
        return this;
      });
      function eval_all(nodes, compressor, ignore_side_effects, cached, depth) {
        var values = [];
        for (var i = 0;i < nodes.length; i++) {
          var node = nodes[i];
          var value = node._eval(compressor, ignore_side_effects, cached, depth);
          if (node === value)
            return;
          values.push(value);
        }
        return values;
      }
      def(AST_Call, function(compressor, ignore_side_effects, cached, depth) {
        var exp = this.expression;
        var fn = exp instanceof AST_SymbolRef ? exp.fixed_value() : exp;
        if (fn instanceof AST_Arrow || fn instanceof AST_Defun || fn instanceof AST_Function) {
          if (fn.evaluating)
            return this;
          if (fn.name && fn.name.definition().recursive_refs > 0)
            return this;
          if (this.is_expr_pure(compressor))
            return this;
          var args = eval_all(this.args, compressor, ignore_side_effects, cached, depth);
          if (!all(fn.argnames, function(sym, index) {
            if (sym instanceof AST_DefaultValue) {
              if (!args)
                return false;
              if (args[index] === undefined) {
                var value = sym.value._eval(compressor, ignore_side_effects, cached, depth);
                if (value === sym.value)
                  return false;
                args[index] = value;
              }
              sym = sym.name;
            }
            return !(sym instanceof AST_Destructured);
          }))
            return this;
          if (fn.rest instanceof AST_Destructured)
            return this;
          if (!args && !ignore_side_effects)
            return this;
          var stat = fn.first_statement();
          if (!(stat instanceof AST_Return)) {
            if (ignore_side_effects) {
              fn.walk(scan_modified);
              var found = false;
              fn.evaluating = true;
              walk_body(fn, new TreeWalker(function(node) {
                if (found)
                  return true;
                if (node instanceof AST_Return) {
                  if (node.value && node.value._eval(compressor, true, cached, depth) !== undefined) {
                    found = true;
                  }
                  return true;
                }
                if (node instanceof AST_Scope && node !== fn)
                  return true;
              }));
              fn.evaluating = false;
              if (!found)
                return;
            }
            return this;
          }
          var val = stat.value;
          if (!val)
            return;
          var cached_args = [];
          if (!args || all(fn.argnames, function(sym, i) {
            return assign(sym, args[i]);
          }) && !(fn.rest && !assign(fn.rest, args.slice(fn.argnames.length))) || ignore_side_effects) {
            if (ignore_side_effects)
              fn.argnames.forEach(function(sym) {
                if (sym instanceof AST_DefaultValue)
                  sym.value.walk(scan_modified);
              });
            fn.evaluating = true;
            val = val._eval(compressor, ignore_side_effects, cached, depth);
            fn.evaluating = false;
          }
          cached_args.forEach(function(node) {
            delete node._eval;
          });
          return val === stat.value ? this : val;
        } else if (compressor.option("unsafe") && exp instanceof AST_PropAccess) {
          var key = exp.property;
          if (key instanceof AST_Node) {
            key = key._eval(compressor, ignore_side_effects, cached, depth);
            if (key === exp.property)
              return this;
          }
          var val;
          var e = exp.expression;
          if (is_undeclared_ref(e)) {
            var static_fn = static_fns[e.name];
            if (!static_fn || !static_fn[key])
              return this;
            val = global_objs[e.name];
          } else {
            val = e._eval(compressor, ignore_side_effects, cached, depth + 1);
            if (val == null || val === e)
              return this;
            var native_fn = native_fns[val.constructor.name];
            if (!native_fn || !native_fn[key])
              return this;
            if (val instanceof RegExp && val.global && !(e instanceof AST_RegExp))
              return this;
          }
          var args = eval_all(this.args, compressor, ignore_side_effects, cached, depth);
          if (!args)
            return this;
          if (key == "replace" && typeof args[1] == "function")
            return this;
          try {
            return val[key].apply(val, args);
          } catch (ex) {
            AST_Node.warn("Error evaluating {this} [{start}]", this);
          } finally {
            if (val instanceof RegExp)
              val.lastIndex = 0;
          }
        }
        return this;
        function assign(sym, arg) {
          if (sym instanceof AST_DefaultValue)
            sym = sym.name;
          var def2 = sym.definition();
          if (def2.orig[def2.orig.length - 1] !== sym)
            return false;
          var value = arg;
          def2.references.forEach(function(node) {
            node._eval = function() {
              return value;
            };
            cached_args.push(node);
          });
          return true;
        }
      });
      def(AST_New, return_this);
      def(AST_Template, function(compressor, ignore_side_effects, cached, depth) {
        if (!compressor.option("templates"))
          return this;
        if (this.tag) {
          if (!is_raw_tag(compressor, this.tag))
            return this;
          decode = function(str) {
            return str;
          };
        }
        var exprs = eval_all(this.expressions, compressor, ignore_side_effects, cached, depth);
        if (!exprs)
          return this;
        var malformed = false;
        var ret = decode(this.strings[0]);
        for (var i = 0;i < exprs.length; i++) {
          ret += exprs[i] + decode(this.strings[i + 1]);
        }
        if (!malformed)
          return ret;
        this._eval = return_this;
        return this;
        function decode(str) {
          str = decode_template(str);
          if (typeof str != "string")
            malformed = true;
          return str;
        }
      });
    })(function(node, func) {
      node.DEFMETHOD("_eval", func);
    });
    (function(def) {
      function basic_negation(exp) {
        return make_node(AST_UnaryPrefix, exp, {
          operator: "!",
          expression: exp
        });
      }
      function best(orig, alt, first_in_statement2) {
        var negated = basic_negation(orig);
        if (first_in_statement2)
          return best_of_expression(negated, make_node(AST_SimpleStatement, alt, {
            body: alt
          })) === negated ? negated : alt;
        return best_of_expression(negated, alt);
      }
      def(AST_Node, function() {
        return basic_negation(this);
      });
      def(AST_Statement, function() {
        throw new Error("Cannot negate a statement");
      });
      def(AST_Binary, function(compressor, first_in_statement2) {
        var self = this.clone(), op = this.operator;
        if (compressor.option("unsafe_comps")) {
          switch (op) {
            case "<=":
              self.operator = ">";
              return self;
            case "<":
              self.operator = ">=";
              return self;
            case ">=":
              self.operator = "<";
              return self;
            case ">":
              self.operator = "<=";
              return self;
          }
        }
        switch (op) {
          case "==":
            self.operator = "!=";
            return self;
          case "!=":
            self.operator = "==";
            return self;
          case "===":
            self.operator = "!==";
            return self;
          case "!==":
            self.operator = "===";
            return self;
          case "&&":
            self.operator = "||";
            self.left = self.left.negate(compressor, first_in_statement2);
            self.right = self.right.negate(compressor);
            return best(this, self, first_in_statement2);
          case "||":
            self.operator = "&&";
            self.left = self.left.negate(compressor, first_in_statement2);
            self.right = self.right.negate(compressor);
            return best(this, self, first_in_statement2);
        }
        return basic_negation(this);
      });
      def(AST_ClassExpression, function() {
        return basic_negation(this);
      });
      def(AST_Conditional, function(compressor, first_in_statement2) {
        var self = this.clone();
        self.consequent = self.consequent.negate(compressor);
        self.alternative = self.alternative.negate(compressor);
        return best(this, self, first_in_statement2);
      });
      def(AST_LambdaExpression, function() {
        return basic_negation(this);
      });
      def(AST_Sequence, function(compressor) {
        var expressions = this.expressions.slice();
        expressions.push(expressions.pop().negate(compressor));
        return make_sequence(this, expressions);
      });
      def(AST_UnaryPrefix, function() {
        if (this.operator == "!")
          return this.expression;
        return basic_negation(this);
      });
    })(function(node, func) {
      node.DEFMETHOD("negate", function(compressor, first_in_statement2) {
        return func.call(this, compressor, first_in_statement2);
      });
    });
    var global_pure_fns = makePredicate("Boolean decodeURI decodeURIComponent Date encodeURI encodeURIComponent Error escape EvalError isFinite isNaN Number Object parseFloat parseInt RangeError ReferenceError String SyntaxError TypeError unescape URIError");
    var global_pure_constructors = makePredicate("Map Set WeakMap WeakSet");
    AST_Call.DEFMETHOD("is_expr_pure", function(compressor) {
      if (compressor.option("unsafe")) {
        var expr = this.expression;
        if (is_undeclared_ref(expr)) {
          if (global_pure_fns[expr.name])
            return true;
          if (this instanceof AST_New && global_pure_constructors[expr.name])
            return true;
        }
        if (is_static_fn(expr))
          return true;
      }
      return compressor.option("annotations") && this.pure || !compressor.pure_funcs(this);
    });
    AST_Template.DEFMETHOD("is_expr_pure", function(compressor) {
      var tag = this.tag;
      if (!tag)
        return true;
      if (compressor.option("unsafe")) {
        if (is_undeclared_ref(tag) && global_pure_fns[tag.name])
          return true;
        if (tag instanceof AST_Dot && is_undeclared_ref(tag.expression)) {
          var static_fn = static_fns[tag.expression.name];
          return static_fn && (static_fn[tag.property] || tag.expression.name == "Math" && tag.property == "random");
        }
      }
      return !compressor.pure_funcs(this);
    });
    AST_Node.DEFMETHOD("is_call_pure", return_false);
    AST_Call.DEFMETHOD("is_call_pure", function(compressor) {
      if (!compressor.option("unsafe"))
        return false;
      var dot = this.expression;
      if (!(dot instanceof AST_Dot))
        return false;
      var exp = dot.expression;
      var map;
      var prop = dot.property;
      if (exp instanceof AST_Array) {
        map = native_fns.Array;
      } else if (exp.is_boolean(compressor)) {
        map = native_fns.Boolean;
      } else if (exp.is_number(compressor)) {
        map = native_fns.Number;
      } else if (exp instanceof AST_RegExp) {
        map = native_fns.RegExp;
      } else if (exp.is_string(compressor)) {
        map = native_fns.String;
        if (prop == "replace") {
          var arg = this.args[1];
          if (arg && !arg.is_string(compressor))
            return false;
        }
      } else if (!dot.may_throw_on_access(compressor)) {
        map = native_fns.Object;
      }
      return map && map[prop];
    });
    (function(def) {
      def(AST_Node, return_false);
      def(AST_Array, return_true);
      def(AST_Assign, function() {
        switch (this.operator) {
          case "=":
            return this.right.safe_to_spread();
          case "&&=":
          case "||=":
          case "??=":
            return this.left.safe_to_spread() && this.right.safe_to_spread();
        }
        return true;
      });
      def(AST_Binary, function() {
        return !lazy_op[this.operator] || this.left.safe_to_spread() && this.right.safe_to_spread();
      });
      def(AST_Constant, return_true);
      def(AST_Lambda, return_true);
      def(AST_Object, function() {
        return all(this.properties, function(prop) {
          return !(prop instanceof AST_ObjectGetter || prop instanceof AST_Spread);
        });
      });
      def(AST_Sequence, function() {
        return this.tail_node().safe_to_spread();
      });
      def(AST_SymbolRef, function() {
        var fixed = this.fixed_value();
        return fixed && fixed.safe_to_spread();
      });
      def(AST_Unary, return_true);
    })(function(node, func) {
      node.DEFMETHOD("safe_to_spread", func);
    });
    (function(def) {
      function any(list, compressor, spread) {
        return !all(list, spread ? function(node) {
          return node instanceof AST_Spread ? !spread(node, compressor) : !node.has_side_effects(compressor);
        } : function(node) {
          return !node.has_side_effects(compressor);
        });
      }
      function array_spread(node, compressor) {
        var exp = node.expression;
        return !exp.is_string(compressor) || exp.has_side_effects(compressor);
      }
      def(AST_Node, return_true);
      def(AST_Array, function(compressor) {
        return any(this.elements, compressor, array_spread);
      });
      def(AST_Assign, function(compressor) {
        var lhs = this.left;
        if (!(lhs instanceof AST_PropAccess))
          return true;
        var node = lhs.expression;
        return !(node instanceof AST_ObjectIdentity) || !node.scope.resolve().new || lhs instanceof AST_Sub && lhs.property.has_side_effects(compressor) || this.right.has_side_effects(compressor);
      });
      def(AST_Binary, function(compressor) {
        return this.left.has_side_effects(compressor) || this.right.has_side_effects(compressor) || !can_drop_op(this.operator, this.right, compressor);
      });
      def(AST_Block, function(compressor) {
        return any(this.body, compressor);
      });
      def(AST_Call, function(compressor) {
        if (!this.is_expr_pure(compressor) && (!this.is_call_pure(compressor) || this.expression.has_side_effects(compressor))) {
          return true;
        }
        return any(this.args, compressor, array_spread);
      });
      def(AST_Case, function(compressor) {
        return this.expression.has_side_effects(compressor) || any(this.body, compressor);
      });
      def(AST_Class, function(compressor) {
        var base = this.extends;
        if (base) {
          if (base instanceof AST_SymbolRef)
            base = base.fixed_value();
          if (!safe_for_extends(base))
            return true;
        }
        return any(this.properties, compressor);
      });
      def(AST_ClassProperty, function(compressor) {
        return this.key instanceof AST_Node && this.key.has_side_effects(compressor) || this.static && this.value && this.value.has_side_effects(compressor);
      });
      def(AST_Conditional, function(compressor) {
        return this.condition.has_side_effects(compressor) || this.consequent.has_side_effects(compressor) || this.alternative.has_side_effects(compressor);
      });
      def(AST_Constant, return_false);
      def(AST_Definitions, function(compressor) {
        return any(this.definitions, compressor);
      });
      def(AST_DestructuredArray, function(compressor) {
        return any(this.elements, compressor);
      });
      def(AST_DestructuredKeyVal, function(compressor) {
        return this.key instanceof AST_Node && this.key.has_side_effects(compressor) || this.value.has_side_effects(compressor);
      });
      def(AST_DestructuredObject, function(compressor) {
        return any(this.properties, compressor);
      });
      def(AST_Dot, function(compressor) {
        return this.expression.may_throw_on_access(compressor) || this.expression.has_side_effects(compressor);
      });
      def(AST_EmptyStatement, return_false);
      def(AST_If, function(compressor) {
        return this.condition.has_side_effects(compressor) || this.body && this.body.has_side_effects(compressor) || this.alternative && this.alternative.has_side_effects(compressor);
      });
      def(AST_LabeledStatement, function(compressor) {
        return this.body.has_side_effects(compressor);
      });
      def(AST_Lambda, return_false);
      def(AST_Object, function(compressor) {
        return any(this.properties, compressor, function(node, compressor2) {
          var exp = node.expression;
          return !exp.safe_to_spread() || exp.has_side_effects(compressor2);
        });
      });
      def(AST_ObjectIdentity, return_false);
      def(AST_ObjectProperty, function(compressor) {
        return this.key instanceof AST_Node && this.key.has_side_effects(compressor) || this.value.has_side_effects(compressor);
      });
      def(AST_Sequence, function(compressor) {
        return any(this.expressions, compressor);
      });
      def(AST_SimpleStatement, function(compressor) {
        return this.body.has_side_effects(compressor);
      });
      def(AST_Sub, function(compressor) {
        return this.expression.may_throw_on_access(compressor) || this.expression.has_side_effects(compressor) || this.property.has_side_effects(compressor);
      });
      def(AST_Switch, function(compressor) {
        return this.expression.has_side_effects(compressor) || any(this.body, compressor);
      });
      def(AST_SymbolDeclaration, return_false);
      def(AST_SymbolRef, function(compressor) {
        return !this.is_declared(compressor) || !can_drop_symbol(this, compressor);
      });
      def(AST_Template, function(compressor) {
        return !this.is_expr_pure(compressor) || any(this.expressions, compressor);
      });
      def(AST_Try, function(compressor) {
        return any(this.body, compressor) || this.bcatch && this.bcatch.has_side_effects(compressor) || this.bfinally && this.bfinally.has_side_effects(compressor);
      });
      def(AST_Unary, function(compressor) {
        return unary_side_effects[this.operator] || this.expression.has_side_effects(compressor);
      });
      def(AST_VarDef, function() {
        return this.value;
      });
    })(function(node, func) {
      node.DEFMETHOD("has_side_effects", func);
    });
    (function(def) {
      def(AST_Node, return_true);
      def(AST_Constant, return_false);
      def(AST_EmptyStatement, return_false);
      def(AST_Lambda, return_false);
      def(AST_ObjectIdentity, return_false);
      def(AST_SymbolDeclaration, return_false);
      function any(list, compressor) {
        for (var i = list.length;--i >= 0; )
          if (list[i].may_throw(compressor))
            return true;
        return false;
      }
      function call_may_throw(exp, compressor) {
        if (exp.may_throw(compressor))
          return true;
        if (exp instanceof AST_SymbolRef)
          exp = exp.fixed_value();
        if (!(exp instanceof AST_Lambda))
          return true;
        if (any(exp.argnames, compressor))
          return true;
        if (any(exp.body, compressor))
          return true;
        return is_arrow(exp) && exp.value && exp.value.may_throw(compressor);
      }
      def(AST_Array, function(compressor) {
        return any(this.elements, compressor);
      });
      def(AST_Assign, function(compressor) {
        if (this.right.may_throw(compressor))
          return true;
        if (!compressor.has_directive("use strict") && this.operator == "=" && this.left instanceof AST_SymbolRef) {
          return false;
        }
        return this.left.may_throw(compressor);
      });
      def(AST_Await, function(compressor) {
        return this.expression.may_throw(compressor);
      });
      def(AST_Binary, function(compressor) {
        return this.left.may_throw(compressor) || this.right.may_throw(compressor) || !can_drop_op(this.operator, this.right, compressor);
      });
      def(AST_Block, function(compressor) {
        return any(this.body, compressor);
      });
      def(AST_Call, function(compressor) {
        if (any(this.args, compressor))
          return true;
        if (this.is_expr_pure(compressor))
          return false;
        this.may_throw = return_true;
        var ret = call_may_throw(this.expression, compressor);
        delete this.may_throw;
        return ret;
      });
      def(AST_Case, function(compressor) {
        return this.expression.may_throw(compressor) || any(this.body, compressor);
      });
      def(AST_Conditional, function(compressor) {
        return this.condition.may_throw(compressor) || this.consequent.may_throw(compressor) || this.alternative.may_throw(compressor);
      });
      def(AST_DefaultValue, function(compressor) {
        return this.name.may_throw(compressor) || this.value && this.value.may_throw(compressor);
      });
      def(AST_Definitions, function(compressor) {
        return any(this.definitions, compressor);
      });
      def(AST_Dot, function(compressor) {
        return !this.optional && this.expression.may_throw_on_access(compressor) || this.expression.may_throw(compressor);
      });
      def(AST_ForEnumeration, function(compressor) {
        if (this.init.may_throw(compressor))
          return true;
        var obj = this.object;
        if (obj.may_throw(compressor))
          return true;
        obj = obj.tail_node();
        if (!(obj instanceof AST_Array || obj.is_string(compressor)))
          return true;
        return this.body.may_throw(compressor);
      });
      def(AST_If, function(compressor) {
        return this.condition.may_throw(compressor) || this.body && this.body.may_throw(compressor) || this.alternative && this.alternative.may_throw(compressor);
      });
      def(AST_LabeledStatement, function(compressor) {
        return this.body.may_throw(compressor);
      });
      def(AST_Object, function(compressor) {
        return any(this.properties, compressor);
      });
      def(AST_ObjectProperty, function(compressor) {
        return this.value.may_throw(compressor) || this.key instanceof AST_Node && this.key.may_throw(compressor);
      });
      def(AST_Return, function(compressor) {
        return this.value && this.value.may_throw(compressor);
      });
      def(AST_Sequence, function(compressor) {
        return any(this.expressions, compressor);
      });
      def(AST_SimpleStatement, function(compressor) {
        return this.body.may_throw(compressor);
      });
      def(AST_Sub, function(compressor) {
        return !this.optional && this.expression.may_throw_on_access(compressor) || this.expression.may_throw(compressor) || this.property.may_throw(compressor);
      });
      def(AST_Switch, function(compressor) {
        return this.expression.may_throw(compressor) || any(this.body, compressor);
      });
      def(AST_SymbolRef, function(compressor) {
        return !this.is_declared(compressor) || !can_drop_symbol(this, compressor);
      });
      def(AST_Template, function(compressor) {
        if (any(this.expressions, compressor))
          return true;
        if (this.is_expr_pure(compressor))
          return false;
        if (!this.tag)
          return false;
        this.may_throw = return_true;
        var ret = call_may_throw(this.tag, compressor);
        delete this.may_throw;
        return ret;
      });
      def(AST_Try, function(compressor) {
        return (this.bcatch ? this.bcatch.may_throw(compressor) : any(this.body, compressor)) || this.bfinally && this.bfinally.may_throw(compressor);
      });
      def(AST_Unary, function(compressor) {
        return this.expression.may_throw(compressor) && !(this.operator == "typeof" && this.expression instanceof AST_SymbolRef);
      });
      def(AST_VarDef, function(compressor) {
        return this.name.may_throw(compressor) || this.value && this.value.may_throw(compressor);
      });
    })(function(node, func) {
      node.DEFMETHOD("may_throw", func);
    });
    (function(def) {
      function all_constant(list, scope) {
        for (var i = list.length;--i >= 0; )
          if (!list[i].is_constant_expression(scope))
            return false;
        return true;
      }
      def(AST_Node, return_false);
      def(AST_Array, function(scope) {
        return all_constant(this.elements, scope);
      });
      def(AST_Binary, function(scope) {
        return this.left.is_constant_expression(scope) && this.right.is_constant_expression(scope) && can_drop_op(this.operator, this.right);
      });
      def(AST_Class, function(scope) {
        var base = this.extends;
        if (base && !safe_for_extends(base))
          return false;
        return all_constant(this.properties, scope);
      });
      def(AST_ClassProperty, function(scope) {
        return typeof this.key == "string" && (!this.value || this.value.is_constant_expression(scope));
      });
      def(AST_Constant, return_true);
      def(AST_Lambda, function(scope) {
        var self = this;
        var result = true;
        var scopes = [];
        self.walk(new TreeWalker(function(node, descend) {
          if (!result)
            return true;
          if (node instanceof AST_BlockScope) {
            if (node === self)
              return;
            scopes.push(node);
            descend();
            scopes.pop();
            return true;
          }
          if (node instanceof AST_SymbolRef) {
            if (self.inlined || node.redef || node.in_arg) {
              result = false;
              return true;
            }
            if (self.variables.has(node.name))
              return true;
            var def2 = node.definition();
            if (member(def2.scope, scopes))
              return true;
            if (scope && !def2.redefined()) {
              var scope_def = scope.find_variable(node.name);
              if (scope_def ? scope_def === def2 : def2.undeclared) {
                result = "f";
                return true;
              }
            }
            result = false;
            return true;
          }
          if (node instanceof AST_ObjectIdentity) {
            if (is_arrow(self) && all(scopes, function(s) {
              return !(s instanceof AST_Scope) || is_arrow(s);
            }))
              result = false;
            return true;
          }
        }));
        return result;
      });
      def(AST_Object, function(scope) {
        return all_constant(this.properties, scope);
      });
      def(AST_ObjectProperty, function(scope) {
        return typeof this.key == "string" && this.value.is_constant_expression(scope);
      });
      def(AST_Unary, function(scope) {
        return this.expression.is_constant_expression(scope);
      });
    })(function(node, func) {
      node.DEFMETHOD("is_constant_expression", func);
    });
    function aborts(thing) {
      return thing && thing.aborts();
    }
    (function(def) {
      def(AST_Statement, return_null);
      def(AST_Jump, return_this);
      function block_aborts() {
        var n = this.body.length;
        return n > 0 && aborts(this.body[n - 1]);
      }
      def(AST_BlockStatement, block_aborts);
      def(AST_SwitchBranch, block_aborts);
      def(AST_If, function() {
        return this.alternative && aborts(this.body) && aborts(this.alternative) && this;
      });
    })(function(node, func) {
      node.DEFMETHOD("aborts", func);
    });
    var directives = makePredicate(["use asm", "use strict"]);
    OPT(AST_Directive, function(self, compressor) {
      if (compressor.option("directives") && (!directives[self.value] || compressor.has_directive(self.value) !== self)) {
        return make_node(AST_EmptyStatement, self);
      }
      return self;
    });
    OPT(AST_Debugger, function(self, compressor) {
      if (compressor.option("drop_debugger"))
        return make_node(AST_EmptyStatement, self);
      return self;
    });
    OPT(AST_LabeledStatement, function(self, compressor) {
      if (self.body instanceof AST_If || self.body instanceof AST_Break) {
        var body = tighten_body([self.body], compressor);
        switch (body.length) {
          case 0:
            self.body = make_node(AST_EmptyStatement, self);
            break;
          case 1:
            self.body = body[0];
            break;
          default:
            self.body = make_node(AST_BlockStatement, self, { body });
            break;
        }
      }
      return compressor.option("unused") && self.label.references.length == 0 ? self.body : self;
    });
    OPT(AST_LoopControl, function(self, compressor) {
      if (!compressor.option("dead_code"))
        return self;
      var label = self.label;
      if (label) {
        var lct = compressor.loopcontrol_target(self);
        self.label = null;
        if (compressor.loopcontrol_target(self) === lct) {
          remove(label.thedef.references, self);
        } else {
          self.label = label;
        }
      }
      return self;
    });
    OPT(AST_Block, function(self, compressor) {
      self.body = tighten_body(self.body, compressor);
      return self;
    });
    function trim_block(node, parent, in_list) {
      switch (node.body.length) {
        case 0:
          return in_list ? List.skip : make_node(AST_EmptyStatement, node);
        case 1:
          var stat = node.body[0];
          if (!safe_to_trim(stat))
            return node;
          if (parent instanceof AST_IterationStatement && stat instanceof AST_LambdaDefinition)
            return node;
          return stat;
      }
      return node;
    }
    OPT(AST_BlockStatement, function(self, compressor) {
      self.body = tighten_body(self.body, compressor);
      return trim_block(self, compressor.parent());
    });
    function drop_rest_farg(fn, compressor) {
      if (!compressor.option("rests"))
        return;
      if (fn.uses_arguments)
        return;
      if (!(fn.rest instanceof AST_DestructuredArray))
        return;
      if (!compressor.drop_fargs(fn, compressor.parent()))
        return;
      fn.argnames = fn.argnames.concat(fn.rest.elements);
      fn.rest = fn.rest.rest;
    }
    OPT(AST_Lambda, function(self, compressor) {
      drop_rest_farg(self, compressor);
      self.body = tighten_body(self.body, compressor);
      return self;
    });
    function opt_arrow(self, compressor) {
      if (!compressor.option("arrows"))
        return self;
      drop_rest_farg(self, compressor);
      if (self.value)
        self.body = [self.first_statement()];
      var body = tighten_body(self.body, compressor);
      switch (body.length) {
        case 1:
          var stat = body[0];
          if (stat instanceof AST_Return) {
            self.body.length = 0;
            self.value = stat.value;
            break;
          }
        default:
          self.body = body;
          self.value = null;
          break;
      }
      return self;
    }
    OPT(AST_Arrow, opt_arrow);
    OPT(AST_AsyncArrow, opt_arrow);
    OPT(AST_Function, function(self, compressor) {
      drop_rest_farg(self, compressor);
      self.body = tighten_body(self.body, compressor);
      var parent = compressor.parent();
      if (compressor.option("inline"))
        for (var i = 0;i < self.body.length; i++) {
          var stat = self.body[i];
          if (stat instanceof AST_Directive)
            continue;
          if (stat instanceof AST_Return) {
            if (i != self.body.length - 1)
              break;
            var call = stat.value;
            if (!call || call.TYPE != "Call")
              break;
            if (call.is_expr_pure(compressor))
              break;
            var exp = call.expression, fn;
            if (!(exp instanceof AST_SymbolRef)) {
              fn = exp;
            } else if (self.name && self.name.definition() === exp.definition()) {
              break;
            } else {
              fn = exp.fixed_value();
            }
            if (!(fn instanceof AST_Defun || fn instanceof AST_Function))
              break;
            if (fn.rest)
              break;
            if (fn.uses_arguments)
              break;
            if (fn === exp) {
              if (fn.parent_scope !== self)
                break;
              if (!all(fn.enclosed, function(def) {
                return def.scope !== self;
              }))
                break;
            }
            if ((fn !== exp || fn.name) && (parent instanceof AST_ClassMethod || parent instanceof AST_ObjectMethod) && parent.value === compressor.self())
              break;
            if (fn.contains_this())
              break;
            var len = fn.argnames.length;
            if (len > 0 && compressor.option("inline") < 2)
              break;
            if (len > self.argnames.length)
              break;
            if (!all(self.argnames, function(argname) {
              return argname instanceof AST_SymbolFunarg;
            }))
              break;
            if (!all(call.args, function(arg2) {
              return !(arg2 instanceof AST_Spread);
            }))
              break;
            for (var j = 0;j < len; j++) {
              var arg = call.args[j];
              if (!(arg instanceof AST_SymbolRef))
                break;
              if (arg.definition() !== self.argnames[j].definition())
                break;
            }
            if (j < len)
              break;
            for (;j < call.args.length; j++) {
              if (call.args[j].has_side_effects(compressor))
                break;
            }
            if (j < call.args.length)
              break;
            if (len < self.argnames.length && !compressor.drop_fargs(self, parent)) {
              if (!compressor.drop_fargs(fn, call))
                break;
              do {
                fn.argnames.push(fn.make_var(AST_SymbolFunarg, fn, "argument_" + len));
              } while (++len < self.argnames.length);
            }
            return exp;
          }
          break;
        }
      return self;
    });
    var NO_MERGE = makePredicate("arguments await yield");
    AST_Scope.DEFMETHOD("merge_variables", function(compressor) {
      if (!compressor.option("merge_vars"))
        return;
      var in_arg = [], in_try, root, segment = {}, self = this;
      var first = [], last = [], index = 0;
      var declarations = new Dictionary;
      var references = Object.create(null);
      var prev = Object.create(null);
      var tw = new TreeWalker(function(node, descend) {
        if (node instanceof AST_Assign) {
          var lhs = node.left;
          var rhs = node.right;
          if (lhs instanceof AST_Destructured) {
            rhs.walk(tw);
            walk_destructured(AST_SymbolRef, mark, lhs);
            return true;
          }
          if (lazy_op[node.operator.slice(0, -1)]) {
            lhs.walk(tw);
            push();
            rhs.walk(tw);
            if (lhs instanceof AST_SymbolRef)
              mark(lhs);
            pop();
            return true;
          }
          if (lhs instanceof AST_SymbolRef) {
            if (node.operator != "=")
              mark(lhs, true);
            rhs.walk(tw);
            mark(lhs);
            return true;
          }
          return;
        }
        if (node instanceof AST_Binary) {
          if (!lazy_op[node.operator])
            return;
          walk_cond(node);
          return true;
        }
        if (node instanceof AST_Break) {
          var target = tw.loopcontrol_target(node);
          if (!(target instanceof AST_IterationStatement))
            insert(target);
          return true;
        }
        if (node instanceof AST_Call) {
          var exp = node.expression;
          if (exp instanceof AST_LambdaExpression) {
            node.args.forEach(function(arg) {
              arg.walk(tw);
            });
            exp.walk(tw);
          } else {
            descend();
            mark_expression(exp);
          }
          return true;
        }
        if (node instanceof AST_Class) {
          if (node.name)
            node.name.walk(tw);
          if (node.extends)
            node.extends.walk(tw);
          node.properties.filter(function(prop) {
            if (prop.key instanceof AST_Node)
              prop.key.walk(tw);
            return prop.value;
          }).forEach(function(prop) {
            if (prop.static) {
              prop.value.walk(tw);
            } else {
              push();
              segment.block = node;
              prop.value.walk(tw);
              pop();
            }
          });
          return true;
        }
        if (node instanceof AST_Conditional) {
          walk_cond(node.condition, node.consequent, node.alternative);
          return true;
        }
        if (node instanceof AST_Continue) {
          var target = tw.loopcontrol_target(node);
          if (target instanceof AST_Do)
            insert(target);
          return true;
        }
        if (node instanceof AST_Do) {
          push();
          segment.block = node;
          segment.loop = true;
          var save = segment;
          node.body.walk(tw);
          if (segment.inserted === node)
            segment = save;
          node.condition.walk(tw);
          pop();
          return true;
        }
        if (node instanceof AST_For) {
          if (node.init)
            node.init.walk(tw);
          push();
          segment.block = node;
          segment.loop = true;
          if (node.condition)
            node.condition.walk(tw);
          node.body.walk(tw);
          if (node.step)
            node.step.walk(tw);
          pop();
          return true;
        }
        if (node instanceof AST_ForEnumeration) {
          node.object.walk(tw);
          push();
          segment.block = node;
          segment.loop = true;
          node.init.walk(tw);
          node.body.walk(tw);
          pop();
          return true;
        }
        if (node instanceof AST_If) {
          walk_cond(node.condition, node.body, node.alternative);
          return true;
        }
        if (node instanceof AST_LabeledStatement) {
          push();
          segment.block = node;
          var save = segment;
          node.body.walk(tw);
          if (segment.inserted === node)
            segment = save;
          pop();
          return true;
        }
        if (node instanceof AST_Scope) {
          push();
          segment.block = node;
          if (node === self)
            root = segment;
          if (node instanceof AST_Lambda) {
            if (node.name)
              references[node.name.definition().id] = false;
            var marker = node.uses_arguments && !tw.has_directive("use strict") ? function(node2) {
              references[node2.definition().id] = false;
            } : function(node2) {
              mark(node2);
            };
            in_arg.push(node);
            node.argnames.forEach(function(argname) {
              walk_destructured(AST_SymbolFunarg, marker, argname);
            });
            if (node.rest)
              walk_destructured(AST_SymbolFunarg, marker, node.rest);
            in_arg.pop();
          }
          walk_lambda(node, tw);
          pop();
          return true;
        }
        if (node instanceof AST_Sub) {
          var exp = node.expression;
          if (node.optional) {
            exp.walk(tw);
            push();
            node.property.walk(tw);
            pop();
          } else {
            descend();
          }
          mark_expression(exp);
          return true;
        }
        if (node instanceof AST_Switch) {
          node.expression.walk(tw);
          var save = segment;
          node.body.forEach(function(branch) {
            if (branch instanceof AST_Default)
              return;
            branch.expression.walk(tw);
            if (save === segment)
              push();
          });
          segment = save;
          node.body.forEach(function(branch) {
            push();
            segment.block = node;
            var save2 = segment;
            walk_body(branch, tw);
            if (segment.inserted === node)
              segment = save2;
            pop();
          });
          return true;
        }
        if (node instanceof AST_SymbolConst || node instanceof AST_SymbolLet) {
          references[node.definition().id] = false;
          return true;
        }
        if (node instanceof AST_SymbolRef) {
          mark(node, true);
          return true;
        }
        if (node instanceof AST_Try) {
          var save_try = in_try;
          in_try = node;
          walk_body(node, tw);
          if (node.bcatch) {
            if (node.bcatch.argname)
              node.bcatch.argname.mark_symbol(function(node2) {
                if (node2 instanceof AST_SymbolCatch) {
                  var def2 = node2.definition();
                  references[def2.id] = false;
                  if (def2 = def2.redefined())
                    references[def2.id] = false;
                }
              }, tw);
            if (node.bfinally || (in_try = save_try)) {
              walk_body(node.bcatch, tw);
            } else {
              push();
              walk_body(node.bcatch, tw);
              pop();
            }
          }
          in_try = save_try;
          if (node.bfinally)
            node.bfinally.walk(tw);
          return true;
        }
        if (node instanceof AST_Unary) {
          if (!UNARY_POSTFIX[node.operator])
            return;
          var sym = node.expression;
          if (!(sym instanceof AST_SymbolRef))
            return;
          mark(sym, true);
          return true;
        }
        if (node instanceof AST_VarDef) {
          var assigned = node.value;
          if (assigned) {
            assigned.walk(tw);
          } else {
            assigned = segment.block instanceof AST_ForEnumeration && segment.block.init === tw.parent();
          }
          walk_destructured(AST_SymbolDeclaration, assigned ? function(node2) {
            if (node2 instanceof AST_SymbolVar) {
              mark(node2);
            } else {
              node2.walk(tw);
            }
          } : function(node2) {
            if (node2 instanceof AST_SymbolVar) {
              var id = node2.definition().id;
              var refs = references[id];
              if (refs) {
                refs.push(node2);
              } else if (!(id in references)) {
                declarations.add(id, node2);
              }
            } else {
              node2.walk(tw);
            }
          }, node.name);
          return true;
        }
        if (node instanceof AST_While) {
          push();
          segment.block = node;
          segment.loop = true;
          descend();
          pop();
          return true;
        }
        function mark_expression(exp2) {
          if (!compressor.option("ie"))
            return;
          var sym2 = root_expr(exp2);
          if (sym2 instanceof AST_SymbolRef)
            sym2.walk(tw);
        }
        function walk_cond(condition, consequent, alternative) {
          var save2 = segment;
          var segments = [save2, save2];
          if (condition instanceof AST_Binary)
            switch (condition.operator) {
              case "&&":
                segments[0] = walk_cond(condition.left, condition.right)[0];
                break;
              case "||":
              case "??":
                segments[1] = walk_cond(condition.left, null, condition.right)[1];
                break;
              default:
                condition.walk(tw);
                break;
            }
          else if (condition instanceof AST_Conditional) {
            walk_cond(condition.condition, condition.consequent, condition.alternative);
          } else {
            condition.walk(tw);
          }
          segment = segments[0];
          if (consequent) {
            push();
            consequent.walk(tw);
          }
          segments[0] = segment;
          segment = segments[1];
          if (alternative) {
            push();
            alternative.walk(tw);
          }
          segments[1] = segment;
          segment = save2;
          return segments;
        }
      });
      tw.directives = Object.create(compressor.directives);
      self.walk(tw);
      var changed = false;
      var merged = Object.create(null);
      while (first.length && last.length) {
        var tail = last.shift();
        if (!tail)
          continue;
        var def = tail.definition;
        var tail_refs = references[def.id];
        if (!tail_refs)
          continue;
        tail_refs = { end: tail_refs.end };
        while (def.id in merged)
          def = merged[def.id];
        tail_refs.start = references[def.id].start;
        var skipped = [];
        do {
          var head = first.shift();
          if (tail.index > head.index)
            continue;
          var prev_def = head.definition;
          if (!(prev_def.id in prev))
            continue;
          var head_refs = references[prev_def.id];
          if (!head_refs)
            continue;
          if (head_refs.start.block !== tail_refs.start.block || !mergeable(head_refs, tail_refs) || (head_refs.start.loop || !same_scope(def)) && !mergeable(tail_refs, head_refs) || compressor.option("webkit") && is_funarg(def) !== is_funarg(prev_def) || prev_def.const_redefs || !all(head_refs.scopes, function(scope) {
            return scope.find_variable(def.name) === def;
          })) {
            skipped.push(head);
            continue;
          }
          head_refs.forEach(function(sym) {
            sym.thedef = def;
            sym.name = def.name;
            if (sym instanceof AST_SymbolRef) {
              def.references.push(sym);
              prev_def.replaced++;
            } else {
              def.orig.push(sym);
              prev_def.eliminated++;
            }
          });
          if (!prev_def.fixed)
            def.fixed = false;
          merged[prev_def.id] = def;
          changed = true;
          break;
        } while (first.length);
        if (skipped.length)
          first = skipped.concat(first);
      }
      return changed;
      function push() {
        segment = Object.create(segment);
      }
      function pop() {
        segment = Object.getPrototypeOf(segment);
      }
      function walk_destructured(symbol_type, mark2, lhs) {
        var marker = new TreeWalker(function(node) {
          if (node instanceof AST_Destructured)
            return;
          if (node instanceof AST_DefaultValue) {
            push();
            node.value.walk(tw);
            pop();
            node.name.walk(marker);
          } else if (node instanceof AST_DestructuredKeyVal) {
            if (!(node.key instanceof AST_Node)) {
              node.value.walk(marker);
            } else if (node.value instanceof AST_PropAccess) {
              push();
              segment.block = node;
              node.key.walk(tw);
              node.value.walk(marker);
              pop();
            } else {
              node.key.walk(tw);
              node.value.walk(marker);
            }
          } else if (node instanceof symbol_type) {
            mark2(node);
          } else {
            node.walk(tw);
          }
          return true;
        });
        lhs.walk(marker);
      }
      function mark(sym, read) {
        var def2 = sym.definition(), ldef;
        if (read && !all(in_arg, function(fn) {
          ldef = fn.variables.get(sym.name);
          if (!ldef)
            return true;
          if (!is_funarg(ldef))
            return true;
          return ldef !== def2 && !def2.undeclared && fn.parent_scope.find_variable(sym.name) !== def2;
        }))
          return references[def2.id] = references[ldef.id] = false;
        var seg = segment;
        if (in_try) {
          push();
          seg = segment;
          pop();
        }
        if (def2.id in references) {
          var refs = references[def2.id];
          if (!refs)
            return;
          if (refs.start.block !== seg.block)
            return references[def2.id] = false;
          push_ref(sym);
          refs.end = seg;
          if (def2.id in prev) {
            last[prev[def2.id]] = null;
          } else if (!read) {
            return;
          }
        } else if ((ldef = self.variables.get(def2.name)) !== def2) {
          if (ldef && root === seg)
            references[ldef.id] = false;
          return references[def2.id] = false;
        } else if (compressor.exposed(def2) || NO_MERGE[sym.name]) {
          return references[def2.id] = false;
        } else {
          var refs = declarations.get(def2.id) || [];
          refs.scopes = [];
          push_ref(sym);
          references[def2.id] = refs;
          if (!read) {
            refs.start = seg;
            return first.push({
              index: index++,
              definition: def2
            });
          }
          if (seg.block !== self)
            return references[def2.id] = false;
          refs.start = root;
        }
        prev[def2.id] = last.length;
        last.push({
          index: index++,
          definition: def2
        });
        function push_ref(sym2) {
          refs.push(sym2);
          push_uniq(refs.scopes, sym2.scope);
          var scope = find_scope(tw);
          if (scope !== sym2.scope)
            push_uniq(refs.scopes, scope);
        }
      }
      function insert(target) {
        var stack = [];
        while (true) {
          if (HOP(segment, "block")) {
            var block = segment.block;
            if (block instanceof AST_LabeledStatement)
              block = block.body;
            if (block === target)
              break;
          }
          stack.push(segment);
          pop();
        }
        segment.inserted = segment.block;
        push();
        while (stack.length) {
          var seg = stack.pop();
          push();
          if (HOP(seg, "block"))
            segment.block = seg.block;
          if (HOP(seg, "loop"))
            segment.loop = seg.loop;
        }
      }
      function must_visit(base, segment2) {
        return base === segment2 || base.isPrototypeOf(segment2);
      }
      function mergeable(head2, tail2) {
        return must_visit(head2.start, head2.end) || must_visit(head2.start, tail2.start);
      }
    });
    function fill_holes(orig, elements) {
      for (var i = elements.length;--i >= 0; ) {
        if (!elements[i])
          elements[i] = make_node(AST_Hole, orig);
      }
    }
    function to_class_expr(defcl, drop_name) {
      var cl = make_node(AST_ClassExpression, defcl);
      if (cl.name)
        cl.name = drop_name ? null : make_node(AST_SymbolClass, cl.name);
      return cl;
    }
    function to_func_expr(defun, drop_name) {
      var ctor;
      switch (defun.CTOR) {
        case AST_AsyncDefun:
          ctor = AST_AsyncFunction;
          break;
        case AST_AsyncGeneratorDefun:
          ctor = AST_AsyncGeneratorFunction;
          break;
        case AST_Defun:
          ctor = AST_Function;
          break;
        case AST_GeneratorDefun:
          ctor = AST_GeneratorFunction;
          break;
      }
      var fn = make_node(ctor, defun);
      fn.name = drop_name ? null : make_node(AST_SymbolLambda, defun.name);
      return fn;
    }
    AST_Scope.DEFMETHOD("drop_unused", function(compressor) {
      if (!compressor.option("unused"))
        return;
      var self = this;
      var drop_funcs = !(self instanceof AST_Toplevel) || compressor.toplevel.funcs;
      var drop_vars = !(self instanceof AST_Toplevel) || compressor.toplevel.vars;
      var assign_as_unused = /keep_assign/.test(compressor.option("unused")) ? return_false : function(node, props) {
        var sym, nested = false;
        if (node instanceof AST_Assign) {
          if (node.write_only || node.operator == "=")
            sym = extract_reference(node.left, props);
        } else if (node instanceof AST_Unary) {
          if (node.write_only)
            sym = extract_reference(node.expression, props);
        }
        if (!(sym instanceof AST_SymbolRef))
          return;
        var def = sym.definition();
        if (export_defaults[def.id])
          return;
        if (compressor.exposed(def))
          return;
        if (!can_drop_symbol(sym, compressor, nested))
          return;
        return sym;
        function extract_reference(node2, props2) {
          if (node2 instanceof AST_PropAccess) {
            var expr = node2.expression;
            if (!expr.may_throw_on_access(compressor, true)) {
              nested = true;
              if (props2 && node2 instanceof AST_Sub)
                props2.unshift(node2.property);
              return extract_reference(expr, props2);
            }
          } else if (node2 instanceof AST_Assign && node2.operator == "=") {
            node2.write_only = "p";
            var ref = extract_reference(node2.right);
            if (!props2)
              return ref;
            props2.assign = node2;
            return ref instanceof AST_SymbolRef ? ref : node2.left;
          }
          return node2;
        }
      };
      var assign_in_use = Object.create(null);
      var export_defaults = Object.create(null);
      var find_variable = function(name) {
        find_variable = compose(self, 0, noop);
        return find_variable(name);
        function compose(child, level, find) {
          var parent = compressor.parent(level);
          if (!parent)
            return find;
          var in_arg = parent instanceof AST_Lambda && member(child, parent.argnames);
          return compose(parent, level + 1, in_arg ? function(name2) {
            var def = find(name2);
            if (def)
              return def;
            def = parent.variables.get(name2);
            if (def) {
              var sym = def.orig[0];
              if (sym instanceof AST_SymbolFunarg || sym instanceof AST_SymbolLambda)
                return def;
            }
          } : parent.variables ? function(name2) {
            return find(name2) || parent.variables.get(name2);
          } : find);
        }
      };
      var for_ins = Object.create(null);
      var in_use = [];
      var in_use_ids = Object.create(null);
      var lambda_ids = Object.create(null);
      var value_read = Object.create(null);
      var value_modified = Object.create(null);
      var var_defs = Object.create(null);
      if (self instanceof AST_Toplevel && compressor.top_retain) {
        self.variables.each(function(def) {
          if (compressor.top_retain(def) && !(def.id in in_use_ids)) {
            AST_Node.info("Retaining variable {name}", def);
            in_use_ids[def.id] = true;
            in_use.push(def);
          }
        });
      }
      var assignments = new Dictionary;
      var initializations = new Dictionary;
      var scope = this;
      var tw = new TreeWalker(function(node, descend) {
        if (node instanceof AST_Lambda && node.uses_arguments && !tw.has_directive("use strict")) {
          node.each_argname(function(argname) {
            var def2 = argname.definition();
            if (!(def2.id in in_use_ids)) {
              in_use_ids[def2.id] = true;
              in_use.push(def2);
            }
          });
        }
        if (node === self)
          return;
        if (scope === self) {
          if (node instanceof AST_DefClass) {
            var def = node.name.definition();
            var drop = drop_funcs && !def.exported;
            if (!drop && !(def.id in in_use_ids)) {
              in_use_ids[def.id] = true;
              in_use.push(def);
            }
            var used = tw.parent() instanceof AST_ExportDefault;
            if (used) {
              export_defaults[def.id] = true;
            } else if (drop && !(def.id in lambda_ids)) {
              lambda_ids[def.id] = 1;
            }
            if (node.extends)
              node.extends.walk(tw);
            var values = [];
            node.properties.forEach(function(prop) {
              if (prop.key instanceof AST_Node)
                prop.key.walk(tw);
              var value = prop.value;
              if (!value)
                return;
              if (is_static_field_or_init(prop)) {
                if (!used && value.contains_this())
                  used = true;
                walk_class_prop(value);
              } else {
                values.push(value);
              }
            });
            values.forEach(drop && used ? walk_class_prop : function(value) {
              initializations.add(def.id, value);
            });
            return true;
          }
          if (node instanceof AST_LambdaDefinition) {
            var def = node.name.definition();
            var drop = drop_funcs && !def.exported;
            if (!drop && !(def.id in in_use_ids)) {
              in_use_ids[def.id] = true;
              in_use.push(def);
            }
            initializations.add(def.id, node);
            if (tw.parent() instanceof AST_ExportDefault) {
              export_defaults[def.id] = true;
              return scan_ref_scoped(node, descend, true);
            }
            if (drop && !(def.id in lambda_ids))
              lambda_ids[def.id] = 1;
            return true;
          }
          if (node instanceof AST_Definitions) {
            node.definitions.forEach(function(defn) {
              var value = defn.value;
              var side_effects = value && (defn.name instanceof AST_Destructured || value.has_side_effects(compressor));
              var shared = side_effects && value.tail_node().operator == "=";
              defn.name.mark_symbol(function(name) {
                if (!(name instanceof AST_SymbolDeclaration))
                  return;
                var def2 = name.definition();
                var_defs[def2.id] = (var_defs[def2.id] || 0) + 1;
                if (node instanceof AST_Var && def2.orig[0] instanceof AST_SymbolCatch) {
                  var redef = def2.redefined();
                  if (redef)
                    var_defs[redef.id] = (var_defs[redef.id] || 0) + 1;
                }
                if (!(def2.id in in_use_ids) && (!drop_vars || def2.exported || (node instanceof AST_Const ? def2.redefined() : def2.const_redefs) || !(node instanceof AST_Var || is_safe_lexical(def2)))) {
                  in_use_ids[def2.id] = true;
                  in_use.push(def2);
                }
                if (value) {
                  if (!side_effects) {
                    initializations.add(def2.id, value);
                  } else if (shared) {
                    verify_safe_usage(def2, name, value_modified[def2.id]);
                  }
                  assignments.add(def2.id, defn);
                }
                unmark_lambda(def2);
                return true;
              }, tw);
              if (side_effects)
                value.walk(tw);
            });
            return true;
          }
          if (node instanceof AST_SymbolFunarg) {
            var def = node.definition();
            var_defs[def.id] = (var_defs[def.id] || 0) + 1;
            assignments.add(def.id, node);
            return true;
          }
          if (node instanceof AST_SymbolImport) {
            var def = node.definition();
            if (!(def.id in in_use_ids) && (!drop_vars || !is_safe_lexical(def))) {
              in_use_ids[def.id] = true;
              in_use.push(def);
            }
            return true;
          }
        }
        return scan_ref_scoped(node, descend, true);
        function walk_class_prop(value) {
          var save_scope = scope;
          scope = node;
          value.walk(tw);
          scope = save_scope;
        }
      });
      tw.directives = Object.create(compressor.directives);
      self.walk(tw);
      var drop_fn_name = compressor.option("keep_fnames") ? return_false : compressor.option("ie") ? function(def) {
        return !compressor.exposed(def) && def.references.length == def.replaced;
      } : function(def) {
        if (!(def.id in in_use_ids))
          return true;
        if (def.orig.length - def.eliminated < 2)
          return false;
        if (def.orig[1] instanceof AST_SymbolFunarg)
          return true;
        return all(def.references, function(ref) {
          return !ref.in_arg;
        });
      };
      if (compressor.option("ie"))
        initializations.each(function(init2, id) {
          if (id in in_use_ids)
            return;
          init2.forEach(function(init3) {
            init3.walk(new TreeWalker(function(node) {
              if (node instanceof AST_Function && node.name && !drop_fn_name(node.name.definition())) {
                node.walk(tw);
                return true;
              }
              if (node instanceof AST_Scope)
                return true;
            }));
          });
        });
      tw = new TreeWalker(scan_ref_scoped);
      for (var i = 0;i < in_use.length; i++) {
        var init = initializations.get(in_use[i].id);
        if (init)
          init.forEach(function(init2) {
            init2.walk(tw);
          });
      }
      Object.keys(assign_in_use).forEach(function(id) {
        var assigns = assign_in_use[id];
        if (!assigns) {
          delete assign_in_use[id];
          return;
        }
        assigns = assigns.reduce(function(in_use3, assigns2) {
          assigns2.forEach(function(assign) {
            push_uniq(in_use3, assign);
          });
          return in_use3;
        }, []);
        var in_use2 = (assignments.get(id) || []).filter(function(node) {
          return find_if(node instanceof AST_Unary ? function(assign) {
            return assign === node;
          } : function(assign) {
            if (assign === node)
              return true;
            if (assign instanceof AST_Unary)
              return false;
            return get_rvalue(assign) === get_rvalue(node);
          }, assigns);
        });
        if (assigns.length == in_use2.length) {
          assign_in_use[id] = in_use2;
        } else {
          delete assign_in_use[id];
        }
      });
      var calls_to_drop_args = [];
      var fns_with_marked_args = [];
      var trimmer = new TreeTransformer(function(node) {
        if (node instanceof AST_DefaultValue)
          return trim_default(trimmer, node);
        if (node instanceof AST_Destructured && node.rest)
          node.rest = node.rest.transform(trimmer);
        if (node instanceof AST_DestructuredArray) {
          var trim = !node.rest;
          for (var i2 = node.elements.length;--i2 >= 0; ) {
            var element = node.elements[i2].transform(trimmer);
            if (element) {
              node.elements[i2] = element;
              trim = false;
            } else if (trim) {
              node.elements.pop();
            } else {
              node.elements[i2] = make_node(AST_Hole, node.elements[i2]);
            }
          }
          return node;
        }
        if (node instanceof AST_DestructuredObject) {
          var properties = [];
          node.properties.forEach(function(prop) {
            var retain = false;
            if (prop.key instanceof AST_Node) {
              prop.key = prop.key.transform(tt);
              retain = prop.key.has_side_effects(compressor);
            }
            if ((retain || node.rest) && is_decl(prop.value)) {
              prop.value = prop.value.transform(tt);
              properties.push(prop);
            } else {
              var value = prop.value.transform(trimmer);
              if (!value && node.rest) {
                if (prop.value instanceof AST_DestructuredArray) {
                  value = make_node(AST_DestructuredArray, prop.value, { elements: [] });
                } else {
                  value = make_node(AST_DestructuredObject, prop.value, { properties: [] });
                }
              }
              if (value) {
                prop.value = value;
                properties.push(prop);
              }
            }
          });
          node.properties = properties;
          return node;
        }
        if (node instanceof AST_SymbolDeclaration)
          return trim_decl(node);
      });
      var tt = new TreeTransformer(function(node, descend, in_list) {
        var parent = tt.parent();
        if (drop_vars) {
          var props = [], sym = assign_as_unused(node, props);
          if (sym) {
            var value;
            if (can_drop_lhs(sym, node)) {
              if (node instanceof AST_Assign) {
                value = get_rhs(node);
                if (node.write_only === true)
                  value = value.drop_side_effect_free(compressor);
              }
              if (!value)
                value = make_node(AST_Number, node, { value: 0 });
            }
            if (value) {
              if (props.assign) {
                var assign = props.assign.drop_side_effect_free(compressor);
                if (assign) {
                  assign.write_only = true;
                  props.unshift(assign);
                }
              }
              if (!(parent instanceof AST_Sequence) || parent.tail_node() === node || value.has_side_effects(compressor)) {
                props.push(value);
              }
              switch (props.length) {
                case 0:
                  return List.skip;
                case 1:
                  return maintain_this_binding(parent, node, props[0].transform(tt));
                default:
                  return make_sequence(node, props.map(function(prop) {
                    return prop.transform(tt);
                  }));
              }
            }
          } else if (node instanceof AST_UnaryPostfix && node.expression instanceof AST_SymbolRef && indexOf_assign(node.expression.definition(), node) < 0) {
            return make_node(AST_UnaryPrefix, node, {
              operator: "+",
              expression: node.expression
            });
          }
        }
        if (node instanceof AST_Binary && node.operator == "instanceof") {
          var sym = node.right;
          if (!(sym instanceof AST_SymbolRef))
            return;
          if (sym.definition().id in in_use_ids)
            return;
          var lhs = node.left.drop_side_effect_free(compressor);
          var value = make_node(AST_False, node).optimize(compressor);
          return lhs ? make_sequence(node, [lhs, value]) : value;
        }
        if (node instanceof AST_Call) {
          calls_to_drop_args.push(node);
          node.args = node.args.map(function(arg) {
            return arg.transform(tt);
          });
          node.expression = node.expression.transform(tt);
          return node;
        }
        if (scope !== self)
          return;
        if (drop_funcs && node !== self && node instanceof AST_DefClass) {
          var def = node.name.definition();
          if (!(def.id in in_use_ids)) {
            log(node.name, "Dropping unused class {name}");
            def.eliminated++;
            descend(node, tt);
            var trimmed = to_class_expr(node, true);
            if (parent instanceof AST_ExportDefault)
              return trimmed;
            trimmed = trimmed.drop_side_effect_free(compressor, true);
            if (trimmed)
              return make_node(AST_SimpleStatement, node, { body: trimmed });
            return in_list ? List.skip : make_node(AST_EmptyStatement, node);
          }
        }
        if (node instanceof AST_ClassExpression && node.name && drop_fn_name(node.name.definition())) {
          node.name = null;
        }
        if (node instanceof AST_Lambda) {
          if (drop_funcs && node !== self && node instanceof AST_LambdaDefinition) {
            var def = node.name.definition();
            if (!(def.id in in_use_ids)) {
              log(node.name, "Dropping unused function {name}");
              def.eliminated++;
              if (parent instanceof AST_ExportDefault) {
                descend_scope();
                return to_func_expr(node, true);
              }
              return in_list ? List.skip : make_node(AST_EmptyStatement, node);
            }
          }
          descend_scope();
          if (node instanceof AST_LambdaExpression && node.name && drop_fn_name(node.name.definition())) {
            node.name = null;
          }
          if (!(node instanceof AST_Accessor)) {
            var args, spread, trim = compressor.drop_fargs(node, parent);
            if (trim && parent instanceof AST_Call && parent.expression === node) {
              args = parent.args;
              for (spread = 0;spread < args.length; spread++) {
                if (args[spread] instanceof AST_Spread)
                  break;
              }
            }
            var argnames = node.argnames;
            var rest = node.rest;
            var after = false, before = false;
            if (rest) {
              before = true;
              if (!args || spread < argnames.length || rest instanceof AST_SymbolFunarg) {
                rest = rest.transform(trimmer);
              } else {
                var trimmed = trim_destructured(rest, make_node(AST_Array, parent, {
                  elements: args.slice(argnames.length)
                }), trim_decl, !node.uses_arguments, rest);
                rest = trimmed.name;
                args.length = argnames.length;
                if (trimmed.value.elements.length)
                  [].push.apply(args, trimmed.value.elements);
              }
              if (rest instanceof AST_Destructured && !rest.rest) {
                if (rest instanceof AST_DestructuredArray) {
                  if (rest.elements.length == 0)
                    rest = null;
                } else if (rest.properties.length == 0) {
                  rest = null;
                }
              }
              node.rest = rest;
              if (rest) {
                trim = false;
                after = true;
              }
            }
            var default_length = trim ? -1 : node.length();
            var trim_value = args && !node.uses_arguments && parent !== compressor.parent();
            for (var i2 = argnames.length;--i2 >= 0; ) {
              var sym = argnames[i2];
              if (sym instanceof AST_SymbolFunarg) {
                var def = sym.definition();
                if (def.id in in_use_ids) {
                  trim = false;
                  if (indexOf_assign(def, sym) < 0)
                    sym.unused = null;
                } else if (trim) {
                  log(sym, "Dropping unused function argument {name}");
                  argnames.pop();
                  def.eliminated++;
                  sym.unused = true;
                } else {
                  sym.unused = true;
                }
              } else {
                before = true;
                var funarg;
                if (!args || spread < i2) {
                  funarg = sym.transform(trimmer);
                } else {
                  var trimmed = trim_destructured(sym, args[i2], trim_decl, trim_value, sym);
                  funarg = trimmed.name;
                  if (trimmed.value)
                    args[i2] = trimmed.value;
                }
                if (funarg) {
                  trim = false;
                  argnames[i2] = funarg;
                  if (!after)
                    after = !(funarg instanceof AST_SymbolFunarg);
                } else if (trim) {
                  log_default(sym, "Dropping unused default argument {name}");
                  argnames.pop();
                } else if (i2 > default_length) {
                  log_default(sym, "Dropping unused default argument assignment {name}");
                  if (sym.name instanceof AST_SymbolFunarg) {
                    sym.name.unused = true;
                  } else {
                    after = true;
                  }
                  argnames[i2] = sym.name;
                } else {
                  log_default(sym, "Dropping unused default argument value {name}");
                  argnames[i2] = sym = sym.clone();
                  sym.value = make_node(AST_Number, sym, { value: 0 });
                  after = true;
                }
              }
            }
            if (before && !after && node.uses_arguments && !tt.has_directive("use strict")) {
              node.rest = make_node(AST_DestructuredArray, node, { elements: [] });
            }
            fns_with_marked_args.push(node);
          }
          return node;
        }
        if (node instanceof AST_Catch && node.argname instanceof AST_Destructured) {
          node.argname.transform(trimmer);
        }
        if (node instanceof AST_Definitions && !(parent instanceof AST_ForEnumeration && parent.init === node)) {
          var body = [], head = [], tail = [];
          var side_effects = [];
          var duplicated = 0;
          var is_var = node instanceof AST_Var;
          node.definitions.forEach(function(def2) {
            if (def2.value)
              def2.value = def2.value.transform(tt);
            var value2 = def2.value;
            if (def2.name instanceof AST_Destructured) {
              var trimmed2 = trim_destructured(def2.name, value2, function(node2) {
                if (!drop_vars)
                  return node2;
                if (node2.definition().id in in_use_ids)
                  return node2;
                if (is_catch(node2))
                  return node2;
                if (is_var && !can_drop_symbol(node2))
                  return node2;
                return null;
              }, true);
              if (trimmed2.name) {
                def2 = make_node(AST_VarDef, def2, {
                  name: trimmed2.name,
                  value: value2 = trimmed2.value
                });
                flush();
              } else if (trimmed2.value) {
                side_effects.push(trimmed2.value);
              }
              return;
            }
            var sym2 = def2.name.definition();
            var drop_sym = is_var ? can_drop_symbol(def2.name) : is_safe_lexical(sym2);
            if (!drop_sym || !drop_vars || sym2.id in in_use_ids) {
              var index;
              if (value2 && ((index = indexOf_assign(sym2, def2)) < 0 || self_assign(value2.tail_node()))) {
                def2 = def2.clone();
                value2 = value2.drop_side_effect_free(compressor);
                if (value2)
                  AST_Node.warn("Side effects in definition of variable {name} [{start}]", def2.name);
                if (node instanceof AST_Const) {
                  def2.value = value2 || make_node(AST_Number, def2, { value: 0 });
                } else {
                  def2.value = null;
                  if (value2)
                    side_effects.push(value2);
                }
                value2 = null;
                if (index >= 0)
                  assign_in_use[sym2.id][index] = def2;
              }
              var old_def, fn;
              if (!value2 && !(node instanceof AST_Let)) {
                if (parent instanceof AST_ExportDeclaration) {
                  flush();
                } else if (drop_sym && var_defs[sym2.id] > 1) {
                  AST_Node.info("Dropping declaration of variable {name} [{start}]", def2.name);
                  var_defs[sym2.id]--;
                  sym2.eliminated++;
                } else {
                  head.push(def2);
                }
              } else if (compressor.option("functions") && !compressor.option("ie") && drop_sym && value2 && var_defs[sym2.id] == 1 && sym2.assignments == 0 && (fn = value2.tail_node()) instanceof AST_LambdaExpression && !is_arguments(sym2) && !is_arrow(fn) && assigned_once(fn, sym2.references) && can_declare_defun(fn) && (old_def = rename_def(fn, def2.name.name)) !== false) {
                AST_Node.warn("Declaring {name} as function [{start}]", def2.name);
                var ctor;
                switch (fn.CTOR) {
                  case AST_AsyncFunction:
                    ctor = AST_AsyncDefun;
                    break;
                  case AST_AsyncGeneratorFunction:
                    ctor = AST_AsyncGeneratorDefun;
                    break;
                  case AST_Function:
                    ctor = AST_Defun;
                    break;
                  case AST_GeneratorFunction:
                    ctor = AST_GeneratorDefun;
                    break;
                }
                var defun = make_node(ctor, fn);
                defun.name = make_node(AST_SymbolDefun, def2.name);
                var name_def = def2.name.scope.resolve().def_function(defun.name);
                if (old_def)
                  old_def.forEach(function(node2) {
                    node2.name = name_def.name;
                    node2.thedef = name_def;
                    node2.reference();
                  });
                body.push(defun);
                if (value2 !== fn)
                  [].push.apply(side_effects, value2.expressions.slice(0, -1));
              } else {
                if (drop_sym && var_defs[sym2.id] > 1 && !(parent instanceof AST_ExportDeclaration) && sym2.orig.indexOf(def2.name) > sym2.eliminated) {
                  var_defs[sym2.id]--;
                  duplicated++;
                }
                flush();
              }
            } else if (is_catch(def2.name)) {
              value2 = value2 && value2.drop_side_effect_free(compressor);
              if (value2)
                side_effects.push(value2);
              if (var_defs[sym2.id] > 1) {
                AST_Node.warn("Dropping duplicated declaration of variable {name} [{start}]", def2.name);
                var_defs[sym2.id]--;
                sym2.eliminated++;
              } else {
                def2.value = null;
                head.push(def2);
              }
            } else {
              value2 = value2 && value2.drop_side_effect_free(compressor);
              if (value2) {
                AST_Node.warn("Side effects in initialization of unused variable {name} [{start}]", def2.name);
                side_effects.push(value2);
              } else {
                log(def2.name, "Dropping unused variable {name}");
              }
              sym2.eliminated++;
            }
            function self_assign(ref) {
              return ref instanceof AST_SymbolRef && ref.definition() === sym2;
            }
            function assigned_once(fn2, refs) {
              if (refs.length == 0)
                return fn2 === def2.name.fixed_value();
              return all(refs, function(ref) {
                return fn2 === ref.fixed_value();
              });
            }
            function can_declare_defun(fn2) {
              if (!is_var || compressor.has_directive("use strict") || !(fn2 instanceof AST_Function)) {
                return parent instanceof AST_Scope;
              }
              return parent instanceof AST_Block || parent instanceof AST_For && parent.init === node || parent instanceof AST_If;
            }
            function rename_def(fn2, name) {
              if (!fn2.name)
                return null;
              var def3 = fn2.name.definition();
              if (def3.orig.length > 1)
                return null;
              if (def3.assignments > 0)
                return false;
              if (def3.name == name)
                return def3;
              if (compressor.option("keep_fnames"))
                return false;
              var forbidden;
              switch (name) {
                case "await":
                  forbidden = is_async;
                  break;
                case "yield":
                  forbidden = is_generator;
                  break;
              }
              return all(def3.references, function(ref) {
                var scope2 = ref.scope;
                if (scope2.find_variable(name) !== sym2)
                  return false;
                if (forbidden)
                  do {
                    scope2 = scope2.resolve();
                    if (forbidden(scope2))
                      return false;
                  } while (scope2 !== fn2 && (scope2 = scope2.parent_scope));
                return true;
              }) && def3;
            }
            function is_catch(node2) {
              var sym3 = node2.definition();
              return sym3.orig[0] instanceof AST_SymbolCatch && sym3.scope.resolve() === node2.scope.resolve();
            }
            function flush() {
              if (side_effects.length > 0) {
                if (tail.length == 0) {
                  body.push(make_node(AST_SimpleStatement, node, {
                    body: make_sequence(node, side_effects)
                  }));
                } else if (value2) {
                  side_effects.push(value2);
                  def2.value = make_sequence(value2, side_effects);
                } else {
                  def2.value = make_node(AST_UnaryPrefix, def2, {
                    operator: "void",
                    expression: make_sequence(def2, side_effects)
                  });
                }
                side_effects = [];
              }
              tail.push(def2);
            }
          });
          switch (head.length) {
            case 0:
              if (tail.length == 0)
                break;
              if (tail.length == duplicated) {
                [].unshift.apply(side_effects, tail.map(function(def2) {
                  AST_Node.info("Dropping duplicated definition of variable {name} [{start}]", def2.name);
                  var sym2 = def2.name.definition();
                  var ref = make_node(AST_SymbolRef, def2.name);
                  sym2.references.push(ref);
                  var assign2 = make_node(AST_Assign, def2, {
                    operator: "=",
                    left: ref,
                    right: def2.value
                  });
                  var index = indexOf_assign(sym2, def2);
                  if (index >= 0)
                    assign_in_use[sym2.id][index] = assign2;
                  sym2.assignments++;
                  sym2.eliminated++;
                  return assign2;
                }));
                break;
              }
            case 1:
              if (tail.length == 0) {
                var id = head[0].name.definition().id;
                if (id in for_ins) {
                  node.definitions = head;
                  for_ins[id].init = node;
                  break;
                }
              }
            default:
              var seq;
              if (tail.length > 0 && (seq = tail[0].value) instanceof AST_Sequence) {
                tail[0].value = seq.tail_node();
                body.push(make_node(AST_SimpleStatement, node, {
                  body: make_sequence(seq, seq.expressions.slice(0, -1))
                }));
              }
              node.definitions = head.concat(tail);
              body.push(node);
          }
          if (side_effects.length > 0) {
            body.push(make_node(AST_SimpleStatement, node, { body: make_sequence(node, side_effects) }));
          }
          return insert_statements(body, node, in_list);
        }
        if (node instanceof AST_Assign) {
          descend(node, tt);
          if (!(node.left instanceof AST_Destructured))
            return node;
          var trimmed = trim_destructured(node.left, node.right, function(node2) {
            return node2;
          }, node.write_only === true);
          if (trimmed.name)
            return make_node(AST_Assign, node, {
              operator: node.operator,
              left: trimmed.name,
              right: trimmed.value
            });
          if (trimmed.value)
            return trimmed.value;
          if (parent instanceof AST_Sequence && parent.tail_node() !== node)
            return List.skip;
          return make_node(AST_Number, node, { value: 0 });
        }
        if (node instanceof AST_LabeledStatement && node.body instanceof AST_For) {
          descend(node, tt);
          if (node.body instanceof AST_BlockStatement) {
            var block = node.body;
            node.body = block.body.pop();
            block.body.push(node);
            return in_list ? List.splice(block.body) : block;
          }
          return node;
        }
        if (node instanceof AST_Scope) {
          descend_scope();
          return node;
        }
        if (node instanceof AST_SymbolImport) {
          if (!compressor.option("imports") || node.definition().id in in_use_ids)
            return node;
          return in_list ? List.skip : null;
        }
        function descend_scope() {
          var save_scope = scope;
          scope = node;
          descend(node, tt);
          scope = save_scope;
        }
      }, function(node, in_list) {
        if (node instanceof AST_BlockStatement)
          return trim_block(node, tt.parent(), in_list);
        if (node instanceof AST_ExportDeclaration) {
          var block = node.body;
          if (!(block instanceof AST_BlockStatement))
            return;
          node.body = block.body.pop();
          block.body.push(node);
          return in_list ? List.splice(block.body) : block;
        }
        if (node instanceof AST_For)
          return patch_for_init(node, in_list);
        if (node instanceof AST_ForIn) {
          if (!drop_vars || !compressor.option("loops"))
            return;
          if (!is_empty(node.body))
            return;
          var sym = get_init_symbol(node);
          if (!sym)
            return;
          var def = sym.definition();
          if (def.id in in_use_ids)
            return;
          log(sym, "Dropping unused loop variable {name}");
          if (for_ins[def.id] === node)
            delete for_ins[def.id];
          var body = [];
          var value = node.object.drop_side_effect_free(compressor);
          if (value) {
            AST_Node.warn("Side effects in object of for-in loop [{start}]", value);
            body.push(make_node(AST_SimpleStatement, node, { body: value }));
          }
          if (node.init instanceof AST_Definitions && def.orig[0] instanceof AST_SymbolCatch) {
            body.push(node.init);
          }
          return insert_statements(body, node, in_list);
        }
        if (node instanceof AST_Import) {
          if (node.properties && node.properties.length == 0)
            node.properties = null;
          return node;
        }
        if (node instanceof AST_Sequence) {
          if (node.expressions.length > 1)
            return;
          return maintain_this_binding(tt.parent(), node, node.expressions[0]);
        }
      });
      tt.push(compressor.parent());
      tt.directives = Object.create(compressor.directives);
      self.transform(tt);
      if (self instanceof AST_Lambda && self.body.length == 1 && self.body[0] instanceof AST_Directive && self.body[0].value == "use strict") {
        self.body.length = 0;
      }
      calls_to_drop_args.forEach(function(call) {
        drop_unused_call_args(call, compressor, fns_with_marked_args);
      });
      function log(sym, text) {
        AST_Node[sym.definition().references.length > 0 ? "info" : "warn"](text + " [{start}]", sym);
      }
      function log_default(node, text) {
        if (node.name instanceof AST_SymbolFunarg) {
          log(node.name, text);
        } else {
          AST_Node.info(text + " [{start}]", node);
        }
      }
      function get_rvalue(expr) {
        return expr[expr instanceof AST_Assign ? "right" : "value"];
      }
      function insert_statements(body, orig, in_list) {
        switch (body.length) {
          case 0:
            return in_list ? List.skip : make_node(AST_EmptyStatement, orig);
          case 1:
            return body[0];
          default:
            return in_list ? List.splice(body) : make_node(AST_BlockStatement, orig, { body });
        }
      }
      function track_assigns(def, node) {
        if (def.scope.resolve() !== self)
          return false;
        if (!def.fixed || !node.fixed)
          assign_in_use[def.id] = false;
        return assign_in_use[def.id] !== false;
      }
      function add_assigns(def, node) {
        if (!assign_in_use[def.id])
          assign_in_use[def.id] = [];
        if (node.fixed.assigns)
          push_uniq(assign_in_use[def.id], node.fixed.assigns);
      }
      function indexOf_assign(def, node) {
        var nodes = assign_in_use[def.id];
        return nodes && nodes.indexOf(node);
      }
      function unmark_lambda(def) {
        if (lambda_ids[def.id] > 1 && !(def.id in in_use_ids)) {
          in_use_ids[def.id] = true;
          in_use.push(def);
        }
        lambda_ids[def.id] = 0;
      }
      function verify_safe_usage(def, read, modified) {
        if (def.id in in_use_ids)
          return;
        if (read && modified) {
          in_use_ids[def.id] = read;
          in_use.push(def);
        } else {
          value_read[def.id] = read;
          value_modified[def.id] = modified;
        }
      }
      function can_drop_lhs(sym, node) {
        var def = sym.definition();
        var in_use2 = in_use_ids[def.id];
        if (!in_use2)
          return true;
        if (node[node instanceof AST_Assign ? "left" : "expression"] !== sym)
          return false;
        return in_use2 === sym && def.references.length - def.replaced == 1 || indexOf_assign(def, node) < 0;
      }
      function get_rhs(assign) {
        var rhs = assign.right;
        if (!assign.write_only)
          return rhs;
        if (!(rhs instanceof AST_Binary && lazy_op[rhs.operator]))
          return rhs;
        if (!(rhs.left instanceof AST_SymbolRef))
          return rhs;
        if (!(assign.left instanceof AST_SymbolRef))
          return rhs;
        var def = assign.left.definition();
        if (rhs.left.definition() !== def)
          return rhs;
        if (rhs.right.has_side_effects(compressor))
          return rhs;
        if (track_assigns(def, rhs.left))
          add_assigns(def, rhs.left);
        return rhs.right;
      }
      function get_init_symbol(for_in) {
        var init2 = for_in.init;
        if (init2 instanceof AST_Definitions) {
          init2 = init2.definitions[0].name;
          return init2 instanceof AST_SymbolDeclaration && init2;
        }
        while (init2 instanceof AST_PropAccess)
          init2 = init2.expression.tail_node();
        if (init2 instanceof AST_SymbolRef)
          return init2;
      }
      function scan_ref_scoped(node, descend, init2) {
        if (node instanceof AST_Assign && node.left instanceof AST_SymbolRef) {
          var def = node.left.definition();
          if (def.scope.resolve() === self)
            assignments.add(def.id, node);
        }
        if (node instanceof AST_SymbolRef && node.in_arg)
          var_defs[node.definition().id] = 0;
        if (node instanceof AST_Unary && node.expression instanceof AST_SymbolRef) {
          var def = node.expression.definition();
          if (def.scope.resolve() === self)
            assignments.add(def.id, node);
        }
        var props = [], sym = assign_as_unused(node, props);
        if (sym) {
          var node_def = sym.definition();
          if (node_def.scope.resolve() !== self && self.variables.get(sym.name) !== node_def)
            return;
          if (is_arguments(node_def) && !all(self.argnames, function(argname) {
            return !argname.match_symbol(function(node2) {
              if (node2 instanceof AST_SymbolFunarg) {
                var def2 = node2.definition();
                return def2.references.length > def2.replaced;
              }
            }, true);
          }))
            return;
          if (node.write_only === "p" && node.right.may_throw_on_access(compressor, true))
            return;
          var assign = props.assign;
          if (assign) {
            assign.write_only = true;
            assign.walk(tw);
          }
          props.forEach(function(prop) {
            prop.walk(tw);
          });
          if (node instanceof AST_Assign) {
            var right = get_rhs(node), shared = false;
            if (init2 && node.write_only === true && !right.has_side_effects(compressor)) {
              initializations.add(node_def.id, right);
            } else {
              right.walk(tw);
              shared = right.tail_node().operator == "=";
            }
            if (node.left === sym) {
              if (!node.write_only || shared) {
                verify_safe_usage(node_def, sym, value_modified[node_def.id]);
              }
            } else {
              var fixed = sym.fixed_value();
              if (!fixed || !fixed.is_constant()) {
                verify_safe_usage(node_def, value_read[node_def.id], true);
              }
            }
          }
          if (track_assigns(node_def, sym) && is_lhs(sym, node) !== sym)
            add_assigns(node_def, sym);
          unmark_lambda(node_def);
          return true;
        }
        if (node instanceof AST_Binary) {
          if (node.operator != "instanceof")
            return;
          var sym = node.right;
          if (!(sym instanceof AST_SymbolRef))
            return;
          var id = sym.definition().id;
          if (!lambda_ids[id])
            return;
          node.left.walk(tw);
          lambda_ids[id]++;
          return true;
        }
        if (node instanceof AST_ForIn) {
          if (node.init instanceof AST_SymbolRef && scope === self) {
            var id = node.init.definition().id;
            if (!(id in for_ins))
              for_ins[id] = node;
          }
          if (!drop_vars || !compressor.option("loops"))
            return;
          if (!is_empty(node.body))
            return;
          if (node.init.has_side_effects(compressor))
            return;
          var sym = get_init_symbol(node);
          if (!sym)
            return;
          var def = sym.definition();
          if (def.scope.resolve() !== self) {
            var d = find_variable(sym.name);
            if (d === def || d && d.redefined() === def)
              return;
          }
          node.object.walk(tw);
          return true;
        }
        if (node instanceof AST_SymbolRef) {
          var node_def = node.definition();
          if (!(node_def.id in in_use_ids)) {
            in_use_ids[node_def.id] = true;
            in_use.push(node_def);
          }
          if (cross_scope(node_def.scope, node.scope)) {
            var redef = node_def.redefined();
            if (redef && !(redef.id in in_use_ids)) {
              in_use_ids[redef.id] = true;
              in_use.push(redef);
            }
          }
          if (track_assigns(node_def, node))
            add_assigns(node_def, node);
          return true;
        }
        if (node instanceof AST_Scope) {
          var save_scope = scope;
          scope = node;
          descend();
          scope = save_scope;
          return true;
        }
      }
      function is_decl(node) {
        return (node instanceof AST_DefaultValue ? node.name : node) instanceof AST_SymbolDeclaration;
      }
      function trim_decl(node) {
        if (node.definition().id in in_use_ids)
          return node;
        if (node instanceof AST_SymbolFunarg)
          node.unused = true;
        return null;
      }
      function trim_default(trimmer2, node) {
        node.value = node.value.transform(tt);
        var name = node.name.transform(trimmer2);
        if (!name) {
          if (node.name instanceof AST_Destructured)
            return null;
          var value = node.value.drop_side_effect_free(compressor);
          if (!value)
            return null;
          log(node.name, "Side effects in default value of unused variable {name}");
          node = node.clone();
          node.name.unused = null;
          node.value = value;
        }
        return node;
      }
      function trim_destructured(node, value, process2, drop, root) {
        var trimmer2 = new TreeTransformer(function(node2) {
          if (node2 instanceof AST_DefaultValue) {
            if (!(compressor.option("default_values") && value && value.is_defined(compressor))) {
              var save_drop = drop;
              drop = false;
              var trimmed = trim_default(trimmer2, node2);
              drop = save_drop;
              if (!trimmed && drop && value)
                value = value.drop_side_effect_free(compressor);
              return trimmed;
            } else if (node2 === root) {
              root = node2 = node2.name;
            } else {
              node2 = node2.name;
            }
          }
          if (node2 instanceof AST_DestructuredArray) {
            var save_drop = drop;
            var save_value = value;
            if (value instanceof AST_SymbolRef) {
              drop = false;
              value = value.fixed_value();
            }
            var native, values;
            if (value instanceof AST_Array) {
              native = true;
              values = value.elements;
            } else {
              native = value && value.is_string(compressor);
              values = false;
            }
            var elements = [], newValues = drop && [], pos = 0;
            node2.elements.forEach(function(element, index) {
              value = values && values[index];
              if (value instanceof AST_Hole) {
                value = null;
              } else if (value instanceof AST_Spread) {
                if (drop) {
                  newValues.length = pos;
                  fill_holes(save_value, newValues);
                  [].push.apply(newValues, values.slice(index));
                  save_value.elements = newValues;
                }
                value = values = false;
              }
              element = element.transform(trimmer2);
              if (element)
                elements[pos] = element;
              if (drop && value)
                newValues[pos] = value;
              if (element || value || !drop || !values)
                pos++;
            });
            value = values && make_node(AST_Array, save_value, {
              elements: values.slice(node2.elements.length)
            });
            if (node2.rest) {
              var was_drop = drop;
              drop = false;
              node2.rest = node2.rest.transform(compressor.option("rests") ? trimmer2 : tt);
              drop = was_drop;
              if (node2.rest)
                elements.length = pos;
            }
            if (drop) {
              if (value && !node2.rest)
                value = value.drop_side_effect_free(compressor);
              if (value instanceof AST_Array) {
                value = value.elements;
              } else if (value instanceof AST_Sequence) {
                value = value.expressions;
              } else if (value) {
                value = [value];
              }
              if (value && value.length) {
                newValues.length = pos;
                [].push.apply(newValues, value);
              }
            }
            value = save_value;
            drop = save_drop;
            if (values && newValues) {
              fill_holes(value, newValues);
              value = value.clone();
              value.elements = newValues;
            }
            if (!native) {
              elements.length = node2.elements.length;
            } else if (!node2.rest)
              switch (elements.length) {
                case 0:
                  if (node2 === root)
                    break;
                  if (drop)
                    value = value.drop_side_effect_free(compressor);
                  return null;
                case 1:
                  if (!drop)
                    break;
                  if (node2 === root)
                    break;
                  var sym = elements[0];
                  if (sym.has_side_effects(compressor))
                    break;
                  if (value.has_side_effects(compressor) && sym.match_symbol(function(node3) {
                    return node3 instanceof AST_PropAccess;
                  }))
                    break;
                  value = make_node(AST_Sub, node2, {
                    expression: value,
                    property: make_node(AST_Number, node2, { value: 0 })
                  });
                  return sym;
              }
            fill_holes(node2, elements);
            node2.elements = elements;
            return node2;
          }
          if (node2 instanceof AST_DestructuredObject) {
            var save_drop = drop;
            var save_value = value;
            if (value instanceof AST_SymbolRef) {
              drop = false;
              value = value.fixed_value();
            }
            var prop_keys, prop_map, values;
            if (value instanceof AST_Object) {
              prop_keys = [];
              prop_map = new Dictionary;
              values = value.properties.map(function(prop2, index) {
                prop2 = prop2.clone();
                if (prop2 instanceof AST_Spread) {
                  prop_map = false;
                } else {
                  var key = prop2.key;
                  if (key instanceof AST_Node)
                    key = key.evaluate(compressor, true);
                  if (key instanceof AST_Node) {
                    prop_map = false;
                  } else if (prop_map && !(prop2 instanceof AST_ObjectSetter)) {
                    prop_map.set(key, prop2);
                  }
                  prop_keys[index] = key;
                }
                return prop2;
              });
            }
            if (node2.rest) {
              value = false;
              node2.rest = node2.rest.transform(compressor.option("rests") ? trimmer2 : tt);
            }
            var can_drop = new Dictionary;
            var drop_keys = drop && new Dictionary;
            var properties = [];
            node2.properties.map(function(prop2) {
              var key = prop2.key;
              if (key instanceof AST_Node) {
                prop2.key = key = key.transform(tt);
                key = key.evaluate(compressor, true);
              }
              if (key instanceof AST_Node) {
                drop_keys = false;
              } else {
                can_drop.set(key, !can_drop.has(key));
              }
              return key;
            }).forEach(function(key, index) {
              var prop2 = node2.properties[index], trimmed2;
              if (key instanceof AST_Node) {
                drop = false;
                value = false;
                trimmed2 = prop2.value.transform(trimmer2) || retain_lhs(prop2.value);
              } else {
                drop = drop_keys && can_drop.get(key);
                var mapped = prop_map && prop_map.get(key);
                if (mapped) {
                  value = mapped.value;
                  if (value instanceof AST_Accessor)
                    value = false;
                } else {
                  value = false;
                }
                trimmed2 = prop2.value.transform(trimmer2);
                if (!trimmed2) {
                  if (node2.rest || retain_key(prop2))
                    trimmed2 = retain_lhs(prop2.value);
                  if (drop_keys && !drop_keys.has(key)) {
                    if (mapped) {
                      drop_keys.set(key, mapped);
                      if (value === null) {
                        prop_map.set(key, retain_key(mapped) && make_node(AST_ObjectKeyVal, mapped, {
                          key: mapped.key,
                          value: make_node(AST_Number, mapped, { value: 0 })
                        }));
                      }
                    } else {
                      drop_keys.set(key, true);
                    }
                  }
                } else if (drop_keys) {
                  drop_keys.set(key, false);
                }
                if (value)
                  mapped.value = value;
              }
              if (trimmed2) {
                prop2.value = trimmed2;
                properties.push(prop2);
              }
            });
            value = save_value;
            drop = save_drop;
            if (drop_keys && prop_keys) {
              value = value.clone();
              value.properties = List(values, function(prop2, index) {
                if (prop2 instanceof AST_Spread)
                  return prop2;
                var key = prop_keys[index];
                if (key instanceof AST_Node)
                  return prop2;
                if (drop_keys.has(key)) {
                  var mapped = drop_keys.get(key);
                  if (!mapped)
                    return prop2;
                  if (mapped === prop2)
                    return prop_map.get(key) || List.skip;
                } else if (node2.rest) {
                  return prop2;
                }
                var trimmed2 = prop2.value.drop_side_effect_free(compressor);
                if (trimmed2) {
                  prop2.value = trimmed2;
                  return prop2;
                }
                return retain_key(prop2) ? make_node(AST_ObjectKeyVal, prop2, {
                  key: prop2.key,
                  value: make_node(AST_Number, prop2, { value: 0 })
                }) : List.skip;
              });
            }
            if (value && !node2.rest)
              switch (properties.length) {
                case 0:
                  if (node2 === root)
                    break;
                  if (value.may_throw_on_access(compressor, true))
                    break;
                  if (drop)
                    value = value.drop_side_effect_free(compressor);
                  return null;
                case 1:
                  if (!drop)
                    break;
                  if (node2 === root)
                    break;
                  var prop = properties[0];
                  if (prop.key instanceof AST_Node)
                    break;
                  if (prop.value.has_side_effects(compressor))
                    break;
                  if (value.has_side_effects(compressor) && prop.value.match_symbol(function(node3) {
                    return node3 instanceof AST_PropAccess;
                  }))
                    break;
                  value = make_node(AST_Sub, node2, {
                    expression: value,
                    property: make_node_from_constant(prop.key, prop)
                  });
                  return prop.value;
              }
            node2.properties = properties;
            return node2;
          }
          if (node2 instanceof AST_Hole) {
            node2 = null;
          } else {
            node2 = process2(node2);
          }
          if (!node2 && drop && value)
            value = value.drop_side_effect_free(compressor);
          return node2;
        });
        return {
          name: node.transform(trimmer2),
          value
        };
        function retain_key(prop) {
          return prop.key instanceof AST_Node && prop.key.has_side_effects(compressor);
        }
        function clear_write_only(node2) {
          if (node2 instanceof AST_Assign) {
            node2.write_only = false;
            clear_write_only(node2.right);
          } else if (node2 instanceof AST_Binary) {
            if (!lazy_op[node2.operator])
              return;
            clear_write_only(node2.left);
            clear_write_only(node2.right);
          } else if (node2 instanceof AST_Conditional) {
            clear_write_only(node2.consequent);
            clear_write_only(node2.alternative);
          } else if (node2 instanceof AST_Sequence) {
            clear_write_only(node2.tail_node());
          } else if (node2 instanceof AST_Unary) {
            node2.write_only = false;
          }
        }
        function retain_lhs(node2) {
          if (node2 instanceof AST_DefaultValue)
            return retain_lhs(node2.name);
          if (node2 instanceof AST_Destructured) {
            if (value === null) {
              value = make_node(AST_Number, node2, { value: 0 });
            } else if (value) {
              if (value.may_throw_on_access(compressor, true)) {
                value = make_node(AST_Array, node2, {
                  elements: value instanceof AST_Sequence ? value.expressions : [value]
                });
              } else {
                clear_write_only(value);
              }
            }
            return make_node(AST_DestructuredObject, node2, { properties: [] });
          }
          node2.unused = null;
          return node2;
        }
      }
    });
    AST_Scope.DEFMETHOD("hoist_declarations", function(compressor) {
      if (compressor.has_directive("use asm"))
        return;
      var hoist_funs = compressor.option("hoist_funs");
      var hoist_vars = compressor.option("hoist_vars");
      var self = this;
      if (hoist_vars) {
        var var_decl = 0;
        self.walk(new TreeWalker(function(node) {
          if (var_decl > 1)
            return true;
          if (node instanceof AST_ExportDeclaration)
            return true;
          if (node instanceof AST_Scope && node !== self)
            return true;
          if (node instanceof AST_Var) {
            var_decl++;
            return true;
          }
        }));
        if (var_decl <= 1)
          hoist_vars = false;
      }
      if (!hoist_funs && !hoist_vars)
        return;
      var consts = new Dictionary;
      var dirs = [];
      var hoisted = [];
      var vars = new Dictionary;
      var tt = new TreeTransformer(function(node, descend, in_list) {
        if (node === self)
          return;
        if (node instanceof AST_Directive) {
          dirs.push(node);
          return in_list ? List.skip : make_node(AST_EmptyStatement, node);
        }
        if (node instanceof AST_LambdaDefinition) {
          if (!hoist_funs)
            return node;
          var p = tt.parent();
          if (p instanceof AST_ExportDeclaration)
            return node;
          if (p instanceof AST_ExportDefault)
            return node;
          if (p !== self && compressor.has_directive("use strict"))
            return node;
          hoisted.push(node);
          return in_list ? List.skip : make_node(AST_EmptyStatement, node);
        }
        if (node instanceof AST_Var) {
          if (!hoist_vars)
            return node;
          var p = tt.parent();
          if (p instanceof AST_ExportDeclaration)
            return node;
          if (!all(node.definitions, function(defn) {
            var sym2 = defn.name;
            return sym2 instanceof AST_SymbolVar && !consts.has(sym2.name) && self.find_variable(sym2.name) === sym2.definition();
          }))
            return node;
          node.definitions.forEach(function(defn) {
            vars.set(defn.name.name, defn);
          });
          var seq = node.to_assignments();
          if (p instanceof AST_ForEnumeration && p.init === node) {
            if (seq)
              return seq;
            var sym = node.definitions[0].name;
            return make_node(AST_SymbolRef, sym);
          }
          if (p instanceof AST_For && p.init === node)
            return seq;
          if (!seq)
            return in_list ? List.skip : make_node(AST_EmptyStatement, node);
          return make_node(AST_SimpleStatement, node, { body: seq });
        }
        if (node instanceof AST_Scope)
          return node;
        if (node instanceof AST_SymbolConst) {
          consts.set(node.name, true);
          return node;
        }
      });
      self.transform(tt);
      if (vars.size() > 0) {
        var defns = [];
        if (self instanceof AST_Lambda)
          self.each_argname(function(argname) {
            if (all(argname.definition().references, function(ref) {
              return !ref.in_arg;
            }))
              vars.del(argname.name);
          });
        vars.each(function(defn, name) {
          defn = defn.clone();
          defn.name = defn.name.clone();
          defn.value = null;
          defns.push(defn);
          vars.set(name, defn);
          defn.name.definition().orig.unshift(defn.name);
        });
        if (defns.length > 0)
          hoisted.push(make_node(AST_Var, self, { definitions: defns }));
      }
      self.body = dirs.concat(hoisted, self.body);
    });
    function scan_local_returns(fn, transform) {
      fn.walk(new TreeWalker(function(node) {
        if (node instanceof AST_Return) {
          transform(node);
          return true;
        }
        if (node instanceof AST_Scope && node !== fn)
          return true;
      }));
    }
    function map_self_returns(fn) {
      var map = Object.create(null);
      scan_local_returns(fn, function(node) {
        var value = node.value;
        if (value)
          value = value.tail_node();
        if (value instanceof AST_SymbolRef) {
          var id = value.definition().id;
          map[id] = (map[id] || 0) + 1;
        }
      });
      return map;
    }
    function can_trim_returns(def, self_returns, compressor) {
      if (compressor.exposed(def))
        return false;
      switch (def.references.length - def.replaced - (self_returns[def.id] || 0)) {
        case def.drop_return:
          return "d";
        case def.bool_return:
          return true;
      }
    }
    function process_boolean_returns(fn, compressor) {
      scan_local_returns(fn, function(node) {
        node.in_bool = true;
        var value = node.value;
        if (value) {
          var ev = fuzzy_eval(compressor, value);
          if (!ev) {
            value = value.drop_side_effect_free(compressor);
            node.value = value ? make_sequence(node.value, [
              value,
              make_node(AST_Number, node.value, { value: 0 })
            ]) : null;
          } else if (!(ev instanceof AST_Node)) {
            value = value.drop_side_effect_free(compressor);
            node.value = value ? make_sequence(node.value, [
              value,
              make_node(AST_Number, node.value, { value: 1 })
            ]) : make_node(AST_Number, node.value, { value: 1 });
          }
        }
      });
    }
    AST_Scope.DEFMETHOD("process_returns", noop);
    AST_Defun.DEFMETHOD("process_returns", function(compressor) {
      if (!compressor.option("booleans"))
        return;
      if (compressor.parent() instanceof AST_ExportDefault)
        return;
      switch (can_trim_returns(this.name.definition(), map_self_returns(this), compressor)) {
        case "d":
          drop_returns(compressor, this, true);
          break;
        case true:
          process_boolean_returns(this, compressor);
          break;
      }
    });
    AST_Function.DEFMETHOD("process_returns", function(compressor) {
      if (!compressor.option("booleans"))
        return;
      var drop = true;
      var self_returns = map_self_returns(this);
      if (this.name && !can_trim(this.name.definition()))
        return;
      var parent = compressor.parent();
      if (parent instanceof AST_Assign) {
        if (parent.operator != "=")
          return;
        var sym = parent.left;
        if (!(sym instanceof AST_SymbolRef))
          return;
        if (!can_trim(sym.definition()))
          return;
      } else if (parent instanceof AST_Call && parent.expression !== this) {
        var exp = parent.expression;
        if (exp instanceof AST_SymbolRef)
          exp = exp.fixed_value();
        if (!(exp instanceof AST_Lambda))
          return;
        if (exp.uses_arguments || exp.pinned())
          return;
        var args = parent.args, sym;
        for (var i = 0;i < args.length; i++) {
          var arg = args[i];
          if (arg === this) {
            sym = exp.argnames[i];
            if (!sym && exp.rest)
              return;
            break;
          }
          if (arg instanceof AST_Spread)
            return;
        }
        if (sym instanceof AST_DefaultValue)
          sym = sym.name;
        if (sym instanceof AST_SymbolFunarg && !can_trim(sym.definition()))
          return;
      } else if (parent.TYPE == "Call") {
        compressor.pop();
        var in_bool = compressor.in_boolean_context();
        compressor.push(this);
        switch (in_bool) {
          case true:
            drop = false;
          case "d":
            break;
          default:
            return;
        }
      } else
        return;
      if (drop) {
        drop_returns(compressor, this, true);
      } else {
        process_boolean_returns(this, compressor);
      }
      function can_trim(def) {
        switch (can_trim_returns(def, self_returns, compressor)) {
          case true:
            drop = false;
          case "d":
            return true;
        }
      }
    });
    AST_BlockScope.DEFMETHOD("var_names", function() {
      var var_names = this._var_names;
      if (!var_names) {
        this._var_names = var_names = new Dictionary;
        this.enclosed.forEach(function(def) {
          var_names.set(def.name, true);
        });
        this.variables.each(function(def, name) {
          var_names.set(name, true);
        });
      }
      return var_names;
    });
    AST_Scope.DEFMETHOD("make_var", function(type, orig, prefix) {
      var scopes = [this];
      if (orig instanceof AST_SymbolDeclaration)
        orig.definition().references.forEach(function(ref) {
          var s = ref.scope;
          do {
            if (!push_uniq(scopes, s))
              return;
            s = s.parent_scope;
          } while (s && s !== this);
        });
      prefix = prefix.replace(/^[^a-z_$]|[^a-z0-9_$]/gi, "_");
      var name = prefix;
      for (var i = 0;!all(scopes, function(scope) {
        return !scope.var_names().has(name);
      }); i++)
        name = prefix + "$" + i;
      var sym = make_node(type, orig, {
        name,
        scope: this
      });
      var def = this.def_variable(sym);
      scopes.forEach(function(scope) {
        scope.enclosed.push(def);
        scope.var_names().set(name, true);
      });
      return sym;
    });
    AST_Scope.DEFMETHOD("hoist_properties", function(compressor) {
      if (!compressor.option("hoist_props") || compressor.has_directive("use asm"))
        return;
      var self = this;
      if (is_arrow(self) && self.value)
        return;
      var top_retain = self instanceof AST_Toplevel && compressor.top_retain || return_false;
      var defs_by_id = Object.create(null);
      var tt = new TreeTransformer(function(node, descend) {
        if (node instanceof AST_Assign) {
          if (node.operator != "=")
            return;
          if (!node.write_only)
            return;
          if (!can_hoist(node.left, node.right, 1))
            return;
          descend(node, tt);
          var defs = new Dictionary;
          var assignments = [];
          var decls = [];
          node.right.properties.forEach(function(prop) {
            var decl2 = make_sym(AST_SymbolVar, node.left, prop.key);
            decls.push(make_node(AST_VarDef, node, {
              name: decl2,
              value: null
            }));
            var sym = make_node(AST_SymbolRef, node, {
              name: decl2.name,
              scope: self,
              thedef: decl2.definition()
            });
            sym.reference();
            assignments.push(make_node(AST_Assign, node, {
              operator: "=",
              left: sym,
              right: prop.value
            }));
          });
          defs.value = node.right;
          defs_by_id[node.left.definition().id] = defs;
          self.body.splice(self.body.indexOf(tt.stack[1]) + 1, 0, make_node(AST_Var, node, {
            definitions: decls
          }));
          return make_sequence(node, assignments);
        }
        if (node instanceof AST_Scope) {
          if (node === self)
            return;
          var parent = tt.parent();
          if (parent.TYPE == "Call" && parent.expression === node)
            return;
          return node;
        }
        if (node instanceof AST_VarDef) {
          if (!can_hoist(node.name, node.value, 0))
            return;
          descend(node, tt);
          var defs = new Dictionary;
          var var_defs = [];
          var decl = node.clone();
          decl.value = node.name instanceof AST_SymbolConst ? make_node(AST_Number, node, { value: 0 }) : null;
          var_defs.push(decl);
          node.value.properties.forEach(function(prop) {
            var_defs.push(make_node(AST_VarDef, node, {
              name: make_sym(node.name.CTOR, node.name, prop.key),
              value: prop.value
            }));
          });
          defs.value = node.value;
          defs_by_id[node.name.definition().id] = defs;
          return List.splice(var_defs);
        }
        function make_sym(type, sym, key) {
          var new_var = self.make_var(type, sym, sym.name + "_" + key);
          defs.set(key, new_var.definition());
          return new_var;
        }
      });
      self.transform(tt);
      self.transform(new TreeTransformer(function(node, descend) {
        if (node instanceof AST_PropAccess) {
          if (!(node.expression instanceof AST_SymbolRef))
            return;
          var defs = defs_by_id[node.expression.definition().id];
          if (!defs)
            return;
          if (node.expression.fixed_value() !== defs.value)
            return;
          var def = defs.get(node.get_property());
          var sym = make_node(AST_SymbolRef, node, {
            name: def.name,
            scope: node.expression.scope,
            thedef: def
          });
          sym.reference();
          return sym;
        }
        if (node instanceof AST_SymbolRef) {
          var defs = defs_by_id[node.definition().id];
          if (!defs)
            return;
          if (node.fixed_value() !== defs.value)
            return;
          return make_node(AST_Object, node, { properties: [] });
        }
      }));
      function can_hoist(sym, right, count) {
        if (!(sym instanceof AST_Symbol))
          return;
        var def = sym.definition();
        if (def.assignments != count)
          return;
        if (def.references.length - def.replaced == count)
          return;
        if (def.single_use)
          return;
        if (self.find_variable(sym.name) !== def)
          return;
        if (top_retain(def))
          return;
        if (sym.fixed_value() !== right)
          return;
        var fixed = sym.fixed || def.fixed;
        if (fixed.direct_access)
          return;
        if (fixed.escaped && fixed.escaped.depth == 1)
          return;
        return right instanceof AST_Object && right.properties.length > 0 && can_drop_symbol(sym, compressor) && all(right.properties, function(prop) {
          return can_hoist_property(prop) && prop.key !== "__proto__";
        });
      }
    });
    function fn_name_unused(fn, compressor) {
      if (!fn.name || !compressor.option("ie"))
        return true;
      var def = fn.name.definition();
      if (compressor.exposed(def))
        return false;
      return all(def.references, function(sym) {
        return !(sym instanceof AST_SymbolRef);
      });
    }
    function drop_returns(compressor, exp, ignore_name) {
      if (!(exp instanceof AST_Lambda))
        return;
      var arrow = is_arrow(exp);
      var async = is_async(exp);
      var changed = false;
      var drop_body = false;
      if (arrow && compressor.option("arrows")) {
        if (!exp.value) {
          drop_body = true;
        } else if (!async || needs_enqueuing(compressor, exp.value)) {
          var dropped = exp.value.drop_side_effect_free(compressor);
          if (dropped !== exp.value) {
            changed = true;
            exp.value = dropped;
          }
        }
      } else if (!is_generator(exp)) {
        if (!ignore_name && exp.name) {
          var def = exp.name.definition();
          drop_body = def.references.length == def.replaced;
        } else {
          drop_body = true;
        }
      }
      if (drop_body) {
        exp.process_expression(false, function(node) {
          var value = node.value;
          if (value) {
            if (async && !needs_enqueuing(compressor, value))
              return node;
            value = value.drop_side_effect_free(compressor, true);
          }
          changed = true;
          if (!value)
            return make_node(AST_EmptyStatement, node);
          return make_node(AST_SimpleStatement, node, { body: value });
        });
        scan_local_returns(exp, function(node) {
          var value = node.value;
          if (value) {
            if (async && !needs_enqueuing(compressor, value))
              return;
            var dropped2 = value.drop_side_effect_free(compressor);
            if (dropped2 !== value) {
              changed = true;
              if (dropped2 && async && !needs_enqueuing(compressor, dropped2)) {
                dropped2 = dropped2.negate(compressor);
              }
              node.value = dropped2;
            }
          }
        });
      }
      if (async && compressor.option("awaits")) {
        if (drop_body)
          exp.process_expression("awaits", function(node) {
            var body = node.body;
            if (body instanceof AST_Await) {
              if (needs_enqueuing(compressor, body.expression)) {
                changed = true;
                body = body.expression.drop_side_effect_free(compressor, true);
                if (!body)
                  return make_node(AST_EmptyStatement, node);
                node.body = body;
              }
            } else if (body instanceof AST_Sequence) {
              var exprs = body.expressions;
              for (var i = exprs.length;--i >= 0; ) {
                var tail = exprs[i];
                if (!(tail instanceof AST_Await))
                  break;
                var value = tail.expression;
                if (!needs_enqueuing(compressor, value))
                  break;
                changed = true;
                if (exprs[i] = value.drop_side_effect_free(compressor))
                  break;
              }
              switch (i) {
                case -1:
                  return make_node(AST_EmptyStatement, node);
                case 0:
                  node.body = exprs[0];
                  break;
                default:
                  exprs.length = i + 1;
                  break;
              }
            }
            return node;
          });
        var abort = !drop_body && exp.name || arrow && exp.value && !needs_enqueuing(compressor, exp.value);
        var tw = new TreeWalker(function(node) {
          if (abort)
            return true;
          if (tw.parent() === exp && node.may_throw(compressor))
            return abort = true;
          if (node instanceof AST_Await)
            return abort = true;
          if (node instanceof AST_ForAwaitOf)
            return abort = true;
          if (node instanceof AST_Return) {
            if (node.value && !needs_enqueuing(compressor, node.value))
              return abort = true;
            return;
          }
          if (node instanceof AST_Scope && node !== exp)
            return true;
        });
        exp.walk(tw);
        if (!abort) {
          var ctor;
          switch (exp.CTOR) {
            case AST_AsyncArrow:
              ctor = AST_Arrow;
              break;
            case AST_AsyncFunction:
              ctor = AST_Function;
              break;
            case AST_AsyncGeneratorFunction:
              ctor = AST_GeneratorFunction;
              break;
          }
          return make_node(ctor, exp);
        }
      }
      return changed && exp.clone();
    }
    (function(def) {
      function trim(nodes, compressor, first_in_statement2, spread) {
        var len = nodes.length;
        var ret = [], changed = false;
        for (var i = 0;i < len; i++) {
          var node = nodes[i];
          var trimmed;
          if (spread && node instanceof AST_Spread) {
            trimmed = spread(node, compressor, first_in_statement2);
          } else {
            trimmed = node.drop_side_effect_free(compressor, first_in_statement2);
          }
          if (trimmed !== node)
            changed = true;
          if (trimmed) {
            ret.push(trimmed);
            first_in_statement2 = false;
          }
        }
        return ret.length ? changed ? ret : nodes : null;
      }
      function array_spread(node, compressor, first_in_statement2) {
        var exp = node.expression;
        if (!exp.is_string(compressor))
          return node;
        return exp.drop_side_effect_free(compressor, first_in_statement2);
      }
      function convert_spread(node) {
        return node instanceof AST_Spread ? make_node(AST_Array, node, { elements: [node] }) : node;
      }
      def(AST_Node, return_this);
      def(AST_Accessor, return_null);
      def(AST_Array, function(compressor, first_in_statement2) {
        var values = trim(this.elements, compressor, first_in_statement2, array_spread);
        if (!values)
          return null;
        if (values === this.elements && all(values, function(node) {
          return node instanceof AST_Spread;
        }))
          return this;
        return make_sequence(this, values.map(convert_spread));
      });
      def(AST_Assign, function(compressor) {
        var left = this.left;
        if (left instanceof AST_PropAccess) {
          var expr = left.expression;
          if (expr.may_throw_on_access(compressor, true))
            return this;
          if (compressor.has_directive("use strict") && expr.is_constant())
            return this;
        }
        if (left.has_side_effects(compressor))
          return this;
        if (lazy_op[this.operator.slice(0, -1)])
          return this;
        this.write_only = true;
        if (!root_expr(left).is_constant_expression(compressor.find_parent(AST_Scope)))
          return this;
        return this.right.drop_side_effect_free(compressor);
      });
      def(AST_Await, function(compressor) {
        if (!compressor.option("awaits"))
          return this;
        var exp = this.expression;
        if (!needs_enqueuing(compressor, exp))
          return this;
        if (exp instanceof AST_UnaryPrefix && exp.operator == "!")
          exp = exp.expression;
        var dropped = exp.drop_side_effect_free(compressor);
        if (dropped === exp)
          return this;
        if (!dropped) {
          dropped = make_node(AST_Number, exp, { value: 0 });
        } else if (!needs_enqueuing(compressor, dropped)) {
          dropped = dropped.negate(compressor);
        }
        var node = this.clone();
        node.expression = dropped;
        return node;
      });
      def(AST_Binary, function(compressor, first_in_statement2) {
        var left = this.left;
        var right = this.right;
        var op = this.operator;
        if (!can_drop_op(op, right, compressor)) {
          var lhs = left.drop_side_effect_free(compressor, first_in_statement2);
          if (lhs === left)
            return this;
          var node = this.clone();
          node.left = lhs || make_node(AST_Number, left, { value: 0 });
          return node;
        }
        var rhs = right.drop_side_effect_free(compressor, first_in_statement2);
        if (!rhs)
          return left.drop_side_effect_free(compressor, first_in_statement2);
        if (lazy_op[op] && rhs.has_side_effects(compressor)) {
          var node = this;
          if (rhs !== right) {
            node = node.clone();
            node.right = rhs.drop_side_effect_free(compressor);
          }
          if (op == "??")
            return node;
          var negated = node.clone();
          negated.operator = op == "&&" ? "||" : "&&";
          negated.left = left.negate(compressor, first_in_statement2);
          var negated_rhs = negated.right.tail_node();
          if (negated_rhs instanceof AST_Binary && negated.operator == negated_rhs.operator)
            swap_chain(negated);
          var best = first_in_statement2 ? best_of_statement : best_of_expression;
          return op == "&&" ? best(node, negated) : best(negated, node);
        }
        var lhs = left.drop_side_effect_free(compressor, first_in_statement2);
        if (!lhs)
          return rhs;
        rhs = rhs.drop_side_effect_free(compressor);
        if (!rhs)
          return lhs;
        return make_sequence(this, [lhs, rhs]);
      });
      function assign_this_only(fn, compressor) {
        fn.new = true;
        var result = all(fn.body, function(stat) {
          return !stat.has_side_effects(compressor);
        }) && all(fn.argnames, function(argname) {
          return !argname.match_symbol(return_false);
        }) && !(fn.rest && fn.rest.match_symbol(return_false));
        fn.new = false;
        return result;
      }
      def(AST_Call, function(compressor, first_in_statement2) {
        var self = this;
        if (self.is_expr_pure(compressor)) {
          if (self.pure)
            AST_Node.warn("Dropping __PURE__ call [{start}]", self);
          var args = trim(self.args, compressor, first_in_statement2, array_spread);
          return args && make_sequence(self, args.map(convert_spread));
        }
        var exp = self.expression;
        if (self.is_call_pure(compressor)) {
          var exprs = self.args.slice();
          exprs.unshift(exp.expression);
          exprs = trim(exprs, compressor, first_in_statement2, array_spread);
          return exprs && make_sequence(self, exprs.map(convert_spread));
        }
        if (compressor.option("yields") && is_generator(exp)) {
          var call = self.clone();
          call.expression = make_node(AST_Function, exp);
          call.expression.body = [];
          var opt = call.transform(compressor);
          if (opt !== call)
            return opt.drop_side_effect_free(compressor, first_in_statement2);
        }
        var dropped = drop_returns(compressor, exp);
        if (dropped) {
          self = self.clone();
          self.expression = dropped;
          if (exp._squeezed)
            self.expression._squeezed = true;
        }
        if (self instanceof AST_New) {
          var fn = exp;
          if (fn instanceof AST_SymbolRef)
            fn = fn.fixed_value();
          if (fn instanceof AST_Lambda) {
            if (assign_this_only(fn, compressor)) {
              var exprs = self.args.slice();
              exprs.unshift(exp);
              exprs = trim(exprs, compressor, first_in_statement2, array_spread);
              return exprs && make_sequence(self, exprs.map(convert_spread));
            }
            if (!fn.contains_this()) {
              self = make_node(AST_Call, self);
              self.expression = self.expression.clone();
              self.args = self.args.slice();
            }
          }
        }
        self.call_only = true;
        return self;
      });
      def(AST_ClassExpression, function(compressor, first_in_statement2) {
        var self = this;
        var exprs = [], values = [], init = 0;
        var props = self.properties;
        for (var i = 0;i < props.length; i++) {
          var prop = props[i];
          if (prop.key instanceof AST_Node)
            exprs.push(prop.key);
          if (!is_static_field_or_init(prop))
            continue;
          var value = prop.value;
          if (!value.has_side_effects(compressor))
            continue;
          if (value.contains_this())
            return self;
          if (prop instanceof AST_ClassInit) {
            init++;
            values.push(prop);
          } else {
            values.push(value);
          }
        }
        var base = self.extends;
        if (base) {
          if (base instanceof AST_SymbolRef)
            base = base.fixed_value();
          base = !safe_for_extends(base);
          if (!base)
            exprs.unshift(self.extends);
        }
        exprs = trim(exprs, compressor, first_in_statement2);
        if (exprs)
          first_in_statement2 = false;
        values = trim(values, compressor, first_in_statement2);
        if (!exprs) {
          if (!base && !values && !self.name)
            return null;
          exprs = [];
        }
        if (base || self.name || !compressor.has_directive("use strict")) {
          var node = to_class_expr(self);
          if (!base)
            node.extends = null;
          node.properties = [];
          if (values) {
            if (values.length == init) {
              if (exprs.length)
                values.unshift(make_node(AST_ClassField, self, {
                  key: make_sequence(self, exprs),
                  value: null
                }));
              node.properties = values;
            } else
              node.properties.push(make_node(AST_ClassField, self, {
                static: true,
                key: exprs.length ? make_sequence(self, exprs) : "c",
                value: make_value()
              }));
          } else if (exprs.length)
            node.properties.push(make_node(AST_ClassMethod, self, {
              key: make_sequence(self, exprs),
              value: make_node(AST_Function, self, {
                argnames: [],
                body: []
              }).init_vars(node)
            }));
          return node;
        }
        if (values)
          exprs.push(make_node(AST_Call, self, {
            expression: make_node(AST_Arrow, self, {
              argnames: [],
              body: [],
              value: make_value()
            }).init_vars(self.parent_scope),
            args: []
          }));
        return make_sequence(self, exprs);
        function make_value() {
          return make_sequence(self, values.map(function(node2) {
            if (!(node2 instanceof AST_ClassInit))
              return node2;
            var fn = make_node(AST_Arrow, node2.value);
            fn.argnames = [];
            return make_node(AST_Call, node2, {
              expression: fn,
              args: []
            });
          }));
        }
      });
      def(AST_Conditional, function(compressor) {
        var consequent = this.consequent.drop_side_effect_free(compressor);
        var alternative = this.alternative.drop_side_effect_free(compressor);
        if (consequent === this.consequent && alternative === this.alternative)
          return this;
        var exprs;
        if (compressor.option("ie")) {
          exprs = [];
          if (consequent instanceof AST_Function) {
            exprs.push(consequent);
            consequent = null;
          }
          if (alternative instanceof AST_Function) {
            exprs.push(alternative);
            alternative = null;
          }
        }
        var node;
        if (!consequent) {
          node = alternative ? make_node(AST_Binary, this, {
            operator: "||",
            left: this.condition,
            right: alternative
          }) : this.condition.drop_side_effect_free(compressor);
        } else if (!alternative) {
          node = make_node(AST_Binary, this, {
            operator: "&&",
            left: this.condition,
            right: consequent
          });
        } else {
          node = this.clone();
          node.consequent = consequent;
          node.alternative = alternative;
        }
        if (!exprs)
          return node;
        if (node)
          exprs.push(node);
        return exprs.length == 0 ? null : make_sequence(this, exprs);
      });
      def(AST_Constant, return_null);
      def(AST_Dot, function(compressor, first_in_statement2) {
        var expr = this.expression;
        if (expr.may_throw_on_access(compressor))
          return this;
        return expr.drop_side_effect_free(compressor, first_in_statement2);
      });
      def(AST_Function, function(compressor) {
        return fn_name_unused(this, compressor) ? null : this;
      });
      def(AST_LambdaExpression, return_null);
      def(AST_Object, function(compressor, first_in_statement2) {
        var exprs = [];
        this.properties.forEach(function(prop) {
          if (prop instanceof AST_Spread) {
            exprs.push(prop);
          } else {
            if (prop.key instanceof AST_Node)
              exprs.push(prop.key);
            exprs.push(prop.value);
          }
        });
        var values = trim(exprs, compressor, first_in_statement2, function(node, compressor2, first_in_statement3) {
          var exp = node.expression;
          return exp.safe_to_spread() ? exp.drop_side_effect_free(compressor2, first_in_statement3) : node;
        });
        if (!values)
          return null;
        if (values === exprs && !all(values, function(node) {
          return !(node instanceof AST_Spread);
        }))
          return this;
        return make_sequence(this, values.map(function(node) {
          return node instanceof AST_Spread ? make_node(AST_Object, node, { properties: [node] }) : node;
        }));
      });
      def(AST_ObjectIdentity, return_null);
      def(AST_Sequence, function(compressor, first_in_statement2) {
        var expressions = trim(this.expressions, compressor, first_in_statement2);
        if (!expressions)
          return null;
        var end = expressions.length - 1;
        var last = expressions[end];
        if (compressor.option("awaits") && end > 0 && last instanceof AST_Await && last.expression.is_constant()) {
          expressions = expressions.slice(0, -1);
          end--;
          var expr = expressions[end];
          last.expression = needs_enqueuing(compressor, expr) ? expr : expr.negate(compressor);
          expressions[end] = last;
        }
        var assign, cond, lhs;
        if (compressor.option("conditionals") && end > 0 && (assign = expressions[end - 1]) instanceof AST_Assign && assign.operator == "=" && (lhs = assign.left) instanceof AST_SymbolRef && (cond = to_conditional_assignment(compressor, lhs.definition(), assign.right, last))) {
          assign = assign.clone();
          assign.right = cond;
          expressions = expressions.slice(0, -2);
          expressions.push(assign.drop_side_effect_free(compressor, first_in_statement2));
        }
        return expressions === this.expressions ? this : make_sequence(this, expressions);
      });
      def(AST_Sub, function(compressor, first_in_statement2) {
        var expr = this.expression;
        if (expr.may_throw_on_access(compressor))
          return this;
        var prop = this.property;
        expr = expr.drop_side_effect_free(compressor, first_in_statement2);
        if (!expr)
          return prop.drop_side_effect_free(compressor, first_in_statement2);
        prop = prop.drop_side_effect_free(compressor);
        if (!prop)
          return expr;
        return make_sequence(this, [expr, prop]);
      });
      def(AST_SymbolRef, function(compressor) {
        return this.is_declared(compressor) && can_drop_symbol(this, compressor) ? null : this;
      });
      def(AST_Template, function(compressor, first_in_statement2) {
        var self = this;
        if (self.is_expr_pure(compressor)) {
          var expressions = self.expressions;
          if (expressions.length == 0)
            return null;
          return make_sequence(self, expressions).drop_side_effect_free(compressor, first_in_statement2);
        }
        var tag = self.tag;
        var dropped = drop_returns(compressor, tag);
        if (dropped) {
          self = self.clone();
          self.tag = dropped;
          if (tag._squeezed)
            self.tag._squeezed = true;
        }
        return self;
      });
      def(AST_Unary, function(compressor, first_in_statement2) {
        var exp = this.expression;
        if (unary_side_effects[this.operator]) {
          this.write_only = !exp.has_side_effects(compressor);
          return this;
        }
        if (this.operator == "typeof" && exp instanceof AST_SymbolRef && can_drop_symbol(exp, compressor)) {
          return null;
        }
        var node = exp.drop_side_effect_free(compressor, first_in_statement2);
        if (first_in_statement2 && node && is_iife_call(node)) {
          if (node === exp && this.operator == "!")
            return this;
          return node.negate(compressor, first_in_statement2);
        }
        return node;
      });
    })(function(node, func) {
      node.DEFMETHOD("drop_side_effect_free", func);
    });
    OPT(AST_SimpleStatement, function(self, compressor) {
      if (compressor.option("side_effects")) {
        var body = self.body;
        var node = body.drop_side_effect_free(compressor, true);
        if (!node) {
          AST_Node.warn("Dropping side-effect-free statement [{start}]", self);
          return make_node(AST_EmptyStatement, self);
        }
        if (node !== body) {
          return make_node(AST_SimpleStatement, self, { body: node });
        }
      }
      return self;
    });
    OPT(AST_While, function(self, compressor) {
      return compressor.option("loops") ? make_node(AST_For, self).optimize(compressor) : self;
    });
    function has_loop_control(loop, parent, type) {
      if (!type)
        type = AST_LoopControl;
      var found = false;
      var tw = new TreeWalker(function(node) {
        if (found || node instanceof AST_Scope)
          return true;
        if (node instanceof type && tw.loopcontrol_target(node) === loop) {
          return found = true;
        }
      });
      if (parent instanceof AST_LabeledStatement)
        tw.push(parent);
      tw.push(loop);
      loop.body.walk(tw);
      return found;
    }
    OPT(AST_Do, function(self, compressor) {
      if (!compressor.option("loops"))
        return self;
      var cond = fuzzy_eval(compressor, self.condition);
      if (!(cond instanceof AST_Node)) {
        if (cond && !has_loop_control(self, compressor.parent(), AST_Continue))
          return make_node(AST_For, self, {
            body: make_node(AST_BlockStatement, self.body, {
              body: [
                self.body,
                make_node(AST_SimpleStatement, self.condition, { body: self.condition })
              ]
            })
          }).optimize(compressor);
        if (!has_loop_control(self, compressor.parent()))
          return make_node(AST_BlockStatement, self.body, {
            body: [
              self.body,
              make_node(AST_SimpleStatement, self.condition, { body: self.condition })
            ]
          }).optimize(compressor);
      }
      if (self.body instanceof AST_BlockStatement && !has_loop_control(self, compressor.parent(), AST_Continue)) {
        var body = self.body.body;
        for (var i = body.length;--i >= 0; ) {
          var stat = body[i];
          if (stat instanceof AST_If && !stat.alternative && stat.body instanceof AST_Break && compressor.loopcontrol_target(stat.body) === self) {
            if (has_block_scope_refs(stat.condition))
              break;
            self.condition = make_node(AST_Binary, self, {
              operator: "&&",
              left: stat.condition.negate(compressor),
              right: self.condition
            });
            body.splice(i, 1);
          } else if (stat instanceof AST_SimpleStatement) {
            if (has_block_scope_refs(stat.body))
              break;
            self.condition = make_sequence(self, [
              stat.body,
              self.condition
            ]);
            body.splice(i, 1);
          } else if (!is_declaration(stat, true)) {
            break;
          }
        }
        self.body = trim_block(self.body, compressor.parent());
      }
      if (self.body instanceof AST_EmptyStatement)
        return make_node(AST_For, self).optimize(compressor);
      if (self.body instanceof AST_SimpleStatement)
        return make_node(AST_For, self, {
          condition: make_sequence(self.condition, [
            self.body.body,
            self.condition
          ]),
          body: make_node(AST_EmptyStatement, self)
        }).optimize(compressor);
      return self;
      function has_block_scope_refs(node) {
        var found = false;
        node.walk(new TreeWalker(function(node2) {
          if (found)
            return true;
          if (node2 instanceof AST_SymbolRef) {
            if (!member(node2.definition(), self.enclosed))
              found = true;
            return true;
          }
        }));
        return found;
      }
    });
    function if_break_in_loop(self, compressor) {
      var first = first_statement(self.body);
      if (compressor.option("dead_code") && (first instanceof AST_Break || first instanceof AST_Continue && external_target(first) || first instanceof AST_Exit)) {
        var body = [];
        if (is_statement(self.init)) {
          body.push(self.init);
        } else if (self.init) {
          body.push(make_node(AST_SimpleStatement, self.init, { body: self.init }));
        }
        var retain = external_target(first) || first instanceof AST_Exit;
        if (self.condition && retain) {
          body.push(make_node(AST_If, self, {
            condition: self.condition,
            body: first,
            alternative: null
          }));
        } else if (self.condition) {
          body.push(make_node(AST_SimpleStatement, self.condition, { body: self.condition }));
        } else if (retain) {
          body.push(first);
        }
        extract_declarations_from_unreachable_code(compressor, self.body, body);
        return make_node(AST_BlockStatement, self, { body });
      }
      if (first instanceof AST_If) {
        var ab = first_statement(first.body);
        if (ab instanceof AST_Break && !external_target(ab)) {
          if (self.condition) {
            self.condition = make_node(AST_Binary, self.condition, {
              left: self.condition,
              operator: "&&",
              right: first.condition.negate(compressor)
            });
          } else {
            self.condition = first.condition.negate(compressor);
          }
          var body = as_statement_array(first.alternative);
          extract_declarations_from_unreachable_code(compressor, first.body, body);
          return drop_it(body);
        }
        ab = first_statement(first.alternative);
        if (ab instanceof AST_Break && !external_target(ab)) {
          if (self.condition) {
            self.condition = make_node(AST_Binary, self.condition, {
              left: self.condition,
              operator: "&&",
              right: first.condition
            });
          } else {
            self.condition = first.condition;
          }
          var body = as_statement_array(first.body);
          extract_declarations_from_unreachable_code(compressor, first.alternative, body);
          return drop_it(body);
        }
      }
      return self;
      function first_statement(body2) {
        return body2 instanceof AST_BlockStatement ? body2.body[0] : body2;
      }
      function external_target(node) {
        return compressor.loopcontrol_target(node) !== compressor.self();
      }
      function drop_it(rest) {
        if (self.body instanceof AST_BlockStatement) {
          self.body = self.body.clone();
          self.body.body = rest.concat(self.body.body.slice(1));
          self.body = self.body.transform(compressor);
        } else {
          self.body = make_node(AST_BlockStatement, self.body, { body: rest }).transform(compressor);
        }
        return if_break_in_loop(self, compressor);
      }
    }
    OPT(AST_For, function(self, compressor) {
      if (!compressor.option("loops"))
        return self;
      if (compressor.option("side_effects")) {
        if (self.init)
          self.init = self.init.drop_side_effect_free(compressor);
        if (self.step)
          self.step = self.step.drop_side_effect_free(compressor);
      }
      if (self.condition) {
        var cond = fuzzy_eval(compressor, self.condition);
        if (!cond) {
          if (compressor.option("dead_code")) {
            var body = [];
            if (is_statement(self.init)) {
              body.push(self.init);
            } else if (self.init) {
              body.push(make_node(AST_SimpleStatement, self.init, { body: self.init }));
            }
            body.push(make_node(AST_SimpleStatement, self.condition, { body: self.condition }));
            extract_declarations_from_unreachable_code(compressor, self.body, body);
            return make_node(AST_BlockStatement, self, { body }).optimize(compressor);
          }
        } else if (!(cond instanceof AST_Node)) {
          self.body = make_node(AST_BlockStatement, self.body, {
            body: [
              make_node(AST_SimpleStatement, self.condition, { body: self.condition }),
              self.body
            ]
          });
          self.condition = null;
        }
      }
      return if_break_in_loop(self, compressor);
    });
    OPT(AST_ForEnumeration, function(self, compressor) {
      if (compressor.option("varify") && is_lexical_definition(self.init)) {
        var name = self.init.definitions[0].name;
        if ((name instanceof AST_Destructured || name instanceof AST_SymbolLet) && !name.match_symbol(function(node) {
          if (node instanceof AST_SymbolDeclaration) {
            var def = node.definition();
            return !same_scope(def) || may_overlap(compressor, def);
          }
        }, true)) {
          self.init = to_var(self.init, self.resolve());
        }
      }
      return self;
    });
    function mark_locally_defined(condition, consequent, alternative) {
      if (condition instanceof AST_Sequence)
        condition = condition.tail_node();
      if (!(condition instanceof AST_Binary))
        return;
      if (!(condition.left instanceof AST_String)) {
        switch (condition.operator) {
          case "&&":
            mark_locally_defined(condition.left, consequent);
            mark_locally_defined(condition.right, consequent);
            break;
          case "||":
            mark_locally_defined(negate(condition.left), alternative);
            mark_locally_defined(negate(condition.right), alternative);
            break;
        }
        return;
      }
      if (!(condition.right instanceof AST_UnaryPrefix))
        return;
      if (condition.right.operator != "typeof")
        return;
      var sym = condition.right.expression;
      if (!is_undeclared_ref(sym))
        return;
      var body;
      var undef = condition.left.value == "undefined";
      switch (condition.operator) {
        case "==":
          body = undef ? alternative : consequent;
          break;
        case "!=":
          body = undef ? consequent : alternative;
          break;
        default:
          return;
      }
      if (!body)
        return;
      var abort = false;
      var def = sym.definition();
      var fn;
      var refs = [];
      var scanned = [];
      var tw = new TreeWalker(function(node, descend) {
        if (abort)
          return true;
        if (node instanceof AST_Assign) {
          var ref = node.left;
          if (!(ref instanceof AST_SymbolRef && ref.definition() === def))
            return;
          node.right.walk(tw);
          switch (node.operator) {
            case "=":
            case "&&=":
              abort = true;
          }
          return true;
        }
        if (node instanceof AST_Call) {
          descend();
          fn = node.expression.tail_node();
          var save;
          if (fn instanceof AST_SymbolRef) {
            fn = fn.fixed_value();
            save = refs.length;
          }
          if (!(fn instanceof AST_Lambda)) {
            abort = true;
          } else if (push_uniq(scanned, fn)) {
            fn.walk(tw);
          }
          if (save >= 0)
            refs.length = save;
          return true;
        }
        if (node instanceof AST_DWLoop) {
          var save = refs.length;
          descend();
          if (abort)
            refs.length = save;
          return true;
        }
        if (node instanceof AST_For) {
          if (node.init)
            node.init.walk(tw);
          var save = refs.length;
          if (node.condition)
            node.condition.walk(tw);
          node.body.walk(tw);
          if (node.step)
            node.step.walk(tw);
          if (abort)
            refs.length = save;
          return true;
        }
        if (node instanceof AST_ForEnumeration) {
          node.object.walk(tw);
          var save = refs.length;
          node.init.walk(tw);
          node.body.walk(tw);
          if (abort)
            refs.length = save;
          return true;
        }
        if (node instanceof AST_Scope) {
          if (node === fn)
            return;
          return true;
        }
        if (node instanceof AST_SymbolRef) {
          if (node.definition() === def)
            refs.push(node);
          return true;
        }
      });
      body.walk(tw);
      refs.forEach(function(ref) {
        ref.defined = true;
      });
      function negate(node) {
        if (!(node instanceof AST_Binary))
          return;
        switch (node.operator) {
          case "==":
            node = node.clone();
            node.operator = "!=";
            return node;
          case "!=":
            node = node.clone();
            node.operator = "==";
            return node;
        }
      }
    }
    function fuzzy_eval(compressor, node, nullish) {
      if (node.truthy)
        return true;
      if (is_undefined(node))
        return;
      if (node.falsy && !nullish)
        return false;
      if (node.is_truthy())
        return true;
      return node.evaluate(compressor, true);
    }
    function mark_duplicate_condition(compressor, node) {
      var child;
      var level = 0;
      var negated = false;
      var parent = compressor.self();
      if (!is_statement(parent))
        while (true) {
          child = parent;
          parent = compressor.parent(level++);
          if (parent instanceof AST_Binary) {
            switch (child) {
              case parent.left:
                if (lazy_op[parent.operator])
                  continue;
                break;
              case parent.right:
                if (match(parent.left))
                  switch (parent.operator) {
                    case "&&":
                      node[negated ? "falsy" : "truthy"] = true;
                      break;
                    case "||":
                    case "??":
                      node[negated ? "truthy" : "falsy"] = true;
                      break;
                  }
                break;
            }
          } else if (parent instanceof AST_Conditional) {
            var cond = parent.condition;
            if (cond === child)
              continue;
            if (match(cond))
              switch (child) {
                case parent.consequent:
                  node[negated ? "falsy" : "truthy"] = true;
                  break;
                case parent.alternative:
                  node[negated ? "truthy" : "falsy"] = true;
                  break;
              }
          } else if (parent instanceof AST_Exit) {
            break;
          } else if (parent instanceof AST_If) {
            break;
          } else if (parent instanceof AST_Sequence) {
            if (parent.expressions[0] === child)
              continue;
          } else if (parent instanceof AST_SimpleStatement) {
            break;
          }
          return;
        }
      while (true) {
        child = parent;
        parent = compressor.parent(level++);
        if (parent instanceof AST_BlockStatement) {
          if (parent.body[0] === child)
            continue;
        } else if (parent instanceof AST_If) {
          if (match(parent.condition))
            switch (child) {
              case parent.body:
                node[negated ? "falsy" : "truthy"] = true;
                break;
              case parent.alternative:
                node[negated ? "truthy" : "falsy"] = true;
                break;
            }
        }
        return;
      }
      function match(cond2) {
        if (node.equals(cond2))
          return true;
        if (!(cond2 instanceof AST_UnaryPrefix))
          return false;
        if (cond2.operator != "!")
          return false;
        if (!node.equals(cond2.expression))
          return false;
        negated = true;
        return true;
      }
    }
    OPT(AST_If, function(self, compressor) {
      if (is_empty(self.alternative))
        self.alternative = null;
      if (!compressor.option("conditionals"))
        return self;
      if (compressor.option("booleans") && !self.condition.has_side_effects(compressor)) {
        mark_duplicate_condition(compressor, self.condition);
      }
      if (compressor.option("dead_code")) {
        var cond = fuzzy_eval(compressor, self.condition);
        if (!cond) {
          AST_Node.warn("Condition always false [{start}]", self.condition);
          var body = [
            make_node(AST_SimpleStatement, self.condition, { body: self.condition }).transform(compressor)
          ];
          extract_declarations_from_unreachable_code(compressor, self.body, body);
          if (self.alternative)
            body.push(self.alternative);
          return make_node(AST_BlockStatement, self, { body }).optimize(compressor);
        } else if (!(cond instanceof AST_Node)) {
          AST_Node.warn("Condition always true [{start}]", self.condition);
          var body = [
            make_node(AST_SimpleStatement, self.condition, { body: self.condition }).transform(compressor),
            self.body
          ];
          if (self.alternative)
            extract_declarations_from_unreachable_code(compressor, self.alternative, body);
          return make_node(AST_BlockStatement, self, { body }).optimize(compressor);
        }
      }
      var negated = self.condition.negate(compressor);
      var self_condition_length = self.condition.print_to_string().length;
      var negated_length = negated.print_to_string().length;
      var negated_is_best = negated_length < self_condition_length;
      if (self.alternative && negated_is_best) {
        negated_is_best = false;
        self.condition = negated;
        var tmp = self.body;
        self.body = self.alternative;
        self.alternative = is_empty(tmp) ? null : tmp;
      }
      var body_defuns = [];
      var body_var_defs = [];
      var body_refs = [];
      var body_exprs = sequencesize(self.body, body_defuns, body_var_defs, body_refs);
      var alt_defuns = [];
      var alt_var_defs = [];
      var alt_refs = [];
      var alt_exprs = sequencesize(self.alternative, alt_defuns, alt_var_defs, alt_refs);
      if (body_exprs instanceof AST_BlockStatement || alt_exprs instanceof AST_BlockStatement) {
        var body = [], var_defs = [];
        if (body_exprs) {
          [].push.apply(body, body_defuns);
          [].push.apply(var_defs, body_var_defs);
          if (body_exprs instanceof AST_BlockStatement) {
            self.body = body_exprs;
          } else if (body_exprs.length == 0) {
            self.body = make_node(AST_EmptyStatement, self.body);
          } else {
            self.body = make_node(AST_SimpleStatement, self.body, {
              body: make_sequence(self.body, body_exprs)
            });
          }
          body_refs.forEach(process_to_assign);
        }
        if (alt_exprs) {
          [].push.apply(body, alt_defuns);
          [].push.apply(var_defs, alt_var_defs);
          if (alt_exprs instanceof AST_BlockStatement) {
            self.alternative = alt_exprs;
          } else if (alt_exprs.length == 0) {
            self.alternative = null;
          } else {
            self.alternative = make_node(AST_SimpleStatement, self.alternative, {
              body: make_sequence(self.alternative, alt_exprs)
            });
          }
          alt_refs.forEach(process_to_assign);
        }
        if (var_defs.length > 0)
          body.push(make_node(AST_Var, self, { definitions: var_defs }));
        if (body.length > 0) {
          body.push(self.transform(compressor));
          return make_node(AST_BlockStatement, self, { body }).optimize(compressor);
        }
      } else if (body_exprs && alt_exprs) {
        var body = body_defuns.concat(alt_defuns);
        if (body_var_defs.length > 0 || alt_var_defs.length > 0)
          body.push(make_node(AST_Var, self, {
            definitions: body_var_defs.concat(alt_var_defs)
          }));
        if (body_exprs.length == 0) {
          body.push(make_node(AST_SimpleStatement, self.condition, {
            body: alt_exprs.length > 0 ? make_node(AST_Binary, self, {
              operator: "||",
              left: self.condition,
              right: make_sequence(self.alternative, alt_exprs)
            }).transform(compressor) : self.condition.clone()
          }).optimize(compressor));
        } else if (alt_exprs.length == 0) {
          if (self_condition_length === negated_length && !negated_is_best && self.condition instanceof AST_Binary && self.condition.operator == "||") {
            negated_is_best = true;
          }
          body.push(make_node(AST_SimpleStatement, self, {
            body: make_node(AST_Binary, self, {
              operator: negated_is_best ? "||" : "&&",
              left: negated_is_best ? negated : self.condition,
              right: make_sequence(self.body, body_exprs)
            }).transform(compressor)
          }).optimize(compressor));
        } else {
          body.push(make_node(AST_SimpleStatement, self, {
            body: make_node(AST_Conditional, self, {
              condition: self.condition,
              consequent: make_sequence(self.body, body_exprs),
              alternative: make_sequence(self.alternative, alt_exprs)
            })
          }).optimize(compressor));
        }
        body_refs.forEach(process_to_assign);
        alt_refs.forEach(process_to_assign);
        return make_node(AST_BlockStatement, self, { body }).optimize(compressor);
      }
      if (is_empty(self.body))
        self = make_node(AST_If, self, {
          condition: negated,
          body: self.alternative,
          alternative: null
        });
      if (self.alternative instanceof AST_Exit && self.body.TYPE == self.alternative.TYPE) {
        var cons_value = self.body.value;
        var alt_value = self.alternative.value;
        if (!cons_value && !alt_value)
          return make_node(AST_BlockStatement, self, {
            body: [
              make_node(AST_SimpleStatement, self, { body: self.condition }),
              self.body
            ]
          }).optimize(compressor);
        if (cons_value && alt_value || !keep_return_void()) {
          var exit = make_node(self.body.CTOR, self, {
            value: make_node(AST_Conditional, self, {
              condition: self.condition,
              consequent: cons_value || make_node(AST_Undefined, self.body).transform(compressor),
              alternative: alt_value || make_node(AST_Undefined, self.alternative).transform(compressor)
            })
          });
          if (exit instanceof AST_Return)
            exit.in_bool = self.body.in_bool || self.alternative.in_bool;
          return exit;
        }
      }
      if (self.body instanceof AST_If && !self.body.alternative && !self.alternative) {
        self = make_node(AST_If, self, {
          condition: make_node(AST_Binary, self.condition, {
            operator: "&&",
            left: self.condition,
            right: self.body.condition
          }),
          body: self.body.body,
          alternative: null
        });
      }
      if (aborts(self.body) && self.alternative) {
        var alt = self.alternative;
        self.alternative = null;
        return make_node(AST_BlockStatement, self, { body: [self, alt] }).optimize(compressor);
      }
      if (aborts(self.alternative)) {
        var body = self.body;
        self.body = self.alternative;
        self.condition = negated_is_best ? negated : self.condition.negate(compressor);
        self.alternative = null;
        return make_node(AST_BlockStatement, self, { body: [self, body] }).optimize(compressor);
      }
      if (self.alternative) {
        var body_stats = as_array(self.body);
        var body_index = last_index(body_stats);
        var alt_stats = as_array(self.alternative);
        var alt_index = last_index(alt_stats);
        for (var stats = [];body_index >= 0 && alt_index >= 0; ) {
          var stat = body_stats[body_index];
          var alt_stat = alt_stats[alt_index];
          if (stat.equals(alt_stat)) {
            body_stats.splice(body_index--, 1);
            alt_stats.splice(alt_index--, 1);
            stats.unshift(merge_expression(stat, alt_stat));
          } else {
            if (!(stat instanceof AST_SimpleStatement))
              break;
            if (!(alt_stat instanceof AST_SimpleStatement))
              break;
            var expr1 = stat.body.tail_node();
            var expr2 = alt_stat.body.tail_node();
            if (!expr1.equals(expr2))
              break;
            body_index = pop_expr(body_stats, stat.body, body_index);
            alt_index = pop_expr(alt_stats, alt_stat.body, alt_index);
            stats.unshift(make_node(AST_SimpleStatement, expr1, { body: merge_expression(expr1, expr2) }));
          }
        }
        if (stats.length > 0) {
          self.body = body_stats.length > 0 ? make_node(AST_BlockStatement, self, {
            body: body_stats
          }) : make_node(AST_EmptyStatement, self);
          self.alternative = alt_stats.length > 0 ? make_node(AST_BlockStatement, self, {
            body: alt_stats
          }) : null;
          stats.unshift(self);
          return make_node(AST_BlockStatement, self, { body: stats }).optimize(compressor);
        }
      }
      if (compressor.option("typeofs"))
        mark_locally_defined(self.condition, self.body, self.alternative);
      return self;
      function as_array(node) {
        return node instanceof AST_BlockStatement ? node.body : [node];
      }
      function keep_return_void() {
        var has_finally = false, level = 0, node = compressor.self();
        do {
          if (node instanceof AST_Catch) {
            if (compressor.parent(level).bfinally)
              has_finally = true;
            level++;
          } else if (node instanceof AST_Finally) {
            level++;
          } else if (node instanceof AST_Scope) {
            return has_finally && in_async_generator(node);
          } else if (node instanceof AST_Try) {
            if (node.bfinally)
              has_finally = true;
          }
        } while (node = compressor.parent(level++));
      }
      function last_index(stats2) {
        for (var index = stats2.length;--index >= 0; ) {
          if (!is_declaration(stats2[index], true))
            break;
        }
        return index;
      }
      function pop_expr(stats2, body2, index) {
        if (body2 instanceof AST_Sequence) {
          stats2[index] = make_node(AST_SimpleStatement, body2, {
            body: make_sequence(body2, body2.expressions.slice(0, -1))
          });
        } else {
          stats2.splice(index--, 1);
        }
        return index;
      }
      function sequencesize(stat2, defuns, var_defs2, refs) {
        if (stat2 == null)
          return [];
        if (stat2 instanceof AST_BlockStatement) {
          var exprs = [];
          for (var i = 0;i < stat2.body.length; i++) {
            var line = stat2.body[i];
            if (line instanceof AST_EmptyStatement)
              continue;
            if (line instanceof AST_Exit) {
              if (i == 0)
                return;
              if (exprs.length > 0) {
                line = line.clone();
                exprs.push(line.value || make_node(AST_Undefined, line).transform(compressor));
                line.value = make_sequence(stat2, exprs);
              }
              var block = stat2.clone();
              block.body = block.body.slice(i + 1);
              block.body.unshift(line);
              return block;
            }
            if (line instanceof AST_LambdaDefinition) {
              defuns.push(line);
            } else if (line instanceof AST_SimpleStatement) {
              if (!compressor.option("sequences") && exprs.length > 0)
                return;
              exprs.push(line.body);
            } else if (line instanceof AST_Var) {
              if (!compressor.option("sequences") && exprs.length > 0)
                return;
              line.remove_initializers(compressor, var_defs2);
              line.definitions.forEach(process_var_def);
            } else {
              return;
            }
          }
          return exprs;
        }
        if (stat2 instanceof AST_LambdaDefinition) {
          defuns.push(stat2);
          return [];
        }
        if (stat2 instanceof AST_EmptyStatement)
          return [];
        if (stat2 instanceof AST_SimpleStatement)
          return [stat2.body];
        if (stat2 instanceof AST_Var) {
          var exprs = [];
          stat2.remove_initializers(compressor, var_defs2);
          stat2.definitions.forEach(process_var_def);
          return exprs;
        }
        function process_var_def(var_def) {
          if (!var_def.value)
            return;
          exprs.push(make_node(AST_Assign, var_def, {
            operator: "=",
            left: var_def.name.convert_symbol(AST_SymbolRef, function(ref) {
              refs.push(ref);
            }),
            right: var_def.value
          }));
        }
      }
    });
    OPT(AST_Switch, function(self, compressor) {
      if (!compressor.option("switches"))
        return self;
      if (!compressor.option("dead_code"))
        return self;
      var body = [];
      var branch;
      var decl = [];
      var default_branch;
      var exact_match;
      var side_effects = [];
      for (var i = 0, len = self.body.length;i < len; i++) {
        branch = self.body[i];
        if (branch instanceof AST_Default) {
          var prev = body[body.length - 1];
          if (default_branch || is_break(branch.body[0], compressor) && (!prev || aborts(prev))) {
            eliminate_branch(branch, prev);
            continue;
          } else {
            default_branch = branch;
          }
        } else {
          var exp = branch.expression;
          var equals = make_node(AST_Binary, self, {
            operator: "===",
            left: self.expression,
            right: exp
          }).evaluate(compressor, true);
          if (!equals) {
            if (exp.has_side_effects(compressor))
              side_effects.push(exp);
            eliminate_branch(branch, body[body.length - 1]);
            continue;
          }
          if (!(equals instanceof AST_Node)) {
            if (default_branch) {
              var default_index = body.indexOf(default_branch);
              body.splice(default_index, 1);
              eliminate_branch(default_branch, body[default_index - 1]);
              default_branch = null;
            }
            if (exp.has_side_effects(compressor)) {
              exact_match = branch;
            } else {
              default_branch = branch = make_node(AST_Default, branch);
            }
            while (++i < len)
              eliminate_branch(self.body[i], branch);
          }
        }
        if (i + 1 >= len || aborts(branch)) {
          var prev = body[body.length - 1];
          var statements = branch.body;
          if (aborts(prev))
            switch (prev.body.length - statements.length) {
              case 1:
                var stat = prev.body[prev.body.length - 1];
                if (!is_break(stat, compressor))
                  break;
                statements = statements.concat(stat);
              case 0:
                var prev_block = make_node(AST_BlockStatement, prev);
                var next_block = make_node(AST_BlockStatement, branch, { body: statements });
                if (prev_block.equals(next_block))
                  prev.body = [];
            }
        }
        if (side_effects.length) {
          if (branch instanceof AST_Default) {
            body.push(make_node(AST_Case, self, { expression: make_sequence(self, side_effects), body: [] }));
          } else {
            side_effects.push(branch.expression);
            branch.expression = make_sequence(self, side_effects);
          }
          side_effects = [];
        }
        body.push(branch);
      }
      if (side_effects.length && !exact_match) {
        body.push(make_node(AST_Case, self, { expression: make_sequence(self, side_effects), body: [] }));
      }
      while (branch = body[body.length - 1]) {
        var stat = branch.body[branch.body.length - 1];
        if (is_break(stat, compressor))
          branch.body.pop();
        if (branch === default_branch) {
          if (!has_declarations_only(branch))
            break;
        } else if (branch.expression.has_side_effects(compressor)) {
          break;
        } else if (default_branch) {
          if (!has_declarations_only(default_branch))
            break;
          if (body[body.length - 2] !== default_branch)
            break;
          default_branch.body = default_branch.body.concat(branch.body);
          branch.body = [];
        } else if (!has_declarations_only(branch))
          break;
        eliminate_branch(branch);
        if (body.pop() === default_branch)
          default_branch = null;
      }
      if (!branch) {
        decl.push(make_node(AST_SimpleStatement, self.expression, { body: self.expression }));
        if (side_effects.length)
          decl.push(make_node(AST_SimpleStatement, self, {
            body: make_sequence(self, side_effects)
          }));
        return make_node(AST_BlockStatement, self, { body: decl }).optimize(compressor);
      }
      if (branch === default_branch)
        while (branch = body[body.length - 2]) {
          if (branch instanceof AST_Default)
            break;
          if (!has_declarations_only(branch))
            break;
          var exp = branch.expression;
          if (exp.has_side_effects(compressor)) {
            var prev = body[body.length - 3];
            if (prev && !aborts(prev))
              break;
            default_branch.body.unshift(make_node(AST_SimpleStatement, self, { body: exp }));
          }
          eliminate_branch(branch);
          body.splice(-2, 1);
        }
      body[0].body = decl.concat(body[0].body);
      self.body = body;
      if (compressor.option("conditionals"))
        switch (body.length) {
          case 1:
            if (!no_break(body[0]))
              break;
            var exp = body[0].expression;
            var statements = body[0].body.slice();
            if (body[0] !== default_branch && body[0] !== exact_match)
              return make_node(AST_If, self, {
                condition: make_node(AST_Binary, self, {
                  operator: "===",
                  left: self.expression,
                  right: exp
                }),
                body: make_node(AST_BlockStatement, self, { body: statements }),
                alternative: null
              }).optimize(compressor);
            if (exp)
              statements.unshift(make_node(AST_SimpleStatement, exp, { body: exp }));
            statements.unshift(make_node(AST_SimpleStatement, self.expression, { body: self.expression }));
            return make_node(AST_BlockStatement, self, { body: statements }).optimize(compressor);
          case 2:
            if (!member(default_branch, body) || !no_break(body[1]))
              break;
            var statements = body[0].body.slice();
            var exclusive = statements.length && is_break(statements[statements.length - 1], compressor);
            if (exclusive)
              statements.pop();
            if (!all(statements, no_break))
              break;
            var alternative = body[1].body.length && make_node(AST_BlockStatement, body[1]);
            var node = make_node(AST_If, self, {
              condition: make_node(AST_Binary, self, body[0] === default_branch ? {
                operator: "!==",
                left: self.expression,
                right: body[1].expression
              } : {
                operator: "===",
                left: self.expression,
                right: body[0].expression
              }),
              body: make_node(AST_BlockStatement, body[0], { body: statements }),
              alternative: exclusive && alternative || null
            });
            if (!exclusive && alternative)
              node = make_node(AST_BlockStatement, self, { body: [node, alternative] });
            return node.optimize(compressor);
        }
      return self;
      function is_break(node2, tw) {
        return node2 instanceof AST_Break && tw.loopcontrol_target(node2) === self;
      }
      function no_break(node2) {
        var found = false;
        var tw = new TreeWalker(function(node3) {
          if (found || node3 instanceof AST_Lambda || node3 instanceof AST_SimpleStatement)
            return true;
          if (is_break(node3, tw))
            found = true;
        });
        tw.push(self);
        node2.walk(tw);
        return !found;
      }
      function eliminate_branch(branch2, prev2) {
        if (prev2 && !aborts(prev2)) {
          prev2.body = prev2.body.concat(branch2.body);
        } else {
          extract_declarations_from_unreachable_code(compressor, branch2, decl);
        }
      }
    });
    OPT(AST_Try, function(self, compressor) {
      self.body = tighten_body(self.body, compressor);
      if (compressor.option("dead_code")) {
        if (has_declarations_only(self) && !(self.bcatch && self.bcatch.argname && self.bcatch.argname.match_symbol(function(node) {
          return node instanceof AST_SymbolCatch && !can_drop_symbol(node);
        }, true))) {
          var body = [];
          if (self.bcatch) {
            extract_declarations_from_unreachable_code(compressor, self.bcatch, body);
            body.forEach(function(stat) {
              if (!(stat instanceof AST_Var))
                return;
              stat.definitions.forEach(function(var_def) {
                var def = var_def.name.definition().redefined();
                if (!def)
                  return;
                var_def.name = var_def.name.clone();
                var_def.name.thedef = def;
              });
            });
          }
          body.unshift(make_node(AST_BlockStatement, self).optimize(compressor));
          if (self.bfinally) {
            body.push(make_node(AST_BlockStatement, self.bfinally).optimize(compressor));
          }
          return make_node(AST_BlockStatement, self, { body }).optimize(compressor);
        }
        if (self.bfinally && has_declarations_only(self.bfinally)) {
          var body = make_node(AST_BlockStatement, self.bfinally).optimize(compressor);
          body = self.body.concat(body);
          if (!self.bcatch)
            return make_node(AST_BlockStatement, self, { body }).optimize(compressor);
          self.body = body;
          self.bfinally = null;
        }
      }
      return self;
    });
    function remove_initializers(make_value) {
      return function(compressor, defns) {
        var dropped = false;
        this.definitions.forEach(function(defn) {
          if (defn.value)
            dropped = true;
          defn.name.match_symbol(function(node) {
            if (node instanceof AST_SymbolDeclaration)
              defns.push(make_node(AST_VarDef, node, {
                name: node,
                value: make_value(compressor, node)
              }));
          }, true);
        });
        return dropped;
      };
    }
    AST_Const.DEFMETHOD("remove_initializers", remove_initializers(function(compressor, node) {
      return make_node(AST_Undefined, node).optimize(compressor);
    }));
    AST_Let.DEFMETHOD("remove_initializers", remove_initializers(return_null));
    AST_Var.DEFMETHOD("remove_initializers", remove_initializers(return_null));
    AST_Definitions.DEFMETHOD("to_assignments", function() {
      var assignments = this.definitions.reduce(function(a, defn) {
        var def = defn.name.definition();
        var value = defn.value;
        if (value) {
          if (value instanceof AST_Sequence)
            value = value.clone();
          var name = make_node(AST_SymbolRef, defn.name);
          var assign = make_node(AST_Assign, defn, {
            operator: "=",
            left: name,
            right: value
          });
          a.push(assign);
          var fixed = function() {
            return assign.right;
          };
          fixed.assigns = [assign];
          fixed.direct_access = def.direct_access;
          fixed.escaped = def.escaped;
          name.fixed = fixed;
          def.references.forEach(function(ref) {
            if (!ref.fixed)
              return;
            var assigns = ref.fixed.assigns;
            if (!assigns)
              return;
            if (assigns[0] !== defn)
              return;
            if (assigns.length > 1 || ref.fixed.to_binary || ref.fixed.to_prefix) {
              assigns[0] = assign;
            } else {
              ref.fixed = fixed;
              if (def.fixed === ref.fixed)
                def.fixed = fixed;
            }
          });
          def.references.push(name);
        }
        def.assignments++;
        def.eliminated++;
        def.single_use = false;
        return a;
      }, []);
      if (assignments.length == 0)
        return null;
      return make_sequence(this, assignments);
    });
    function is_safe_lexical(def) {
      return def.name != "arguments" && def.orig.length < (def.orig[0] instanceof AST_SymbolLambda ? 3 : 2);
    }
    function may_overlap(compressor, def) {
      if (compressor.exposed(def))
        return true;
      var scope = def.scope.resolve();
      for (var s = def.scope;s !== scope; ) {
        s = s.parent_scope;
        if (s.var_names().has(def.name))
          return true;
      }
    }
    function to_var(stat, scope) {
      return make_node(AST_Var, stat, {
        definitions: stat.definitions.map(function(defn) {
          return make_node(AST_VarDef, defn, {
            name: defn.name.convert_symbol(AST_SymbolVar, function(name, node) {
              var def = name.definition();
              def.orig[def.orig.indexOf(node)] = name;
              if (def.scope === scope)
                return;
              def.scope = scope;
              scope.variables.set(def.name, def);
              scope.enclosed.push(def);
              scope.var_names().set(def.name, true);
            }),
            value: defn.value
          });
        })
      });
    }
    function can_varify(compressor, sym) {
      var def = sym.definition();
      return (def.fixed || def.fixed === 0) && is_safe_lexical(def) && same_scope(def) && !may_overlap(compressor, def);
    }
    function varify(self, compressor) {
      return compressor.option("varify") && all(self.definitions, function(defn) {
        return !defn.name.match_symbol(function(node) {
          if (node instanceof AST_SymbolDeclaration)
            return !can_varify(compressor, node);
        }, true);
      }) ? to_var(self, compressor.find_parent(AST_Scope)) : self;
    }
    OPT(AST_Const, varify);
    OPT(AST_Let, varify);
    function trim_optional_chain(node, compressor) {
      if (!compressor.option("optional_chains"))
        return;
      if (node.terminal)
        do {
          var expr = node.expression;
          if (node.optional) {
            var ev = fuzzy_eval(compressor, expr, true);
            if (ev == null)
              return make_node(AST_UnaryPrefix, node, {
                operator: "void",
                expression: expr
              }).optimize(compressor);
            if (!(ev instanceof AST_Node))
              node.optional = false;
          }
          node = expr;
        } while ((node.TYPE == "Call" || node instanceof AST_PropAccess) && !node.terminal);
    }
    function lift_sequence_in_expression(node, compressor) {
      var exp = node.expression;
      if (!(exp instanceof AST_Sequence))
        return node;
      var x = exp.expressions.slice();
      var e = node.clone();
      e.expression = x.pop();
      x.push(e);
      return make_sequence(node, x);
    }
    function drop_unused_call_args(call, compressor, fns_with_marked_args) {
      var exp = call.expression;
      var fn = exp instanceof AST_SymbolRef ? exp.fixed_value() : exp;
      if (!(fn instanceof AST_Lambda))
        return;
      if (fn.uses_arguments)
        return;
      if (fn.pinned())
        return;
      if (fns_with_marked_args && fns_with_marked_args.indexOf(fn) < 0)
        return;
      var args = call.args;
      if (!all(args, function(arg2) {
        return !(arg2 instanceof AST_Spread);
      }))
        return;
      var argnames = fn.argnames;
      var is_iife = fn === exp && !fn.name;
      if (fn.rest) {
        if (!(is_iife && compressor.option("rests")))
          return;
        var insert = argnames.length;
        args = args.slice(0, insert);
        while (args.length < insert)
          args.push(make_node(AST_Undefined, call).optimize(compressor));
        args.push(make_node(AST_Array, call, { elements: call.args.slice(insert) }));
        argnames = argnames.concat(fn.rest);
        fn.rest = null;
      } else {
        args = args.slice();
        argnames = argnames.slice();
      }
      var pos = 0, last = 0;
      var drop_defaults = is_iife && compressor.option("default_values");
      var drop_fargs = is_iife && compressor.drop_fargs(fn, call) ? function(argname2, arg2) {
        if (!argname2)
          return true;
        if (argname2 instanceof AST_DestructuredArray) {
          return argname2.elements.length == 0 && !argname2.rest && arg2 instanceof AST_Array;
        }
        if (argname2 instanceof AST_DestructuredObject) {
          return argname2.properties.length == 0 && !argname2.rest && arg2 && !arg2.may_throw_on_access(compressor);
        }
        return argname2.unused;
      } : return_false;
      var side_effects = [];
      for (var i = 0;i < args.length; i++) {
        var argname = argnames[i];
        if (drop_defaults && argname instanceof AST_DefaultValue && args[i].is_defined(compressor)) {
          argnames[i] = argname = argname.name;
        }
        if (!argname || argname.unused !== undefined) {
          var node = args[i].drop_side_effect_free(compressor);
          if (drop_fargs(argname)) {
            if (argname)
              argnames.splice(i, 1);
            args.splice(i, 1);
            if (node)
              side_effects.push(node);
            i--;
            continue;
          } else if (node) {
            side_effects.push(node);
            args[pos++] = make_sequence(call, side_effects);
            side_effects = [];
          } else if (argname) {
            if (side_effects.length) {
              args[pos++] = make_sequence(call, side_effects);
              side_effects = [];
            } else {
              args[pos++] = make_node(AST_Number, args[i], { value: 0 });
              continue;
            }
          }
        } else if (drop_fargs(argname, args[i])) {
          var node = args[i].drop_side_effect_free(compressor);
          argnames.splice(i, 1);
          args.splice(i, 1);
          if (node)
            side_effects.push(node);
          i--;
          continue;
        } else {
          side_effects.push(args[i]);
          args[pos++] = make_sequence(call, side_effects);
          side_effects = [];
        }
        last = pos;
      }
      for (;i < argnames.length; i++) {
        if (drop_fargs(argnames[i]))
          argnames.splice(i--, 1);
      }
      fn.argnames = argnames;
      args.length = last;
      call.args = args;
      if (!side_effects.length)
        return;
      var arg = make_sequence(call, side_effects);
      args.push(args.length < argnames.length ? make_node(AST_UnaryPrefix, call, {
        operator: "void",
        expression: arg
      }) : arg);
    }
    function avoid_await_yield(compressor, parent_scope) {
      if (!parent_scope)
        parent_scope = compressor.find_parent(AST_Scope);
      var avoid = [];
      if (is_async(parent_scope) || parent_scope instanceof AST_Toplevel && compressor.option("module")) {
        avoid.push("await");
      }
      if (is_generator(parent_scope))
        avoid.push("yield");
      return avoid.length && makePredicate(avoid);
    }
    function safe_from_await_yield(fn, avoid) {
      if (!avoid)
        return true;
      var safe = true;
      var tw = new TreeWalker(function(node) {
        if (!safe)
          return true;
        if (node instanceof AST_Scope) {
          if (node === fn)
            return;
          if (is_arrow(node)) {
            for (var i = 0;safe && i < node.argnames.length; i++)
              node.argnames[i].walk(tw);
          } else if (node instanceof AST_LambdaDefinition && avoid[node.name.name]) {
            safe = false;
          }
          return true;
        }
        if (node instanceof AST_Symbol && avoid[node.name] && node !== fn.name)
          safe = false;
      });
      fn.walk(tw);
      return safe;
    }
    function safe_from_strict_mode(fn, compressor) {
      return fn.in_strict_mode(compressor) || !compressor.has_directive("use strict");
    }
    OPT(AST_Call, function(self, compressor) {
      var exp = self.expression;
      var terminated = trim_optional_chain(self, compressor);
      if (terminated)
        return terminated;
      if (compressor.option("sequences")) {
        if (exp instanceof AST_PropAccess) {
          var seq = lift_sequence_in_expression(exp, compressor);
          if (seq !== exp) {
            var call = self.clone();
            call.expression = seq.expressions.pop();
            seq.expressions.push(call);
            return seq.optimize(compressor);
          }
        } else if (!needs_unbinding(exp.tail_node())) {
          var seq = lift_sequence_in_expression(self, compressor);
          if (seq !== self)
            return seq.optimize(compressor);
        }
      }
      if (compressor.option("unused"))
        drop_unused_call_args(self, compressor);
      if (compressor.option("unsafe")) {
        if (is_undeclared_ref(exp))
          switch (exp.name) {
            case "Array":
              if (self.args.length == 1) {
                var first = self.args[0];
                if (first instanceof AST_Number)
                  try {
                    var length = first.value;
                    if (length > 6)
                      break;
                    var elements = Array(length);
                    for (var i = 0;i < length; i++)
                      elements[i] = make_node(AST_Hole, self);
                    return make_node(AST_Array, self, { elements });
                  } catch (ex) {
                    AST_Node.warn("Invalid array length: {length} [{start}]", {
                      length,
                      start: self.start
                    });
                    break;
                  }
                if (!first.is_boolean(compressor) && !first.is_string(compressor))
                  break;
              }
              return make_node(AST_Array, self, { elements: self.args });
            case "Object":
              if (self.args.length == 0)
                return make_node(AST_Object, self, { properties: [] });
              break;
            case "String":
              if (self.args.length == 0)
                return make_node(AST_String, self, { value: "" });
              if (self.args.length == 1)
                return make_node(AST_Binary, self, {
                  operator: "+",
                  left: make_node(AST_String, self, { value: "" }),
                  right: self.args[0]
                }).optimize(compressor);
              break;
            case "Number":
              if (self.args.length == 0)
                return make_node(AST_Number, self, { value: 0 });
              if (self.args.length == 1)
                return make_node(AST_UnaryPrefix, self, {
                  operator: "+",
                  expression: make_node(AST_Binary, self, {
                    operator: "+",
                    left: make_node(AST_String, self, { value: "" }),
                    right: self.args[0]
                  })
                }).optimize(compressor);
              break;
            case "Boolean":
              if (self.args.length == 0)
                return make_node(AST_False, self).optimize(compressor);
              if (self.args.length == 1)
                return make_node(AST_UnaryPrefix, self, {
                  operator: "!",
                  expression: make_node(AST_UnaryPrefix, self, {
                    operator: "!",
                    expression: self.args[0]
                  })
                }).optimize(compressor);
              break;
            case "RegExp":
              var params = [];
              if (all(self.args, function(arg) {
                var value2 = arg.evaluate(compressor);
                params.unshift(value2);
                return arg !== value2;
              }))
                try {
                  return best_of(compressor, self, make_node(AST_RegExp, self, {
                    value: RegExp.apply(RegExp, params)
                  }));
                } catch (ex) {
                  AST_Node.warn("Error converting {this} [{start}]", self);
                }
              break;
          }
        else if (exp instanceof AST_Dot)
          switch (exp.property) {
            case "toString":
              var expr = exp.expression;
              if (self.args.length == 0 && !(expr.may_throw_on_access(compressor) || expr instanceof AST_Super)) {
                return make_node(AST_Binary, self, {
                  operator: "+",
                  left: make_node(AST_String, self, { value: "" }),
                  right: expr
                }).optimize(compressor);
              }
              break;
            case "join":
              if (exp.expression instanceof AST_Array && self.args.length < 2)
                EXIT: {
                  var separator = self.args[0];
                  if (exp.expression.elements.length == 0 && !(separator instanceof AST_Spread)) {
                    return separator ? make_sequence(self, [
                      separator,
                      make_node(AST_String, self, { value: "" })
                    ]).optimize(compressor) : make_node(AST_String, self, { value: "" });
                  }
                  if (separator) {
                    separator = separator.evaluate(compressor);
                    if (separator instanceof AST_Node)
                      break EXIT;
                  }
                  var elements = [];
                  var consts = [];
                  for (var i = 0;i < exp.expression.elements.length; i++) {
                    var el = exp.expression.elements[i];
                    var value = el.evaluate(compressor);
                    if (value !== el) {
                      consts.push(value);
                    } else if (el instanceof AST_Spread) {
                      break EXIT;
                    } else {
                      if (consts.length > 0) {
                        elements.push(make_node(AST_String, self, { value: consts.join(separator) }));
                        consts.length = 0;
                      }
                      elements.push(el);
                    }
                  }
                  if (consts.length > 0)
                    elements.push(make_node(AST_String, self, {
                      value: consts.join(separator)
                    }));
                  if (elements.length == 1) {
                    if (elements[0].is_string(compressor))
                      return elements[0];
                    return make_node(AST_Binary, elements[0], {
                      operator: "+",
                      left: make_node(AST_String, self, { value: "" }),
                      right: elements[0]
                    });
                  }
                  if (separator == "") {
                    var first;
                    if (elements[0].is_string(compressor) || elements[1].is_string(compressor)) {
                      first = elements.shift();
                    } else {
                      first = make_node(AST_String, self, { value: "" });
                    }
                    return elements.reduce(function(prev, el2) {
                      return make_node(AST_Binary, el2, {
                        operator: "+",
                        left: prev,
                        right: el2
                      });
                    }, first).optimize(compressor);
                  }
                  var node = self.clone();
                  node.expression = node.expression.clone();
                  node.expression.expression = node.expression.expression.clone();
                  node.expression.expression.elements = elements;
                  return best_of(compressor, self, node);
                }
              break;
            case "charAt":
              if (self.args.length < 2) {
                var node = make_node(AST_Binary, self, {
                  operator: "||",
                  left: make_node(AST_Sub, self, {
                    expression: exp.expression,
                    property: self.args.length ? make_node(AST_Binary, self.args[0], {
                      operator: "|",
                      left: make_node(AST_Number, self, { value: 0 }),
                      right: self.args[0]
                    }) : make_node(AST_Number, self, { value: 0 })
                  }).optimize(compressor),
                  right: make_node(AST_String, self, { value: "" })
                });
                node.is_string = return_true;
                return node.optimize(compressor);
              }
              break;
            case "apply":
              if (self.args.length == 2 && self.args[1] instanceof AST_Array) {
                var args = self.args[1].elements.slice();
                args.unshift(self.args[0]);
                return make_node(AST_Call, self, {
                  expression: make_node(AST_Dot, exp, {
                    expression: exp.expression,
                    property: "call"
                  }),
                  args
                }).optimize(compressor);
              }
              break;
            case "call":
              var func = exp.expression;
              if (func instanceof AST_SymbolRef) {
                func = func.fixed_value();
              }
              if (func instanceof AST_Lambda && !func.contains_this()) {
                return (self.args.length ? make_sequence(self, [
                  self.args[0],
                  make_node(AST_Call, self, {
                    expression: exp.expression,
                    args: self.args.slice(1)
                  })
                ]) : make_node(AST_Call, self, {
                  expression: exp.expression,
                  args: []
                })).optimize(compressor);
              }
              break;
          }
        else if (compressor.option("side_effects") && exp instanceof AST_Call && exp.args.length == 1 && is_undeclared_ref(exp.expression) && exp.expression.name == "Object") {
          var call = self.clone();
          call.expression = maintain_this_binding(self, exp, exp.args[0]);
          return call.optimize(compressor);
        }
      }
      if (compressor.option("unsafe_Function") && is_undeclared_ref(exp) && exp.name == "Function") {
        if (self.args.length == 0)
          return make_node(AST_Function, self, {
            argnames: [],
            body: []
          }).init_vars(exp.scope);
        if (all(self.args, function(x) {
          return x instanceof AST_String;
        })) {
          try {
            var code = "n(function(" + self.args.slice(0, -1).map(function(arg) {
              return arg.value;
            }).join() + "){" + self.args[self.args.length - 1].value + "})";
            var ast = parse(code);
            var mangle = { ie: compressor.option("ie") };
            ast.figure_out_scope(mangle);
            var comp = new Compressor2(compressor.options);
            ast = ast.transform(comp);
            ast.figure_out_scope(mangle);
            ast.compute_char_frequency(mangle);
            ast.mangle_names(mangle);
            var fun;
            ast.walk(new TreeWalker(function(node2) {
              if (fun)
                return true;
              if (node2 instanceof AST_Lambda) {
                fun = node2;
                return true;
              }
            }));
            var code = OutputStream();
            AST_BlockStatement.prototype._codegen.call(fun, code);
            self.args = [
              make_node(AST_String, self, {
                value: fun.argnames.map(function(arg) {
                  return arg.print_to_string();
                }).join()
              }),
              make_node(AST_String, self.args[self.args.length - 1], {
                value: code.get().replace(/^\{|\}$/g, "")
              })
            ];
            return self;
          } catch (ex) {
            if (ex instanceof JS_Parse_Error) {
              AST_Node.warn("Error parsing code passed to new Function [{start}]", self.args[self.args.length - 1]);
              AST_Node.warn(ex.toString());
            } else {
              throw ex;
            }
          }
        }
      }
      var fn = exp instanceof AST_SymbolRef ? exp.fixed_value() : exp;
      var parent = compressor.parent(), current = compressor.self();
      var is_func = fn instanceof AST_Lambda && (!is_async(fn) || compressor.option("awaits") && parent instanceof AST_Await) && (!is_generator(fn) || compressor.option("yields") && current instanceof AST_Yield && current.nested);
      var stat = is_func && fn.first_statement();
      var has_default = 0, has_destructured = false;
      var has_spread = !all(self.args, function(arg) {
        return !(arg instanceof AST_Spread);
      });
      var can_drop = is_func && all(fn.argnames, function(argname, index) {
        if (has_default == 1 && self.args[index] instanceof AST_Spread)
          has_default = 2;
        if (argname instanceof AST_DefaultValue) {
          if (!has_default)
            has_default = 1;
          var arg = has_default == 1 && self.args[index];
          if (!is_undefined(arg))
            has_default = 2;
          if (has_arg_refs(fn, argname.value))
            return false;
          argname = argname.name;
        }
        if (argname instanceof AST_Destructured) {
          has_destructured = true;
          if (has_arg_refs(fn, argname))
            return false;
        }
        return true;
      }) && !(fn.rest instanceof AST_Destructured && has_arg_refs(fn, fn.rest));
      var can_inline = can_drop && compressor.option("inline") && !self.is_expr_pure(compressor) && (exp === fn || safe_from_strict_mode(fn, compressor));
      if (can_inline && stat instanceof AST_Return) {
        var value = stat.value;
        if (exp === fn && !fn.name && (!value || value.is_constant_expression()) && safe_from_await_yield(fn, avoid_await_yield(compressor))) {
          return make_sequence(self, convert_args(value)).optimize(compressor);
        }
      }
      if (is_func && !fn.contains_this()) {
        var def, value, var_assigned = false;
        if (can_inline && !fn.uses_arguments && !fn.pinned() && !(fn.name && fn instanceof AST_LambdaExpression) && (exp === fn || !recursive_ref(compressor, def = exp.definition(), fn) && fn.is_constant_expression(find_scope(compressor))) && (value = can_flatten_body(stat))) {
          var replacing = exp === fn || def.single_use && def.references.length - def.replaced == 1;
          if (can_substitute_directly()) {
            var args = self.args.slice();
            var refs = [];
            var retValue = value.clone(true).transform(new TreeTransformer(function(node2) {
              if (node2 instanceof AST_SymbolRef) {
                var def2 = node2.definition();
                if (fn.variables.get(node2.name) !== def2) {
                  refs.push(node2);
                  return node2;
                }
                var index = resolve_index(def2);
                var arg = args[index];
                if (!arg)
                  return make_node(AST_Undefined, self);
                args[index] = null;
                var parent2 = this.parent();
                return parent2 ? maintain_this_binding(parent2, node2, arg) : arg;
              }
            }));
            var save_inlined = fn.inlined;
            if (exp !== fn)
              fn.inlined = true;
            var exprs = [];
            args.forEach(function(arg) {
              if (!arg)
                return;
              arg = arg.clone(true);
              arg.walk(new TreeWalker(function(node2) {
                if (node2 instanceof AST_SymbolRef)
                  refs.push(node2);
              }));
              exprs.push(arg);
            }, []);
            exprs.push(retValue);
            var node = make_sequence(self, exprs).optimize(compressor);
            fn.inlined = save_inlined;
            node = maintain_this_binding(parent, current, node);
            if (replacing || best_of_expression(node, self) === node) {
              refs.forEach(function(ref) {
                ref.scope = exp === fn ? fn.parent_scope : exp.scope;
                ref.reference();
                var def2 = ref.definition();
                if (replacing)
                  def2.replaced++;
                def2.single_use = false;
              });
              return node;
            } else if (!node.has_side_effects(compressor)) {
              self.drop_side_effect_free = function(compressor2, first_in_statement2) {
                var self2 = this;
                var exprs2 = self2.args.slice();
                exprs2.unshift(self2.expression);
                return make_sequence(self2, exprs2).drop_side_effect_free(compressor2, first_in_statement2);
              };
            }
          }
          var arg_used, insert, in_loop, scope;
          if (replacing && can_inject_symbols()) {
            fn._squeezed = true;
            if (exp !== fn)
              fn.parent_scope = exp.scope;
            var node = make_sequence(self, flatten_fn()).optimize(compressor);
            return maintain_this_binding(parent, current, node);
          }
        }
        if (compressor.option("side_effects") && can_drop && all(fn.body, is_empty) && (fn === exp ? fn_name_unused(fn, compressor) : !has_default && !has_destructured && !fn.rest) && !(is_arrow(fn) && fn.value) && safe_from_await_yield(fn, avoid_await_yield(compressor))) {
          return make_sequence(self, convert_args()).optimize(compressor);
        }
      }
      if (compressor.option("drop_console")) {
        if (exp instanceof AST_PropAccess) {
          var name = exp.expression;
          while (name.expression) {
            name = name.expression;
          }
          if (is_undeclared_ref(name) && name.name == "console") {
            return make_node(AST_Undefined, self).optimize(compressor);
          }
        }
      }
      if (compressor.option("negate_iife") && parent instanceof AST_SimpleStatement && is_iife_call(current)) {
        return self.negate(compressor, true);
      }
      return try_evaluate(compressor, self);
      function make_void_lhs(orig) {
        return make_node(AST_Sub, orig, {
          expression: make_node(AST_Array, orig, { elements: [] }),
          property: make_node(AST_Number, orig, { value: 0 })
        });
      }
      function convert_args(value2) {
        var args2 = self.args.slice();
        var destructured = has_default > 1 || has_destructured || fn.rest;
        if (destructured || has_spread)
          args2 = [make_node(AST_Array, self, { elements: args2 })];
        if (destructured) {
          var tt = new TreeTransformer(function(node2, descend) {
            if (node2 instanceof AST_DefaultValue)
              return make_node(AST_DefaultValue, node2, {
                name: node2.name.transform(tt) || make_void_lhs(node2),
                value: node2.value
              });
            if (node2 instanceof AST_DestructuredArray) {
              var elements2 = [];
              node2.elements.forEach(function(node3, index) {
                node3 = node3.transform(tt);
                if (node3)
                  elements2[index] = node3;
              });
              fill_holes(node2, elements2);
              return make_node(AST_DestructuredArray, node2, { elements: elements2 });
            }
            if (node2 instanceof AST_DestructuredObject) {
              var properties = [], side_effects = [];
              node2.properties.forEach(function(prop) {
                var key = prop.key;
                var value3 = prop.value.transform(tt);
                if (value3) {
                  if (side_effects.length) {
                    if (!(key instanceof AST_Node))
                      key = make_node_from_constant(key, prop);
                    side_effects.push(key);
                    key = make_sequence(node2, side_effects);
                    side_effects = [];
                  }
                  properties.push(make_node(AST_DestructuredKeyVal, prop, {
                    key,
                    value: value3
                  }));
                } else if (key instanceof AST_Node) {
                  side_effects.push(key);
                }
              });
              if (side_effects.length)
                properties.push(make_node(AST_DestructuredKeyVal, node2, {
                  key: make_sequence(node2, side_effects),
                  value: make_void_lhs(node2)
                }));
              return make_node(AST_DestructuredObject, node2, { properties });
            }
            if (node2 instanceof AST_SymbolFunarg)
              return null;
          });
          var lhs = [];
          fn.argnames.forEach(function(argname, index) {
            argname = argname.transform(tt);
            if (argname)
              lhs[index] = argname;
          });
          var rest = fn.rest && fn.rest.transform(tt);
          if (rest)
            lhs.length = fn.argnames.length;
          fill_holes(fn, lhs);
          args2[0] = make_node(AST_Assign, self, {
            operator: "=",
            left: make_node(AST_DestructuredArray, fn, {
              elements: lhs,
              rest
            }),
            right: args2[0]
          });
        } else
          fn.argnames.forEach(function(argname) {
            if (argname instanceof AST_DefaultValue)
              args2.push(argname.value);
          });
        args2.push(value2 || make_node(AST_Undefined, self));
        return args2;
      }
      function noop_value() {
        return self.call_only ? make_node(AST_Number, self, { value: 0 }) : make_node(AST_Undefined, self);
      }
      function return_value(stat2) {
        if (!stat2)
          return noop_value();
        if (stat2 instanceof AST_Return)
          return stat2.value || noop_value();
        if (stat2 instanceof AST_SimpleStatement) {
          return self.call_only ? stat2.body : make_node(AST_UnaryPrefix, stat2, {
            operator: "void",
            expression: stat2.body
          });
        }
      }
      function can_flatten_body(stat2) {
        var len = fn.body.length;
        if (len < 2) {
          stat2 = return_value(stat2);
          if (stat2)
            return stat2;
        }
        if (compressor.option("inline") < 3)
          return false;
        stat2 = null;
        for (var i2 = 0;i2 < len; i2++) {
          var line = fn.body[i2];
          if (line instanceof AST_Var) {
            if (var_assigned) {
              if (!stat2)
                continue;
              if (!(stat2 instanceof AST_SimpleStatement))
                return false;
              if (!declarations_only(line))
                stat2 = null;
            } else if (!declarations_only(line)) {
              if (stat2 && !(stat2 instanceof AST_SimpleStatement))
                return false;
              stat2 = null;
              var_assigned = true;
            }
          } else if (line instanceof AST_AsyncDefun || line instanceof AST_Defun || line instanceof AST_EmptyStatement) {
            continue;
          } else if (stat2) {
            return false;
          } else {
            stat2 = line;
          }
        }
        return return_value(stat2);
      }
      function resolve_index(def2) {
        for (var i2 = fn.argnames.length;--i2 >= 0; ) {
          if (fn.argnames[i2].definition() === def2)
            return i2;
        }
      }
      function can_substitute_directly() {
        if (has_default || has_destructured || has_spread || var_assigned || fn.rest)
          return;
        if (compressor.option("inline") < 2 && fn.argnames.length)
          return;
        if (!fn.variables.all(function(def2) {
          return def2.references.length - def2.replaced < 2 && def2.orig[0] instanceof AST_SymbolFunarg;
        }))
          return;
        var scope2 = compressor.find_parent(AST_Scope);
        var abort = false;
        var avoid = avoid_await_yield(compressor, scope2);
        var begin;
        var in_order = [];
        var side_effects = false;
        var tw = new TreeWalker(function(node2, descend) {
          if (abort)
            return true;
          if (node2 instanceof AST_Binary && lazy_op[node2.operator] || node2 instanceof AST_Conditional) {
            in_order = null;
            return;
          }
          if (node2 instanceof AST_Scope)
            return abort = true;
          if (avoid && node2 instanceof AST_Symbol && avoid[node2.name])
            return abort = true;
          if (node2 instanceof AST_SymbolRef) {
            var def2 = node2.definition();
            if (fn.variables.get(node2.name) !== def2) {
              in_order = null;
              return;
            }
            if (def2.init instanceof AST_LambdaDefinition)
              return abort = true;
            if (is_lhs(node2, tw.parent()))
              return abort = true;
            var index = resolve_index(def2);
            if (!(begin < index))
              begin = index;
            if (!in_order)
              return;
            if (side_effects) {
              in_order = null;
            } else {
              in_order.push(fn.argnames[index]);
            }
            return;
          }
          if (side_effects)
            return;
          if (node2 instanceof AST_Assign && node2.left instanceof AST_PropAccess) {
            node2.left.expression.walk(tw);
            if (node2.left instanceof AST_Sub)
              node2.left.property.walk(tw);
            node2.right.walk(tw);
            side_effects = true;
            return true;
          }
          if (node2.has_side_effects(compressor)) {
            descend();
            side_effects = true;
            return true;
          }
        });
        value.walk(tw);
        if (abort)
          return;
        var end = self.args.length;
        if (in_order && fn.argnames.length >= end) {
          end = fn.argnames.length;
          while (end-- > begin && fn.argnames[end] === in_order.pop())
            ;
          end++;
        }
        return end <= begin || all(self.args.slice(begin, end), side_effects && !in_order ? function(funarg) {
          return funarg.is_constant_expression(scope2);
        } : function(funarg) {
          return !funarg.has_side_effects(compressor);
        });
      }
      function var_exists(defined, name2) {
        return defined.has(name2) || identifier_atom[name2] || scope.var_names().has(name2);
      }
      function can_inject_args(defined, safe_to_inject) {
        var abort = false;
        fn.each_argname(function(arg) {
          if (abort)
            return;
          if (arg.unused)
            return;
          if (!safe_to_inject || var_exists(defined, arg.name))
            return abort = true;
          arg_used.set(arg.name, true);
          if (in_loop)
            in_loop.push(arg.definition());
        });
        return !abort;
      }
      function can_inject_vars(defined, safe_to_inject) {
        for (var i2 = 0;i2 < fn.body.length; i2++) {
          var stat2 = fn.body[i2];
          if (stat2 instanceof AST_LambdaDefinition) {
            var name2 = stat2.name;
            if (!safe_to_inject)
              return false;
            if (arg_used.has(name2.name))
              return false;
            if (var_exists(defined, name2.name))
              return false;
            if (!all(stat2.enclosed, function(def2) {
              return def2.scope === scope || def2.scope === stat2 || !defined.has(def2.name);
            }))
              return false;
            if (in_loop)
              in_loop.push(name2.definition());
            continue;
          }
          if (!(stat2 instanceof AST_Var))
            continue;
          if (!safe_to_inject)
            return false;
          for (var j = stat2.definitions.length;--j >= 0; ) {
            var name2 = stat2.definitions[j].name;
            if (var_exists(defined, name2.name))
              return false;
            if (in_loop)
              in_loop.push(name2.definition());
          }
        }
        return true;
      }
      function can_inject_symbols() {
        var defined = new Dictionary;
        var level = 0, child;
        scope = current;
        do {
          if (scope.variables)
            scope.variables.each(function(def2) {
              defined.set(def2.name, true);
            });
          child = scope;
          scope = compressor.parent(level++);
          if (scope instanceof AST_ClassField) {
            if (!scope.static)
              return false;
          } else if (scope instanceof AST_DWLoop) {
            in_loop = [];
          } else if (scope instanceof AST_For) {
            if (scope.init === child)
              continue;
            in_loop = [];
          } else if (scope instanceof AST_ForEnumeration) {
            if (scope.init === child)
              continue;
            if (scope.object === child)
              continue;
            in_loop = [];
          }
        } while (!(scope instanceof AST_Scope));
        insert = scope.body.indexOf(child) + 1;
        if (!insert)
          return false;
        if (!safe_from_await_yield(fn, avoid_await_yield(compressor, scope)))
          return false;
        var safe_to_inject = (exp !== fn || fn.parent_scope.resolve() === scope) && !scope.pinned();
        if (scope instanceof AST_Toplevel) {
          if (compressor.toplevel.vars) {
            defined.set("arguments", true);
          } else {
            safe_to_inject = false;
          }
        }
        arg_used = new Dictionary;
        var inline = compressor.option("inline");
        if (!can_inject_args(defined, inline >= 2 && safe_to_inject))
          return false;
        if (!can_inject_vars(defined, inline >= 3 && safe_to_inject))
          return false;
        return !in_loop || in_loop.length == 0 || !is_reachable(fn, in_loop);
      }
      function append_var(decls, expressions, name2, value2) {
        var def2 = name2.definition();
        if (!scope.var_names().has(name2.name)) {
          scope.var_names().set(name2.name, true);
          decls.push(make_node(AST_VarDef, name2, {
            name: name2,
            value: null
          }));
        }
        scope.variables.set(name2.name, def2);
        scope.enclosed.push(def2);
        if (!value2)
          return;
        var sym = make_node(AST_SymbolRef, name2);
        def2.assignments++;
        def2.references.push(sym);
        expressions.push(make_node(AST_Assign, self, {
          operator: "=",
          left: sym,
          right: value2
        }));
      }
      function flatten_args(decls, expressions) {
        var len = fn.argnames.length;
        for (var i2 = self.args.length;--i2 >= len; ) {
          expressions.push(self.args[i2]);
        }
        var default_args = [];
        for (i2 = len;--i2 >= 0; ) {
          var argname = fn.argnames[i2];
          var name2;
          if (argname instanceof AST_DefaultValue) {
            default_args.push(argname);
            name2 = argname.name;
          } else {
            name2 = argname;
          }
          var value2 = self.args[i2];
          if (name2.unused || scope.var_names().has(name2.name)) {
            if (value2)
              expressions.push(value2);
          } else {
            var symbol = make_node(AST_SymbolVar, name2);
            var def2 = name2.definition();
            def2.orig.push(symbol);
            def2.eliminated++;
            if (name2.unused !== undefined) {
              append_var(decls, expressions, symbol);
              if (value2)
                expressions.push(value2);
            } else {
              if (!value2 && argname === name2 && (in_loop || name2.name == "arguments" && !is_arrow(fn) && is_arrow(scope))) {
                value2 = make_node(AST_Undefined, self);
              }
              append_var(decls, expressions, symbol, value2);
            }
          }
        }
        decls.reverse();
        expressions.reverse();
        for (i2 = default_args.length;--i2 >= 0; ) {
          var node2 = default_args[i2];
          if (node2.name.unused !== undefined) {
            expressions.push(node2.value);
          } else {
            var sym = make_node(AST_SymbolRef, node2.name);
            node2.name.definition().references.push(sym);
            expressions.push(make_node(AST_Assign, node2, {
              operator: "=",
              left: sym,
              right: node2.value
            }));
          }
        }
      }
      function flatten_destructured(decls, expressions) {
        expressions.push(make_node(AST_Assign, self, {
          operator: "=",
          left: make_node(AST_DestructuredArray, self, {
            elements: fn.argnames.map(function(argname) {
              if (argname.unused)
                return make_node(AST_Hole, argname);
              return argname.convert_symbol(AST_SymbolRef, process2);
            }),
            rest: fn.rest && fn.rest.convert_symbol(AST_SymbolRef, process2)
          }),
          right: make_node(AST_Array, self, { elements: self.args.slice() })
        }));
        function process2(ref, name2) {
          if (name2.unused)
            return make_void_lhs(name2);
          var def2 = name2.definition();
          def2.assignments++;
          def2.references.push(ref);
          var symbol = make_node(AST_SymbolVar, name2);
          def2.orig.push(symbol);
          def2.eliminated++;
          append_var(decls, expressions, symbol);
        }
      }
      function flatten_vars(decls, expressions) {
        var args2 = [insert, 0];
        var decl_var = [], expr_fn = [], expr_var = [], expr_loop = [], exprs2 = [];
        fn.body.filter(in_loop ? function(stat2) {
          if (!(stat2 instanceof AST_LambdaDefinition))
            return true;
          var name2 = make_node(AST_SymbolVar, flatten_var(stat2.name));
          var def2 = name2.definition();
          def2.fixed = false;
          def2.orig.push(name2);
          def2.eliminated++;
          append_var(decls, expr_fn, name2, to_func_expr(stat2, true));
          return false;
        } : function(stat2) {
          if (!(stat2 instanceof AST_LambdaDefinition))
            return true;
          var def2 = stat2.name.definition();
          scope.functions.set(def2.name, def2);
          scope.variables.set(def2.name, def2);
          scope.enclosed.push(def2);
          scope.var_names().set(def2.name, true);
          args2.push(stat2);
          return false;
        }).forEach(function(stat2) {
          if (!(stat2 instanceof AST_Var)) {
            if (stat2 instanceof AST_SimpleStatement)
              exprs2.push(stat2.body);
            return;
          }
          for (var j = 0;j < stat2.definitions.length; j++) {
            var var_def = stat2.definitions[j];
            var name2 = flatten_var(var_def.name);
            var value2 = var_def.value;
            if (value2 && exprs2.length > 0) {
              exprs2.push(value2);
              value2 = make_sequence(var_def, exprs2);
              exprs2 = [];
            }
            append_var(decl_var, expr_var, name2, value2);
            if (!in_loop)
              continue;
            if (arg_used.has(name2.name))
              continue;
            if (name2.definition().orig.length == 1 && fn.functions.has(name2.name))
              continue;
            expr_loop.push(init_ref(compressor, name2));
          }
        });
        [].push.apply(decls, decl_var);
        [].push.apply(expressions, expr_loop);
        [].push.apply(expressions, expr_fn);
        [].push.apply(expressions, expr_var);
        return args2;
      }
      function flatten_fn() {
        var decls = [];
        var expressions = [];
        if (has_default > 1 || has_destructured || has_spread || fn.rest) {
          flatten_destructured(decls, expressions);
        } else {
          flatten_args(decls, expressions);
        }
        var args2 = flatten_vars(decls, expressions);
        expressions.push(value);
        if (decls.length)
          args2.push(make_node(AST_Var, fn, { definitions: decls }));
        [].splice.apply(scope.body, args2);
        fn.enclosed.forEach(function(def2) {
          if (scope.var_names().has(def2.name))
            return;
          scope.enclosed.push(def2);
          scope.var_names().set(def2.name, true);
        });
        return expressions;
      }
    });
    OPT(AST_New, function(self, compressor) {
      if (compressor.option("unsafe")) {
        var exp = self.expression;
        if (is_undeclared_ref(exp))
          switch (exp.name) {
            case "Array":
            case "Error":
            case "Function":
            case "Object":
            case "RegExp":
              return make_node(AST_Call, self).transform(compressor);
          }
      }
      if (compressor.option("sequences")) {
        var seq = lift_sequence_in_expression(self, compressor);
        if (seq !== self)
          return seq.optimize(compressor);
      }
      if (compressor.option("unused"))
        drop_unused_call_args(self, compressor);
      return self;
    });
    function to_conditional_assignment(compressor, def, value, node) {
      if (!(node instanceof AST_Binary))
        return;
      if (!(node.operator == "&&" || node.operator == "||"))
        return;
      if (!(node.right instanceof AST_Assign))
        return;
      if (node.right.operator != "=")
        return;
      if (!(node.right.left instanceof AST_SymbolRef))
        return;
      if (node.right.left.definition() !== def)
        return;
      if (value.has_side_effects(compressor))
        return;
      if (!safe_from_assignment(node.left))
        return;
      if (!safe_from_assignment(node.right.right))
        return;
      def.replaced++;
      return node.operator == "&&" ? make_node(AST_Conditional, node, {
        condition: node.left,
        consequent: node.right.right,
        alternative: value
      }) : make_node(AST_Conditional, node, {
        condition: node.left,
        consequent: value,
        alternative: node.right.right
      });
      function safe_from_assignment(node2) {
        if (node2.has_side_effects(compressor))
          return;
        var hit = false;
        node2.walk(new TreeWalker(function(node3) {
          if (hit)
            return true;
          if (node3 instanceof AST_SymbolRef && node3.definition() === def)
            return hit = true;
        }));
        return !hit;
      }
    }
    OPT(AST_Sequence, function(self, compressor) {
      var expressions = filter_for_side_effects();
      var end = expressions.length - 1;
      merge_assignments();
      trim_right_for_undefined();
      if (end == 0) {
        self = maintain_this_binding(compressor.parent(), compressor.self(), expressions[0]);
        if (!(self instanceof AST_Sequence))
          self = self.optimize(compressor);
        return self;
      }
      self.expressions = expressions;
      return self;
      function filter_for_side_effects() {
        if (!compressor.option("side_effects"))
          return self.expressions;
        var expressions2 = [];
        var first = first_in_statement(compressor);
        var last = self.expressions.length - 1;
        self.expressions.forEach(function(expr, index) {
          if (index < last)
            expr = expr.drop_side_effect_free(compressor, first);
          if (expr) {
            merge_sequence(expressions2, expr);
            first = false;
          }
        });
        return expressions2;
      }
      function trim_right_for_undefined() {
        if (!compressor.option("side_effects"))
          return;
        while (end > 0 && is_undefined(expressions[end], compressor))
          end--;
        if (end < expressions.length - 1) {
          expressions[end] = make_node(AST_UnaryPrefix, self, {
            operator: "void",
            expression: expressions[end]
          });
          expressions.length = end + 1;
        }
      }
      function is_simple_assign(node) {
        return node instanceof AST_Assign && node.operator == "=" && node.left instanceof AST_SymbolRef && node.left.definition();
      }
      function merge_assignments() {
        for (var i = 1;i < end; i++) {
          var prev = expressions[i - 1];
          var def = is_simple_assign(prev);
          if (!def)
            continue;
          var expr = expressions[i];
          if (compressor.option("conditionals")) {
            var cond = to_conditional_assignment(compressor, def, prev.right, expr);
            if (cond) {
              prev.right = cond;
              expressions.splice(i--, 1);
              end--;
              continue;
            }
          }
          if (compressor.option("dead_code") && is_simple_assign(expr) === def && expr.right.is_constant_expression(def.scope.resolve())) {
            expressions[--i] = prev.right;
          }
        }
      }
    });
    OPT(AST_UnaryPostfix, function(self, compressor) {
      if (compressor.option("sequences")) {
        var seq = lift_sequence_in_expression(self, compressor);
        if (seq !== self)
          return seq.optimize(compressor);
      }
      return try_evaluate(compressor, self);
    });
    var SIGN_OPS = makePredicate("+ -");
    var MULTIPLICATIVE_OPS = makePredicate("* / %");
    OPT(AST_UnaryPrefix, function(self, compressor) {
      var op = self.operator;
      var exp = self.expression;
      if (compressor.option("sequences") && can_lift()) {
        var seq = lift_sequence_in_expression(self, compressor);
        if (seq !== self)
          return seq.optimize(compressor);
      }
      switch (op) {
        case "+":
          if (!compressor.option("evaluate"))
            break;
          if (!exp.is_number(compressor, true))
            break;
          var parent = compressor.parent();
          if (parent instanceof AST_UnaryPrefix && parent.operator == "delete")
            break;
          return exp;
        case "-":
          if (exp instanceof AST_Infinity)
            exp = exp.transform(compressor);
          if (exp instanceof AST_Number || exp instanceof AST_Infinity)
            return self;
          break;
        case "!":
          if (!compressor.option("booleans"))
            break;
          if (exp.is_truthy())
            return make_sequence(self, [exp, make_node(AST_False, self)]).optimize(compressor);
          if (compressor.in_boolean_context()) {
            if (exp instanceof AST_UnaryPrefix && exp.operator == "!")
              return exp.expression;
            if (exp instanceof AST_Binary) {
              var first = first_in_statement(compressor);
              self = (first ? best_of_statement : best_of_expression)(self, exp.negate(compressor, first));
            }
          }
          break;
        case "delete":
          if (!compressor.option("evaluate"))
            break;
          if (may_not_delete(exp))
            break;
          return make_sequence(self, [exp, make_node(AST_True, self)]).optimize(compressor);
        case "typeof":
          if (!compressor.option("booleans"))
            break;
          if (!compressor.in_boolean_context())
            break;
          AST_Node.warn("Boolean expression always true [{start}]", self);
          var exprs = [make_node(AST_True, self)];
          if (!(exp instanceof AST_SymbolRef && can_drop_symbol(exp, compressor)))
            exprs.unshift(exp);
          return make_sequence(self, exprs).optimize(compressor);
        case "void":
          if (!compressor.option("side_effects"))
            break;
          exp = exp.drop_side_effect_free(compressor);
          if (!exp)
            return make_node(AST_Undefined, self).optimize(compressor);
          self.expression = exp;
          return self;
      }
      if (compressor.option("evaluate") && exp instanceof AST_Binary && SIGN_OPS[op] && MULTIPLICATIVE_OPS[exp.operator] && (exp.left.is_constant() || !exp.right.has_side_effects(compressor))) {
        return make_node(AST_Binary, self, {
          operator: exp.operator,
          left: make_node(AST_UnaryPrefix, exp.left, {
            operator: op,
            expression: exp.left
          }),
          right: exp.right
        });
      }
      return try_evaluate(compressor, self);
      function may_not_delete(node) {
        return node instanceof AST_Infinity || node instanceof AST_NaN || node instanceof AST_NewTarget || node instanceof AST_PropAccess || node instanceof AST_SymbolRef || node instanceof AST_Undefined;
      }
      function can_lift() {
        switch (op) {
          case "delete":
            return !may_not_delete(exp.tail_node());
          case "typeof":
            return !is_undeclared_ref(exp.tail_node());
          default:
            return true;
        }
      }
    });
    OPT(AST_Await, function(self, compressor) {
      if (!compressor.option("awaits"))
        return self;
      if (compressor.option("sequences")) {
        var seq = lift_sequence_in_expression(self, compressor);
        if (seq !== self)
          return seq.optimize(compressor);
      }
      if (compressor.option("side_effects")) {
        var exp = self.expression;
        if (exp instanceof AST_Await)
          return exp.optimize(compressor);
        if (exp instanceof AST_UnaryPrefix && exp.expression instanceof AST_Await)
          return exp.optimize(compressor);
        for (var level = 0, node = self, parent;parent = compressor.parent(level++); node = parent) {
          if (is_arrow(parent)) {
            if (parent.value === node)
              return exp.optimize(compressor);
          } else if (parent instanceof AST_Return) {
            var drop = true;
            do {
              node = parent;
              parent = compressor.parent(level++);
              if (parent instanceof AST_Try && (parent.bfinally || parent.bcatch) !== node) {
                drop = false;
                break;
              }
            } while (parent && !(parent instanceof AST_Scope));
            if (drop)
              return exp.optimize(compressor);
          } else if (parent instanceof AST_Sequence) {
            if (parent.tail_node() === node)
              continue;
          }
          break;
        }
      }
      return self;
    });
    OPT(AST_Yield, function(self, compressor) {
      if (!compressor.option("yields"))
        return self;
      if (compressor.option("sequences")) {
        var seq = lift_sequence_in_expression(self, compressor);
        if (seq !== self)
          return seq.optimize(compressor);
      }
      var exp = self.expression;
      if (self.nested && exp.TYPE == "Call") {
        var inlined = exp.clone().optimize(compressor);
        if (inlined.TYPE != "Call")
          return inlined;
      }
      return self;
    });
    AST_Binary.DEFMETHOD("lift_sequences", function(compressor) {
      if (this.left instanceof AST_PropAccess) {
        if (!(this.left.expression instanceof AST_Sequence))
          return this;
        var x = this.left.expression.expressions.slice();
        var e = this.clone();
        e.left = e.left.clone();
        e.left.expression = x.pop();
        x.push(e);
        return make_sequence(this, x);
      }
      if (this.left instanceof AST_Sequence) {
        var x = this.left.expressions.slice();
        var e = this.clone();
        e.left = x.pop();
        x.push(e);
        return make_sequence(this, x);
      }
      if (this.right instanceof AST_Sequence) {
        if (this.left.has_side_effects(compressor))
          return this;
        var assign = this.operator == "=" && this.left instanceof AST_SymbolRef;
        var x = this.right.expressions;
        var last = x.length - 1;
        for (var i = 0;i < last; i++) {
          if (!assign && x[i].has_side_effects(compressor))
            break;
        }
        if (i == last) {
          x = x.slice();
          var e = this.clone();
          e.right = x.pop();
          x.push(e);
          return make_sequence(this, x);
        }
        if (i > 0) {
          var e = this.clone();
          e.right = make_sequence(this.right, x.slice(i));
          x = x.slice(0, i);
          x.push(e);
          return make_sequence(this, x);
        }
      }
      return this;
    });
    var indexFns = makePredicate("indexOf lastIndexOf");
    var commutativeOperators = makePredicate("== === != !== * & | ^");
    function is_object(node, plain) {
      if (node instanceof AST_Assign)
        return !plain && node.operator == "=" && is_object(node.right);
      if (node instanceof AST_New)
        return !plain;
      if (node instanceof AST_Sequence)
        return is_object(node.tail_node(), plain);
      if (node instanceof AST_SymbolRef)
        return !plain && is_object(node.fixed_value());
      return node instanceof AST_Array || node instanceof AST_Class || node instanceof AST_Lambda || node instanceof AST_Object;
    }
    function can_drop_op(op, rhs, compressor) {
      switch (op) {
        case "in":
          return is_object(rhs) || compressor && compressor.option("unsafe_comps");
        case "instanceof":
          if (rhs instanceof AST_SymbolRef)
            rhs = rhs.fixed_value();
          return is_lambda(rhs) || compressor && compressor.option("unsafe_comps");
        default:
          return true;
      }
    }
    function needs_enqueuing(compressor, node) {
      if (node.is_constant())
        return true;
      if (node instanceof AST_Assign)
        return node.operator != "=" || needs_enqueuing(compressor, node.right);
      if (node instanceof AST_Binary) {
        return !lazy_op[node.operator] || needs_enqueuing(compressor, node.left) && needs_enqueuing(compressor, node.right);
      }
      if (node instanceof AST_Call)
        return is_async(node.expression);
      if (node instanceof AST_Conditional) {
        return needs_enqueuing(compressor, node.consequent) && needs_enqueuing(compressor, node.alternative);
      }
      if (node instanceof AST_Sequence)
        return needs_enqueuing(compressor, node.tail_node());
      if (node instanceof AST_SymbolRef) {
        var fixed = node.fixed_value();
        return fixed && needs_enqueuing(compressor, fixed);
      }
      if (node instanceof AST_Template)
        return !node.tag || is_raw_tag(compressor, node.tag);
      if (node instanceof AST_Unary)
        return true;
    }
    function extract_lhs(node, compressor) {
      if (node instanceof AST_Assign)
        return is_lhs_read_only(node.left, compressor) ? node : node.left;
      if (node instanceof AST_Sequence)
        return extract_lhs(node.tail_node(), compressor);
      if (node instanceof AST_UnaryPrefix && UNARY_POSTFIX[node.operator]) {
        return is_lhs_read_only(node.expression, compressor) ? node : node.expression;
      }
      return node;
    }
    function repeatable(compressor, node) {
      if (node instanceof AST_Dot)
        return repeatable(compressor, node.expression);
      if (node instanceof AST_Sub) {
        return repeatable(compressor, node.expression) && repeatable(compressor, node.property);
      }
      if (node instanceof AST_Symbol)
        return true;
      return !node.has_side_effects(compressor);
    }
    function swap_chain(self, compressor) {
      var rhs = self.right.tail_node();
      if (rhs !== self.right) {
        var exprs = self.right.expressions.slice(0, -1);
        exprs.push(rhs.left);
        rhs = rhs.clone();
        rhs.left = make_sequence(self.right, exprs);
        self.right = rhs;
      }
      self.left = make_node(AST_Binary, self, {
        operator: self.operator,
        left: self.left,
        right: rhs.left,
        start: self.left.start,
        end: rhs.left.end
      });
      self.right = rhs.right;
      if (compressor) {
        self.left = self.left.transform(compressor);
      } else if (self.operator == rhs.left.operator) {
        swap_chain(self.left);
      }
    }
    OPT(AST_Binary, function(self, compressor) {
      if (commutativeOperators[self.operator] && self.right.is_constant() && !self.left.is_constant() && !(self.left instanceof AST_Binary && PRECEDENCE[self.left.operator] >= PRECEDENCE[self.operator])) {
        reverse();
      }
      if (compressor.option("sequences")) {
        var seq = self.lift_sequences(compressor);
        if (seq !== self)
          return seq.optimize(compressor);
      }
      if (compressor.option("assignments") && lazy_op[self.operator]) {
        var lhs = extract_lhs(self.left, compressor);
        var right = self.right;
        if (lhs instanceof AST_SymbolRef && right instanceof AST_Assign && right.operator == "=" && lhs.equals(right.left)) {
          lhs = lhs.clone();
          var assign = make_node(AST_Assign, self, {
            operator: "=",
            left: lhs,
            right: make_node(AST_Binary, self, {
              operator: self.operator,
              left: self.left,
              right: right.right
            })
          });
          if (lhs.fixed) {
            lhs.fixed = function() {
              return assign.right;
            };
            lhs.fixed.assigns = [assign];
          }
          var def = lhs.definition();
          def.references.push(lhs);
          def.replaced++;
          return assign.optimize(compressor);
        }
      }
      if (compressor.option("comparisons"))
        switch (self.operator) {
          case "===":
          case "!==":
            if (is_undefined(self.left, compressor) && self.right.is_defined(compressor)) {
              AST_Node.warn("Expression always defined [{start}]", self);
              return make_sequence(self, [
                self.right,
                make_node(self.operator == "===" ? AST_False : AST_True, self)
              ]).optimize(compressor);
            }
            var is_strict_comparison = true;
            if (self.left.is_string(compressor) && self.right.is_string(compressor) || self.left.is_number(compressor) && self.right.is_number(compressor) || self.left.is_boolean(compressor) && self.right.is_boolean(compressor) || repeatable(compressor, self.left) && self.left.equals(self.right)) {
              self.operator = self.operator.slice(0, 2);
            }
          case "==":
          case "!=":
            if (!is_strict_comparison && is_undefined(self.left, compressor)) {
              self.left = make_node(AST_Null, self.left);
            } else if (compressor.option("typeofs") && self.left instanceof AST_String && self.left.value == "undefined" && self.right instanceof AST_UnaryPrefix && self.right.operator == "typeof") {
              var expr = self.right.expression;
              if (expr instanceof AST_SymbolRef ? expr.is_declared(compressor) : !(expr instanceof AST_PropAccess && compressor.option("ie"))) {
                self.right = expr;
                self.left = make_node(AST_Undefined, self.left).optimize(compressor);
                if (self.operator.length == 2)
                  self.operator += "=";
              }
            } else if (self.left instanceof AST_SymbolRef && self.right instanceof AST_SymbolRef && self.left.definition() === self.right.definition() && is_object(self.left)) {
              return make_node(self.operator[0] == "=" ? AST_True : AST_False, self).optimize(compressor);
            }
            break;
          case "&&":
          case "||":
            var left = self.left;
            if (!(left instanceof AST_Binary))
              break;
            if (left.operator != (self.operator == "&&" ? "!==" : "==="))
              break;
            if (!(self.right instanceof AST_Binary))
              break;
            if (left.operator != self.right.operator)
              break;
            if (is_undefined(left.left, compressor) && self.right.left instanceof AST_Null || left.left instanceof AST_Null && is_undefined(self.right.left, compressor)) {
              var expr = left.right;
              if (expr instanceof AST_Assign && expr.operator == "=")
                expr = expr.left;
              if (expr.has_side_effects(compressor))
                break;
              if (!expr.equals(self.right.right))
                break;
              left.operator = left.operator.slice(0, -1);
              left.left = make_node(AST_Null, self);
              return left;
            }
            break;
        }
      var in_bool = false;
      var parent = compressor.parent();
      if (compressor.option("booleans")) {
        var lhs = extract_lhs(self.left, compressor);
        if (lazy_op[self.operator] && !lhs.has_side_effects(compressor)) {
          if (lhs.equals(self.right)) {
            return maintain_this_binding(parent, compressor.self(), self.left).optimize(compressor);
          }
          mark_duplicate_condition(compressor, lhs);
        }
        in_bool = compressor.in_boolean_context();
      }
      if (in_bool)
        switch (self.operator) {
          case "+":
            var ev = self.left.evaluate(compressor, true);
            if (ev && typeof ev == "string" || (ev = self.right.evaluate(compressor, true)) && typeof ev == "string") {
              AST_Node.warn("+ in boolean context always true [{start}]", self);
              var exprs = [];
              if (self.left.evaluate(compressor) instanceof AST_Node)
                exprs.push(self.left);
              if (self.right.evaluate(compressor) instanceof AST_Node)
                exprs.push(self.right);
              if (exprs.length < 2) {
                exprs.push(make_node(AST_True, self));
                return make_sequence(self, exprs).optimize(compressor);
              }
              self.truthy = true;
            }
            break;
          case "==":
            if (self.left instanceof AST_String && self.left.value == "" && self.right.is_string(compressor)) {
              return make_node(AST_UnaryPrefix, self, {
                operator: "!",
                expression: self.right
              }).optimize(compressor);
            }
            break;
          case "!=":
            if (self.left instanceof AST_String && self.left.value == "" && self.right.is_string(compressor)) {
              return self.right.optimize(compressor);
            }
            break;
        }
      if (compressor.option("comparisons") && self.is_boolean(compressor)) {
        if (parent.TYPE != "Binary") {
          var negated = make_node(AST_UnaryPrefix, self, {
            operator: "!",
            expression: self.negate(compressor)
          });
          if (best_of(compressor, self, negated) === negated)
            return negated;
        }
        switch (self.operator) {
          case ">":
            reverse("<");
            break;
          case ">=":
            reverse("<=");
            break;
        }
      }
      if (compressor.option("conditionals") && lazy_op[self.operator]) {
        if (self.left instanceof AST_Binary && self.operator == self.left.operator) {
          var before = make_node(AST_Binary, self, {
            operator: self.operator,
            left: self.left.right,
            right: self.right
          });
          var after = before.transform(compressor);
          if (before !== after) {
            self.left = self.left.left;
            self.right = after;
          }
        }
        var rhs = self.right.tail_node();
        if (rhs instanceof AST_Binary && self.operator == rhs.operator)
          swap_chain(self, compressor);
      }
      if (compressor.option("strings") && self.operator == "+") {
        if (self.right instanceof AST_String && self.right.value == "" && self.left.is_string(compressor)) {
          return self.left.optimize(compressor);
        }
        if (self.left instanceof AST_String && self.left.value == "" && self.right.is_string(compressor)) {
          return self.right.optimize(compressor);
        }
        if (self.left instanceof AST_Binary && self.left.operator == "+" && self.left.left instanceof AST_String && self.left.left.value == "" && self.right.is_string(compressor) && (self.left.right.is_constant() || !self.right.has_side_effects(compressor))) {
          self.left = self.left.right;
          return self.optimize(compressor);
        }
        var rhs = self.right.tail_node();
        if (rhs instanceof AST_Binary && self.operator == rhs.operator && (self.left.is_string(compressor) && rhs.is_string(compressor) || rhs.left.is_string(compressor) && (self.left.is_constant() || !rhs.right.has_side_effects(compressor)))) {
          swap_chain(self, compressor);
        }
      }
      if (compressor.option("evaluate")) {
        var associative = true;
        switch (self.operator) {
          case "&&":
            var ll = fuzzy_eval(compressor, self.left);
            if (!ll) {
              AST_Node.warn("Condition left of && always false [{start}]", self);
              return maintain_this_binding(parent, compressor.self(), self.left).optimize(compressor);
            } else if (!(ll instanceof AST_Node)) {
              AST_Node.warn("Condition left of && always true [{start}]", self);
              return make_sequence(self, [self.left, self.right]).optimize(compressor);
            }
            if (!self.right.evaluate(compressor, true)) {
              if (in_bool && !(self.right.evaluate(compressor) instanceof AST_Node)) {
                AST_Node.warn("Boolean && always false [{start}]", self);
                return make_sequence(self, [self.left, make_node(AST_False, self)]).optimize(compressor);
              } else
                self.falsy = true;
            } else if ((in_bool || parent.operator == "&&" && parent.left === compressor.self()) && !(self.right.evaluate(compressor) instanceof AST_Node)) {
              AST_Node.warn("Dropping side-effect-free && [{start}]", self);
              return self.left.optimize(compressor);
            }
            if (self.left.operator == "||") {
              var lr = fuzzy_eval(compressor, self.left.right);
              if (!lr)
                return make_node(AST_Conditional, self, {
                  condition: self.left.left,
                  consequent: self.right,
                  alternative: self.left.right
                }).optimize(compressor);
            }
            break;
          case "??":
            var nullish = true;
          case "||":
            var ll = fuzzy_eval(compressor, self.left, nullish);
            if (nullish ? ll == null : !ll) {
              AST_Node.warn("Condition left of {operator} always {value} [{start}]", {
                operator: self.operator,
                value: nullish ? "nullish" : "false",
                start: self.start
              });
              return make_sequence(self, [self.left, self.right]).optimize(compressor);
            } else if (!(ll instanceof AST_Node)) {
              AST_Node.warn("Condition left of {operator} always {value} [{start}]", {
                operator: self.operator,
                value: nullish ? "defined" : "true",
                start: self.start
              });
              return maintain_this_binding(parent, compressor.self(), self.left).optimize(compressor);
            }
            var rr;
            if (!nullish && (rr = self.right.evaluate(compressor, true)) && !(rr instanceof AST_Node)) {
              if (in_bool && !(self.right.evaluate(compressor) instanceof AST_Node)) {
                AST_Node.warn("Boolean || always true [{start}]", self);
                return make_sequence(self, [self.left, make_node(AST_True, self)]).optimize(compressor);
              } else
                self.truthy = true;
            } else if ((in_bool || parent.operator == "||" && parent.left === compressor.self()) && !self.right.evaluate(compressor)) {
              AST_Node.warn("Dropping side-effect-free {operator} [{start}]", self);
              return self.left.optimize(compressor);
            }
            if (!nullish && self.left.operator == "&&") {
              var lr = fuzzy_eval(compressor, self.left.right);
              if (lr && !(lr instanceof AST_Node))
                return make_node(AST_Conditional, self, {
                  condition: self.left.left,
                  consequent: self.left.right,
                  alternative: self.right
                }).optimize(compressor);
            }
            break;
          case "+":
            if (self.left instanceof AST_Constant && self.right instanceof AST_Binary && self.right.operator == "+" && self.right.left instanceof AST_Constant && self.right.is_string(compressor)) {
              self = make_node(AST_Binary, self, {
                operator: "+",
                left: make_node(AST_String, self.left, {
                  value: "" + self.left.value + self.right.left.value,
                  start: self.left.start,
                  end: self.right.left.end
                }),
                right: self.right.right
              });
            }
            if (self.right instanceof AST_Constant && self.left instanceof AST_Binary && self.left.operator == "+" && self.left.right instanceof AST_Constant && self.left.is_string(compressor)) {
              self = make_node(AST_Binary, self, {
                operator: "+",
                left: self.left.left,
                right: make_node(AST_String, self.right, {
                  value: "" + self.left.right.value + self.right.value,
                  start: self.left.right.start,
                  end: self.right.end
                })
              });
            }
            if (self.right instanceof AST_UnaryPrefix && self.right.operator == "-" && self.left.is_number(compressor)) {
              self = make_node(AST_Binary, self, {
                operator: "-",
                left: self.left,
                right: self.right.expression
              });
              break;
            }
            if (self.left instanceof AST_UnaryPrefix && self.left.operator == "-" && reversible() && self.right.is_number(compressor)) {
              self = make_node(AST_Binary, self, {
                operator: "-",
                left: self.right,
                right: self.left.expression
              });
              break;
            }
            if (compressor.option("unsafe_math") && self.left instanceof AST_Binary && PRECEDENCE[self.left.operator] == PRECEDENCE[self.operator] && self.right.is_constant() && (self.right.is_boolean(compressor) || self.right.is_number(compressor)) && self.left.is_number(compressor) && !self.left.right.is_constant() && (self.left.left.is_boolean(compressor) || self.left.left.is_number(compressor))) {
              self = make_node(AST_Binary, self, {
                operator: self.left.operator,
                left: make_node(AST_Binary, self, {
                  operator: self.operator,
                  left: self.right,
                  right: self.left.left
                }),
                right: self.left.right
              });
              break;
            }
          case "-":
            if (self.right instanceof AST_UnaryPrefix && self.right.operator == "-" && self.left.is_number(compressor) && self.right.expression.is_number(compressor)) {
              self = make_node(AST_Binary, self, {
                operator: "+",
                left: self.left,
                right: self.right.expression
              });
              break;
            }
          case "*":
          case "/":
            associative = compressor.option("unsafe_math");
            if (self.operator != "+")
              ["left", "right"].forEach(function(operand) {
                var node2 = self[operand];
                if (node2 instanceof AST_UnaryPrefix && node2.operator == "+") {
                  var exp = node2.expression;
                  if (exp.is_boolean(compressor) || exp.is_number(compressor) || exp.is_string(compressor)) {
                    self[operand] = exp;
                  }
                }
              });
          case "&":
          case "|":
          case "^":
            if (self.operator != "-" && self.operator != "/" && (self.left.is_boolean(compressor) || self.left.is_number(compressor)) && (self.right.is_boolean(compressor) || self.right.is_number(compressor)) && reversible() && !(self.left instanceof AST_Binary && self.left.operator != self.operator && PRECEDENCE[self.left.operator] >= PRECEDENCE[self.operator])) {
              self = best_of(compressor, self, make_node(AST_Binary, self, {
                operator: self.operator,
                left: self.right,
                right: self.left
              }), self.right instanceof AST_Constant && !(self.left instanceof AST_Constant));
            }
            if (!associative || !self.is_number(compressor))
              break;
            if (self.right instanceof AST_Binary && self.right.operator != "%" && PRECEDENCE[self.right.operator] == PRECEDENCE[self.operator] && self.right.is_number(compressor) && (self.operator != "+" || self.right.left.is_boolean(compressor) || self.right.left.is_number(compressor)) && (self.operator != "-" || !self.left.is_negative_zero()) && (self.right.left.is_constant_expression() || !self.right.right.has_side_effects(compressor)) && !is_modify_array(self.right.right)) {
              self = make_node(AST_Binary, self, {
                operator: align(self.operator, self.right.operator),
                left: make_node(AST_Binary, self.left, {
                  operator: self.operator,
                  left: self.left,
                  right: self.right.left,
                  start: self.left.start,
                  end: self.right.left.end
                }),
                right: self.right.right
              });
              if (self.operator == "+" && !self.right.is_boolean(compressor) && !self.right.is_number(compressor)) {
                self.right = make_node(AST_UnaryPrefix, self.right, {
                  operator: "+",
                  expression: self.right
                });
              }
            }
            if (self.right instanceof AST_Constant && self.left instanceof AST_Binary && self.left.operator != "%" && PRECEDENCE[self.left.operator] == PRECEDENCE[self.operator] && self.left.is_number(compressor)) {
              if (self.left.left instanceof AST_Constant) {
                var lhs = make_binary(self.operator, self.left.left, self.right, {
                  start: self.left.left.start,
                  end: self.right.end
                });
                self = make_binary(self.left.operator, try_evaluate(compressor, lhs), self.left.right, self);
              } else if (self.left.right instanceof AST_Constant) {
                var op = align(self.left.operator, self.operator);
                var rhs = try_evaluate(compressor, make_binary(op, self.left.right, self.right, self.left));
                if (rhs.is_constant() && !(self.left.operator == "-" && self.right.value != 0 && +rhs.value == 0 && self.left.left.is_negative_zero())) {
                  self = make_binary(self.left.operator, self.left.left, rhs, self);
                }
              }
            }
            break;
          case "instanceof":
            if (is_lambda(self.right))
              return make_sequence(self, [
                self,
                make_node(AST_False, self)
              ]).optimize(compressor);
            break;
        }
        if (!(parent instanceof AST_UnaryPrefix && parent.operator == "delete")) {
          if (self.left instanceof AST_Number && !self.right.is_constant())
            switch (self.operator) {
              case "+":
                if (self.left.value == 0) {
                  if (self.right.is_boolean(compressor))
                    return make_node(AST_UnaryPrefix, self, {
                      operator: "+",
                      expression: self.right
                    }).optimize(compressor);
                  if (self.right.is_number(compressor) && !self.right.is_negative_zero())
                    return self.right;
                }
                break;
              case "*":
                if (self.left.value == 1)
                  return make_node(AST_UnaryPrefix, self, {
                    operator: "+",
                    expression: self.right
                  }).optimize(compressor);
                break;
            }
          if (self.right instanceof AST_Number && !self.left.is_constant())
            switch (self.operator) {
              case "+":
                if (self.right.value == 0) {
                  if (self.left.is_boolean(compressor))
                    return make_node(AST_UnaryPrefix, self, {
                      operator: "+",
                      expression: self.left
                    }).optimize(compressor);
                  if (self.left.is_number(compressor) && !self.left.is_negative_zero())
                    return self.left;
                }
                break;
              case "-":
                if (self.right.value == 0)
                  return make_node(AST_UnaryPrefix, self, {
                    operator: "+",
                    expression: self.left
                  }).optimize(compressor);
                break;
              case "/":
                if (self.right.value == 1)
                  return make_node(AST_UnaryPrefix, self, {
                    operator: "+",
                    expression: self.left
                  }).optimize(compressor);
                break;
            }
        }
      }
      if (compressor.option("typeofs"))
        switch (self.operator) {
          case "&&":
            mark_locally_defined(self.left, self.right, null);
            break;
          case "||":
            mark_locally_defined(self.left, null, self.right);
            break;
        }
      if (compressor.option("unsafe")) {
        var indexRight = is_indexFn(self.right);
        if (in_bool && indexRight && (self.operator == "==" || self.operator == "!=") && self.left instanceof AST_Number && self.left.value == 0) {
          return (self.operator == "==" ? make_node(AST_UnaryPrefix, self, {
            operator: "!",
            expression: self.right
          }) : self.right).optimize(compressor);
        }
        var indexLeft = is_indexFn(self.left);
        if (compressor.option("comparisons") && is_indexOf_match_pattern()) {
          var node = make_node(AST_UnaryPrefix, self, {
            operator: "!",
            expression: make_node(AST_UnaryPrefix, self, {
              operator: "~",
              expression: indexLeft ? self.left : self.right
            })
          });
          switch (self.operator) {
            case "<":
              if (indexLeft)
                break;
            case "<=":
            case "!=":
              node = make_node(AST_UnaryPrefix, self, {
                operator: "!",
                expression: node
              });
              break;
          }
          return node.optimize(compressor);
        }
      }
      return try_evaluate(compressor, self);
      function is_modify_array(node2) {
        var found = false;
        node2.walk(new TreeWalker(function(node3) {
          if (found)
            return true;
          if (node3 instanceof AST_Assign) {
            if (node3.left instanceof AST_PropAccess)
              return found = true;
          } else if (node3 instanceof AST_Unary) {
            if (unary_side_effects[node3.operator] && node3.expression instanceof AST_PropAccess) {
              return found = true;
            }
          }
        }));
        return found;
      }
      function align(ref, op2) {
        switch (ref) {
          case "-":
            return op2 == "+" ? "-" : "+";
          case "/":
            return op2 == "*" ? "/" : "*";
          default:
            return op2;
        }
      }
      function make_binary(op2, left2, right2, orig) {
        if (op2 == "+") {
          if (!left2.is_boolean(compressor) && !left2.is_number(compressor)) {
            left2 = make_node(AST_UnaryPrefix, left2, {
              operator: "+",
              expression: left2
            });
          }
          if (!right2.is_boolean(compressor) && !right2.is_number(compressor)) {
            right2 = make_node(AST_UnaryPrefix, right2, {
              operator: "+",
              expression: right2
            });
          }
        }
        return make_node(AST_Binary, orig, {
          operator: op2,
          left: left2,
          right: right2
        });
      }
      function is_indexFn(node2) {
        return node2.TYPE == "Call" && node2.expression instanceof AST_Dot && indexFns[node2.expression.property];
      }
      function is_indexOf_match_pattern() {
        switch (self.operator) {
          case "<=":
            return indexRight && self.left instanceof AST_Number && self.left.value == 0;
          case "<":
            if (indexLeft && self.right instanceof AST_Number && self.right.value == 0)
              return true;
          case "==":
          case "!=":
            if (!indexRight)
              return false;
            return self.left instanceof AST_Number && self.left.value == -1 || self.left instanceof AST_UnaryPrefix && self.left.operator == "-" && self.left.expression instanceof AST_Number && self.left.expression.value == 1;
        }
      }
      function reversible() {
        return self.left.is_constant() || self.right.is_constant() || !self.left.has_side_effects(compressor) && !self.right.has_side_effects(compressor);
      }
      function reverse(op2) {
        if (reversible()) {
          if (op2)
            self.operator = op2;
          var tmp = self.left;
          self.left = self.right;
          self.right = tmp;
        }
      }
    });
    OPT(AST_SymbolExport, function(self) {
      return self;
    });
    function recursive_ref(compressor, def, fn) {
      var level = 0, node = compressor.self();
      do {
        if (node === fn)
          return node;
        if (is_lambda(node) && node.name && node.name.definition() === def)
          return node;
      } while (node = compressor.parent(level++));
    }
    function same_scope(def) {
      var scope = def.scope.resolve();
      return all(def.references, function(ref) {
        return scope === ref.scope.resolve();
      });
    }
    OPT(AST_SymbolRef, function(self, compressor) {
      if (!compressor.option("ie") && is_undeclared_ref(self) && !(self.scope.resolve().uses_with && compressor.find_parent(AST_With))) {
        switch (self.name) {
          case "undefined":
            return make_node(AST_Undefined, self).optimize(compressor);
          case "NaN":
            return make_node(AST_NaN, self).optimize(compressor);
          case "Infinity":
            return make_node(AST_Infinity, self).optimize(compressor);
        }
      }
      var parent = compressor.parent();
      if (compressor.option("reduce_vars") && is_lhs(compressor.self(), parent) !== compressor.self()) {
        var def = self.definition();
        var fixed = self.fixed_value();
        var single_use = def.single_use && !(parent instanceof AST_Call && parent.is_expr_pure(compressor));
        if (single_use) {
          if (is_lambda(fixed)) {
            if ((def.scope !== self.scope.resolve(true) || def.in_loop) && (!compressor.option("reduce_funcs") || def.escaped.depth == 1 || fixed.inlined)) {
              single_use = false;
            } else if (def.redefined()) {
              single_use = false;
            } else if (recursive_ref(compressor, def, fixed)) {
              single_use = false;
            } else if (fixed.name && fixed.name.definition() !== def) {
              single_use = false;
            } else if (fixed.parent_scope !== self.scope || is_funarg(def)) {
              if (!safe_from_strict_mode(fixed, compressor)) {
                single_use = false;
              } else if ((single_use = fixed.is_constant_expression(self.scope)) == "f") {
                var scope = self.scope;
                do {
                  if (scope instanceof AST_LambdaDefinition || scope instanceof AST_LambdaExpression) {
                    scope.inlined = true;
                  }
                } while (scope = scope.parent_scope);
              }
            } else if (fixed.name && (fixed.name.name == "await" && is_async(fixed) || fixed.name.name == "yield" && is_generator(fixed))) {
              single_use = false;
            } else if (fixed.has_side_effects(compressor)) {
              single_use = false;
            } else if (compressor.option("ie") && fixed instanceof AST_Class) {
              single_use = false;
            }
            if (single_use)
              fixed.parent_scope = self.scope;
          } else if (!fixed || def.recursive_refs > 0 || !fixed.is_constant_expression() || fixed.drop_side_effect_free(compressor)) {
            single_use = false;
          }
        }
        if (single_use) {
          def.single_use = false;
          fixed._squeezed = true;
          fixed.single_use = true;
          if (fixed instanceof AST_DefClass)
            fixed = to_class_expr(fixed);
          if (fixed instanceof AST_LambdaDefinition)
            fixed = to_func_expr(fixed);
          if (is_lambda(fixed)) {
            var scopes = [];
            var scope = self.scope;
            do {
              scopes.push(scope);
              if (scope === def.scope)
                break;
            } while (scope = scope.parent_scope);
            fixed.enclosed.forEach(function(def2) {
              if (fixed.variables.has(def2.name))
                return;
              for (var i = 0;i < scopes.length; i++) {
                var scope2 = scopes[i];
                if (!push_uniq(scope2.enclosed, def2))
                  return;
                scope2.var_names().set(def2.name, true);
              }
            });
          }
          var value;
          if (def.recursive_refs > 0) {
            value = fixed.clone(true);
            var defun_def = value.name.definition();
            var lambda_def = value.variables.get(value.name.name);
            var name = lambda_def && lambda_def.orig[0];
            var def_fn_name, symbol_type;
            if (value instanceof AST_Class) {
              def_fn_name = "def_function";
              symbol_type = AST_SymbolClass;
            } else {
              def_fn_name = "def_variable";
              symbol_type = AST_SymbolLambda;
            }
            if (!(name instanceof symbol_type)) {
              name = make_node(symbol_type, value.name);
              name.scope = value;
              value.name = name;
              lambda_def = value[def_fn_name](name);
              lambda_def.recursive_refs = def.recursive_refs;
            }
            value.walk(new TreeWalker(function(node) {
              if (node instanceof AST_SymbolDeclaration) {
                if (node !== name) {
                  var def2 = node.definition();
                  def2.orig.push(node);
                  def2.eliminated++;
                }
                return;
              }
              if (!(node instanceof AST_SymbolRef))
                return;
              var def2 = node.definition();
              if (def2 === defun_def) {
                node.thedef = def2 = lambda_def;
              } else {
                def2.single_use = false;
                var fn = node.fixed_value();
                if (is_lambda(fn) && fn.name && fn.name.definition() === def2 && def2.scope === fn.name.scope && fixed.variables.get(fn.name.name) === def2) {
                  fn.name = fn.name.clone();
                  node.thedef = def2 = value.variables.get(fn.name.name) || value[def_fn_name](fn.name);
                }
              }
              def2.references.push(node);
            }));
          } else {
            if (fixed instanceof AST_Scope) {
              compressor.push(fixed);
              value = fixed.optimize(compressor);
              compressor.pop();
            } else {
              value = fixed.optimize(compressor);
            }
            value = value.transform(new TreeTransformer(function(node, descend) {
              if (node instanceof AST_Scope)
                return node;
              node = node.clone();
              descend(node, this);
              return node;
            }));
          }
          def.replaced++;
          return value;
        }
        var state;
        if (fixed && (state = self.fixed || def.fixed).should_replace !== false) {
          var ev, init;
          if (fixed instanceof AST_This) {
            if (!is_funarg(def) && same_scope(def) && !cross_class(def))
              init = fixed;
          } else if ((ev = fixed.evaluate(compressor, true)) !== fixed && typeof ev != "function" && (ev === null || typeof ev != "object" || compressor.option("unsafe_regexp") && ev instanceof RegExp && !def.cross_loop && same_scope(def))) {
            init = make_node_from_constant(ev, fixed);
          }
          if (init) {
            if (state.should_replace === undefined) {
              var value_length = init.optimize(compressor).print_to_string().length;
              if (!has_symbol_ref(fixed)) {
                value_length = Math.min(value_length, fixed.print_to_string().length);
              }
              var name_length = def.name.length;
              if (compressor.option("unused") && !compressor.exposed(def)) {
                var refs = def.references.length - def.replaced - def.assignments;
                refs = Math.min(refs, def.references.filter(function(ref) {
                  return ref.fixed === state;
                }).length);
                name_length += (name_length + 2 + value_length) / Math.max(1, refs);
              }
              state.should_replace = value_length - Math.floor(name_length) < compressor.eval_threshold;
            }
            if (state.should_replace) {
              var value;
              if (has_symbol_ref(fixed)) {
                value = init.optimize(compressor);
                if (value === init)
                  value = value.clone(true);
              } else {
                value = best_of_expression(init.optimize(compressor), fixed);
                if (value === init || value === fixed)
                  value = value.clone(true);
              }
              def.replaced++;
              return value;
            }
          }
        }
      }
      return self;
      function cross_class(def2) {
        var scope2 = self.scope;
        while (scope2 !== def2.scope) {
          if (scope2 instanceof AST_Class)
            return true;
          scope2 = scope2.parent_scope;
        }
      }
      function has_symbol_ref(value2) {
        var found;
        value2.walk(new TreeWalker(function(node) {
          if (node instanceof AST_SymbolRef)
            found = true;
          if (found)
            return true;
        }));
        return found;
      }
    });
    function is_raw_tag(compressor, tag) {
      return compressor.option("unsafe") && tag instanceof AST_Dot && tag.property == "raw" && is_undeclared_ref(tag.expression) && tag.expression.name == "String";
    }
    function decode_template(str) {
      var malformed = false;
      str = str.replace(/\\(u\{[^{}]*\}?|u[\s\S]{0,4}|x[\s\S]{0,2}|[0-9]+|[\s\S])/g, function(match, seq) {
        var ch = decode_escape_sequence(seq);
        if (typeof ch == "string")
          return ch;
        malformed = true;
      });
      if (!malformed)
        return str;
    }
    OPT(AST_Template, function(self, compressor) {
      if (!compressor.option("templates"))
        return self;
      var tag = self.tag;
      if (!tag || is_raw_tag(compressor, tag)) {
        var exprs = [];
        var strs = [];
        for (var i = 0, status;i < self.strings.length; i++) {
          var str = self.strings[i];
          if (!tag) {
            var trimmed = decode_template(str);
            if (trimmed)
              str = escape_literal(trimmed);
          }
          if (i > 0) {
            var node = self.expressions[i - 1];
            var value = should_join(node);
            if (value) {
              var prev = strs[strs.length - 1];
              var joined = prev + value + str;
              var decoded;
              if (tag || typeof (decoded = decode_template(joined)) == status) {
                strs[strs.length - 1] = decoded ? escape_literal(decoded) : joined;
                continue;
              }
            }
            exprs.push(node);
          }
          strs.push(str);
          if (!tag)
            status = typeof trimmed;
        }
        if (!tag && strs.length > 1) {
          if (strs[strs.length - 1] == "")
            return make_node(AST_Binary, self, {
              operator: "+",
              left: make_node(AST_Template, self, {
                expressions: exprs.slice(0, -1),
                strings: strs.slice(0, -1)
              }).transform(compressor),
              right: exprs[exprs.length - 1]
            }).optimize(compressor);
          if (strs[0] == "") {
            var left = make_node(AST_Binary, self, {
              operator: "+",
              left: make_node(AST_String, self, { value: "" }),
              right: exprs[0]
            });
            for (var i = 1;strs[i] == "" && i < exprs.length; i++) {
              left = make_node(AST_Binary, self, {
                operator: "+",
                left,
                right: exprs[i]
              });
            }
            return best_of(compressor, self, make_node(AST_Binary, self, {
              operator: "+",
              left: left.transform(compressor),
              right: make_node(AST_Template, self, {
                expressions: exprs.slice(i),
                strings: strs.slice(i)
              }).transform(compressor)
            }).optimize(compressor));
          }
        }
        self.expressions = exprs;
        self.strings = strs;
      }
      return try_evaluate(compressor, self);
      function escape_literal(str2) {
        return str2.replace(/\r|\\|`|\${/g, function(s) {
          return "\\" + (s == "\r" ? "r" : s);
        });
      }
      function should_join(node2) {
        var ev = node2.evaluate(compressor);
        if (ev === node2)
          return;
        if (tag && /\r|\\|`/.test(ev))
          return;
        ev = escape_literal("" + ev);
        if (ev.length > node2.print_to_string().length + "${}".length)
          return;
        return ev;
      }
    });
    function is_atomic(lhs, self) {
      return lhs instanceof AST_SymbolRef || lhs.TYPE === self.TYPE;
    }
    OPT(AST_Undefined, function(self, compressor) {
      if (compressor.option("unsafe_undefined")) {
        var undef = find_scope(compressor).find_variable("undefined");
        if (undef) {
          var ref = make_node(AST_SymbolRef, self, {
            name: "undefined",
            scope: undef.scope,
            thedef: undef
          });
          ref.is_undefined = true;
          return ref;
        }
      }
      var lhs = is_lhs(compressor.self(), compressor.parent());
      if (lhs && is_atomic(lhs, self))
        return self;
      return make_node(AST_UnaryPrefix, self, {
        operator: "void",
        expression: make_node(AST_Number, self, { value: 0 })
      });
    });
    OPT(AST_Infinity, function(self, compressor) {
      var lhs = is_lhs(compressor.self(), compressor.parent());
      if (lhs && is_atomic(lhs, self))
        return self;
      if (compressor.option("keep_infinity") && !lhs && !find_scope(compressor).find_variable("Infinity")) {
        return self;
      }
      return make_node(AST_Binary, self, {
        operator: "/",
        left: make_node(AST_Number, self, { value: 1 }),
        right: make_node(AST_Number, self, { value: 0 })
      });
    });
    OPT(AST_NaN, function(self, compressor) {
      var lhs = is_lhs(compressor.self(), compressor.parent());
      if (lhs && is_atomic(lhs, self))
        return self;
      if (!lhs && !find_scope(compressor).find_variable("NaN"))
        return self;
      return make_node(AST_Binary, self, {
        operator: "/",
        left: make_node(AST_Number, self, { value: 0 }),
        right: make_node(AST_Number, self, { value: 0 })
      });
    });
    function is_reachable(self, defs) {
      var reachable = false;
      var find_ref = new TreeWalker(function(node) {
        if (reachable)
          return true;
        if (node instanceof AST_SymbolRef && member(node.definition(), defs))
          return reachable = true;
      });
      var scan_scope = new TreeWalker(function(node) {
        if (reachable)
          return true;
        if (node instanceof AST_Lambda && node !== self) {
          if (!(node.name || is_async(node) || is_generator(node))) {
            var parent = scan_scope.parent();
            if (parent instanceof AST_Call && parent.expression === node)
              return;
          }
          node.walk(find_ref);
          return true;
        }
      });
      self.walk(scan_scope);
      return reachable;
    }
    var ASSIGN_OPS = makePredicate("+ - * / % >> << >>> | ^ &");
    var ASSIGN_OPS_COMMUTATIVE = makePredicate("* | ^ &");
    OPT(AST_Assign, function(self, compressor) {
      if (compressor.option("dead_code")) {
        if (self.left instanceof AST_PropAccess) {
          if (self.operator == "=") {
            if (self.redundant) {
              var exprs = [self.left.expression];
              if (self.left instanceof AST_Sub)
                exprs.push(self.left.property);
              exprs.push(self.right);
              return make_sequence(self, exprs).optimize(compressor);
            }
            if (self.left.equals(self.right) && !self.left.has_side_effects(compressor)) {
              return self.right;
            }
            var exp = self.left.expression;
            if (exp instanceof AST_Lambda || !compressor.has_directive("use strict") && exp instanceof AST_Constant && !exp.may_throw_on_access(compressor)) {
              return self.left instanceof AST_Dot ? self.right : make_sequence(self, [
                self.left.property,
                self.right
              ]).optimize(compressor);
            }
          }
        } else if (self.left instanceof AST_SymbolRef && can_drop_symbol(self.left, compressor)) {
          var parent;
          if (self.operator == "=" && self.left.equals(self.right) && !((parent = compressor.parent()) instanceof AST_UnaryPrefix && parent.operator == "delete")) {
            return self.right;
          }
          if (self.left.is_immutable())
            return strip_assignment();
          var def = self.left.definition();
          var scope = def.scope.resolve();
          var local = scope === compressor.find_parent(AST_Lambda);
          var level = 0, node;
          parent = compressor.self();
          if (!(scope.uses_arguments && is_funarg(def)) || compressor.has_directive("use strict"))
            do {
              node = parent;
              parent = compressor.parent(level++);
              if (parent instanceof AST_Assign) {
                if (parent.left instanceof AST_SymbolRef && parent.left.definition() === def) {
                  if (in_try(level, parent, !local))
                    break;
                  return strip_assignment(def);
                }
                if (parent.left.match_symbol(function(node2) {
                  if (node2 instanceof AST_PropAccess)
                    return true;
                }))
                  break;
                continue;
              }
              if (parent instanceof AST_Exit) {
                if (!local)
                  break;
                if (in_try(level, parent))
                  break;
                if (is_reachable(scope, [def]))
                  break;
                return strip_assignment(def);
              }
              if (parent instanceof AST_SimpleStatement) {
                if (!local)
                  break;
                if (is_reachable(scope, [def]))
                  break;
                var stat;
                do {
                  stat = parent;
                  parent = compressor.parent(level++);
                  if (parent === scope && is_last_statement(parent.body, stat))
                    return strip_assignment(def);
                } while (is_tail_block(stat, parent));
                break;
              }
              if (parent instanceof AST_VarDef) {
                if (!(parent.name instanceof AST_SymbolDeclaration))
                  continue;
                if (parent.name.definition() !== def)
                  continue;
                if (in_try(level, parent))
                  break;
                return strip_assignment(def);
              }
            } while (is_tail(node, parent));
        }
      }
      if (compressor.option("sequences")) {
        var seq = self.lift_sequences(compressor);
        if (seq !== self)
          return seq.optimize(compressor);
      }
      if (compressor.option("assignments")) {
        if (self.operator == "=" && self.left instanceof AST_SymbolRef && self.right instanceof AST_Binary) {
          if (self.right.left instanceof AST_SymbolRef && self.right.left.name == self.left.name && ASSIGN_OPS[self.right.operator]) {
            return make_compound(self.right.right);
          }
          if (self.right.right instanceof AST_SymbolRef && self.right.right.name == self.left.name && ASSIGN_OPS_COMMUTATIVE[self.right.operator] && !self.right.left.has_side_effects(compressor)) {
            return make_compound(self.right.left);
          }
        }
        if ((self.operator == "-=" || self.operator == "+=" && (self.left.is_boolean(compressor) || self.left.is_number(compressor))) && self.right instanceof AST_Number && self.right.value == 1) {
          var op = self.operator.slice(0, -1);
          return make_node(AST_UnaryPrefix, self, {
            operator: op + op,
            expression: self.left
          });
        }
      }
      return try_evaluate(compressor, self);
      function is_tail(node2, parent2) {
        if (parent2 instanceof AST_Binary)
          switch (node2) {
            case parent2.left:
              return parent2.right.is_constant_expression(scope);
            case parent2.right:
              return true;
            default:
              return false;
          }
        if (parent2 instanceof AST_Conditional)
          switch (node2) {
            case parent2.condition:
              return parent2.consequent.is_constant_expression(scope) && parent2.alternative.is_constant_expression(scope);
            case parent2.consequent:
            case parent2.alternative:
              return true;
            default:
              return false;
          }
        if (parent2 instanceof AST_Sequence) {
          var exprs2 = parent2.expressions;
          var stop = exprs2.indexOf(node2);
          if (stop < 0)
            return false;
          for (var i = exprs2.length;--i > stop; ) {
            if (!exprs2[i].is_constant_expression(scope))
              return false;
          }
          return true;
        }
        return parent2 instanceof AST_UnaryPrefix;
      }
      function is_tail_block(stat2, parent2) {
        if (parent2 instanceof AST_BlockStatement)
          return is_last_statement(parent2.body, stat2);
        if (parent2 instanceof AST_Catch)
          return is_last_statement(parent2.body, stat2);
        if (parent2 instanceof AST_Finally)
          return is_last_statement(parent2.body, stat2);
        if (parent2 instanceof AST_If)
          return parent2.body === stat2 || parent2.alternative === stat2;
        if (parent2 instanceof AST_Try)
          return parent2.bfinally ? parent2.bfinally === stat2 : parent2.bcatch === stat2;
      }
      function in_try(level2, node2, sync) {
        var right = self.right;
        self.right = make_node(AST_Null, right);
        var may_throw = node2.may_throw(compressor);
        self.right = right;
        return find_try(compressor, level2, node2, scope, may_throw, sync);
      }
      function make_compound(rhs) {
        var fixed = self.left.fixed;
        if (fixed)
          fixed.to_binary = replace_ref(function(node2) {
            return node2.left;
          }, fixed);
        return make_node(AST_Assign, self, {
          operator: self.right.operator + "=",
          left: self.left,
          right: rhs
        });
      }
      function strip_assignment(def2) {
        if (def2)
          def2.fixed = false;
        return (self.operator != "=" ? make_node(AST_Binary, self, {
          operator: self.operator.slice(0, -1),
          left: self.left,
          right: self.right
        }) : maintain_this_binding(compressor.parent(), self, self.right)).optimize(compressor);
      }
    });
    OPT(AST_Conditional, function(self, compressor) {
      if (compressor.option("sequences") && self.condition instanceof AST_Sequence) {
        var expressions = self.condition.expressions.slice();
        var node = self.clone();
        node.condition = expressions.pop();
        expressions.push(node);
        return make_sequence(self, expressions).optimize(compressor);
      }
      if (!compressor.option("conditionals"))
        return self;
      var condition = self.condition;
      if (compressor.option("booleans") && !condition.has_side_effects(compressor)) {
        mark_duplicate_condition(compressor, condition);
      }
      condition = fuzzy_eval(compressor, condition);
      if (!condition) {
        AST_Node.warn("Condition always false [{start}]", self);
        return make_sequence(self, [self.condition, self.alternative]).optimize(compressor);
      } else if (!(condition instanceof AST_Node)) {
        AST_Node.warn("Condition always true [{start}]", self);
        return make_sequence(self, [self.condition, self.consequent]).optimize(compressor);
      }
      var first = first_in_statement(compressor);
      var negated = condition.negate(compressor, first);
      if ((first ? best_of_statement : best_of_expression)(condition, negated) === negated) {
        self = make_node(AST_Conditional, self, {
          condition: negated,
          consequent: self.alternative,
          alternative: self.consequent
        });
        negated = condition;
        condition = self.condition;
      }
      var consequent = self.consequent;
      var alternative = self.alternative;
      var cond_lhs = extract_lhs(condition, compressor);
      if (repeatable(compressor, cond_lhs)) {
        if (cond_lhs.equals(consequent))
          return make_node(AST_Binary, self, {
            operator: "||",
            left: condition,
            right: alternative
          }).optimize(compressor);
        if (cond_lhs.equals(alternative))
          return make_node(AST_Binary, self, {
            operator: "&&",
            left: condition,
            right: consequent
          }).optimize(compressor);
      }
      var seq_tail = consequent.tail_node();
      if (seq_tail instanceof AST_Assign) {
        var is_eq = seq_tail.operator == "=";
        var alt_tail = is_eq ? alternative.tail_node() : alternative;
        if ((is_eq || consequent === seq_tail) && alt_tail instanceof AST_Assign && seq_tail.operator == alt_tail.operator && seq_tail.left.equals(alt_tail.left) && (is_eq && seq_tail.left instanceof AST_SymbolRef || !condition.has_side_effects(compressor) && can_shift_lhs_of_tail(consequent) && can_shift_lhs_of_tail(alternative))) {
          return make_node(AST_Assign, self, {
            operator: seq_tail.operator,
            left: seq_tail.left,
            right: make_node(AST_Conditional, self, {
              condition,
              consequent: pop_lhs(consequent),
              alternative: pop_lhs(alternative)
            })
          });
        }
      }
      var alt_tail = alternative.tail_node();
      if (seq_tail.equals(alt_tail))
        return make_sequence(self, consequent.equals(alternative) ? [
          condition,
          consequent
        ] : [
          make_node(AST_Conditional, self, {
            condition,
            consequent: pop_seq(consequent),
            alternative: pop_seq(alternative)
          }),
          alt_tail
        ]).optimize(compressor);
      var combined = combine_tail(consequent, alternative, true);
      if (combined)
        return combined;
      var arg_index;
      if (consequent instanceof AST_Call && alternative.TYPE == consequent.TYPE && (arg_index = arg_diff(consequent, alternative)) >= 0 && consequent.expression.equals(alternative.expression) && !condition.has_side_effects(compressor) && !consequent.expression.has_side_effects(compressor)) {
        var node = consequent.clone();
        var arg = consequent.args[arg_index];
        node.args[arg_index] = arg instanceof AST_Spread ? make_node(AST_Spread, self, {
          expression: make_node(AST_Conditional, self, {
            condition,
            consequent: arg.expression,
            alternative: alternative.args[arg_index].expression
          })
        }) : make_node(AST_Conditional, self, {
          condition,
          consequent: arg,
          alternative: alternative.args[arg_index]
        });
        return node;
      }
      if (seq_tail instanceof AST_Conditional && seq_tail.alternative.equals(alternative)) {
        return make_node(AST_Conditional, self, {
          condition: make_node(AST_Binary, self, {
            left: condition,
            operator: "&&",
            right: fuse(consequent, seq_tail, "condition")
          }),
          consequent: seq_tail.consequent,
          alternative: merge_expression(seq_tail.alternative, alternative)
        });
      }
      if (seq_tail instanceof AST_Conditional && seq_tail.consequent.equals(alternative)) {
        return make_node(AST_Conditional, self, {
          condition: make_node(AST_Binary, self, {
            left: negated,
            operator: "||",
            right: fuse(consequent, seq_tail, "condition")
          }),
          consequent: merge_expression(seq_tail.consequent, alternative),
          alternative: seq_tail.alternative
        });
      }
      if (alt_tail instanceof AST_Conditional && consequent.equals(alt_tail.consequent)) {
        return make_node(AST_Conditional, self, {
          condition: make_node(AST_Binary, self, {
            left: condition,
            operator: "||",
            right: fuse(alternative, alt_tail, "condition")
          }),
          consequent: merge_expression(consequent, alt_tail.consequent),
          alternative: alt_tail.alternative
        });
      }
      if (alt_tail instanceof AST_Conditional && consequent.equals(alt_tail.alternative)) {
        return make_node(AST_Conditional, self, {
          condition: make_node(AST_Binary, self, {
            left: negated,
            operator: "&&",
            right: fuse(alternative, alt_tail, "condition")
          }),
          consequent: alt_tail.consequent,
          alternative: merge_expression(consequent, alt_tail.alternative)
        });
      }
      if (seq_tail instanceof AST_Binary && seq_tail.operator == "&&" && seq_tail.right.equals(alternative)) {
        return make_node(AST_Binary, self, {
          operator: "&&",
          left: make_node(AST_Binary, self, {
            operator: "||",
            left: negated,
            right: fuse(consequent, seq_tail, "left")
          }),
          right: merge_expression(seq_tail.right, alternative)
        }).optimize(compressor);
      }
      if (seq_tail instanceof AST_Binary && seq_tail.operator == "||" && seq_tail.right.equals(alternative)) {
        return make_node(AST_Binary, self, {
          operator: "||",
          left: make_node(AST_Binary, self, {
            operator: "&&",
            left: condition,
            right: fuse(consequent, seq_tail, "left")
          }),
          right: merge_expression(seq_tail.right, alternative)
        }).optimize(compressor);
      }
      if (alt_tail instanceof AST_Binary && alt_tail.operator == "&&" && alt_tail.right.equals(consequent)) {
        return make_node(AST_Binary, self, {
          operator: "&&",
          left: make_node(AST_Binary, self, {
            operator: "||",
            left: condition,
            right: fuse(alternative, alt_tail, "left")
          }),
          right: merge_expression(consequent, alt_tail.right)
        }).optimize(compressor);
      }
      if (alt_tail instanceof AST_Binary && alt_tail.operator == "||" && alt_tail.right.equals(consequent)) {
        return make_node(AST_Binary, self, {
          operator: "||",
          left: make_node(AST_Binary, self, {
            operator: "&&",
            left: negated,
            right: fuse(alternative, alt_tail, "left")
          }),
          right: merge_expression(consequent, alt_tail.right)
        }).optimize(compressor);
      }
      var in_bool = compressor.option("booleans") && compressor.in_boolean_context();
      if (is_true(consequent)) {
        if (is_false(alternative))
          return booleanize(condition);
        return make_node(AST_Binary, self, {
          operator: "||",
          left: booleanize(condition),
          right: alternative
        }).optimize(compressor);
      }
      if (is_false(consequent)) {
        if (is_true(alternative))
          return booleanize(condition.negate(compressor));
        return make_node(AST_Binary, self, {
          operator: "&&",
          left: booleanize(condition.negate(compressor)),
          right: alternative
        }).optimize(compressor);
      }
      if (is_true(alternative))
        return make_node(AST_Binary, self, {
          operator: "||",
          left: booleanize(condition.negate(compressor)),
          right: consequent
        }).optimize(compressor);
      if (is_false(alternative))
        return make_node(AST_Binary, self, {
          operator: "&&",
          left: booleanize(condition),
          right: consequent
        }).optimize(compressor);
      if (compressor.option("typeofs"))
        mark_locally_defined(condition, consequent, alternative);
      return self;
      function booleanize(node2) {
        if (node2.is_boolean(compressor))
          return node2;
        return make_node(AST_UnaryPrefix, node2, {
          operator: "!",
          expression: node2.negate(compressor)
        });
      }
      function is_true(node2) {
        return node2 instanceof AST_True || in_bool && node2 instanceof AST_Constant && node2.value || node2 instanceof AST_UnaryPrefix && node2.operator == "!" && node2.expression instanceof AST_Constant && !node2.expression.value;
      }
      function is_false(node2) {
        return node2 instanceof AST_False || in_bool && (node2 instanceof AST_Constant && !node2.value || node2 instanceof AST_UnaryPrefix && node2.operator == "void" && !node2.expression.has_side_effects(compressor)) || node2 instanceof AST_UnaryPrefix && node2.operator == "!" && node2.expression instanceof AST_Constant && node2.expression.value;
      }
      function arg_diff(consequent2, alternative2) {
        var a = consequent2.args;
        var b = alternative2.args;
        var len = a.length;
        if (len != b.length)
          return -2;
        for (var i = 0;i < len; i++) {
          if (!a[i].equals(b[i])) {
            if (a[i] instanceof AST_Spread !== b[i] instanceof AST_Spread)
              return -3;
            for (var j = i + 1;j < len; j++) {
              if (!a[j].equals(b[j]))
                return -2;
            }
            return i;
          }
        }
        return -1;
      }
      function fuse(node2, tail, prop) {
        if (node2 === tail)
          return tail[prop];
        var exprs = node2.expressions.slice(0, -1);
        exprs.push(tail[prop]);
        return make_sequence(node2, exprs);
      }
      function is_tail_equivalent(consequent2, alternative2) {
        if (consequent2.TYPE != alternative2.TYPE)
          return;
        if (consequent2.optional != alternative2.optional)
          return;
        if (consequent2 instanceof AST_Call) {
          if (arg_diff(consequent2, alternative2) != -1)
            return;
          return consequent2.TYPE != "Call" || !(consequent2.expression instanceof AST_PropAccess || alternative2.expression instanceof AST_PropAccess) || is_tail_equivalent(consequent2.expression, alternative2.expression);
        }
        if (!(consequent2 instanceof AST_PropAccess))
          return;
        var p = consequent2.property;
        var q = alternative2.property;
        return (p instanceof AST_Node ? p.equals(q) : p == q) && !(consequent2.expression instanceof AST_Super || alternative2.expression instanceof AST_Super);
      }
      function combine_tail(consequent2, alternative2, top) {
        var seq_tail2 = consequent2.tail_node();
        var alt_tail2 = alternative2.tail_node();
        if (!is_tail_equivalent(seq_tail2, alt_tail2))
          return !top && make_node(AST_Conditional, self, {
            condition,
            consequent: consequent2,
            alternative: alternative2
          });
        var node2 = seq_tail2.clone();
        var seq_expr = fuse(consequent2, seq_tail2, "expression");
        var alt_expr = fuse(alternative2, alt_tail2, "expression");
        var combined2 = combine_tail(seq_expr, alt_expr);
        if (seq_tail2.expression instanceof AST_Sequence) {
          combined2 = maintain_this_binding(seq_tail2, seq_tail2.expression, combined2);
        }
        node2.expression = combined2;
        return node2;
      }
      function can_shift_lhs_of_tail(node2) {
        return node2 === node2.tail_node() || all(node2.expressions.slice(0, -1), function(expr) {
          return !expr.has_side_effects(compressor);
        });
      }
      function pop_lhs(node2) {
        if (!(node2 instanceof AST_Sequence))
          return node2.right;
        var exprs = node2.expressions.slice();
        exprs.push(exprs.pop().right);
        return make_sequence(node2, exprs);
      }
      function pop_seq(node2) {
        if (!(node2 instanceof AST_Sequence))
          return make_node(AST_Number, node2, { value: 0 });
        return make_sequence(node2, node2.expressions.slice(0, -1));
      }
    });
    OPT(AST_Boolean, function(self, compressor) {
      if (!compressor.option("booleans"))
        return self;
      if (compressor.in_boolean_context())
        return make_node(AST_Number, self, { value: +self.value });
      var p = compressor.parent();
      if (p instanceof AST_Binary && (p.operator == "==" || p.operator == "!=")) {
        AST_Node.warn("Non-strict equality against boolean: {operator} {value} [{start}]", {
          operator: p.operator,
          value: self.value,
          start: p.start
        });
        return make_node(AST_Number, self, { value: +self.value });
      }
      return make_node(AST_UnaryPrefix, self, {
        operator: "!",
        expression: make_node(AST_Number, self, { value: 1 - self.value })
      });
    });
    OPT(AST_Spread, function(self, compressor) {
      var exp = self.expression;
      if (compressor.option("spreads") && exp instanceof AST_Array && !(compressor.parent() instanceof AST_Object)) {
        return List.splice(exp.elements.map(function(node) {
          return node instanceof AST_Hole ? make_node(AST_Undefined, node).optimize(compressor) : node;
        }));
      }
      return self;
    });
    function safe_to_flatten(value, compressor) {
      if (!value)
        return false;
      var parent = compressor.parent();
      if (parent.TYPE != "Call")
        return true;
      if (parent.expression !== compressor.self())
        return true;
      if (value instanceof AST_SymbolRef) {
        value = value.fixed_value();
        if (!value)
          return false;
      }
      return value instanceof AST_Lambda && !value.contains_this();
    }
    OPT(AST_Sub, function(self, compressor) {
      var expr = self.expression;
      var prop = self.property;
      var terminated = trim_optional_chain(self, compressor);
      if (terminated)
        return terminated;
      if (compressor.option("properties")) {
        var key = prop.evaluate(compressor);
        if (key !== prop) {
          if (typeof key == "string") {
            if (key == "undefined") {
              key = undefined;
            } else {
              var value = parseFloat(key);
              if (value.toString() == key) {
                key = value;
              }
            }
          }
          prop = self.property = best_of_expression(prop, make_node_from_constant(key, prop).transform(compressor));
          var property = "" + key;
          if (is_identifier_string(property) && property.length <= prop.print_to_string().length + 1) {
            return make_node(AST_Dot, self, {
              optional: self.optional,
              expression: expr,
              property,
              quoted: true
            }).optimize(compressor);
          }
        }
      }
      var parent = compressor.parent();
      var assigned = is_lhs(compressor.self(), parent);
      var def, fn, fn_parent, index;
      if (compressor.option("arguments") && expr instanceof AST_SymbolRef && is_arguments(def = expr.definition()) && !expr.in_arg && prop instanceof AST_Number && Math.floor(index = prop.value) == index && (fn = def.scope) === find_lambda() && fn.uses_arguments < (assigned ? 2 : 3)) {
        if (parent instanceof AST_UnaryPrefix && parent.operator == "delete") {
          if (!def.deleted)
            def.deleted = [];
          def.deleted[index] = true;
        }
        var argname = fn.argnames[index];
        if (def.deleted && def.deleted[index]) {
          argname = null;
        } else if (argname) {
          var arg_def;
          if (!(argname instanceof AST_SymbolFunarg) || argname.name == "await" || expr.scope.find_variable(argname.name) !== (arg_def = argname.definition())) {
            argname = null;
          } else if (compressor.has_directive("use strict") || fn.name || fn.rest || !(fn_parent instanceof AST_Call && index < fn_parent.args.length && all(fn_parent.args.slice(0, index + 1), function(arg) {
            return !(arg instanceof AST_Spread);
          })) || !all(fn.argnames, function(argname2) {
            return argname2 instanceof AST_SymbolFunarg;
          })) {
            if (has_reassigned() || arg_def.assignments || arg_def.orig.length > 1)
              argname = null;
          }
        } else if ((assigned || !has_reassigned()) && index < fn.argnames.length + 5 && compressor.drop_fargs(fn, fn_parent) && !fn.rest) {
          while (index >= fn.argnames.length) {
            argname = fn.make_var(AST_SymbolFunarg, fn, "argument_" + fn.argnames.length);
            fn.argnames.push(argname);
          }
        }
        if (argname && find_if(function(node) {
          return node.name === argname.name;
        }, fn.argnames) === argname) {
          if (assigned)
            def.reassigned--;
          var sym = make_node(AST_SymbolRef, argname);
          sym.reference();
          argname.unused = undefined;
          return sym;
        }
      }
      if (assigned)
        return self;
      if (compressor.option("sequences") && parent.TYPE != "Call" && !(parent instanceof AST_ForEnumeration && parent.init === self)) {
        var seq = lift_sequence_in_expression(self, compressor);
        if (seq !== self)
          return seq.optimize(compressor);
      }
      if (key !== prop) {
        var sub = self.flatten_object(property, compressor);
        if (sub) {
          expr = self.expression = sub.expression;
          prop = self.property = sub.property;
        }
      }
      var elements;
      if (compressor.option("properties") && compressor.option("side_effects") && prop instanceof AST_Number && expr instanceof AST_Array && all(elements = expr.elements, function(value2) {
        return !(value2 instanceof AST_Spread);
      })) {
        var index = prop.value;
        var retValue = elements[index];
        if (safe_to_flatten(retValue, compressor)) {
          var is_hole = retValue instanceof AST_Hole;
          var flatten = !is_hole;
          var values = [];
          for (var i = elements.length;--i > index; ) {
            var value = elements[i].drop_side_effect_free(compressor);
            if (value) {
              values.unshift(value);
              if (flatten && value.has_side_effects(compressor))
                flatten = false;
            }
          }
          if (!flatten)
            values.unshift(retValue);
          while (--i >= 0) {
            var value = elements[i].drop_side_effect_free(compressor);
            if (value) {
              values.unshift(value);
            } else if (is_hole) {
              values.unshift(make_node(AST_Hole, elements[i]));
            } else {
              index--;
            }
          }
          if (flatten) {
            values.push(retValue);
            return make_sequence(self, values).optimize(compressor);
          }
          return make_node(AST_Sub, self, {
            expression: make_node(AST_Array, expr, { elements: values }),
            property: make_node(AST_Number, prop, { value: index })
          });
        }
      }
      return try_evaluate(compressor, self);
      function find_lambda() {
        var i2 = 0, p;
        while (p = compressor.parent(i2++)) {
          if (p instanceof AST_Lambda) {
            if (p instanceof AST_Accessor)
              return;
            if (is_arrow(p))
              continue;
            fn_parent = compressor.parent(i2);
            return p;
          }
        }
      }
      function has_reassigned() {
        return !compressor.option("reduce_vars") || def.reassigned;
      }
    });
    AST_LambdaExpression.DEFMETHOD("contains_super", function() {
      var result = false;
      var self = this;
      self.walk(new TreeWalker(function(node) {
        if (result)
          return true;
        if (node instanceof AST_Super)
          return result = true;
        if (node !== self && node instanceof AST_Scope && !is_arrow(node))
          return true;
      }));
      return result;
    });
    (function(def) {
      def(AST_Arrow, return_false);
      def(AST_AsyncArrow, return_false);
      def(AST_Node, function() {
        var result = false;
        var self = this;
        self.walk(new TreeWalker(function(node) {
          if (result)
            return true;
          if (node instanceof AST_This)
            return result = true;
          if (node !== self && node instanceof AST_Scope && !is_arrow(node))
            return true;
        }));
        return result;
      });
    })(function(node, func) {
      node.DEFMETHOD("contains_this", func);
    });
    function can_hoist_property(prop) {
      return prop instanceof AST_ObjectKeyVal && typeof prop.key == "string" && !(prop instanceof AST_ObjectMethod && prop.value.contains_super());
    }
    AST_PropAccess.DEFMETHOD("flatten_object", function(key, compressor) {
      if (!compressor.option("properties"))
        return;
      if (key === "__proto__")
        return;
      var self = this;
      var expr = self.expression;
      if (!(expr instanceof AST_Object))
        return;
      var props = expr.properties;
      for (var i = props.length;--i >= 0; ) {
        var prop = props[i];
        if (prop.key !== key)
          continue;
        if (!all(props, can_hoist_property))
          return;
        if (!safe_to_flatten(prop.value, compressor))
          return;
        var call, scope, values = [];
        for (var j = 0;j < props.length; j++) {
          var value = props[j].value;
          if (props[j] instanceof AST_ObjectMethod) {
            var arrow = !(value.uses_arguments || is_generator(value) || value.contains_this());
            if (arrow) {
              if (!scope)
                scope = compressor.find_parent(AST_Scope);
              var avoid = avoid_await_yield(compressor, scope);
              value.each_argname(function(argname) {
                if (avoid[argname.name])
                  arrow = false;
              });
            }
            var ctor;
            if (arrow) {
              ctor = is_async(value) ? AST_AsyncArrow : AST_Arrow;
            } else if (i != j || (call = compressor.parent()) instanceof AST_Call && call.expression === self) {
              ctor = value.CTOR;
            } else {
              return;
            }
            value = make_node(ctor, value);
          }
          values.push(value);
        }
        return make_node(AST_Sub, self, {
          expression: make_node(AST_Array, expr, { elements: values }),
          property: make_node(AST_Number, self, { value: i })
        });
      }
    });
    OPT(AST_Dot, function(self, compressor) {
      if (self.property == "arguments" || self.property == "caller") {
        AST_Node.warn("Function.prototype.{property} not supported [{start}]", self);
      }
      var parent = compressor.parent();
      if (is_lhs(compressor.self(), parent))
        return self;
      var terminated = trim_optional_chain(self, compressor);
      if (terminated)
        return terminated;
      if (compressor.option("sequences") && parent.TYPE != "Call" && !(parent instanceof AST_ForEnumeration && parent.init === self)) {
        var seq = lift_sequence_in_expression(self, compressor);
        if (seq !== self)
          return seq.optimize(compressor);
      }
      if (compressor.option("unsafe_proto") && self.expression instanceof AST_Dot && self.expression.property == "prototype") {
        var exp = self.expression.expression;
        if (is_undeclared_ref(exp))
          switch (exp.name) {
            case "Array":
              self.expression = make_node(AST_Array, self.expression, { elements: [] });
              break;
            case "Function":
              self.expression = make_node(AST_Function, self.expression, {
                argnames: [],
                body: []
              }).init_vars(exp.scope);
              break;
            case "Number":
              self.expression = make_node(AST_Number, self.expression, { value: 0 });
              break;
            case "Object":
              self.expression = make_node(AST_Object, self.expression, { properties: [] });
              break;
            case "RegExp":
              self.expression = make_node(AST_RegExp, self.expression, { value: /t/ });
              break;
            case "String":
              self.expression = make_node(AST_String, self.expression, { value: "" });
              break;
          }
      }
      var sub = self.flatten_object(self.property, compressor);
      if (sub)
        return sub.optimize(compressor);
      return try_evaluate(compressor, self);
    });
    OPT(AST_DestructuredArray, function(self, compressor) {
      if (compressor.option("rests") && self.rest instanceof AST_DestructuredArray) {
        return make_node(AST_DestructuredArray, self, {
          elements: self.elements.concat(self.rest.elements),
          rest: self.rest.rest
        });
      }
      return self;
    });
    OPT(AST_DestructuredKeyVal, function(self, compressor) {
      if (compressor.option("objects")) {
        var key = self.key;
        if (key instanceof AST_Node) {
          key = key.evaluate(compressor);
          if (key !== self.key)
            self.key = "" + key;
        }
      }
      return self;
    });
    OPT(AST_Object, function(self, compressor) {
      if (!compressor.option("objects"))
        return self;
      var changed = false;
      var found = false;
      var generated = false;
      var keep_duplicate = compressor.has_directive("use strict");
      var keys = [];
      var map = new Dictionary;
      var values = [];
      self.properties.forEach(function(prop) {
        if (!(prop instanceof AST_Spread))
          return process2(prop);
        found = true;
        var exp = prop.expression;
        if (compressor.option("spreads") && exp instanceof AST_Object && all(exp.properties, function(prop2) {
          if (prop2 instanceof AST_ObjectGetter)
            return false;
          if (prop2 instanceof AST_Spread)
            return false;
          if (prop2.key !== "__proto__")
            return true;
          if (prop2 instanceof AST_ObjectSetter)
            return true;
          return !prop2.value.has_side_effects(compressor);
        })) {
          changed = true;
          exp.properties.forEach(function(prop2) {
            var key = prop2.key;
            var setter = prop2 instanceof AST_ObjectSetter;
            if (key === "__proto__") {
              if (!setter)
                return;
              key = make_node_from_constant(key, prop2);
            }
            process2(setter ? make_node(AST_ObjectKeyVal, prop2, {
              key,
              value: make_node(AST_Undefined, prop2).optimize(compressor)
            }) : prop2);
          });
        } else {
          generated = true;
          flush();
          values.push(prop);
        }
      });
      flush();
      if (!changed)
        return self;
      if (found && generated && values.length == 1) {
        var value = values[0];
        if (value instanceof AST_ObjectProperty && value.key instanceof AST_Number) {
          value.key = "" + value.key.value;
        }
      }
      return make_node(AST_Object, self, { properties: values });
      function flush() {
        keys.forEach(function(key) {
          var props = map.get(key);
          switch (props.length) {
            case 0:
              return;
            case 1:
              return values.push(props[0]);
          }
          changed = true;
          var tail = keep_duplicate && !generated && props.pop();
          values.push(props.length == 1 ? props[0] : make_node(AST_ObjectKeyVal, self, {
            key: props[0].key,
            value: make_sequence(self, props.map(function(prop) {
              return prop.value;
            }))
          }));
          if (tail)
            values.push(tail);
          props.length = 0;
        });
        keys = [];
        map = new Dictionary;
      }
      function process2(prop) {
        var key = prop.key;
        if (key instanceof AST_Node) {
          found = true;
          key = key.evaluate(compressor);
          if (key === prop.key || key === "__proto__") {
            generated = true;
          } else {
            key = prop.key = "" + key;
          }
        }
        if (can_hoist_property(prop)) {
          if (prop.value.has_side_effects(compressor))
            flush();
          keys.push(key);
          map.add(key, prop);
        } else {
          flush();
          values.push(prop);
        }
        if (found && !generated && typeof key == "string" && RE_POSITIVE_INTEGER.test(key)) {
          generated = true;
          if (map.has(key))
            prop = map.get(key)[0];
          prop.key = make_node(AST_Number, prop, { value: +key });
        }
      }
    });
    function flatten_var(name) {
      var redef = name.definition().redefined();
      if (redef) {
        name = name.clone();
        name.thedef = redef;
      }
      return name;
    }
    function has_arg_refs(fn, node) {
      var found = false;
      node.walk(new TreeWalker(function(node2) {
        if (found)
          return true;
        if (node2 instanceof AST_SymbolRef && fn.variables.get(node2.name) === node2.definition()) {
          return found = true;
        }
      }));
      return found;
    }
    function insert_assign(def, assign) {
      var visited = [];
      def.references.forEach(function(ref) {
        var fixed = ref.fixed;
        if (!fixed || !push_uniq(visited, fixed))
          return;
        if (fixed.assigns) {
          fixed.assigns.unshift(assign);
        } else {
          fixed.assigns = [assign];
        }
      });
    }
    function init_ref(compressor, name) {
      var sym = make_node(AST_SymbolRef, name);
      var assign = make_node(AST_Assign, name, {
        operator: "=",
        left: sym,
        right: make_node(AST_Undefined, name).transform(compressor)
      });
      var def = name.definition();
      if (def.fixed) {
        sym.fixed = function() {
          return assign.right;
        };
        sym.fixed.assigns = [assign];
        insert_assign(def, assign);
      }
      def.assignments++;
      def.references.push(sym);
      return assign;
    }
    (function(def) {
      def(AST_Node, noop);
      def(AST_Assign, noop);
      def(AST_Await, function(compressor, scope, no_return, in_loop) {
        if (!compressor.option("awaits"))
          return;
        var self = this;
        var inlined = self.expression.try_inline(compressor, scope, no_return, in_loop, true);
        if (!inlined)
          return;
        if (!no_return)
          scan_local_returns(inlined, function(node) {
            node.in_bool = false;
            var value = node.value;
            if (value instanceof AST_Await)
              return;
            node.value = make_node(AST_Await, self, {
              expression: value || make_node(AST_Undefined, node).transform(compressor)
            });
          });
        return aborts(inlined) ? inlined : make_node(AST_BlockStatement, self, {
          body: [inlined, make_node(AST_SimpleStatement, self, {
            body: make_node(AST_Await, self, { expression: make_node(AST_Number, self, { value: 0 }) })
          })]
        });
      });
      def(AST_Binary, function(compressor, scope, no_return, in_loop, in_await) {
        if (no_return === undefined)
          return;
        var self = this;
        var op = self.operator;
        if (!lazy_op[op])
          return;
        var inlined = self.right.try_inline(compressor, scope, no_return, in_loop, in_await);
        if (!inlined)
          return;
        return make_node(AST_If, self, {
          condition: make_condition(self.left),
          body: inlined,
          alternative: no_return ? null : make_node(AST_Return, self, {
            value: make_node(AST_Undefined, self).transform(compressor)
          })
        });
        function make_condition(cond) {
          switch (op) {
            case "&&":
              return cond;
            case "||":
              return cond.negate(compressor);
            case "??":
              return make_node(AST_Binary, self, {
                operator: "==",
                left: make_node(AST_Null, self),
                right: cond
              });
          }
        }
      });
      def(AST_BlockStatement, function(compressor, scope, no_return, in_loop) {
        if (no_return)
          return;
        if (!this.variables)
          return;
        var body = this.body;
        var last = body.length - 1;
        if (last < 0)
          return;
        var inlined = body[last].try_inline(compressor, this, no_return, in_loop);
        if (!inlined)
          return;
        body[last] = inlined;
        return this;
      });
      def(AST_Call, function(compressor, scope, no_return, in_loop, in_await) {
        if (compressor.option("inline") < 4)
          return;
        var call = this;
        if (call.is_expr_pure(compressor))
          return;
        var fn = call.expression;
        if (!(fn instanceof AST_LambdaExpression))
          return;
        if (fn.name)
          return;
        if (fn.uses_arguments)
          return;
        if (fn.pinned())
          return;
        if (is_generator(fn))
          return;
        var arrow = is_arrow(fn);
        if (arrow && fn.value)
          return;
        if (fn.body[0] instanceof AST_Directive)
          return;
        if (fn.contains_this())
          return;
        if (!scope)
          scope = find_scope(compressor);
        var defined = new Dictionary;
        defined.set("NaN", true);
        while (!(scope instanceof AST_Scope)) {
          scope.variables.each(function(def2) {
            defined.set(def2.name, true);
          });
          scope = scope.parent_scope;
        }
        if (!member(scope, compressor.stack))
          return;
        if (scope.pinned() && fn.variables.size() > (arrow ? 0 : 1))
          return;
        if (scope instanceof AST_Toplevel) {
          if (fn.variables.size() > (arrow ? 0 : 1)) {
            if (!compressor.toplevel.vars)
              return;
            if (fn.functions.size() > 0 && !compressor.toplevel.funcs)
              return;
          }
          defined.set("arguments", true);
        }
        var async = !in_await && is_async(fn);
        if (async) {
          if (!compressor.option("awaits"))
            return;
          if (!is_async(scope))
            return;
          if (call.may_throw(compressor))
            return;
        }
        var names = scope.var_names();
        if (in_loop)
          in_loop = [];
        if (!fn.variables.all(function(def2, name) {
          if (in_loop)
            in_loop.push(def2);
          if (!defined.has(name) && !names.has(name))
            return true;
          return !arrow && name == "arguments" && def2.orig.length == 1;
        }))
          return;
        if (in_loop && in_loop.length > 0 && is_reachable(fn, in_loop))
          return;
        var simple_argnames = true;
        if (!all(fn.argnames, function(argname) {
          var abort = false;
          var tw = new TreeWalker(function(node) {
            if (abort)
              return true;
            if (node instanceof AST_DefaultValue) {
              if (has_arg_refs(fn, node.value))
                return abort = true;
              node.name.walk(tw);
              return true;
            }
            if (node instanceof AST_DestructuredKeyVal) {
              if (node.key instanceof AST_Node && has_arg_refs(fn, node.key))
                return abort = true;
              node.value.walk(tw);
              return true;
            }
            if (node instanceof AST_SymbolFunarg && !all(node.definition().orig, function(sym) {
              return !(sym instanceof AST_SymbolDefun);
            }))
              return abort = true;
          });
          argname.walk(tw);
          if (abort)
            return false;
          if (!(argname instanceof AST_SymbolFunarg))
            simple_argnames = false;
          return true;
        }))
          return;
        if (fn.rest) {
          if (has_arg_refs(fn, fn.rest))
            return;
          simple_argnames = false;
        }
        var verify_body;
        if (no_return) {
          verify_body = function(stat) {
            var abort = false;
            stat.walk(new TreeWalker(function(node) {
              if (abort)
                return true;
              if (async && (node instanceof AST_Await || node instanceof AST_ForAwaitOf) || node instanceof AST_Return) {
                return abort = true;
              }
              if (node instanceof AST_Scope)
                return true;
            }));
            return !abort;
          };
        } else if (in_await || is_async(fn) || in_async_generator(scope)) {
          verify_body = function(stat) {
            var abort = false;
            var find_return = new TreeWalker(function(node) {
              if (abort)
                return true;
              if (node instanceof AST_Return)
                return abort = true;
              if (node instanceof AST_Scope)
                return true;
            });
            stat.walk(new TreeWalker(function(node) {
              if (abort)
                return true;
              if (node instanceof AST_Try) {
                if (node.bfinally && all(node.body, function(stat2) {
                  stat2.walk(find_return);
                  return !abort;
                }) && node.bcatch)
                  node.bcatch.walk(find_return);
                return true;
              }
              if (node instanceof AST_Scope)
                return true;
            }));
            return !abort;
          };
        }
        if (verify_body && !all(fn.body, verify_body))
          return;
        if (!safe_from_await_yield(fn, avoid_await_yield(compressor, scope)))
          return;
        fn.functions.each(function(def2, name) {
          scope.functions.set(name, def2);
        });
        var body = [];
        fn.variables.each(function(def2, name) {
          if (!arrow && name == "arguments" && def2.orig.length == 1)
            return;
          names.set(name, true);
          scope.enclosed.push(def2);
          scope.variables.set(name, def2);
          def2.single_use = false;
          if (!in_loop)
            return;
          if (def2.references.length == def2.replaced)
            return;
          if (def2.orig.length == def2.eliminated)
            return;
          if (def2.orig.length == 1 && fn.functions.has(name))
            return;
          if (!all(def2.orig, function(sym2) {
            if (sym2 instanceof AST_SymbolConst)
              return false;
            if (sym2 instanceof AST_SymbolFunarg)
              return !sym2.unused && def2.scope.resolve() !== fn;
            if (sym2 instanceof AST_SymbolLet)
              return false;
            return true;
          }))
            return;
          var sym = def2.orig[0];
          if (sym instanceof AST_SymbolCatch)
            return;
          body.push(make_node(AST_SimpleStatement, sym, { body: init_ref(compressor, flatten_var(sym)) }));
        });
        var defs = Object.create(null), syms = new Dictionary;
        if (simple_argnames && all(call.args, function(arg) {
          return !(arg instanceof AST_Spread);
        })) {
          var values = call.args.slice();
          fn.argnames.forEach(function(argname) {
            var value = values.shift();
            if (argname.unused) {
              if (value)
                body.push(make_node(AST_SimpleStatement, call, { body: value }));
              return;
            }
            var defn = make_node(AST_VarDef, call, {
              name: argname.convert_symbol(AST_SymbolVar, process2),
              value: value || make_node(AST_Undefined, call).transform(compressor)
            });
            if (argname instanceof AST_SymbolFunarg)
              insert_assign(argname.definition(), defn);
            body.push(make_node(AST_Var, call, { definitions: [defn] }));
          });
          if (values.length)
            body.push(make_node(AST_SimpleStatement, call, {
              body: make_sequence(call, values)
            }));
        } else {
          body.push(make_node(AST_Var, call, {
            definitions: [make_node(AST_VarDef, call, {
              name: make_node(AST_DestructuredArray, call, {
                elements: fn.argnames.map(function(argname) {
                  if (argname.unused)
                    return make_node(AST_Hole, argname);
                  return argname.convert_symbol(AST_SymbolVar, process2);
                }),
                rest: fn.rest && fn.rest.convert_symbol(AST_SymbolVar, process2)
              }),
              value: make_node(AST_Array, call, { elements: call.args.slice() })
            })]
          }));
        }
        syms.each(function(orig, id) {
          var def2 = defs[id];
          [].unshift.apply(def2.orig, orig);
          def2.eliminated += orig.length;
        });
        [].push.apply(body, in_loop ? fn.body.filter(function(stat) {
          if (!(stat instanceof AST_LambdaDefinition))
            return true;
          var name = make_node(AST_SymbolVar, flatten_var(stat.name));
          var def2 = name.definition();
          def2.fixed = false;
          def2.orig.push(name);
          def2.eliminated++;
          body.push(make_node(AST_Var, stat, {
            definitions: [make_node(AST_VarDef, stat, {
              name,
              value: to_func_expr(stat, true)
            })]
          }));
          return false;
        }) : fn.body);
        var inlined = make_node(AST_BlockStatement, call, { body });
        if (!no_return) {
          if (async)
            scan_local_returns(inlined, function(node) {
              var value = node.value;
              if (is_undefined(value))
                return;
              node.value = make_node(AST_Await, call, { expression: value });
            });
          body.push(make_node(AST_Return, call, {
            value: in_async_generator(scope) ? make_node(AST_Undefined, call).transform(compressor) : null
          }));
        }
        return inlined;
        function process2(sym, argname) {
          var def2 = argname.definition();
          defs[def2.id] = def2;
          syms.add(def2.id, sym);
        }
      });
      def(AST_Conditional, function(compressor, scope, no_return, in_loop, in_await) {
        var self = this;
        var body = self.consequent.try_inline(compressor, scope, no_return, in_loop, in_await);
        var alt = self.alternative.try_inline(compressor, scope, no_return, in_loop, in_await);
        if (!body && !alt)
          return;
        return make_node(AST_If, self, {
          condition: self.condition,
          body: body || make_body(self.consequent),
          alternative: alt || make_body(self.alternative)
        });
        function make_body(value) {
          if (no_return)
            return make_node(AST_SimpleStatement, value, { body: value });
          return make_node(AST_Return, value, { value });
        }
      });
      def(AST_For, function(compressor, scope, no_return, in_loop) {
        var body = this.body.try_inline(compressor, scope, true, true);
        if (body)
          this.body = body;
        var inlined = this.init;
        if (inlined) {
          inlined = inlined.try_inline(compressor, scope, true, in_loop);
          if (inlined) {
            this.init = null;
            if (inlined instanceof AST_BlockStatement) {
              inlined.body.push(this);
              return inlined;
            }
            return make_node(AST_BlockStatement, inlined, { body: [inlined, this] });
          }
        }
        return body && this;
      });
      def(AST_ForEnumeration, function(compressor, scope, no_return, in_loop) {
        var body = this.body.try_inline(compressor, scope, true, true);
        if (body)
          this.body = body;
        var obj = this.object;
        if (obj instanceof AST_Sequence) {
          var inlined = inline_sequence(compressor, scope, true, in_loop, false, obj, 1);
          if (inlined) {
            this.object = obj.tail_node();
            inlined.body.push(this);
            return inlined;
          }
        }
        return body && this;
      });
      def(AST_If, function(compressor, scope, no_return, in_loop) {
        var body = this.body.try_inline(compressor, scope, no_return, in_loop);
        if (body)
          this.body = body;
        var alt = this.alternative;
        if (alt) {
          alt = alt.try_inline(compressor, scope, no_return, in_loop);
          if (alt)
            this.alternative = alt;
        }
        var cond = this.condition;
        if (cond instanceof AST_Sequence) {
          var inlined = inline_sequence(compressor, scope, true, in_loop, false, cond, 1);
          if (inlined) {
            this.condition = cond.tail_node();
            inlined.body.push(this);
            return inlined;
          }
        }
        return (body || alt) && this;
      });
      def(AST_IterationStatement, function(compressor, scope, no_return, in_loop) {
        var body = this.body.try_inline(compressor, scope, true, true);
        if (!body)
          return;
        this.body = body;
        return this;
      });
      def(AST_LabeledStatement, function(compressor, scope, no_return, in_loop) {
        var body = this.body.try_inline(compressor, scope, no_return, in_loop);
        if (!body)
          return;
        if (this.body instanceof AST_IterationStatement && body instanceof AST_BlockStatement) {
          var loop = body.body.pop();
          this.body = loop;
          body.body.push(this);
          return body;
        }
        this.body = body;
        return this;
      });
      def(AST_New, noop);
      def(AST_Return, function(compressor, scope, no_return, in_loop) {
        var value = this.value;
        return value && value.try_inline(compressor, scope, undefined, in_loop === "try");
      });
      function inline_sequence(compressor, scope, no_return, in_loop, in_await, node, skip) {
        var body = [], exprs = node.expressions, no_ret = no_return;
        for (var i = exprs.length - (skip || 0), j = i;--i >= 0; no_ret = true, in_await = false) {
          var inlined = exprs[i].try_inline(compressor, scope, no_ret, in_loop, in_await);
          if (!inlined)
            continue;
          flush();
          body.push(inlined);
        }
        if (body.length == 0)
          return;
        flush();
        if (!no_return && body[0] instanceof AST_SimpleStatement) {
          body[0] = make_node(AST_Return, node, { value: body[0].body });
        }
        return make_node(AST_BlockStatement, node, { body: body.reverse() });
        function flush() {
          if (j > i + 1)
            body.push(make_node(AST_SimpleStatement, node, {
              body: make_sequence(node, exprs.slice(i + 1, j))
            }));
          j = i;
        }
      }
      def(AST_Sequence, function(compressor, scope, no_return, in_loop, in_await) {
        return inline_sequence(compressor, scope, no_return, in_loop, in_await, this);
      });
      def(AST_SimpleStatement, function(compressor, scope, no_return, in_loop) {
        var body = this.body;
        while (body instanceof AST_UnaryPrefix) {
          var op = body.operator;
          if (unary_side_effects[op])
            break;
          if (op == "void")
            break;
          body = body.expression;
        }
        if (!no_return && !is_undefined(body))
          body = make_node(AST_UnaryPrefix, this, {
            operator: "void",
            expression: body
          });
        return body.try_inline(compressor, scope, no_return || false, in_loop);
      });
      def(AST_UnaryPrefix, function(compressor, scope, no_return, in_loop, in_await) {
        var self = this;
        var op = self.operator;
        if (unary_side_effects[op])
          return;
        if (!no_return && op == "void")
          no_return = false;
        var inlined = self.expression.try_inline(compressor, scope, no_return, in_loop, in_await);
        if (!inlined)
          return;
        if (!no_return)
          scan_local_returns(inlined, function(node) {
            node.in_bool = false;
            var value = node.value;
            if (op == "void" && is_undefined(value))
              return;
            node.value = make_node(AST_UnaryPrefix, self, {
              operator: op,
              expression: value || make_node(AST_Undefined, node).transform(compressor)
            });
          });
        return inlined;
      });
      def(AST_With, function(compressor, scope, no_return, in_loop) {
        var body = this.body.try_inline(compressor, scope, no_return, in_loop);
        if (body)
          this.body = body;
        var exp = this.expression;
        if (exp instanceof AST_Sequence) {
          var inlined = inline_sequence(compressor, scope, true, in_loop, false, exp, 1);
          if (inlined) {
            this.expression = exp.tail_node();
            inlined.body.push(this);
            return inlined;
          }
        }
        return body && this;
      });
      def(AST_Yield, function(compressor, scope, no_return, in_loop) {
        if (!compressor.option("yields"))
          return;
        if (!this.nested)
          return;
        var call = this.expression;
        if (call.TYPE != "Call")
          return;
        var fn = call.expression;
        switch (fn.CTOR) {
          case AST_AsyncGeneratorFunction:
            fn = make_node(AST_AsyncFunction, fn);
            break;
          case AST_GeneratorFunction:
            fn = make_node(AST_Function, fn);
            break;
          default:
            return;
        }
        call = call.clone();
        call.expression = fn;
        return call.try_inline(compressor, scope, no_return, in_loop);
      });
    })(function(node, func) {
      node.DEFMETHOD("try_inline", func);
    });
    OPT(AST_Return, function(self, compressor) {
      var value = self.value;
      if (value && compressor.option("side_effects") && is_undefined(value, compressor) && !in_async_generator(compressor.find_parent(AST_Scope))) {
        self.value = null;
      }
      return self;
    });
  })(function(node, optimizer) {
    node.DEFMETHOD("optimize", function(compressor) {
      var self = this;
      if (self._optimized)
        return self;
      if (compressor.has_directive("use asm"))
        return self;
      var opt = optimizer(self, compressor);
      opt._optimized = true;
      return opt;
    });
  });
});

// node_modules/uglify-js/lib/output.js
var exports_output = {};
var is_some_comments, OutputStream2;
var init_output = __esm(() => {
  is_some_comments = function(comment) {
    return comment.type == "comment2" && /@preserve|@license|@cc_on/i.test(comment.value);
  };
  OutputStream2 = function(options) {
    options = defaults(options, {
      annotations: false,
      ascii_only: false,
      beautify: false,
      braces: false,
      comments: false,
      extendscript: false,
      galio: false,
      ie: false,
      indent_level: 4,
      indent_start: 0,
      inline_script: true,
      keep_quoted_props: false,
      max_line_len: false,
      preamble: null,
      preserve_line: false,
      quote_keys: false,
      quote_style: 0,
      semicolons: true,
      shebang: true,
      source_map: null,
      v8: false,
      webkit: false,
      width: 80,
      wrap_iife: false
    }, true);
    var comment_filter = return_false;
    if (options.comments) {
      var comments = options.comments;
      if (typeof options.comments === "string" && /^\/.*\/[a-zA-Z]*$/.test(options.comments)) {
        var regex_pos = options.comments.lastIndexOf("/");
        comments = new RegExp(options.comments.substr(1, regex_pos - 1), options.comments.substr(regex_pos + 1));
      }
      if (comments instanceof RegExp) {
        comment_filter = function(comment) {
          return comment.type != "comment5" && comments.test(comment.value);
        };
      } else if (typeof comments === "function") {
        comment_filter = function(comment) {
          return comment.type != "comment5" && comments(this, comment);
        };
      } else if (comments === "some") {
        comment_filter = is_some_comments;
      } else {
        comment_filter = return_true;
      }
    }
    function make_indent(value) {
      if (typeof value == "number")
        return new Array(value + 1).join(" ");
      if (!value)
        return "";
      if (!/^\s*$/.test(value))
        throw new Error("unsupported indentation: " + JSON.stringify("" + value));
      return value;
    }
    var current_col = 0;
    var current_line = 1;
    var current_indent = make_indent(options.indent_start);
    var full_indent = make_indent(options.indent_level);
    var half_indent = full_indent.length + 1 >> 1;
    var last;
    var line_end = 0;
    var line_fixed = true;
    var mappings = options.source_map && [];
    var mapping_name;
    var mapping_token;
    var might_need_space;
    var might_need_semicolon;
    var need_newline_indented = false;
    var need_space = false;
    var output;
    var stack;
    var stored = "";
    function reset() {
      last = "";
      might_need_space = false;
      might_need_semicolon = false;
      stack = [];
      var str = output;
      output = "";
      return str;
    }
    reset();
    var to_utf8 = options.ascii_only ? function(str, identifier) {
      if (identifier)
        str = str.replace(/[\ud800-\udbff][\udc00-\udfff]/g, function(ch) {
          return "\\u{" + (ch.charCodeAt(0) - 55232 << 10 | ch.charCodeAt(1) - 56320).toString(16) + "}";
        });
      return str.replace(/[\u0000-\u001f\u007f-\uffff]/g, function(ch) {
        var code = ch.charCodeAt(0).toString(16);
        if (code.length <= 2 && !identifier) {
          while (code.length < 2)
            code = "0" + code;
          return "\\x" + code;
        } else {
          while (code.length < 4)
            code = "0" + code;
          return "\\u" + code;
        }
      });
    } : function(str) {
      var s = "";
      for (var i = 0, j = 0;i < str.length; i++) {
        var code = str.charCodeAt(i);
        if (is_surrogate_pair_head(code)) {
          if (is_surrogate_pair_tail(str.charCodeAt(i + 1))) {
            i++;
            continue;
          }
        } else if (!is_surrogate_pair_tail(code)) {
          continue;
        }
        s += str.slice(j, i) + "\\u" + code.toString(16);
        j = i + 1;
      }
      return j == 0 ? str : s + str.slice(j);
    };
    function quote_single(str) {
      return "'" + str.replace(/\x27/g, "\\'") + "'";
    }
    function quote_double(str) {
      return '"' + str.replace(/\x22/g, '\\"') + '"';
    }
    var quote_string = [
      null,
      quote_single,
      quote_double,
      function(str, quote) {
        return quote == "'" ? quote_single(str) : quote_double(str);
      }
    ][options.quote_style] || function(str, quote, dq, sq) {
      return dq > sq ? quote_single(str) : quote_double(str);
    };
    function make_string(str, quote) {
      var dq = 0, sq = 0;
      str = str.replace(/[\\\b\f\n\r\v\t\x22\x27\u2028\u2029\0\ufeff]/g, function(s, i) {
        switch (s) {
          case '"':
            ++dq;
            return '"';
          case "'":
            ++sq;
            return "'";
          case "\\":
            return "\\\\";
          case "\n":
            return "\\n";
          case "\r":
            return "\\r";
          case "\t":
            return "\\t";
          case "\b":
            return "\\b";
          case "\f":
            return "\\f";
          case "\v":
            return options.ie ? "\\x0B" : "\\v";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          case "\uFEFF":
            return "\\ufeff";
          case "\0":
            return /[0-9]/.test(str.charAt(i + 1)) ? "\\x00" : "\\0";
        }
        return s;
      });
      return quote_string(to_utf8(str), quote, dq, sq);
    }
    var adjust_mappings = mappings ? function(line, col) {
      mappings.forEach(function(mapping) {
        mapping.line += line;
        mapping.col += col;
      });
    } : noop;
    var flush_mappings = mappings ? function() {
      mappings.forEach(function(mapping) {
        options.source_map.add(mapping.token.file, mapping.line, mapping.col, mapping.token.line, mapping.token.col, !mapping.name && mapping.token.type == "name" ? mapping.token.value : mapping.name);
      });
      mappings = [];
    } : noop;
    function insert_newlines(count) {
      stored += output.slice(0, line_end);
      output = output.slice(line_end);
      var new_col = output.length;
      adjust_mappings(count, new_col - current_col);
      current_line += count;
      current_col = new_col;
      while (count--)
        stored += "\n";
    }
    var fix_line = options.max_line_len ? function(flush) {
      if (line_fixed) {
        if (current_col > options.max_line_len) {
          AST_Node.warn("Output exceeds {max_line_len} characters", options);
        }
        return;
      }
      if (current_col > options.max_line_len) {
        insert_newlines(1);
        line_fixed = true;
      }
      if (line_fixed || flush)
        flush_mappings();
    } : noop;
    var require_semicolon = makePredicate("( [ + * / - , .");
    function require_space(prev, ch, str) {
      return is_identifier_char(prev) && (is_identifier_char(ch) || ch == "\\") || ch == "/" && ch == prev || (ch == "+" || ch == "-") && ch == last || last == "--" && ch == ">" || last == "!" && str == "--" || prev == "/" && (str == "in" || str == "instanceof");
    }
    var print = options.beautify || options.comments || options.max_line_len || options.preserve_line || options.shebang || !options.semicolons || options.source_map || options.width ? function(str) {
      var ch = str.charAt(0);
      if (need_newline_indented && ch) {
        need_newline_indented = false;
        if (ch != "\n") {
          print("\n");
          indent();
        }
      }
      if (need_space && ch) {
        need_space = false;
        if (!/[\s;})]/.test(ch)) {
          space();
        }
      }
      var prev = last.slice(-1);
      if (might_need_semicolon) {
        might_need_semicolon = false;
        if (prev == ":" && ch == "}" || prev != ";" && (!ch || ";}".indexOf(ch) < 0)) {
          var need_semicolon = require_semicolon[ch];
          if (need_semicolon || options.semicolons) {
            output += ";";
            current_col++;
            if (!line_fixed) {
              fix_line();
              if (line_fixed && !need_semicolon && output == ";") {
                output = "";
                current_col = 0;
              }
            }
            if (line_end == output.length - 1)
              line_end++;
          } else {
            fix_line();
            output += "\n";
            current_line++;
            current_col = 0;
            if (/^\s+$/.test(str))
              might_need_semicolon = true;
          }
          if (!options.beautify)
            might_need_space = false;
        }
      }
      if (might_need_space) {
        if (require_space(prev, ch, str)) {
          output += " ";
          current_col++;
        }
        if (prev != "<" || str != "!")
          might_need_space = false;
      }
      if (mapping_token) {
        mappings.push({
          token: mapping_token,
          name: mapping_name,
          line: current_line,
          col: current_col
        });
        mapping_token = false;
        if (line_fixed)
          flush_mappings();
      }
      output += str;
      var a = str.split(/\r?\n/), n = a.length - 1;
      current_line += n;
      current_col += a[0].length;
      if (n > 0) {
        fix_line();
        current_col = a[n].length;
      }
      last = str;
    } : function(str) {
      var ch = str.charAt(0);
      var prev = last.slice(-1);
      if (might_need_semicolon) {
        might_need_semicolon = false;
        if (prev == ":" && ch == "}" || (!ch || ";}".indexOf(ch) < 0) && prev != ";") {
          output += ";";
          might_need_space = false;
        }
      }
      if (might_need_space) {
        if (require_space(prev, ch, str))
          output += " ";
        if (prev != "<" || str != "!")
          might_need_space = false;
      }
      output += str;
      last = str;
    };
    var space = options.beautify ? function() {
      print(" ");
    } : function() {
      might_need_space = true;
    };
    var indent = options.beautify ? function(half) {
      if (need_newline_indented)
        print("\n");
      print(half ? current_indent.slice(0, -half_indent) : current_indent);
    } : noop;
    var with_indent = options.beautify ? function(cont) {
      var save_indentation = current_indent;
      current_indent += full_indent;
      cont();
      current_indent = save_indentation;
    } : function(cont) {
      cont();
    };
    var may_add_newline = options.max_line_len || options.preserve_line ? function() {
      fix_line();
      line_end = output.length;
      line_fixed = false;
    } : noop;
    var newline = options.beautify ? function() {
      print("\n");
      line_end = output.length;
    } : may_add_newline;
    var semicolon = options.beautify ? function() {
      print(";");
    } : function() {
      might_need_semicolon = true;
    };
    function force_semicolon() {
      if (might_need_semicolon)
        print(";");
      print(";");
    }
    function with_block(cont, end) {
      print("{");
      newline();
      with_indent(cont);
      add_mapping(end);
      indent();
      print("}");
    }
    function with_parens(cont) {
      print("(");
      may_add_newline();
      cont();
      may_add_newline();
      print(")");
    }
    function with_square(cont) {
      print("[");
      may_add_newline();
      cont();
      may_add_newline();
      print("]");
    }
    function comma() {
      may_add_newline();
      print(",");
      may_add_newline();
      space();
    }
    function colon() {
      print(":");
      space();
    }
    var add_mapping = mappings ? function(token, name) {
      mapping_token = token;
      mapping_name = name;
    } : noop;
    function get() {
      if (!line_fixed)
        fix_line(true);
      return stored + output;
    }
    function has_nlb() {
      return /(^|\n) *$/.test(output);
    }
    function pad_comment(token, force) {
      if (need_newline_indented)
        return;
      if (token.nlb && (force || !has_nlb())) {
        need_newline_indented = true;
      } else if (force) {
        need_space = true;
      }
    }
    function print_comment(comment) {
      var value = comment.value.replace(/[@#]__PURE__/g, " ");
      if (/^\s*$/.test(value) && !/^\s*$/.test(comment.value))
        return false;
      if (/comment[134]/.test(comment.type)) {
        print("//" + value);
        need_newline_indented = true;
      } else if (comment.type == "comment2") {
        print("/*" + value + "*/");
      }
      return true;
    }
    function should_merge_comments(node, parent) {
      if (parent instanceof AST_Binary)
        return parent.left === node;
      if (parent.TYPE == "Call")
        return parent.expression === node;
      if (parent instanceof AST_Conditional)
        return parent.condition === node;
      if (parent instanceof AST_Dot)
        return parent.expression === node;
      if (parent instanceof AST_Exit)
        return true;
      if (parent instanceof AST_Sequence)
        return parent.expressions[0] === node;
      if (parent instanceof AST_Sub)
        return parent.expression === node;
      if (parent instanceof AST_UnaryPostfix)
        return true;
      if (parent instanceof AST_Yield)
        return true;
    }
    function prepend_comments(node) {
      var self = this;
      var scan;
      if (node instanceof AST_Exit) {
        scan = node.value;
      } else if (node instanceof AST_Yield) {
        scan = node.expression;
      }
      var comments2 = dump(node);
      if (!comments2)
        comments2 = [];
      if (scan) {
        var tw = new TreeWalker(function(node2) {
          if (!should_merge_comments(node2, tw.parent()))
            return true;
          var before = dump(node2);
          if (before)
            comments2 = comments2.concat(before);
        });
        tw.push(node);
        scan.walk(tw);
      }
      if (current_line == 1 && current_col == 0) {
        if (comments2.length > 0 && options.shebang && comments2[0].type == "comment5") {
          print("#!" + comments2.shift().value + "\n");
          indent();
        }
        var preamble = options.preamble;
        if (preamble)
          print(preamble.replace(/\r\n?|\u2028|\u2029|(^|\S)\s*$/g, "$1\n"));
      }
      comments2 = comments2.filter(comment_filter, node);
      var printed = false;
      comments2.forEach(function(comment, index) {
        pad_comment(comment, index);
        if (print_comment(comment))
          printed = true;
      });
      if (printed)
        pad_comment(node.start, true);
      function dump(node2) {
        var token = node2.start;
        if (!token) {
          if (!scan)
            return;
          node2.start = token = new AST_Token;
        }
        var comments3 = token.comments_before;
        if (!comments3) {
          if (!scan)
            return;
          token.comments_before = comments3 = [];
        }
        if (comments3._dumped === self)
          return;
        comments3._dumped = self;
        return comments3;
      }
    }
    function append_comments(node, tail) {
      var self = this;
      var token = node.end;
      if (!token)
        return;
      var comments2 = token[tail ? "comments_before" : "comments_after"];
      if (!comments2 || comments2._dumped === self)
        return;
      if (!(node instanceof AST_Statement || all(comments2, function(c) {
        return !/comment[134]/.test(c.type);
      })))
        return;
      comments2._dumped = self;
      comments2.filter(comment_filter, node).forEach(function(comment, index) {
        pad_comment(comment, index || !tail);
        print_comment(comment);
      });
    }
    return {
      get,
      reset,
      indent,
      should_break: options.beautify && options.width ? function() {
        return current_col >= options.width;
      } : return_false,
      has_parens: function() {
        return last.slice(-1) == "(";
      },
      newline,
      print,
      space,
      comma,
      colon,
      last: function() {
        return last;
      },
      semicolon,
      force_semicolon,
      to_utf8,
      print_name: function(name) {
        print(to_utf8(name.toString(), true));
      },
      print_string: options.inline_script ? function(str, quote) {
        str = make_string(str, quote).replace(/<\x2f(script)([>\/\t\n\f\r ])/gi, "<\\/$1$2");
        print(str.replace(/\x3c!--/g, "\\x3c!--").replace(/--\x3e/g, "--\\x3e"));
      } : function(str, quote) {
        print(make_string(str, quote));
      },
      with_indent,
      with_block,
      with_parens,
      with_square,
      add_mapping,
      option: function(opt) {
        return options[opt];
      },
      prepend_comments: options.comments || options.shebang ? prepend_comments : noop,
      append_comments: options.comments ? append_comments : noop,
      push_node: function(node) {
        stack.push(node);
      },
      pop_node: options.preserve_line ? function() {
        var node = stack.pop();
        if (node.start && node.start.line > current_line) {
          insert_newlines(node.start.line - current_line);
        }
      } : function() {
        stack.pop();
      },
      parent: function(n) {
        return stack[stack.length - 2 - (n || 0)];
      }
    };
  };
  (function() {
    function DEFPRINT(nodetype, generator) {
      nodetype.DEFMETHOD("_codegen", generator);
    }
    var use_asm = false;
    AST_Node.DEFMETHOD("print", function(stream, force_parens) {
      var self = this;
      stream.push_node(self);
      if (force_parens || self.needs_parens(stream)) {
        stream.with_parens(doit);
      } else {
        doit();
      }
      stream.pop_node();
      function doit() {
        stream.prepend_comments(self);
        self.add_source_map(stream);
        self._codegen(stream);
        stream.append_comments(self);
      }
    });
    var readonly = OutputStream2({
      inline_script: false,
      shebang: false,
      width: false
    });
    AST_Node.DEFMETHOD("print_to_string", function(options) {
      if (options) {
        var stream = OutputStream2(options);
        this.print(stream);
        return stream.get();
      }
      this.print(readonly);
      return readonly.reset();
    });
    function PARENS(nodetype, func) {
      nodetype.DEFMETHOD("needs_parens", func);
    }
    PARENS(AST_Node, return_false);
    function needs_parens_function(output) {
      var p = output.parent();
      if (!output.has_parens() && first_in_statement(output, false, true)) {
        return this.name || !(p instanceof AST_ExportDefault);
      }
      if (output.option("webkit") && p instanceof AST_PropAccess && p.expression === this)
        return true;
      if (output.option("wrap_iife") && p instanceof AST_Call && p.expression === this)
        return true;
    }
    PARENS(AST_AsyncFunction, needs_parens_function);
    PARENS(AST_AsyncGeneratorFunction, needs_parens_function);
    PARENS(AST_ClassExpression, needs_parens_function);
    PARENS(AST_Function, needs_parens_function);
    PARENS(AST_GeneratorFunction, needs_parens_function);
    function needs_parens_obj(output) {
      return !output.has_parens() && first_in_statement(output, true);
    }
    PARENS(AST_Object, needs_parens_obj);
    function needs_parens_unary(output) {
      var p = output.parent();
      if (p instanceof AST_Binary)
        return p.operator == "**" && p.left === this;
      if (p instanceof AST_Call)
        return p.expression === this;
      if (p instanceof AST_Class)
        return true;
      if (p instanceof AST_PropAccess)
        return p.expression === this;
      if (p instanceof AST_Template)
        return p.tag === this;
    }
    PARENS(AST_Await, needs_parens_unary);
    PARENS(AST_Unary, needs_parens_unary);
    PARENS(AST_Sequence, function(output) {
      var p = output.parent();
      return p instanceof AST_Array || is_arrow(p) && p.value === this || p instanceof AST_Await || p instanceof AST_Binary || p instanceof AST_Call || p instanceof AST_Class || p instanceof AST_ClassProperty || p instanceof AST_Conditional || p instanceof AST_DefaultValue || p instanceof AST_DestructuredKeyVal || p instanceof AST_ExportDefault || p instanceof AST_ForOf || p instanceof AST_ObjectProperty || p instanceof AST_PropAccess && p.expression === this || p instanceof AST_Spread || p instanceof AST_Template && p.tag === this || p instanceof AST_Unary || p instanceof AST_VarDef || p instanceof AST_Yield;
    });
    PARENS(AST_Binary, function(output) {
      var p = output.parent();
      if (p instanceof AST_Await)
        return true;
      if (p instanceof AST_Binary) {
        var po = p.operator, pp = PRECEDENCE[po];
        var so = this.operator, sp = PRECEDENCE[so];
        return pp > sp || po == "??" && (so == "&&" || so == "||") || pp == sp && this === p[po == "**" ? "left" : "right"];
      }
      if (p instanceof AST_Call)
        return p.expression === this;
      if (p instanceof AST_Class)
        return true;
      if (p instanceof AST_PropAccess)
        return p.expression === this;
      if (p instanceof AST_Template)
        return p.tag === this;
      if (p instanceof AST_Unary)
        return true;
    });
    function need_chain_parens(node, parent) {
      if (!node.terminal)
        return false;
      if (!(parent instanceof AST_Call || parent instanceof AST_PropAccess))
        return false;
      return parent.expression === node;
    }
    PARENS(AST_PropAccess, function(output) {
      var node = this;
      var p = output.parent();
      if (p instanceof AST_New && p.expression === node && root_expr(node).TYPE == "Call")
        return true;
      return need_chain_parens(node, p);
    });
    PARENS(AST_Call, function(output) {
      var node = this;
      var p = output.parent();
      if (p instanceof AST_New)
        return p.expression === node;
      if (output.option("webkit") && node.expression instanceof AST_Function && p instanceof AST_PropAccess && p.expression === node) {
        var g = output.parent(1);
        if (g instanceof AST_Assign && g.left === p)
          return true;
      }
      return need_chain_parens(node, p);
    });
    PARENS(AST_New, function(output) {
      if (need_constructor_parens(this, output))
        return false;
      var p = output.parent();
      if (p instanceof AST_Call)
        return p.expression === this;
      if (p instanceof AST_PropAccess)
        return true;
      if (p instanceof AST_Template)
        return p.tag === this;
    });
    PARENS(AST_Number, function(output) {
      if (!output.option("galio"))
        return false;
      var p = output.parent();
      return p instanceof AST_PropAccess && p.expression === this && /^0/.test(make_num(this.value));
    });
    function needs_parens_assign_cond(self, output) {
      var p = output.parent();
      if (p instanceof AST_Await)
        return true;
      if (p instanceof AST_Binary)
        return !(p instanceof AST_Assign);
      if (p instanceof AST_Call)
        return p.expression === self;
      if (p instanceof AST_Class)
        return true;
      if (p instanceof AST_Conditional)
        return p.condition === self;
      if (p instanceof AST_PropAccess)
        return p.expression === self;
      if (p instanceof AST_Template)
        return p.tag === self;
      if (p instanceof AST_Unary)
        return true;
    }
    PARENS(AST_Arrow, function(output) {
      return needs_parens_assign_cond(this, output);
    });
    PARENS(AST_Assign, function(output) {
      if (needs_parens_assign_cond(this, output))
        return true;
      if (output.option("v8"))
        return this.left instanceof AST_Destructured;
      if (this.left instanceof AST_DestructuredObject)
        return needs_parens_obj(output);
    });
    PARENS(AST_AsyncArrow, function(output) {
      return needs_parens_assign_cond(this, output);
    });
    PARENS(AST_Conditional, function(output) {
      return needs_parens_assign_cond(this, output) || output.option("extendscript") && output.parent() instanceof AST_Conditional;
    });
    PARENS(AST_Yield, function(output) {
      return needs_parens_assign_cond(this, output);
    });
    DEFPRINT(AST_Directive, function(output) {
      var quote = this.quote;
      var value = this.value;
      switch (output.option("quote_style")) {
        case 0:
        case 2:
          if (value.indexOf('"') == -1)
            quote = '"';
          break;
        case 1:
          if (value.indexOf("'") == -1)
            quote = "'";
          break;
      }
      output.print(quote + value + quote);
      output.semicolon();
    });
    DEFPRINT(AST_Debugger, function(output) {
      output.print("debugger");
      output.semicolon();
    });
    function display_body(body, is_toplevel, output, allow_directives) {
      var last = body.length - 1;
      var in_directive = allow_directives;
      var was_asm = use_asm;
      body.forEach(function(stmt, i) {
        if (in_directive) {
          if (stmt instanceof AST_Directive) {
            if (stmt.value == "use asm")
              use_asm = true;
          } else if (!(stmt instanceof AST_EmptyStatement)) {
            if (stmt instanceof AST_SimpleStatement && stmt.body instanceof AST_String) {
              output.force_semicolon();
            }
            in_directive = false;
          }
        }
        if (stmt instanceof AST_EmptyStatement)
          return;
        output.indent();
        stmt.print(output);
        if (i == last && is_toplevel)
          return;
        output.newline();
        if (is_toplevel)
          output.newline();
      });
      use_asm = was_asm;
    }
    DEFPRINT(AST_Toplevel, function(output) {
      display_body(this.body, true, output, true);
      output.print("");
    });
    DEFPRINT(AST_LabeledStatement, function(output) {
      this.label.print(output);
      output.colon();
      this.body.print(output);
    });
    DEFPRINT(AST_SimpleStatement, function(output) {
      this.body.print(output);
      output.semicolon();
    });
    function print_braced_empty(self, output) {
      output.print("{");
      output.with_indent(function() {
        output.append_comments(self, true);
      });
      output.print("}");
    }
    function print_braced(self, output, allow_directives) {
      if (self.body.length > 0) {
        output.with_block(function() {
          display_body(self.body, false, output, allow_directives);
        }, self.end);
      } else
        print_braced_empty(self, output);
    }
    DEFPRINT(AST_BlockStatement, function(output) {
      print_braced(this, output);
    });
    DEFPRINT(AST_EmptyStatement, function(output) {
      output.semicolon();
    });
    DEFPRINT(AST_Do, function(output) {
      var self = this;
      output.print("do");
      make_block(self.body, output);
      output.space();
      output.print("while");
      output.space();
      output.with_parens(function() {
        self.condition.print(output);
      });
      output.semicolon();
    });
    DEFPRINT(AST_While, function(output) {
      var self = this;
      output.print("while");
      output.space();
      output.with_parens(function() {
        self.condition.print(output);
      });
      force_statement(self.body, output);
    });
    DEFPRINT(AST_For, function(output) {
      var self = this;
      output.print("for");
      output.space();
      output.with_parens(function() {
        if (self.init) {
          if (self.init instanceof AST_Definitions) {
            self.init.print(output);
          } else {
            parenthesize_for_no_in(self.init, output, true);
          }
          output.print(";");
          output.space();
        } else {
          output.print(";");
        }
        if (self.condition) {
          self.condition.print(output);
          output.print(";");
          output.space();
        } else {
          output.print(";");
        }
        if (self.step) {
          self.step.print(output);
        }
      });
      force_statement(self.body, output);
    });
    function print_for_enum(prefix, infix) {
      return function(output) {
        var self = this;
        output.print(prefix);
        output.space();
        output.with_parens(function() {
          self.init.print(output);
          output.space();
          output.print(infix);
          output.space();
          self.object.print(output);
        });
        force_statement(self.body, output);
      };
    }
    DEFPRINT(AST_ForAwaitOf, print_for_enum("for await", "of"));
    DEFPRINT(AST_ForIn, print_for_enum("for", "in"));
    DEFPRINT(AST_ForOf, print_for_enum("for", "of"));
    DEFPRINT(AST_With, function(output) {
      var self = this;
      output.print("with");
      output.space();
      output.with_parens(function() {
        self.expression.print(output);
      });
      force_statement(self.body, output);
    });
    DEFPRINT(AST_ExportDeclaration, function(output) {
      output.print("export");
      output.space();
      this.body.print(output);
    });
    DEFPRINT(AST_ExportDefault, function(output) {
      output.print("export");
      output.space();
      output.print("default");
      output.space();
      var body = this.body;
      body.print(output);
      if (body instanceof AST_ClassExpression) {
        if (!body.name)
          return;
      }
      if (body instanceof AST_DefClass)
        return;
      if (body instanceof AST_LambdaDefinition)
        return;
      if (body instanceof AST_LambdaExpression) {
        if (!body.name && !is_arrow(body))
          return;
      }
      output.semicolon();
    });
    function print_alias(alias, output) {
      var value = alias.value;
      if (value == "*" || is_identifier_string(value)) {
        output.print_name(value);
      } else {
        output.print_string(value, alias.quote);
      }
    }
    DEFPRINT(AST_ExportForeign, function(output) {
      var self = this;
      output.print("export");
      output.space();
      var len = self.keys.length;
      if (len == 0) {
        print_braced_empty(self, output);
      } else if (self.keys[0].value == "*") {
        print_entry(0);
      } else
        output.with_block(function() {
          output.indent();
          print_entry(0);
          for (var i = 1;i < len; i++) {
            output.print(",");
            output.newline();
            output.indent();
            print_entry(i);
          }
          output.newline();
        }, self.end);
      output.space();
      output.print("from");
      output.space();
      self.path.print(output);
      output.semicolon();
      function print_entry(index) {
        var alias = self.aliases[index];
        var key = self.keys[index];
        print_alias(key, output);
        if (alias.value != key.value) {
          output.space();
          output.print("as");
          output.space();
          print_alias(alias, output);
        }
      }
    });
    DEFPRINT(AST_ExportReferences, function(output) {
      var self = this;
      output.print("export");
      output.space();
      print_properties(self, output);
      output.semicolon();
    });
    DEFPRINT(AST_Import, function(output) {
      var self = this;
      output.print("import");
      output.space();
      if (self.default)
        self.default.print(output);
      if (self.all) {
        if (self.default)
          output.comma();
        self.all.print(output);
      }
      if (self.properties) {
        if (self.default)
          output.comma();
        print_properties(self, output);
      }
      if (self.all || self.default || self.properties) {
        output.space();
        output.print("from");
        output.space();
      }
      self.path.print(output);
      output.semicolon();
    });
    function print_funargs(self, output) {
      output.with_parens(function() {
        self.argnames.forEach(function(arg, i) {
          if (i)
            output.comma();
          arg.print(output);
        });
        if (self.rest) {
          if (self.argnames.length)
            output.comma();
          output.print("...");
          self.rest.print(output);
        }
      });
    }
    function print_arrow(self, output) {
      var argname = self.argnames.length == 1 && !self.rest && self.argnames[0];
      if (argname instanceof AST_SymbolFunarg && argname.name != "yield") {
        argname.print(output);
      } else {
        print_funargs(self, output);
      }
      output.space();
      output.print("=>");
      output.space();
      if (self.value) {
        self.value.print(output);
      } else {
        print_braced(self, output, true);
      }
    }
    DEFPRINT(AST_Arrow, function(output) {
      print_arrow(this, output);
    });
    DEFPRINT(AST_AsyncArrow, function(output) {
      output.print("async");
      output.space();
      print_arrow(this, output);
    });
    function print_lambda(self, output) {
      if (self.name) {
        output.space();
        self.name.print(output);
      }
      print_funargs(self, output);
      output.space();
      print_braced(self, output, true);
    }
    DEFPRINT(AST_Lambda, function(output) {
      output.print("function");
      print_lambda(this, output);
    });
    function print_async(output) {
      output.print("async");
      output.space();
      output.print("function");
      print_lambda(this, output);
    }
    DEFPRINT(AST_AsyncDefun, print_async);
    DEFPRINT(AST_AsyncFunction, print_async);
    function print_async_generator(output) {
      output.print("async");
      output.space();
      output.print("function*");
      print_lambda(this, output);
    }
    DEFPRINT(AST_AsyncGeneratorDefun, print_async_generator);
    DEFPRINT(AST_AsyncGeneratorFunction, print_async_generator);
    function print_generator(output) {
      output.print("function*");
      print_lambda(this, output);
    }
    DEFPRINT(AST_GeneratorDefun, print_generator);
    DEFPRINT(AST_GeneratorFunction, print_generator);
    DEFPRINT(AST_Class, function(output) {
      var self = this;
      output.print("class");
      if (self.name) {
        output.space();
        self.name.print(output);
      }
      if (self.extends) {
        output.space();
        output.print("extends");
        output.space();
        self.extends.print(output);
      }
      output.space();
      print_properties(self, output, true);
    });
    DEFPRINT(AST_ClassField, function(output) {
      var self = this;
      if (self.static) {
        output.print("static");
        output.space();
      }
      print_property_key(self, output);
      if (self.value) {
        output.space();
        output.print("=");
        output.space();
        self.value.print(output);
      }
      output.semicolon();
    });
    DEFPRINT(AST_ClassGetter, print_accessor("get"));
    DEFPRINT(AST_ClassSetter, print_accessor("set"));
    function print_method(self, output) {
      var fn = self.value;
      if (is_async(fn)) {
        output.print("async");
        output.space();
      }
      if (is_generator(fn))
        output.print("*");
      print_property_key(self, output);
      print_lambda(self.value, output);
    }
    DEFPRINT(AST_ClassMethod, function(output) {
      var self = this;
      if (self.static) {
        output.print("static");
        output.space();
      }
      print_method(self, output);
    });
    DEFPRINT(AST_ClassInit, function(output) {
      output.print("static");
      output.space();
      print_braced(this.value, output);
    });
    function print_jump(kind, prop) {
      return function(output) {
        output.print(kind);
        var target = this[prop];
        if (target) {
          output.space();
          target.print(output);
        }
        output.semicolon();
      };
    }
    DEFPRINT(AST_Return, print_jump("return", "value"));
    DEFPRINT(AST_Throw, print_jump("throw", "value"));
    DEFPRINT(AST_Break, print_jump("break", "label"));
    DEFPRINT(AST_Continue, print_jump("continue", "label"));
    function make_then(self, output) {
      var b = self.body;
      if (output.option("braces") && !(b instanceof AST_Const || b instanceof AST_Let) || output.option("ie") && b instanceof AST_Do)
        return make_block(b, output);
      if (!b)
        return output.force_semicolon();
      while (true) {
        if (b instanceof AST_If) {
          if (!b.alternative) {
            make_block(self.body, output);
            return;
          }
          b = b.alternative;
        } else if (b instanceof AST_StatementWithBody) {
          b = b.body;
        } else
          break;
      }
      force_statement(self.body, output);
    }
    DEFPRINT(AST_If, function(output) {
      var self = this;
      output.print("if");
      output.space();
      output.with_parens(function() {
        self.condition.print(output);
      });
      if (self.alternative) {
        make_then(self, output);
        output.space();
        output.print("else");
        if (self.alternative instanceof AST_If) {
          output.space();
          self.alternative.print(output);
        } else {
          force_statement(self.alternative, output);
        }
      } else {
        force_statement(self.body, output);
      }
    });
    DEFPRINT(AST_Switch, function(output) {
      var self = this;
      output.print("switch");
      output.space();
      output.with_parens(function() {
        self.expression.print(output);
      });
      output.space();
      var last = self.body.length - 1;
      if (last < 0)
        print_braced_empty(self, output);
      else
        output.with_block(function() {
          self.body.forEach(function(branch, i) {
            output.indent(true);
            branch.print(output);
            if (i < last && branch.body.length > 0)
              output.newline();
          });
        }, self.end);
    });
    function print_branch_body(self, output) {
      output.newline();
      self.body.forEach(function(stmt) {
        output.indent();
        stmt.print(output);
        output.newline();
      });
    }
    DEFPRINT(AST_Default, function(output) {
      output.print("default:");
      print_branch_body(this, output);
    });
    DEFPRINT(AST_Case, function(output) {
      var self = this;
      output.print("case");
      output.space();
      self.expression.print(output);
      output.print(":");
      print_branch_body(self, output);
    });
    DEFPRINT(AST_Try, function(output) {
      var self = this;
      output.print("try");
      output.space();
      print_braced(self, output);
      if (self.bcatch) {
        output.space();
        self.bcatch.print(output);
      }
      if (self.bfinally) {
        output.space();
        self.bfinally.print(output);
      }
    });
    DEFPRINT(AST_Catch, function(output) {
      var self = this;
      output.print("catch");
      if (self.argname) {
        output.space();
        output.with_parens(function() {
          self.argname.print(output);
        });
      }
      output.space();
      print_braced(self, output);
    });
    DEFPRINT(AST_Finally, function(output) {
      output.print("finally");
      output.space();
      print_braced(this, output);
    });
    function print_definitions(type) {
      return function(output) {
        var self = this;
        output.print(type);
        output.space();
        self.definitions.forEach(function(def, i) {
          if (i)
            output.comma();
          def.print(output);
        });
        var p = output.parent();
        if (!(p instanceof AST_IterationStatement && p.init === self))
          output.semicolon();
      };
    }
    DEFPRINT(AST_Const, print_definitions("const"));
    DEFPRINT(AST_Let, print_definitions("let"));
    DEFPRINT(AST_Var, print_definitions("var"));
    function parenthesize_for_no_in(node, output, no_in) {
      var parens = false;
      if (no_in)
        node.walk(new TreeWalker(function(node2) {
          if (parens)
            return true;
          if (node2 instanceof AST_Binary && node2.operator == "in")
            return parens = true;
          if (node2 instanceof AST_Scope && !(is_arrow(node2) && node2.value))
            return true;
        }));
      node.print(output, parens);
    }
    DEFPRINT(AST_VarDef, function(output) {
      var self = this;
      self.name.print(output);
      if (self.value) {
        output.space();
        output.print("=");
        output.space();
        var p = output.parent(1);
        var no_in = p instanceof AST_For || p instanceof AST_ForEnumeration;
        parenthesize_for_no_in(self.value, output, no_in);
      }
    });
    DEFPRINT(AST_DefaultValue, function(output) {
      var self = this;
      self.name.print(output);
      output.space();
      output.print("=");
      output.space();
      self.value.print(output);
    });
    function print_annotation(self, output) {
      if (!output.option("annotations"))
        return;
      if (!self.pure)
        return;
      var level = 0, parent = self, node;
      do {
        node = parent;
        parent = output.parent(level++);
        if (parent instanceof AST_Call && parent.expression === node)
          return;
      } while (parent instanceof AST_PropAccess && parent.expression === node);
      output.print("/*@__PURE__*/");
    }
    function print_call_args(self, output) {
      output.with_parens(function() {
        self.args.forEach(function(expr, i) {
          if (i)
            output.comma();
          expr.print(output);
        });
        output.add_mapping(self.end);
      });
    }
    DEFPRINT(AST_Call, function(output) {
      var self = this;
      print_annotation(self, output);
      self.expression.print(output);
      if (self.optional)
        output.print("?.");
      print_call_args(self, output);
    });
    DEFPRINT(AST_New, function(output) {
      var self = this;
      print_annotation(self, output);
      output.print("new");
      output.space();
      self.expression.print(output);
      if (need_constructor_parens(self, output))
        print_call_args(self, output);
    });
    DEFPRINT(AST_Sequence, function(output) {
      this.expressions.forEach(function(node, index) {
        if (index > 0) {
          output.comma();
          if (output.should_break()) {
            output.newline();
            output.indent();
          }
        }
        node.print(output);
      });
    });
    DEFPRINT(AST_Dot, function(output) {
      var self = this;
      var expr = self.expression;
      expr.print(output);
      var prop = self.property;
      if (output.option("ie") && RESERVED_WORDS[prop] || self.quoted && output.option("keep_quoted_props")) {
        if (self.optional)
          output.print("?.");
        output.with_square(function() {
          output.add_mapping(self.end);
          output.print_string(prop);
        });
      } else {
        if (expr instanceof AST_Number && !/[ex.)]/i.test(output.last()))
          output.print(".");
        output.print(self.optional ? "?." : ".");
        output.add_mapping(self.end);
        output.print_name(prop);
      }
    });
    DEFPRINT(AST_Sub, function(output) {
      var self = this;
      self.expression.print(output);
      if (self.optional)
        output.print("?.");
      output.with_square(function() {
        self.property.print(output);
      });
    });
    DEFPRINT(AST_Spread, function(output) {
      output.print("...");
      this.expression.print(output);
    });
    DEFPRINT(AST_UnaryPrefix, function(output) {
      var op = this.operator;
      var exp = this.expression;
      output.print(op);
      if (/^[a-z]/i.test(op) || /[+-]$/.test(op) && exp instanceof AST_UnaryPrefix && /^[+-]/.test(exp.operator)) {
        output.space();
      }
      exp.print(output);
    });
    DEFPRINT(AST_UnaryPostfix, function(output) {
      var self = this;
      self.expression.print(output);
      output.add_mapping(self.end);
      output.print(self.operator);
    });
    DEFPRINT(AST_Binary, function(output) {
      var self = this;
      self.left.print(output);
      output.space();
      output.print(self.operator);
      output.space();
      self.right.print(output);
    });
    DEFPRINT(AST_Conditional, function(output) {
      var self = this;
      self.condition.print(output);
      output.space();
      output.print("?");
      output.space();
      self.consequent.print(output);
      output.space();
      output.colon();
      self.alternative.print(output);
    });
    DEFPRINT(AST_Await, function(output) {
      output.print("await");
      output.space();
      this.expression.print(output);
    });
    DEFPRINT(AST_Yield, function(output) {
      output.print(this.nested ? "yield*" : "yield");
      if (this.expression) {
        output.space();
        this.expression.print(output);
      }
    });
    DEFPRINT(AST_Array, function(output) {
      var a = this.elements, len = a.length;
      output.with_square(len > 0 ? function() {
        output.space();
        a.forEach(function(exp, i) {
          if (i)
            output.comma();
          exp.print(output);
          if (i === len - 1 && exp instanceof AST_Hole)
            output.comma();
        });
        output.space();
      } : noop);
    });
    DEFPRINT(AST_DestructuredArray, function(output) {
      var a = this.elements, len = a.length, rest = this.rest;
      output.with_square(len || rest ? function() {
        output.space();
        a.forEach(function(exp, i) {
          if (i)
            output.comma();
          exp.print(output);
        });
        if (rest) {
          if (len)
            output.comma();
          output.print("...");
          rest.print(output);
        } else if (a[len - 1] instanceof AST_Hole) {
          output.comma();
        }
        output.space();
      } : noop);
    });
    DEFPRINT(AST_DestructuredKeyVal, function(output) {
      var self = this;
      var key = print_property_key(self, output);
      var value = self.value;
      if (key) {
        if (value instanceof AST_DefaultValue) {
          if (value.name instanceof AST_Symbol && key == get_symbol_name(value.name)) {
            output.space();
            output.print("=");
            output.space();
            value.value.print(output);
            return;
          }
        } else if (value instanceof AST_Symbol) {
          if (key == get_symbol_name(value))
            return;
        }
      }
      output.colon();
      value.print(output);
    });
    DEFPRINT(AST_DestructuredObject, function(output) {
      var self = this;
      var props = self.properties, len = props.length, rest = self.rest;
      if (len || rest)
        output.with_block(function() {
          props.forEach(function(prop, i) {
            if (i) {
              output.print(",");
              output.newline();
            }
            output.indent();
            prop.print(output);
          });
          if (rest) {
            if (len) {
              output.print(",");
              output.newline();
            }
            output.indent();
            output.print("...");
            rest.print(output);
          }
          output.newline();
        }, self.end);
      else
        print_braced_empty(self, output);
    });
    function print_properties(self, output, no_comma) {
      var props = self.properties;
      if (props.length > 0)
        output.with_block(function() {
          props.forEach(function(prop, i) {
            if (i) {
              if (!no_comma)
                output.print(",");
              output.newline();
            }
            output.indent();
            prop.print(output);
          });
          output.newline();
        }, self.end);
      else
        print_braced_empty(self, output);
    }
    DEFPRINT(AST_Object, function(output) {
      print_properties(this, output);
    });
    function print_property_key(self, output) {
      var key = self.key;
      if (key instanceof AST_Node)
        return output.with_square(function() {
          key.print(output);
        });
      var quote = self.start && self.start.quote;
      if (output.option("quote_keys") || quote && output.option("keep_quoted_props")) {
        output.print_string(key, quote);
      } else if ("" + +key == key && key >= 0) {
        output.print(make_num(key));
      } else if (self.private) {
        output.print_name(key);
      } else if (RESERVED_WORDS[key] ? !output.option("ie") : is_identifier_string(key)) {
        output.print_name(key);
        return key;
      } else {
        output.print_string(key, quote);
      }
    }
    DEFPRINT(AST_ObjectKeyVal, function(output) {
      var self = this;
      print_property_key(self, output);
      output.colon();
      self.value.print(output);
    });
    DEFPRINT(AST_ObjectMethod, function(output) {
      print_method(this, output);
    });
    function print_accessor(type) {
      return function(output) {
        var self = this;
        if (self.static) {
          output.print("static");
          output.space();
        }
        output.print(type);
        output.space();
        print_property_key(self, output);
        print_lambda(self.value, output);
      };
    }
    DEFPRINT(AST_ObjectGetter, print_accessor("get"));
    DEFPRINT(AST_ObjectSetter, print_accessor("set"));
    function get_symbol_name(sym) {
      var def = sym.definition();
      return def && def.mangled_name || sym.name;
    }
    DEFPRINT(AST_Symbol, function(output) {
      output.print_name(get_symbol_name(this));
    });
    DEFPRINT(AST_SymbolExport, function(output) {
      var self = this;
      var name = get_symbol_name(self);
      output.print_name(name);
      var alias = self.alias;
      if (alias.value != name) {
        output.space();
        output.print("as");
        output.space();
        print_alias(alias, output);
      }
    });
    DEFPRINT(AST_SymbolImport, function(output) {
      var self = this;
      var name = get_symbol_name(self);
      var key = self.key;
      if (key.value && key.value != name) {
        print_alias(key, output);
        output.space();
        output.print("as");
        output.space();
      }
      output.print_name(name);
    });
    DEFPRINT(AST_Hole, noop);
    DEFPRINT(AST_Template, function(output) {
      var self = this;
      if (self.tag)
        self.tag.print(output);
      output.print("`");
      for (var i = 0;i < self.expressions.length; i++) {
        output.print(self.strings[i]);
        output.print("${");
        self.expressions[i].print(output);
        output.print("}");
      }
      output.print(self.strings[i]);
      output.print("`");
    });
    DEFPRINT(AST_Constant, function(output) {
      output.print("" + this.value);
    });
    DEFPRINT(AST_String, function(output) {
      output.print_string(this.value, this.quote);
    });
    DEFPRINT(AST_Number, function(output) {
      var start = this.start;
      if (use_asm && start && start.raw != null) {
        output.print(start.raw);
      } else {
        output.print(make_num(this.value));
      }
    });
    DEFPRINT(AST_RegExp, function(output) {
      var regexp = this.value;
      var str = regexp.toString();
      var end = str.lastIndexOf("/");
      if (regexp.raw_source) {
        str = "/" + regexp.raw_source + str.slice(end);
      } else if (end == 1) {
        str = "/(?:)" + str.slice(end);
      } else if (str.indexOf("/", 1) < end) {
        str = "/" + str.slice(1, end).replace(/\\\\|[^/]?\//g, function(match) {
          return match[0] == "\\" ? match : match.slice(0, -1) + "\\/";
        }) + str.slice(end);
      }
      output.print(output.to_utf8(str).replace(/\\(?:\0(?![0-9])|[^\0])/g, function(match) {
        switch (match[1]) {
          case "\n":
            return "\\n";
          case "\r":
            return "\\r";
          case "\t":
            return "\t";
          case "\b":
            return "\b";
          case "\f":
            return "\f";
          case "\0":
            return "\0";
          case "\v":
            return "\v";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            return match;
        }
      }).replace(/[\n\r\u2028\u2029]/g, function(c) {
        switch (c) {
          case "\n":
            return "\\n";
          case "\r":
            return "\\r";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
        }
      }));
    });
    function force_statement(stat, output) {
      if (output.option("braces") && !(stat instanceof AST_Const || stat instanceof AST_Let)) {
        make_block(stat, output);
      } else if (stat instanceof AST_EmptyStatement) {
        output.force_semicolon();
      } else {
        output.space();
        stat.print(output);
      }
    }
    function need_constructor_parens(self, output) {
      if (self.args.length > 0)
        return true;
      return output.option("beautify");
    }
    function best_of(a) {
      var best = a[0], len = best.length;
      for (var i = 1;i < a.length; ++i) {
        if (a[i].length < len) {
          best = a[i];
          len = best.length;
        }
      }
      return best;
    }
    function make_num(num) {
      var str = num.toString(10).replace(/^0\./, ".").replace("e+", "e");
      var candidates = [str];
      if (Math.floor(num) === num) {
        if (num < 0) {
          candidates.push("-0x" + (-num).toString(16).toLowerCase());
        } else {
          candidates.push("0x" + num.toString(16).toLowerCase());
        }
      }
      var match, len, digits;
      if (match = /^\.0+/.exec(str)) {
        len = match[0].length;
        digits = str.slice(len);
        candidates.push(digits + "e-" + (digits.length + len - 1));
      } else if (match = /[^0]0+$/.exec(str)) {
        len = match[0].length - 1;
        candidates.push(str.slice(0, -len) + "e" + len);
      } else if (match = /^(\d)\.(\d+)e(-?\d+)$/.exec(str)) {
        candidates.push(match[1] + match[2] + "e" + (match[3] - match[2].length));
      }
      return best_of(candidates);
    }
    function make_block(stmt, output) {
      output.space();
      if (stmt instanceof AST_EmptyStatement) {
        print_braced_empty(stmt, output);
      } else if (stmt instanceof AST_BlockStatement) {
        stmt.print(output);
      } else
        output.with_block(function() {
          output.indent();
          stmt.print(output);
          output.newline();
        }, stmt.end);
    }
    function DEFMAP(nodetype, generator) {
      nodetype.forEach(function(nodetype2) {
        nodetype2.DEFMETHOD("add_source_map", generator);
      });
    }
    DEFMAP([
      AST_Node,
      AST_LabeledStatement
    ], noop);
    DEFMAP([
      AST_Array,
      AST_Await,
      AST_BlockStatement,
      AST_Catch,
      AST_Constant,
      AST_Debugger,
      AST_Definitions,
      AST_Destructured,
      AST_Directive,
      AST_Finally,
      AST_Jump,
      AST_Lambda,
      AST_New,
      AST_Object,
      AST_Spread,
      AST_StatementWithBody,
      AST_Symbol,
      AST_Switch,
      AST_SwitchBranch,
      AST_Try,
      AST_UnaryPrefix,
      AST_Yield
    ], function(output) {
      output.add_mapping(this.start);
    });
    DEFMAP([
      AST_ClassProperty,
      AST_DestructuredKeyVal,
      AST_ObjectProperty
    ], function(output) {
      if (typeof this.key == "string")
        output.add_mapping(this.start, this.key);
    });
  })();
});

// node_modules/uglify-js/lib/sourcemap.js
var exports_sourcemap = {};
var vlq_char, vlq_bits;
var init_sourcemap = __esm(() => {
  vlq_char = characters("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
  vlq_bits = vlq_char.reduce(function(map, ch, bits) {
    map[ch] = bits;
    return map;
  }, Object.create(null));
});

// node_modules/uglify-js/lib/mozilla-ast.js
var require_mozilla_ast = __commonJS((exports) => {
  (function() {
    var MOZ_TO_ME = {
      Program: function(M) {
        return new AST_Toplevel({
          start: my_start_token(M),
          end: my_end_token(M),
          body: normalize_directives(M.body.map(from_moz))
        });
      },
      ArrowFunctionExpression: function(M) {
        var argnames = [], rest = null;
        M.params.forEach(function(param) {
          if (param.type == "RestElement") {
            rest = from_moz(param.argument);
          } else {
            argnames.push(from_moz(param));
          }
        });
        var fn = new (M.async ? AST_AsyncArrow : AST_Arrow)({
          start: my_start_token(M),
          end: my_end_token(M),
          argnames,
          rest
        });
        var node = from_moz(M.body);
        if (node instanceof AST_BlockStatement) {
          fn.body = normalize_directives(node.body);
          fn.value = null;
        } else {
          fn.body = [];
          fn.value = node;
        }
        return fn;
      },
      FunctionDeclaration: function(M) {
        var ctor;
        if (M.async) {
          ctor = M.generator ? AST_AsyncGeneratorDefun : AST_AsyncDefun;
        } else {
          ctor = M.generator ? AST_GeneratorDefun : AST_Defun;
        }
        var argnames = [], rest = null;
        M.params.forEach(function(param) {
          if (param.type == "RestElement") {
            rest = from_moz(param.argument);
          } else {
            argnames.push(from_moz(param));
          }
        });
        return new ctor({
          start: my_start_token(M),
          end: my_end_token(M),
          name: from_moz(M.id),
          argnames,
          rest,
          body: normalize_directives(from_moz(M.body).body)
        });
      },
      FunctionExpression: function(M) {
        var ctor;
        if (M.async) {
          ctor = M.generator ? AST_AsyncGeneratorFunction : AST_AsyncFunction;
        } else {
          ctor = M.generator ? AST_GeneratorFunction : AST_Function;
        }
        var argnames = [], rest = null;
        M.params.forEach(function(param) {
          if (param.type == "RestElement") {
            rest = from_moz(param.argument);
          } else {
            argnames.push(from_moz(param));
          }
        });
        return new ctor({
          start: my_start_token(M),
          end: my_end_token(M),
          name: from_moz(M.id),
          argnames,
          rest,
          body: normalize_directives(from_moz(M.body).body)
        });
      },
      ClassDeclaration: function(M) {
        return new AST_DefClass({
          start: my_start_token(M),
          end: my_end_token(M),
          name: from_moz(M.id),
          extends: from_moz(M.superClass),
          properties: M.body.body.map(from_moz)
        });
      },
      ClassExpression: function(M) {
        return new AST_ClassExpression({
          start: my_start_token(M),
          end: my_end_token(M),
          name: from_moz(M.id),
          extends: from_moz(M.superClass),
          properties: M.body.body.map(from_moz)
        });
      },
      MethodDefinition: function(M) {
        var key = M.key, internal = false;
        if (M.computed) {
          key = from_moz(key);
        } else if (key.type == "PrivateIdentifier") {
          internal = true;
          key = "#" + key.name;
        } else {
          key = read_name(key);
        }
        var ctor = AST_ClassMethod, value = from_moz(M.value);
        switch (M.kind) {
          case "get":
            ctor = AST_ClassGetter;
            value = new AST_Accessor(value);
            break;
          case "set":
            ctor = AST_ClassSetter;
            value = new AST_Accessor(value);
            break;
        }
        return new ctor({
          start: my_start_token(M),
          end: my_end_token(M),
          key,
          private: internal,
          static: M.static,
          value
        });
      },
      PropertyDefinition: function(M) {
        var key = M.key, internal = false;
        if (M.computed) {
          key = from_moz(key);
        } else if (key.type == "PrivateIdentifier") {
          internal = true;
          key = "#" + key.name;
        } else {
          key = read_name(key);
        }
        return new AST_ClassField({
          start: my_start_token(M),
          end: my_end_token(M),
          key,
          private: internal,
          static: M.static,
          value: from_moz(M.value)
        });
      },
      StaticBlock: function(M) {
        var start = my_start_token(M);
        var end = my_end_token(M);
        return new AST_ClassInit({
          start,
          end,
          value: new AST_ClassInitBlock({
            start,
            end,
            body: normalize_directives(M.body.map(from_moz))
          })
        });
      },
      ForOfStatement: function(M) {
        return new (M.await ? AST_ForAwaitOf : AST_ForOf)({
          start: my_start_token(M),
          end: my_end_token(M),
          init: from_moz(M.left),
          object: from_moz(M.right),
          body: from_moz(M.body)
        });
      },
      TryStatement: function(M) {
        var handlers = M.handlers || [M.handler];
        if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {
          throw new Error("Multiple catch clauses are not supported.");
        }
        return new AST_Try({
          start: my_start_token(M),
          end: my_end_token(M),
          body: from_moz(M.block).body,
          bcatch: from_moz(handlers[0]),
          bfinally: M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null
        });
      },
      Property: function(M) {
        var key = M.computed ? from_moz(M.key) : read_name(M.key);
        var args = {
          start: my_start_token(M),
          end: my_end_token(M),
          key,
          value: from_moz(M.value)
        };
        if (M.kind == "init")
          return new (M.method ? AST_ObjectMethod : AST_ObjectKeyVal)(args);
        args.value = new AST_Accessor(args.value);
        if (M.kind == "get")
          return new AST_ObjectGetter(args);
        if (M.kind == "set")
          return new AST_ObjectSetter(args);
      },
      ArrayExpression: function(M) {
        return new AST_Array({
          start: my_start_token(M),
          end: my_end_token(M),
          elements: M.elements.map(function(elem) {
            return elem === null ? new AST_Hole : from_moz(elem);
          })
        });
      },
      ArrayPattern: function(M) {
        var elements = [], rest = null;
        M.elements.forEach(function(el) {
          if (el === null) {
            elements.push(new AST_Hole);
          } else if (el.type == "RestElement") {
            rest = from_moz(el.argument);
          } else {
            elements.push(from_moz(el));
          }
        });
        return new AST_DestructuredArray({
          start: my_start_token(M),
          end: my_end_token(M),
          elements,
          rest
        });
      },
      ObjectPattern: function(M) {
        var props = [], rest = null;
        M.properties.forEach(function(prop) {
          if (prop.type == "RestElement") {
            rest = from_moz(prop.argument);
          } else {
            props.push(new AST_DestructuredKeyVal(from_moz(prop)));
          }
        });
        return new AST_DestructuredObject({
          start: my_start_token(M),
          end: my_end_token(M),
          properties: props,
          rest
        });
      },
      MemberExpression: function(M) {
        return new (M.computed ? AST_Sub : AST_Dot)({
          start: my_start_token(M),
          end: my_end_token(M),
          optional: M.optional,
          expression: from_moz(M.object),
          property: M.computed ? from_moz(M.property) : M.property.name
        });
      },
      MetaProperty: function(M) {
        var expr = from_moz(M.meta);
        var prop = read_name(M.property);
        if (expr.name == "new" && prop == "target")
          return new AST_NewTarget({
            start: my_start_token(M),
            end: my_end_token(M),
            name: "new.target"
          });
        return new AST_Dot({
          start: my_start_token(M),
          end: my_end_token(M),
          expression: expr,
          property: prop
        });
      },
      SwitchCase: function(M) {
        return new (M.test ? AST_Case : AST_Default)({
          start: my_start_token(M),
          end: my_end_token(M),
          expression: from_moz(M.test),
          body: M.consequent.map(from_moz)
        });
      },
      ExportAllDeclaration: function(M) {
        var start = my_start_token(M);
        var end = my_end_token(M);
        return new AST_ExportForeign({
          start,
          end,
          aliases: [M.exported ? from_moz_alias(M.exported) : new AST_String({
            start,
            value: "*",
            end
          })],
          keys: [new AST_String({
            start,
            value: "*",
            end
          })],
          path: from_moz(M.source)
        });
      },
      ExportDefaultDeclaration: function(M) {
        var decl = from_moz(M.declaration);
        if (!decl.name)
          switch (decl.CTOR) {
            case AST_AsyncDefun:
              decl = new AST_AsyncFunction(decl);
              break;
            case AST_AsyncGeneratorDefun:
              decl = new AST_AsyncGeneratorFunction(decl);
              break;
            case AST_DefClass:
              decl = new AST_ClassExpression(decl);
              break;
            case AST_Defun:
              decl = new AST_Function(decl);
              break;
            case AST_GeneratorDefun:
              decl = new AST_GeneratorFunction(decl);
              break;
          }
        return new AST_ExportDefault({
          start: my_start_token(M),
          end: my_end_token(M),
          body: decl
        });
      },
      ExportNamedDeclaration: function(M) {
        if (M.declaration)
          return new AST_ExportDeclaration({
            start: my_start_token(M),
            end: my_end_token(M),
            body: from_moz(M.declaration)
          });
        if (M.source) {
          var aliases = [], keys = [];
          M.specifiers.forEach(function(prop) {
            aliases.push(from_moz_alias(prop.exported));
            keys.push(from_moz_alias(prop.local));
          });
          return new AST_ExportForeign({
            start: my_start_token(M),
            end: my_end_token(M),
            aliases,
            keys,
            path: from_moz(M.source)
          });
        }
        return new AST_ExportReferences({
          start: my_start_token(M),
          end: my_end_token(M),
          properties: M.specifiers.map(function(prop) {
            var sym = new AST_SymbolExport(from_moz(prop.local));
            sym.alias = from_moz_alias(prop.exported);
            return sym;
          })
        });
      },
      ImportDeclaration: function(M) {
        var start = my_start_token(M);
        var end = my_end_token(M);
        var all2 = null, def = null, props = null;
        M.specifiers.forEach(function(prop) {
          var sym = new AST_SymbolImport(from_moz(prop.local));
          switch (prop.type) {
            case "ImportDefaultSpecifier":
              def = sym;
              def.key = new AST_String({
                start,
                value: "",
                end
              });
              break;
            case "ImportNamespaceSpecifier":
              all2 = sym;
              all2.key = new AST_String({
                start,
                value: "*",
                end
              });
              break;
            default:
              sym.key = from_moz_alias(prop.imported);
              if (!props)
                props = [];
              props.push(sym);
              break;
          }
        });
        return new AST_Import({
          start,
          end,
          all: all2,
          default: def,
          properties: props,
          path: from_moz(M.source)
        });
      },
      ImportExpression: function(M) {
        var start = my_start_token(M);
        var arg = from_moz(M.source);
        return new AST_Call({
          start,
          end: my_end_token(M),
          expression: new AST_SymbolRef({
            start,
            end: arg.start,
            name: "import"
          }),
          args: [arg]
        });
      },
      VariableDeclaration: function(M) {
        return new ({
          const: AST_Const,
          let: AST_Let
        }[M.kind] || AST_Var)({
          start: my_start_token(M),
          end: my_end_token(M),
          definitions: M.declarations.map(from_moz)
        });
      },
      Literal: function(M) {
        var args = {
          start: my_start_token(M),
          end: my_end_token(M)
        };
        if (M.bigint) {
          args.value = M.bigint.toLowerCase() + "n";
          return new AST_BigInt(args);
        }
        var val = M.value;
        if (val === null)
          return new AST_Null(args);
        var rx = M.regex;
        if (rx && rx.pattern) {
          args.value = new RegExp(rx.pattern, rx.flags);
          args.value.raw_source = rx.pattern;
          return new AST_RegExp(args);
        } else if (rx) {
          args.value = M.regex && M.raw ? M.raw : val;
          return new AST_RegExp(args);
        }
        switch (typeof val) {
          case "string":
            args.value = val;
            return new AST_String(args);
          case "number":
            if (isNaN(val))
              return new AST_NaN(args);
            var negate, node;
            if (isFinite(val)) {
              negate = 1 / val < 0;
              args.value = negate ? -val : val;
              node = new AST_Number(args);
            } else {
              negate = val < 0;
              node = new AST_Infinity(args);
            }
            return negate ? new AST_UnaryPrefix({
              start: args.start,
              end: args.end,
              operator: "-",
              expression: node
            }) : node;
          case "boolean":
            return new (val ? AST_True : AST_False)(args);
        }
      },
      TemplateLiteral: function(M) {
        return new AST_Template({
          start: my_start_token(M),
          end: my_end_token(M),
          expressions: M.expressions.map(from_moz),
          strings: M.quasis.map(function(el) {
            return el.value.raw;
          })
        });
      },
      TaggedTemplateExpression: function(M) {
        var tmpl = from_moz(M.quasi);
        tmpl.start = my_start_token(M);
        tmpl.end = my_end_token(M);
        tmpl.tag = from_moz(M.tag);
        return tmpl;
      },
      Identifier: function(M) {
        var p, level = FROM_MOZ_STACK.length - 1;
        do {
          p = FROM_MOZ_STACK[--level];
        } while (p.type == "ArrayPattern" || p.type == "AssignmentPattern" && p.left === FROM_MOZ_STACK[level + 1] || p.type == "ObjectPattern" || p.type == "Property" && p.value === FROM_MOZ_STACK[level + 1] || p.type == "VariableDeclarator" && p.id === FROM_MOZ_STACK[level + 1]);
        var ctor = AST_SymbolRef;
        switch (p.type) {
          case "ArrowFunctionExpression":
            if (p.body !== FROM_MOZ_STACK[level + 1])
              ctor = AST_SymbolFunarg;
            break;
          case "BreakStatement":
          case "ContinueStatement":
            ctor = AST_LabelRef;
            break;
          case "CatchClause":
            ctor = AST_SymbolCatch;
            break;
          case "ClassDeclaration":
            if (p.id === FROM_MOZ_STACK[level + 1])
              ctor = AST_SymbolDefClass;
            break;
          case "ClassExpression":
            if (p.id === FROM_MOZ_STACK[level + 1])
              ctor = AST_SymbolClass;
            break;
          case "FunctionDeclaration":
            ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolDefun : AST_SymbolFunarg;
            break;
          case "FunctionExpression":
            ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolLambda : AST_SymbolFunarg;
            break;
          case "LabeledStatement":
            ctor = AST_Label;
            break;
          case "VariableDeclaration":
            ctor = {
              const: AST_SymbolConst,
              let: AST_SymbolLet
            }[p.kind] || AST_SymbolVar;
            break;
        }
        return new ctor({
          start: my_start_token(M),
          end: my_end_token(M),
          name: M.name
        });
      },
      Super: function(M) {
        return new AST_Super({
          start: my_start_token(M),
          end: my_end_token(M),
          name: "super"
        });
      },
      ThisExpression: function(M) {
        return new AST_This({
          start: my_start_token(M),
          end: my_end_token(M),
          name: "this"
        });
      },
      ParenthesizedExpression: function(M) {
        var node = from_moz(M.expression);
        if (!node.start.parens)
          node.start.parens = [];
        node.start.parens.push(my_start_token(M));
        if (!node.end.parens)
          node.end.parens = [];
        node.end.parens.push(my_end_token(M));
        return node;
      },
      ChainExpression: function(M) {
        var node = from_moz(M.expression);
        node.terminal = true;
        return node;
      }
    };
    MOZ_TO_ME.UpdateExpression = MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {
      var prefix = "prefix" in M ? M.prefix : M.type == "UnaryExpression" ? true : false;
      return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({
        start: my_start_token(M),
        end: my_end_token(M),
        operator: M.operator,
        expression: from_moz(M.argument)
      });
    };
    map("EmptyStatement", AST_EmptyStatement);
    map("ExpressionStatement", AST_SimpleStatement, "expression>body");
    map("BlockStatement", AST_BlockStatement, "body@body");
    map("IfStatement", AST_If, "test>condition, consequent>body, alternate>alternative");
    map("LabeledStatement", AST_LabeledStatement, "label>label, body>body");
    map("BreakStatement", AST_Break, "label>label");
    map("ContinueStatement", AST_Continue, "label>label");
    map("WithStatement", AST_With, "object>expression, body>body");
    map("SwitchStatement", AST_Switch, "discriminant>expression, cases@body");
    map("ReturnStatement", AST_Return, "argument>value");
    map("ThrowStatement", AST_Throw, "argument>value");
    map("WhileStatement", AST_While, "test>condition, body>body");
    map("DoWhileStatement", AST_Do, "test>condition, body>body");
    map("ForStatement", AST_For, "init>init, test>condition, update>step, body>body");
    map("ForInStatement", AST_ForIn, "left>init, right>object, body>body");
    map("DebuggerStatement", AST_Debugger);
    map("VariableDeclarator", AST_VarDef, "id>name, init>value");
    map("CatchClause", AST_Catch, "param>argname, body%body");
    map("BinaryExpression", AST_Binary, "operator=operator, left>left, right>right");
    map("LogicalExpression", AST_Binary, "operator=operator, left>left, right>right");
    map("AssignmentExpression", AST_Assign, "operator=operator, left>left, right>right");
    map("AssignmentPattern", AST_DefaultValue, "left>name, right>value");
    map("ConditionalExpression", AST_Conditional, "test>condition, consequent>consequent, alternate>alternative");
    map("NewExpression", AST_New, "callee>expression, arguments@args, pure=pure");
    map("CallExpression", AST_Call, "callee>expression, arguments@args, optional=optional, pure=pure");
    map("SequenceExpression", AST_Sequence, "expressions@expressions");
    map("SpreadElement", AST_Spread, "argument>expression");
    map("ObjectExpression", AST_Object, "properties@properties");
    map("AwaitExpression", AST_Await, "argument>expression");
    map("YieldExpression", AST_Yield, "argument>expression, delegate=nested");
    def_to_moz(AST_Toplevel, function To_Moz_Program(M) {
      return to_moz_scope("Program", M);
    });
    def_to_moz(AST_LambdaDefinition, function To_Moz_FunctionDeclaration(M) {
      var params = M.argnames.map(to_moz);
      if (M.rest)
        params.push({
          type: "RestElement",
          argument: to_moz(M.rest)
        });
      return {
        type: "FunctionDeclaration",
        id: to_moz(M.name),
        async: is_async(M),
        generator: is_generator(M),
        params,
        body: to_moz_scope("BlockStatement", M)
      };
    });
    def_to_moz(AST_Lambda, function To_Moz_FunctionExpression(M) {
      var params = M.argnames.map(to_moz);
      if (M.rest)
        params.push({
          type: "RestElement",
          argument: to_moz(M.rest)
        });
      if (is_arrow(M))
        return {
          type: "ArrowFunctionExpression",
          async: is_async(M),
          params,
          body: M.value ? to_moz(M.value) : to_moz_scope("BlockStatement", M)
        };
      return {
        type: "FunctionExpression",
        id: to_moz(M.name),
        async: is_async(M),
        generator: is_generator(M),
        params,
        body: to_moz_scope("BlockStatement", M)
      };
    });
    def_to_moz(AST_DefClass, function To_Moz_ClassDeclaration(M) {
      return {
        type: "ClassDeclaration",
        id: to_moz(M.name),
        superClass: to_moz(M.extends),
        body: {
          type: "ClassBody",
          body: M.properties.map(to_moz)
        }
      };
    });
    def_to_moz(AST_ClassExpression, function To_Moz_ClassExpression(M) {
      return {
        type: "ClassExpression",
        id: to_moz(M.name),
        superClass: to_moz(M.extends),
        body: {
          type: "ClassBody",
          body: M.properties.map(to_moz)
        }
      };
    });
    function To_Moz_MethodDefinition(kind) {
      return function(M) {
        var computed = M.key instanceof AST_Node;
        var key = computed ? to_moz(M.key) : M.private ? {
          type: "PrivateIdentifier",
          name: M.key.slice(1)
        } : {
          type: "Literal",
          value: M.key
        };
        return {
          type: "MethodDefinition",
          kind,
          computed,
          key,
          static: M.static,
          value: to_moz(M.value)
        };
      };
    }
    def_to_moz(AST_ClassGetter, To_Moz_MethodDefinition("get"));
    def_to_moz(AST_ClassSetter, To_Moz_MethodDefinition("set"));
    def_to_moz(AST_ClassMethod, To_Moz_MethodDefinition("method"));
    def_to_moz(AST_ClassField, function To_Moz_PropertyDefinition(M) {
      var computed = M.key instanceof AST_Node;
      var key = computed ? to_moz(M.key) : M.private ? {
        type: "PrivateIdentifier",
        name: M.key.slice(1)
      } : {
        type: "Literal",
        value: M.key
      };
      return {
        type: "PropertyDefinition",
        computed,
        key,
        static: M.static,
        value: to_moz(M.value)
      };
    });
    def_to_moz(AST_ClassInit, function To_Moz_StaticBlock(M) {
      return to_moz_scope("StaticBlock", M.value);
    });
    function To_Moz_ForOfStatement(is_await) {
      return function(M) {
        return {
          type: "ForOfStatement",
          await: is_await,
          left: to_moz(M.init),
          right: to_moz(M.object),
          body: to_moz(M.body)
        };
      };
    }
    def_to_moz(AST_ForAwaitOf, To_Moz_ForOfStatement(true));
    def_to_moz(AST_ForOf, To_Moz_ForOfStatement(false));
    def_to_moz(AST_Directive, function To_Moz_Directive(M) {
      return {
        type: "ExpressionStatement",
        expression: set_moz_loc(M, {
          type: "Literal",
          value: M.value
        })
      };
    });
    def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {
      return {
        type: "SwitchCase",
        test: to_moz(M.expression),
        consequent: M.body.map(to_moz)
      };
    });
    def_to_moz(AST_Try, function To_Moz_TryStatement(M) {
      return {
        type: "TryStatement",
        block: to_moz_block(M),
        handler: to_moz(M.bcatch),
        guardedHandlers: [],
        finalizer: to_moz(M.bfinally)
      };
    });
    def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {
      return {
        type: "CatchClause",
        param: to_moz(M.argname),
        guard: null,
        body: to_moz_block(M)
      };
    });
    def_to_moz(AST_ExportDeclaration, function To_Moz_ExportNamedDeclaration_declaration(M) {
      return {
        type: "ExportNamedDeclaration",
        declaration: to_moz(M.body)
      };
    });
    def_to_moz(AST_ExportDefault, function To_Moz_ExportDefaultDeclaration(M) {
      return {
        type: "ExportDefaultDeclaration",
        declaration: to_moz(M.body)
      };
    });
    def_to_moz(AST_ExportForeign, function To_Moz_ExportAllDeclaration_ExportNamedDeclaration(M) {
      if (M.keys[0].value == "*")
        return {
          type: "ExportAllDeclaration",
          exported: M.aliases[0].value == "*" ? null : to_moz_alias(M.aliases[0]),
          source: to_moz(M.path)
        };
      var specifiers = [];
      for (var i = 0;i < M.aliases.length; i++) {
        specifiers.push(set_moz_loc({
          start: M.keys[i].start,
          end: M.aliases[i].end
        }, {
          type: "ExportSpecifier",
          local: to_moz_alias(M.keys[i]),
          exported: to_moz_alias(M.aliases[i])
        }));
      }
      return {
        type: "ExportNamedDeclaration",
        specifiers,
        source: to_moz(M.path)
      };
    });
    def_to_moz(AST_ExportReferences, function To_Moz_ExportNamedDeclaration_specifiers(M) {
      return {
        type: "ExportNamedDeclaration",
        specifiers: M.properties.map(function(prop) {
          return set_moz_loc({
            start: prop.start,
            end: prop.alias.end
          }, {
            type: "ExportSpecifier",
            local: to_moz(prop),
            exported: to_moz_alias(prop.alias)
          });
        })
      };
    });
    def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {
      var specifiers = M.properties ? M.properties.map(function(prop) {
        return set_moz_loc({
          start: prop.key.start,
          end: prop.end
        }, {
          type: "ImportSpecifier",
          local: to_moz(prop),
          imported: to_moz_alias(prop.key)
        });
      }) : [];
      if (M.all)
        specifiers.unshift(set_moz_loc(M.all, {
          type: "ImportNamespaceSpecifier",
          local: to_moz(M.all)
        }));
      if (M.default)
        specifiers.unshift(set_moz_loc(M.default, {
          type: "ImportDefaultSpecifier",
          local: to_moz(M.default)
        }));
      return {
        type: "ImportDeclaration",
        specifiers,
        source: to_moz(M.path)
      };
    });
    def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {
      return {
        type: "VariableDeclaration",
        kind: M.TYPE.toLowerCase(),
        declarations: M.definitions.map(to_moz)
      };
    });
    def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {
      var computed = M instanceof AST_Sub;
      var expr = {
        type: "MemberExpression",
        object: to_moz(M.expression),
        computed,
        optional: M.optional,
        property: computed ? to_moz(M.property) : {
          type: "Identifier",
          name: M.property
        }
      };
      return M.terminal ? {
        type: "ChainExpression",
        expression: expr
      } : expr;
    });
    def_to_moz(AST_Unary, function To_Moz_Unary(M) {
      return {
        type: M.operator == "++" || M.operator == "--" ? "UpdateExpression" : "UnaryExpression",
        operator: M.operator,
        prefix: M instanceof AST_UnaryPrefix,
        argument: to_moz(M.expression)
      };
    });
    def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {
      return {
        type: M.operator == "&&" || M.operator == "||" ? "LogicalExpression" : "BinaryExpression",
        left: to_moz(M.left),
        operator: M.operator,
        right: to_moz(M.right)
      };
    });
    def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {
      return {
        type: "ArrayExpression",
        elements: M.elements.map(to_moz)
      };
    });
    def_to_moz(AST_DestructuredArray, function To_Moz_ArrayPattern(M) {
      var elements = M.elements.map(to_moz);
      if (M.rest)
        elements.push({
          type: "RestElement",
          argument: to_moz(M.rest)
        });
      return {
        type: "ArrayPattern",
        elements
      };
    });
    def_to_moz(AST_DestructuredKeyVal, function To_Moz_Property(M) {
      var computed = M.key instanceof AST_Node;
      var key = computed ? to_moz(M.key) : {
        type: "Literal",
        value: M.key
      };
      return {
        type: "Property",
        kind: "init",
        computed,
        key,
        value: to_moz(M.value)
      };
    });
    def_to_moz(AST_DestructuredObject, function To_Moz_ObjectPattern(M) {
      var props = M.properties.map(to_moz);
      if (M.rest)
        props.push({
          type: "RestElement",
          argument: to_moz(M.rest)
        });
      return {
        type: "ObjectPattern",
        properties: props
      };
    });
    def_to_moz(AST_ObjectProperty, function To_Moz_Property(M) {
      var computed = M.key instanceof AST_Node;
      var key = computed ? to_moz(M.key) : {
        type: "Literal",
        value: M.key
      };
      var kind;
      if (M instanceof AST_ObjectKeyVal) {
        kind = "init";
      } else if (M instanceof AST_ObjectGetter) {
        kind = "get";
      } else if (M instanceof AST_ObjectSetter) {
        kind = "set";
      }
      return {
        type: "Property",
        kind,
        computed,
        method: M instanceof AST_ObjectMethod,
        key,
        value: to_moz(M.value)
      };
    });
    def_to_moz(AST_Symbol, function To_Moz_Identifier(M) {
      var def = M.definition();
      return {
        type: "Identifier",
        name: def && def.mangled_name || M.name
      };
    });
    def_to_moz(AST_Super, function To_Moz_Super() {
      return { type: "Super" };
    });
    def_to_moz(AST_This, function To_Moz_ThisExpression() {
      return { type: "ThisExpression" };
    });
    def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {
      return {
        type: "MetaProperty",
        meta: {
          type: "Identifier",
          name: "new"
        },
        property: {
          type: "Identifier",
          name: "target"
        }
      };
    });
    def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {
      var flags = M.value.toString().match(/\/([gimuy]*)$/)[1];
      var value = "/" + M.value.raw_source + "/" + flags;
      return {
        type: "Literal",
        value,
        raw: value,
        regex: {
          pattern: M.value.raw_source,
          flags
        }
      };
    });
    def_to_moz(AST_BigInt, function To_Moz_BigInt(M) {
      var value = M.value;
      return {
        type: "Literal",
        bigint: value.slice(0, -1),
        raw: value
      };
    });
    function To_Moz_Literal(M) {
      var value = M.value;
      if (typeof value === "number" && (value < 0 || value === 0 && 1 / value < 0)) {
        return {
          type: "UnaryExpression",
          operator: "-",
          prefix: true,
          argument: {
            type: "Literal",
            value: -value,
            raw: M.start.raw
          }
        };
      }
      return {
        type: "Literal",
        value,
        raw: M.start.raw
      };
    }
    def_to_moz(AST_Boolean, To_Moz_Literal);
    def_to_moz(AST_Constant, To_Moz_Literal);
    def_to_moz(AST_Null, To_Moz_Literal);
    def_to_moz(AST_Atom, function To_Moz_Atom(M) {
      return {
        type: "Identifier",
        name: String(M.value)
      };
    });
    def_to_moz(AST_Template, function To_Moz_TemplateLiteral_TaggedTemplateExpression(M) {
      var last = M.strings.length - 1;
      var tmpl = {
        type: "TemplateLiteral",
        expressions: M.expressions.map(to_moz),
        quasis: M.strings.map(function(str, index) {
          return {
            type: "TemplateElement",
            tail: index == last,
            value: { raw: str }
          };
        })
      };
      if (!M.tag)
        return tmpl;
      return {
        type: "TaggedTemplateExpression",
        tag: to_moz(M.tag),
        quasi: tmpl
      };
    });
    AST_Block.DEFMETHOD("to_mozilla_ast", AST_BlockStatement.prototype.to_mozilla_ast);
    AST_Hole.DEFMETHOD("to_mozilla_ast", return_null);
    AST_Node.DEFMETHOD("to_mozilla_ast", function() {
      throw new Error("Cannot convert AST_" + this.TYPE);
    });
    function normalize_directives(body) {
      for (var i = 0;i < body.length; i++) {
        var stat = body[i];
        if (!(stat instanceof AST_SimpleStatement))
          break;
        var node = stat.body;
        if (!(node instanceof AST_String))
          break;
        if (stat.start.pos !== node.start.pos)
          break;
        body[i] = new AST_Directive(node);
      }
      return body;
    }
    function raw_token(moznode) {
      if (moznode.type == "Literal") {
        return moznode.raw != null ? moznode.raw : moznode.value + "";
      }
    }
    function my_start_token(moznode) {
      var loc = moznode.loc, start = loc && loc.start;
      var range = moznode.range;
      return new AST_Token({
        file: loc && loc.source,
        line: start && start.line,
        col: start && start.column,
        pos: range ? range[0] : moznode.start,
        endline: start && start.line,
        endcol: start && start.column,
        endpos: range ? range[0] : moznode.start,
        raw: raw_token(moznode)
      });
    }
    function my_end_token(moznode) {
      var loc = moznode.loc, end = loc && loc.end;
      var range = moznode.range;
      return new AST_Token({
        file: loc && loc.source,
        line: end && end.line,
        col: end && end.column,
        pos: range ? range[1] : moznode.end,
        endline: end && end.line,
        endcol: end && end.column,
        endpos: range ? range[1] : moznode.end,
        raw: raw_token(moznode)
      });
    }
    function read_name(M) {
      return "" + M[M.type == "Identifier" ? "name" : "value"];
    }
    function map(moztype, mytype, propmap) {
      var moz_to_me = [
        "start: my_start_token(M)",
        "end: my_end_token(M)"
      ];
      var me_to_moz = [
        "type: " + JSON.stringify(moztype)
      ];
      if (propmap)
        propmap.split(/\s*,\s*/).forEach(function(prop) {
          var m = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);
          if (!m)
            throw new Error("Can't understand property map: " + prop);
          var moz = m[1], how = m[2], my = m[3];
          switch (how) {
            case "@":
              moz_to_me.push(my + ": M." + moz + ".map(from_moz)");
              me_to_moz.push(moz + ": M." + my + ".map(to_moz)");
              break;
            case ">":
              moz_to_me.push(my + ": from_moz(M." + moz + ")");
              me_to_moz.push(moz + ": to_moz(M." + my + ")");
              break;
            case "=":
              moz_to_me.push(my + ": M." + moz);
              me_to_moz.push(moz + ": M." + my);
              break;
            case "%":
              moz_to_me.push(my + ": from_moz(M." + moz + ").body");
              me_to_moz.push(moz + ": to_moz_block(M)");
              break;
            default:
              throw new Error("Can't understand operator in propmap: " + prop);
          }
        });
      MOZ_TO_ME[moztype] = new Function("U2", "my_start_token", "my_end_token", "from_moz", [
        "return function From_Moz_" + moztype + "(M) {",
        "    return new U2.AST_" + mytype.TYPE + "({",
        moz_to_me.join(",\n"),
        "    });",
        "};"
      ].join("\n"))(exports, my_start_token, my_end_token, from_moz);
      def_to_moz(mytype, new Function("to_moz", "to_moz_block", "to_moz_scope", [
        "return function To_Moz_" + moztype + "(M) {",
        "    return {",
        me_to_moz.join(",\n"),
        "    };",
        "};"
      ].join("\n"))(to_moz, to_moz_block, to_moz_scope));
    }
    var FROM_MOZ_STACK = null;
    function from_moz(moz) {
      FROM_MOZ_STACK.push(moz);
      var node = null;
      if (moz) {
        if (!HOP(MOZ_TO_ME, moz.type))
          throw new Error("Unsupported type: " + moz.type);
        node = MOZ_TO_ME[moz.type](moz);
      }
      FROM_MOZ_STACK.pop();
      return node;
    }
    function from_moz_alias(moz) {
      return new AST_String({
        start: my_start_token(moz),
        value: read_name(moz),
        end: my_end_token(moz)
      });
    }
    AST_Node.from_mozilla_ast = function(node) {
      var save_stack = FROM_MOZ_STACK;
      FROM_MOZ_STACK = [];
      var ast = from_moz(node);
      FROM_MOZ_STACK = save_stack;
      ast.walk(new TreeWalker(function(node2) {
        if (node2 instanceof AST_LabelRef) {
          for (var level = 0, parent;parent = this.parent(level); level++) {
            if (parent instanceof AST_Scope)
              break;
            if (parent instanceof AST_LabeledStatement && parent.label.name == node2.name) {
              node2.thedef = parent.label;
              break;
            }
          }
          if (!node2.thedef) {
            var s = node2.start;
            js_error("Undefined label " + node2.name, s.file, s.line, s.col, s.pos);
          }
        }
      }));
      return ast;
    };
    function set_moz_loc(mynode, moznode) {
      var start = mynode.start;
      var end = mynode.end;
      if (start.pos != null && end.endpos != null) {
        moznode.range = [start.pos, end.endpos];
      }
      if (start.line) {
        moznode.loc = {
          start: { line: start.line, column: start.col },
          end: end.endline ? { line: end.endline, column: end.endcol } : null
        };
        if (start.file) {
          moznode.loc.source = start.file;
        }
      }
      return moznode;
    }
    function def_to_moz(mytype, handler) {
      mytype.DEFMETHOD("to_mozilla_ast", function() {
        return set_moz_loc(this, handler(this));
      });
    }
    function to_moz(node) {
      return node != null ? node.to_mozilla_ast() : null;
    }
    function to_moz_alias(alias) {
      return is_identifier_string(alias.value) ? set_moz_loc(alias, {
        type: "Identifier",
        name: alias.value
      }) : to_moz(alias);
    }
    function to_moz_block(node) {
      return {
        type: "BlockStatement",
        body: node.body.map(to_moz)
      };
    }
    function to_moz_scope(type, node) {
      var body = node.body.map(to_moz);
      if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {
        body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));
      }
      return {
        type,
        body
      };
    }
  })();
});

// node_modules/uglify-js/lib/propmangle.js
var exports_propmangle = {};
var init_propmangle = __esm(() => {
});

// node_modules/uglify-js/lib/minify.js
var exports_minify = {};
var to_ascii, to_base64;
var init_minify = __esm(() => {
  if (typeof Buffer == "undefined") {
    to_ascii = atob;
    to_base64 = btoa;
  } else if (typeof Buffer.alloc == "undefined") {
    to_ascii = function(b64) {
      return new Buffer(b64, "base64").toString();
    };
    to_base64 = function(str) {
      return new Buffer(str).toString("base64");
    };
  } else {
    to_ascii = function(b64) {
      return Buffer.from(b64, "base64").toString();
    };
    to_base64 = function(str) {
      return Buffer.from(str).toString("base64");
    };
  }
});

// node_modules/uglify-js/tools/exports.js
var require_exports = __commonJS((exports) => {
  exports.Dictionary = Dictionary;
  exports.is_statement = is_statement;
  exports.List = List;
  exports.minify = minify;
  exports.parse = parse;
  exports.push_uniq = push_uniq;
  exports.TreeTransformer = TreeTransformer;
  exports.TreeWalker = TreeWalker;
});

// node_modules/uglify-js/tools/domprops.json
var require_domprops = __commonJS((exports, module) => {
  module.exports = [
    "$&",
    "$'",
    "$*",
    "$+",
    "$1",
    "$2",
    "$3",
    "$4",
    "$5",
    "$6",
    "$7",
    "$8",
    "$9",
    "$_",
    "$`",
    "$input",
    "-moz-animation",
    "-moz-animation-delay",
    "-moz-animation-direction",
    "-moz-animation-duration",
    "-moz-animation-fill-mode",
    "-moz-animation-iteration-count",
    "-moz-animation-name",
    "-moz-animation-play-state",
    "-moz-animation-timing-function",
    "-moz-appearance",
    "-moz-backface-visibility",
    "-moz-binding",
    "-moz-border-end",
    "-moz-border-end-color",
    "-moz-border-end-style",
    "-moz-border-end-width",
    "-moz-border-image",
    "-moz-border-start",
    "-moz-border-start-color",
    "-moz-border-start-style",
    "-moz-border-start-width",
    "-moz-box-align",
    "-moz-box-direction",
    "-moz-box-flex",
    "-moz-box-ordinal-group",
    "-moz-box-orient",
    "-moz-box-pack",
    "-moz-box-sizing",
    "-moz-column-count",
    "-moz-column-fill",
    "-moz-column-gap",
    "-moz-column-rule",
    "-moz-column-rule-color",
    "-moz-column-rule-style",
    "-moz-column-rule-width",
    "-moz-column-width",
    "-moz-columns",
    "-moz-float-edge",
    "-moz-font-feature-settings",
    "-moz-font-language-override",
    "-moz-force-broken-image-icon",
    "-moz-hyphens",
    "-moz-image-region",
    "-moz-margin-end",
    "-moz-margin-start",
    "-moz-orient",
    "-moz-outline-radius",
    "-moz-outline-radius-bottomleft",
    "-moz-outline-radius-bottomright",
    "-moz-outline-radius-topleft",
    "-moz-outline-radius-topright",
    "-moz-padding-end",
    "-moz-padding-start",
    "-moz-perspective",
    "-moz-perspective-origin",
    "-moz-stack-sizing",
    "-moz-tab-size",
    "-moz-text-size-adjust",
    "-moz-transform",
    "-moz-transform-origin",
    "-moz-transform-style",
    "-moz-transition",
    "-moz-transition-delay",
    "-moz-transition-duration",
    "-moz-transition-property",
    "-moz-transition-timing-function",
    "-moz-user-focus",
    "-moz-user-input",
    "-moz-user-modify",
    "-moz-user-select",
    "-moz-window-dragging",
    "-webkit-align-content",
    "-webkit-align-items",
    "-webkit-align-self",
    "-webkit-animation",
    "-webkit-animation-delay",
    "-webkit-animation-direction",
    "-webkit-animation-duration",
    "-webkit-animation-fill-mode",
    "-webkit-animation-iteration-count",
    "-webkit-animation-name",
    "-webkit-animation-play-state",
    "-webkit-animation-timing-function",
    "-webkit-appearance",
    "-webkit-backface-visibility",
    "-webkit-background-clip",
    "-webkit-background-origin",
    "-webkit-background-size",
    "-webkit-border-bottom-left-radius",
    "-webkit-border-bottom-right-radius",
    "-webkit-border-image",
    "-webkit-border-radius",
    "-webkit-border-top-left-radius",
    "-webkit-border-top-right-radius",
    "-webkit-box-align",
    "-webkit-box-direction",
    "-webkit-box-flex",
    "-webkit-box-ordinal-group",
    "-webkit-box-orient",
    "-webkit-box-pack",
    "-webkit-box-shadow",
    "-webkit-box-sizing",
    "-webkit-filter",
    "-webkit-flex",
    "-webkit-flex-basis",
    "-webkit-flex-direction",
    "-webkit-flex-flow",
    "-webkit-flex-grow",
    "-webkit-flex-shrink",
    "-webkit-flex-wrap",
    "-webkit-justify-content",
    "-webkit-line-clamp",
    "-webkit-mask",
    "-webkit-mask-clip",
    "-webkit-mask-composite",
    "-webkit-mask-image",
    "-webkit-mask-origin",
    "-webkit-mask-position",
    "-webkit-mask-position-x",
    "-webkit-mask-position-y",
    "-webkit-mask-repeat",
    "-webkit-mask-size",
    "-webkit-order",
    "-webkit-perspective",
    "-webkit-perspective-origin",
    "-webkit-text-fill-color",
    "-webkit-text-size-adjust",
    "-webkit-text-stroke",
    "-webkit-text-stroke-color",
    "-webkit-text-stroke-width",
    "-webkit-transform",
    "-webkit-transform-origin",
    "-webkit-transform-style",
    "-webkit-transition",
    "-webkit-transition-delay",
    "-webkit-transition-duration",
    "-webkit-transition-property",
    "-webkit-transition-timing-function",
    "-webkit-user-select",
    "0",
    "1",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "2",
    "20",
    "21",
    "22",
    "23",
    "24",
    "25",
    "26",
    "27",
    "28",
    "29",
    "3",
    "30",
    "31",
    "32",
    "33",
    "34",
    "35",
    "36",
    "37",
    "38",
    "39",
    "4",
    "40",
    "41",
    "42",
    "43",
    "44",
    "45",
    "46",
    "47",
    "48",
    "49",
    "5",
    "50",
    "51",
    "6",
    "7",
    "8",
    "9",
    "@@iterator",
    "ABORT_ERR",
    "ACTIVE",
    "ACTIVE_ATTRIBUTES",
    "ACTIVE_TEXTURE",
    "ACTIVE_UNIFORMS",
    "ACTIVE_UNIFORM_BLOCKS",
    "ADDITION",
    "ALIASED_LINE_WIDTH_RANGE",
    "ALIASED_POINT_SIZE_RANGE",
    "ALLOW_KEYBOARD_INPUT",
    "ALLPASS",
    "ALPHA",
    "ALPHA_BITS",
    "ALREADY_SIGNALED",
    "ALT_MASK",
    "ALWAYS",
    "ANDROID",
    "ANGLE_instanced_arrays",
    "ANY_SAMPLES_PASSED",
    "ANY_SAMPLES_PASSED_CONSERVATIVE",
    "ANY_TYPE",
    "ANY_UNORDERED_NODE_TYPE",
    "APP_UPDATE",
    "ARM",
    "ARRAY_BUFFER",
    "ARRAY_BUFFER_BINDING",
    "ATTACHED_SHADERS",
    "ATTRIBUTE_NODE",
    "AT_TARGET",
    "AbortController",
    "AbortSignal",
    "AbsoluteOrientationSensor",
    "AbstractRange",
    "Accelerometer",
    "ActiveXObject",
    "AddSearchProvider",
    "AesGcmEncryptResult",
    "AggregateError",
    "AnalyserNode",
    "Animation",
    "AnimationEffect",
    "AnimationEvent",
    "AnimationPlaybackEvent",
    "AnimationTimeline",
    "AnonXMLHttpRequest",
    "AppBannerPromptResult",
    "ApplicationCache",
    "ApplicationCacheErrorEvent",
    "Array",
    "ArrayBuffer",
    "Atomics",
    "Attr",
    "Audio",
    "AudioBuffer",
    "AudioBufferSourceNode",
    "AudioContext",
    "AudioDestinationNode",
    "AudioListener",
    "AudioNode",
    "AudioParam",
    "AudioParamMap",
    "AudioProcessingEvent",
    "AudioScheduledSourceNode",
    "AudioStreamTrack",
    "AudioTrack",
    "AudioTrackList",
    "AudioWorklet",
    "AudioWorkletNode",
    "AuthenticatorAssertionResponse",
    "AuthenticatorAttestationResponse",
    "AuthenticatorResponse",
    "AutocompleteErrorEvent",
    "BACK",
    "BAD_BOUNDARYPOINTS_ERR",
    "BAD_REQUEST",
    "BANDPASS",
    "BLEND",
    "BLEND_COLOR",
    "BLEND_DST_ALPHA",
    "BLEND_DST_RGB",
    "BLEND_EQUATION",
    "BLEND_EQUATION_ALPHA",
    "BLEND_EQUATION_RGB",
    "BLEND_SRC_ALPHA",
    "BLEND_SRC_RGB",
    "BLUE_BITS",
    "BLUR",
    "BOOL",
    "BOOLEAN_TYPE",
    "BOOL_VEC2",
    "BOOL_VEC3",
    "BOOL_VEC4",
    "BOTH",
    "BROWSER_DEFAULT_WEBGL",
    "BUBBLING_PHASE",
    "BUFFER_SIZE",
    "BUFFER_USAGE",
    "BYTE",
    "BYTES_PER_ELEMENT",
    "BackgroundFetchManager",
    "BackgroundFetchRecord",
    "BackgroundFetchRegistration",
    "BarProp",
    "BarcodeDetector",
    "BaseAudioContext",
    "BaseHref",
    "BatteryManager",
    "BeforeInstallPromptEvent",
    "BeforeLoadEvent",
    "BeforeUnloadEvent",
    "BigInt",
    "BigInt64Array",
    "BigUint64Array",
    "BiquadFilterNode",
    "Blob",
    "BlobEvent",
    "Bluetooth",
    "BluetoothCharacteristicProperties",
    "BluetoothDevice",
    "BluetoothRemoteGATTCharacteristic",
    "BluetoothRemoteGATTDescriptor",
    "BluetoothRemoteGATTServer",
    "BluetoothRemoteGATTService",
    "BluetoothUUID",
    "BookmarkCollection",
    "Boolean",
    "BroadcastChannel",
    "ByteLengthQueuingStrategy",
    "CANNOT_RUN",
    "CAPTURING_PHASE",
    "CCW",
    "CDATASection",
    "CDATA_SECTION_NODE",
    "CHANGE",
    "CHARSET_RULE",
    "CHECKING",
    "CHROME_UPDATE",
    "CLAMP_TO_EDGE",
    "CLICK",
    "CLOSED",
    "CLOSING",
    "COLOR",
    "COLOR_ATTACHMENT0",
    "COLOR_ATTACHMENT1",
    "COLOR_ATTACHMENT10",
    "COLOR_ATTACHMENT11",
    "COLOR_ATTACHMENT12",
    "COLOR_ATTACHMENT13",
    "COLOR_ATTACHMENT14",
    "COLOR_ATTACHMENT15",
    "COLOR_ATTACHMENT2",
    "COLOR_ATTACHMENT3",
    "COLOR_ATTACHMENT4",
    "COLOR_ATTACHMENT5",
    "COLOR_ATTACHMENT6",
    "COLOR_ATTACHMENT7",
    "COLOR_ATTACHMENT8",
    "COLOR_ATTACHMENT9",
    "COLOR_BUFFER_BIT",
    "COLOR_CLEAR_VALUE",
    "COLOR_WRITEMASK",
    "COMMENT_NODE",
    "COMPARE_REF_TO_TEXTURE",
    "COMPILE_STATUS",
    "COMPRESSED_RGBA_S3TC_DXT1_EXT",
    "COMPRESSED_RGBA_S3TC_DXT3_EXT",
    "COMPRESSED_RGBA_S3TC_DXT5_EXT",
    "COMPRESSED_RGB_S3TC_DXT1_EXT",
    "COMPRESSED_TEXTURE_FORMATS",
    "CONDITION_SATISFIED",
    "CONFIGURATION_UNSUPPORTED",
    "CONNECTING",
    "CONSTANT_ALPHA",
    "CONSTANT_COLOR",
    "CONSTRAINT_ERR",
    "CONTENT",
    "CONTEXT_LOST_WEBGL",
    "CONTROL_MASK",
    "COPY_READ_BUFFER",
    "COPY_READ_BUFFER_BINDING",
    "COPY_WRITE_BUFFER",
    "COPY_WRITE_BUFFER_BINDING",
    "COUNTER_STYLE_RULE",
    "CROS",
    "CSS",
    "CSS2Properties",
    "CSSAnimation",
    "CSSCharsetRule",
    "CSSConditionRule",
    "CSSCounterStyleRule",
    "CSSFontFaceRule",
    "CSSFontFeatureValuesRule",
    "CSSGroupingRule",
    "CSSImageValue",
    "CSSImportRule",
    "CSSKeyframeRule",
    "CSSKeyframesRule",
    "CSSKeywordValue",
    "CSSMathInvert",
    "CSSMathMax",
    "CSSMathMin",
    "CSSMathNegate",
    "CSSMathProduct",
    "CSSMathSum",
    "CSSMathValue",
    "CSSMatrixComponent",
    "CSSMediaRule",
    "CSSMozDocumentRule",
    "CSSNameSpaceRule",
    "CSSNamespaceRule",
    "CSSNumericArray",
    "CSSNumericValue",
    "CSSPageRule",
    "CSSPerspective",
    "CSSPositionValue",
    "CSSPrimitiveValue",
    "CSSRotate",
    "CSSRule",
    "CSSRuleList",
    "CSSScale",
    "CSSSkew",
    "CSSSkewX",
    "CSSSkewY",
    "CSSStyleDeclaration",
    "CSSStyleRule",
    "CSSStyleSheet",
    "CSSStyleValue",
    "CSSSupportsRule",
    "CSSTransformComponent",
    "CSSTransformValue",
    "CSSTransition",
    "CSSTranslate",
    "CSSUnitValue",
    "CSSUnknownRule",
    "CSSUnparsedValue",
    "CSSValue",
    "CSSValueList",
    "CSSVariableReferenceValue",
    "CSSVariablesDeclaration",
    "CSSVariablesRule",
    "CSSViewportRule",
    "CSS_ATTR",
    "CSS_CM",
    "CSS_COUNTER",
    "CSS_CUSTOM",
    "CSS_DEG",
    "CSS_DIMENSION",
    "CSS_EMS",
    "CSS_EXS",
    "CSS_FILTER_BLUR",
    "CSS_FILTER_BRIGHTNESS",
    "CSS_FILTER_CONTRAST",
    "CSS_FILTER_CUSTOM",
    "CSS_FILTER_DROP_SHADOW",
    "CSS_FILTER_GRAYSCALE",
    "CSS_FILTER_HUE_ROTATE",
    "CSS_FILTER_INVERT",
    "CSS_FILTER_OPACITY",
    "CSS_FILTER_REFERENCE",
    "CSS_FILTER_SATURATE",
    "CSS_FILTER_SEPIA",
    "CSS_GRAD",
    "CSS_HZ",
    "CSS_IDENT",
    "CSS_IN",
    "CSS_INHERIT",
    "CSS_KHZ",
    "CSS_MATRIX",
    "CSS_MATRIX3D",
    "CSS_MM",
    "CSS_MS",
    "CSS_NUMBER",
    "CSS_PC",
    "CSS_PERCENTAGE",
    "CSS_PERSPECTIVE",
    "CSS_PRIMITIVE_VALUE",
    "CSS_PT",
    "CSS_PX",
    "CSS_RAD",
    "CSS_RECT",
    "CSS_RGBCOLOR",
    "CSS_ROTATE",
    "CSS_ROTATE3D",
    "CSS_ROTATEX",
    "CSS_ROTATEY",
    "CSS_ROTATEZ",
    "CSS_S",
    "CSS_SCALE",
    "CSS_SCALE3D",
    "CSS_SCALEX",
    "CSS_SCALEY",
    "CSS_SCALEZ",
    "CSS_SKEW",
    "CSS_SKEWX",
    "CSS_SKEWY",
    "CSS_STRING",
    "CSS_TRANSLATE",
    "CSS_TRANSLATE3D",
    "CSS_TRANSLATEX",
    "CSS_TRANSLATEY",
    "CSS_TRANSLATEZ",
    "CSS_UNKNOWN",
    "CSS_URI",
    "CSS_VALUE_LIST",
    "CSS_VH",
    "CSS_VMAX",
    "CSS_VMIN",
    "CSS_VW",
    "CULL_FACE",
    "CULL_FACE_MODE",
    "CURRENT_PROGRAM",
    "CURRENT_QUERY",
    "CURRENT_VERTEX_ATTRIB",
    "CUSTOM",
    "CW",
    "Cache",
    "CacheStorage",
    "CanvasCaptureMediaStream",
    "CanvasCaptureMediaStreamTrack",
    "CanvasGradient",
    "CanvasPattern",
    "CanvasPixelArray",
    "CanvasRenderingContext2D",
    "CaretPosition",
    "ChannelMergerNode",
    "ChannelSplitterNode",
    "CharacterData",
    "Chrome PDF Plugin",
    "Chrome PDF Viewer",
    "ClientRect",
    "ClientRectList",
    "Clipboard",
    "ClipboardEvent",
    "ClipboardItem",
    "CloseEvent",
    "Collator",
    "CollectGarbage",
    "CommandEvent",
    "Comment",
    "CompileError",
    "CompositionEvent",
    "CompressionStream",
    "Console",
    "ConstantSourceNode",
    "ControlRangeCollection",
    "Controllers",
    "ConvolverNode",
    "Coordinates",
    "CountQueuingStrategy",
    "Counter",
    "Credential",
    "CredentialsContainer",
    "Crypto",
    "CryptoKey",
    "CryptoOperation",
    "CustomElementRegistry",
    "CustomEvent",
    "DATABASE_ERR",
    "DATA_CLONE_ERR",
    "DATA_ERR",
    "DBLCLICK",
    "DECR",
    "DECR_WRAP",
    "DELETE_STATUS",
    "DEPTH",
    "DEPTH24_STENCIL8",
    "DEPTH32F_STENCIL8",
    "DEPTH_ATTACHMENT",
    "DEPTH_BITS",
    "DEPTH_BUFFER_BIT",
    "DEPTH_CLEAR_VALUE",
    "DEPTH_COMPONENT",
    "DEPTH_COMPONENT16",
    "DEPTH_COMPONENT24",
    "DEPTH_COMPONENT32F",
    "DEPTH_FUNC",
    "DEPTH_RANGE",
    "DEPTH_STENCIL",
    "DEPTH_STENCIL_ATTACHMENT",
    "DEPTH_TEST",
    "DEPTH_WRITEMASK",
    "DEVICE_INELIGIBLE",
    "DIRECTION_DOWN",
    "DIRECTION_LEFT",
    "DIRECTION_RIGHT",
    "DIRECTION_UP",
    "DISABLED",
    "DISPATCH_REQUEST_ERR",
    "DITHER",
    "DOCUMENT_FRAGMENT_NODE",
    "DOCUMENT_NODE",
    "DOCUMENT_POSITION_CONTAINED_BY",
    "DOCUMENT_POSITION_CONTAINS",
    "DOCUMENT_POSITION_DISCONNECTED",
    "DOCUMENT_POSITION_FOLLOWING",
    "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC",
    "DOCUMENT_POSITION_PRECEDING",
    "DOCUMENT_TYPE_NODE",
    "DOMCursor",
    "DOMError",
    "DOMException",
    "DOMImplementation",
    "DOMImplementationLS",
    "DOMMatrix",
    "DOMMatrixReadOnly",
    "DOMParser",
    "DOMPoint",
    "DOMPointReadOnly",
    "DOMQuad",
    "DOMRect",
    "DOMRectList",
    "DOMRectReadOnly",
    "DOMRequest",
    "DOMSTRING_SIZE_ERR",
    "DOMSettableTokenList",
    "DOMStringList",
    "DOMStringMap",
    "DOMTokenList",
    "DOMTransactionEvent",
    "DOM_DELTA_LINE",
    "DOM_DELTA_PAGE",
    "DOM_DELTA_PIXEL",
    "DOM_INPUT_METHOD_DROP",
    "DOM_INPUT_METHOD_HANDWRITING",
    "DOM_INPUT_METHOD_IME",
    "DOM_INPUT_METHOD_KEYBOARD",
    "DOM_INPUT_METHOD_MULTIMODAL",
    "DOM_INPUT_METHOD_OPTION",
    "DOM_INPUT_METHOD_PASTE",
    "DOM_INPUT_METHOD_SCRIPT",
    "DOM_INPUT_METHOD_UNKNOWN",
    "DOM_INPUT_METHOD_VOICE",
    "DOM_KEY_LOCATION_JOYSTICK",
    "DOM_KEY_LOCATION_LEFT",
    "DOM_KEY_LOCATION_MOBILE",
    "DOM_KEY_LOCATION_NUMPAD",
    "DOM_KEY_LOCATION_RIGHT",
    "DOM_KEY_LOCATION_STANDARD",
    "DOM_VK_0",
    "DOM_VK_1",
    "DOM_VK_2",
    "DOM_VK_3",
    "DOM_VK_4",
    "DOM_VK_5",
    "DOM_VK_6",
    "DOM_VK_7",
    "DOM_VK_8",
    "DOM_VK_9",
    "DOM_VK_A",
    "DOM_VK_ACCEPT",
    "DOM_VK_ADD",
    "DOM_VK_ALT",
    "DOM_VK_ALTGR",
    "DOM_VK_AMPERSAND",
    "DOM_VK_ASTERISK",
    "DOM_VK_AT",
    "DOM_VK_ATTN",
    "DOM_VK_B",
    "DOM_VK_BACKSPACE",
    "DOM_VK_BACK_QUOTE",
    "DOM_VK_BACK_SLASH",
    "DOM_VK_BACK_SPACE",
    "DOM_VK_C",
    "DOM_VK_CANCEL",
    "DOM_VK_CAPS_LOCK",
    "DOM_VK_CIRCUMFLEX",
    "DOM_VK_CLEAR",
    "DOM_VK_CLOSE_BRACKET",
    "DOM_VK_CLOSE_CURLY_BRACKET",
    "DOM_VK_CLOSE_PAREN",
    "DOM_VK_COLON",
    "DOM_VK_COMMA",
    "DOM_VK_CONTEXT_MENU",
    "DOM_VK_CONTROL",
    "DOM_VK_CONVERT",
    "DOM_VK_CRSEL",
    "DOM_VK_CTRL",
    "DOM_VK_D",
    "DOM_VK_DECIMAL",
    "DOM_VK_DELETE",
    "DOM_VK_DIVIDE",
    "DOM_VK_DOLLAR",
    "DOM_VK_DOUBLE_QUOTE",
    "DOM_VK_DOWN",
    "DOM_VK_E",
    "DOM_VK_EISU",
    "DOM_VK_END",
    "DOM_VK_ENTER",
    "DOM_VK_EQUALS",
    "DOM_VK_EREOF",
    "DOM_VK_ESCAPE",
    "DOM_VK_EXCLAMATION",
    "DOM_VK_EXECUTE",
    "DOM_VK_EXSEL",
    "DOM_VK_F",
    "DOM_VK_F1",
    "DOM_VK_F10",
    "DOM_VK_F11",
    "DOM_VK_F12",
    "DOM_VK_F13",
    "DOM_VK_F14",
    "DOM_VK_F15",
    "DOM_VK_F16",
    "DOM_VK_F17",
    "DOM_VK_F18",
    "DOM_VK_F19",
    "DOM_VK_F2",
    "DOM_VK_F20",
    "DOM_VK_F21",
    "DOM_VK_F22",
    "DOM_VK_F23",
    "DOM_VK_F24",
    "DOM_VK_F25",
    "DOM_VK_F26",
    "DOM_VK_F27",
    "DOM_VK_F28",
    "DOM_VK_F29",
    "DOM_VK_F3",
    "DOM_VK_F30",
    "DOM_VK_F31",
    "DOM_VK_F32",
    "DOM_VK_F33",
    "DOM_VK_F34",
    "DOM_VK_F35",
    "DOM_VK_F36",
    "DOM_VK_F4",
    "DOM_VK_F5",
    "DOM_VK_F6",
    "DOM_VK_F7",
    "DOM_VK_F8",
    "DOM_VK_F9",
    "DOM_VK_FINAL",
    "DOM_VK_FRONT",
    "DOM_VK_G",
    "DOM_VK_GREATER_THAN",
    "DOM_VK_H",
    "DOM_VK_HANGUL",
    "DOM_VK_HANJA",
    "DOM_VK_HASH",
    "DOM_VK_HELP",
    "DOM_VK_HK_TOGGLE",
    "DOM_VK_HOME",
    "DOM_VK_HYPHEN_MINUS",
    "DOM_VK_I",
    "DOM_VK_INSERT",
    "DOM_VK_J",
    "DOM_VK_JUNJA",
    "DOM_VK_K",
    "DOM_VK_KANA",
    "DOM_VK_KANJI",
    "DOM_VK_L",
    "DOM_VK_LEFT",
    "DOM_VK_LEFT_TAB",
    "DOM_VK_LESS_THAN",
    "DOM_VK_M",
    "DOM_VK_META",
    "DOM_VK_MODECHANGE",
    "DOM_VK_MULTIPLY",
    "DOM_VK_N",
    "DOM_VK_NONCONVERT",
    "DOM_VK_NUMPAD0",
    "DOM_VK_NUMPAD1",
    "DOM_VK_NUMPAD2",
    "DOM_VK_NUMPAD3",
    "DOM_VK_NUMPAD4",
    "DOM_VK_NUMPAD5",
    "DOM_VK_NUMPAD6",
    "DOM_VK_NUMPAD7",
    "DOM_VK_NUMPAD8",
    "DOM_VK_NUMPAD9",
    "DOM_VK_NUM_LOCK",
    "DOM_VK_O",
    "DOM_VK_OEM_1",
    "DOM_VK_OEM_102",
    "DOM_VK_OEM_2",
    "DOM_VK_OEM_3",
    "DOM_VK_OEM_4",
    "DOM_VK_OEM_5",
    "DOM_VK_OEM_6",
    "DOM_VK_OEM_7",
    "DOM_VK_OEM_8",
    "DOM_VK_OEM_COMMA",
    "DOM_VK_OEM_MINUS",
    "DOM_VK_OEM_PERIOD",
    "DOM_VK_OEM_PLUS",
    "DOM_VK_OPEN_BRACKET",
    "DOM_VK_OPEN_CURLY_BRACKET",
    "DOM_VK_OPEN_PAREN",
    "DOM_VK_P",
    "DOM_VK_PA1",
    "DOM_VK_PAGEDOWN",
    "DOM_VK_PAGEUP",
    "DOM_VK_PAGE_DOWN",
    "DOM_VK_PAGE_UP",
    "DOM_VK_PAUSE",
    "DOM_VK_PERCENT",
    "DOM_VK_PERIOD",
    "DOM_VK_PIPE",
    "DOM_VK_PLAY",
    "DOM_VK_PLUS",
    "DOM_VK_PRINT",
    "DOM_VK_PRINTSCREEN",
    "DOM_VK_PROCESSKEY",
    "DOM_VK_PROPERITES",
    "DOM_VK_Q",
    "DOM_VK_QUESTION_MARK",
    "DOM_VK_QUOTE",
    "DOM_VK_R",
    "DOM_VK_REDO",
    "DOM_VK_RETURN",
    "DOM_VK_RIGHT",
    "DOM_VK_S",
    "DOM_VK_SCROLL_LOCK",
    "DOM_VK_SELECT",
    "DOM_VK_SEMICOLON",
    "DOM_VK_SEPARATOR",
    "DOM_VK_SHIFT",
    "DOM_VK_SLASH",
    "DOM_VK_SLEEP",
    "DOM_VK_SPACE",
    "DOM_VK_SUBTRACT",
    "DOM_VK_T",
    "DOM_VK_TAB",
    "DOM_VK_TILDE",
    "DOM_VK_U",
    "DOM_VK_UNDERSCORE",
    "DOM_VK_UNDO",
    "DOM_VK_UNICODE",
    "DOM_VK_UP",
    "DOM_VK_V",
    "DOM_VK_VOLUME_DOWN",
    "DOM_VK_VOLUME_MUTE",
    "DOM_VK_VOLUME_UP",
    "DOM_VK_W",
    "DOM_VK_WIN",
    "DOM_VK_WINDOW",
    "DOM_VK_WIN_ICO_00",
    "DOM_VK_WIN_ICO_CLEAR",
    "DOM_VK_WIN_ICO_HELP",
    "DOM_VK_WIN_OEM_ATTN",
    "DOM_VK_WIN_OEM_AUTO",
    "DOM_VK_WIN_OEM_BACKTAB",
    "DOM_VK_WIN_OEM_CLEAR",
    "DOM_VK_WIN_OEM_COPY",
    "DOM_VK_WIN_OEM_CUSEL",
    "DOM_VK_WIN_OEM_ENLW",
    "DOM_VK_WIN_OEM_FINISH",
    "DOM_VK_WIN_OEM_FJ_JISHO",
    "DOM_VK_WIN_OEM_FJ_LOYA",
    "DOM_VK_WIN_OEM_FJ_MASSHOU",
    "DOM_VK_WIN_OEM_FJ_ROYA",
    "DOM_VK_WIN_OEM_FJ_TOUROKU",
    "DOM_VK_WIN_OEM_JUMP",
    "DOM_VK_WIN_OEM_PA1",
    "DOM_VK_WIN_OEM_PA2",
    "DOM_VK_WIN_OEM_PA3",
    "DOM_VK_WIN_OEM_RESET",
    "DOM_VK_WIN_OEM_WSCTRL",
    "DOM_VK_X",
    "DOM_VK_XF86XK_ADD_FAVORITE",
    "DOM_VK_XF86XK_APPLICATION_LEFT",
    "DOM_VK_XF86XK_APPLICATION_RIGHT",
    "DOM_VK_XF86XK_AUDIO_CYCLE_TRACK",
    "DOM_VK_XF86XK_AUDIO_FORWARD",
    "DOM_VK_XF86XK_AUDIO_LOWER_VOLUME",
    "DOM_VK_XF86XK_AUDIO_MEDIA",
    "DOM_VK_XF86XK_AUDIO_MUTE",
    "DOM_VK_XF86XK_AUDIO_NEXT",
    "DOM_VK_XF86XK_AUDIO_PAUSE",
    "DOM_VK_XF86XK_AUDIO_PLAY",
    "DOM_VK_XF86XK_AUDIO_PREV",
    "DOM_VK_XF86XK_AUDIO_RAISE_VOLUME",
    "DOM_VK_XF86XK_AUDIO_RANDOM_PLAY",
    "DOM_VK_XF86XK_AUDIO_RECORD",
    "DOM_VK_XF86XK_AUDIO_REPEAT",
    "DOM_VK_XF86XK_AUDIO_REWIND",
    "DOM_VK_XF86XK_AUDIO_STOP",
    "DOM_VK_XF86XK_AWAY",
    "DOM_VK_XF86XK_BACK",
    "DOM_VK_XF86XK_BACK_FORWARD",
    "DOM_VK_XF86XK_BATTERY",
    "DOM_VK_XF86XK_BLUE",
    "DOM_VK_XF86XK_BLUETOOTH",
    "DOM_VK_XF86XK_BOOK",
    "DOM_VK_XF86XK_BRIGHTNESS_ADJUST",
    "DOM_VK_XF86XK_CALCULATOR",
    "DOM_VK_XF86XK_CALENDAR",
    "DOM_VK_XF86XK_CD",
    "DOM_VK_XF86XK_CLOSE",
    "DOM_VK_XF86XK_COMMUNITY",
    "DOM_VK_XF86XK_CONTRAST_ADJUST",
    "DOM_VK_XF86XK_COPY",
    "DOM_VK_XF86XK_CUT",
    "DOM_VK_XF86XK_CYCLE_ANGLE",
    "DOM_VK_XF86XK_DISPLAY",
    "DOM_VK_XF86XK_DOCUMENTS",
    "DOM_VK_XF86XK_DOS",
    "DOM_VK_XF86XK_EJECT",
    "DOM_VK_XF86XK_EXCEL",
    "DOM_VK_XF86XK_EXPLORER",
    "DOM_VK_XF86XK_FAVORITES",
    "DOM_VK_XF86XK_FINANCE",
    "DOM_VK_XF86XK_FORWARD",
    "DOM_VK_XF86XK_FRAME_BACK",
    "DOM_VK_XF86XK_FRAME_FORWARD",
    "DOM_VK_XF86XK_GAME",
    "DOM_VK_XF86XK_GO",
    "DOM_VK_XF86XK_GREEN",
    "DOM_VK_XF86XK_HIBERNATE",
    "DOM_VK_XF86XK_HISTORY",
    "DOM_VK_XF86XK_HOME_PAGE",
    "DOM_VK_XF86XK_HOT_LINKS",
    "DOM_VK_XF86XK_I_TOUCH",
    "DOM_VK_XF86XK_KBD_BRIGHTNESS_DOWN",
    "DOM_VK_XF86XK_KBD_BRIGHTNESS_UP",
    "DOM_VK_XF86XK_KBD_LIGHT_ON_OFF",
    "DOM_VK_XF86XK_LAUNCH0",
    "DOM_VK_XF86XK_LAUNCH1",
    "DOM_VK_XF86XK_LAUNCH2",
    "DOM_VK_XF86XK_LAUNCH3",
    "DOM_VK_XF86XK_LAUNCH4",
    "DOM_VK_XF86XK_LAUNCH5",
    "DOM_VK_XF86XK_LAUNCH6",
    "DOM_VK_XF86XK_LAUNCH7",
    "DOM_VK_XF86XK_LAUNCH8",
    "DOM_VK_XF86XK_LAUNCH9",
    "DOM_VK_XF86XK_LAUNCH_A",
    "DOM_VK_XF86XK_LAUNCH_B",
    "DOM_VK_XF86XK_LAUNCH_C",
    "DOM_VK_XF86XK_LAUNCH_D",
    "DOM_VK_XF86XK_LAUNCH_E",
    "DOM_VK_XF86XK_LAUNCH_F",
    "DOM_VK_XF86XK_LIGHT_BULB",
    "DOM_VK_XF86XK_LOG_OFF",
    "DOM_VK_XF86XK_MAIL",
    "DOM_VK_XF86XK_MAIL_FORWARD",
    "DOM_VK_XF86XK_MARKET",
    "DOM_VK_XF86XK_MEETING",
    "DOM_VK_XF86XK_MEMO",
    "DOM_VK_XF86XK_MENU_KB",
    "DOM_VK_XF86XK_MENU_PB",
    "DOM_VK_XF86XK_MESSENGER",
    "DOM_VK_XF86XK_MON_BRIGHTNESS_DOWN",
    "DOM_VK_XF86XK_MON_BRIGHTNESS_UP",
    "DOM_VK_XF86XK_MUSIC",
    "DOM_VK_XF86XK_MY_COMPUTER",
    "DOM_VK_XF86XK_MY_SITES",
    "DOM_VK_XF86XK_NEW",
    "DOM_VK_XF86XK_NEWS",
    "DOM_VK_XF86XK_OFFICE_HOME",
    "DOM_VK_XF86XK_OPEN",
    "DOM_VK_XF86XK_OPEN_URL",
    "DOM_VK_XF86XK_OPTION",
    "DOM_VK_XF86XK_PASTE",
    "DOM_VK_XF86XK_PHONE",
    "DOM_VK_XF86XK_PICTURES",
    "DOM_VK_XF86XK_POWER_DOWN",
    "DOM_VK_XF86XK_POWER_OFF",
    "DOM_VK_XF86XK_RED",
    "DOM_VK_XF86XK_REFRESH",
    "DOM_VK_XF86XK_RELOAD",
    "DOM_VK_XF86XK_REPLY",
    "DOM_VK_XF86XK_ROCKER_DOWN",
    "DOM_VK_XF86XK_ROCKER_ENTER",
    "DOM_VK_XF86XK_ROCKER_UP",
    "DOM_VK_XF86XK_ROTATE_WINDOWS",
    "DOM_VK_XF86XK_ROTATION_KB",
    "DOM_VK_XF86XK_ROTATION_PB",
    "DOM_VK_XF86XK_SAVE",
    "DOM_VK_XF86XK_SCREEN_SAVER",
    "DOM_VK_XF86XK_SCROLL_CLICK",
    "DOM_VK_XF86XK_SCROLL_DOWN",
    "DOM_VK_XF86XK_SCROLL_UP",
    "DOM_VK_XF86XK_SEARCH",
    "DOM_VK_XF86XK_SEND",
    "DOM_VK_XF86XK_SHOP",
    "DOM_VK_XF86XK_SPELL",
    "DOM_VK_XF86XK_SPLIT_SCREEN",
    "DOM_VK_XF86XK_STANDBY",
    "DOM_VK_XF86XK_START",
    "DOM_VK_XF86XK_STOP",
    "DOM_VK_XF86XK_SUBTITLE",
    "DOM_VK_XF86XK_SUPPORT",
    "DOM_VK_XF86XK_SUSPEND",
    "DOM_VK_XF86XK_TASK_PANE",
    "DOM_VK_XF86XK_TERMINAL",
    "DOM_VK_XF86XK_TIME",
    "DOM_VK_XF86XK_TOOLS",
    "DOM_VK_XF86XK_TOP_MENU",
    "DOM_VK_XF86XK_TO_DO_LIST",
    "DOM_VK_XF86XK_TRAVEL",
    "DOM_VK_XF86XK_USER1KB",
    "DOM_VK_XF86XK_USER2KB",
    "DOM_VK_XF86XK_USER_PB",
    "DOM_VK_XF86XK_UWB",
    "DOM_VK_XF86XK_VENDOR_HOME",
    "DOM_VK_XF86XK_VIDEO",
    "DOM_VK_XF86XK_VIEW",
    "DOM_VK_XF86XK_WAKE_UP",
    "DOM_VK_XF86XK_WEB_CAM",
    "DOM_VK_XF86XK_WHEEL_BUTTON",
    "DOM_VK_XF86XK_WLAN",
    "DOM_VK_XF86XK_WORD",
    "DOM_VK_XF86XK_WWW",
    "DOM_VK_XF86XK_XFER",
    "DOM_VK_XF86XK_YELLOW",
    "DOM_VK_XF86XK_ZOOM_IN",
    "DOM_VK_XF86XK_ZOOM_OUT",
    "DOM_VK_Y",
    "DOM_VK_Z",
    "DOM_VK_ZOOM",
    "DONE",
    "DONT_CARE",
    "DOWNLOADING",
    "DRAGDROP",
    "DRAW_BUFFER0",
    "DRAW_BUFFER1",
    "DRAW_BUFFER10",
    "DRAW_BUFFER11",
    "DRAW_BUFFER12",
    "DRAW_BUFFER13",
    "DRAW_BUFFER14",
    "DRAW_BUFFER15",
    "DRAW_BUFFER2",
    "DRAW_BUFFER3",
    "DRAW_BUFFER4",
    "DRAW_BUFFER5",
    "DRAW_BUFFER6",
    "DRAW_BUFFER7",
    "DRAW_BUFFER8",
    "DRAW_BUFFER9",
    "DRAW_FRAMEBUFFER",
    "DRAW_FRAMEBUFFER_BINDING",
    "DST_ALPHA",
    "DST_COLOR",
    "DYNAMIC_COPY",
    "DYNAMIC_DRAW",
    "DYNAMIC_READ",
    "DataChannel",
    "DataCue",
    "DataTransfer",
    "DataTransferItem",
    "DataTransferItemList",
    "DataView",
    "Database",
    "Date",
    "DateTimeFormat",
    "Debug",
    "DecompressionStream",
    "Default Browser Helper",
    "DelayNode",
    "DesktopNotification",
    "DesktopNotificationCenter",
    "DeviceAcceleration",
    "DeviceLightEvent",
    "DeviceMotionEvent",
    "DeviceMotionEventAcceleration",
    "DeviceMotionEventRotationRate",
    "DeviceOrientationEvent",
    "DeviceProximityEvent",
    "DeviceRotationRate",
    "DeviceStorage",
    "DeviceStorageChangeEvent",
    "Directory",
    "DisplayNames",
    "Document",
    "DocumentFragment",
    "DocumentTimeline",
    "DocumentType",
    "DragEvent",
    "DynamicsCompressorNode",
    "E",
    "ELEMENT_ARRAY_BUFFER",
    "ELEMENT_ARRAY_BUFFER_BINDING",
    "ELEMENT_NODE",
    "EMPTY",
    "ENCODING_ERR",
    "ENDED",
    "END_TO_END",
    "END_TO_START",
    "ENTITY_NODE",
    "ENTITY_REFERENCE_NODE",
    "EPSILON",
    "EQUAL",
    "EQUALPOWER",
    "ERROR",
    "EXPONENTIAL_DISTANCE",
    "EXT_texture_filter_anisotropic",
    "Element",
    "ElementInternals",
    "ElementQuery",
    "EnterPictureInPictureEvent",
    "Entity",
    "EntityReference",
    "Enumerator",
    "Error",
    "ErrorEvent",
    "EvalError",
    "Event",
    "EventException",
    "EventSource",
    "EventTarget",
    "External",
    "FASTEST",
    "FIDOSDK",
    "FILTER_ACCEPT",
    "FILTER_INTERRUPT",
    "FILTER_REJECT",
    "FILTER_SKIP",
    "FINISHED_STATE",
    "FIRST_ORDERED_NODE_TYPE",
    "FLOAT",
    "FLOAT_32_UNSIGNED_INT_24_8_REV",
    "FLOAT_MAT2",
    "FLOAT_MAT2x3",
    "FLOAT_MAT2x4",
    "FLOAT_MAT3",
    "FLOAT_MAT3x2",
    "FLOAT_MAT3x4",
    "FLOAT_MAT4",
    "FLOAT_MAT4x2",
    "FLOAT_MAT4x3",
    "FLOAT_VEC2",
    "FLOAT_VEC3",
    "FLOAT_VEC4",
    "FOCUS",
    "FONT_FACE_RULE",
    "FONT_FEATURE_VALUES_RULE",
    "FRAGMENT_SHADER",
    "FRAGMENT_SHADER_DERIVATIVE_HINT",
    "FRAGMENT_SHADER_DERIVATIVE_HINT_OES",
    "FRAMEBUFFER",
    "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE",
    "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE",
    "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING",
    "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE",
    "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE",
    "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE",
    "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME",
    "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE",
    "FRAMEBUFFER_ATTACHMENT_RED_SIZE",
    "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE",
    "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE",
    "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER",
    "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL",
    "FRAMEBUFFER_BINDING",
    "FRAMEBUFFER_COMPLETE",
    "FRAMEBUFFER_DEFAULT",
    "FRAMEBUFFER_INCOMPLETE_ATTACHMENT",
    "FRAMEBUFFER_INCOMPLETE_DIMENSIONS",
    "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",
    "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE",
    "FRAMEBUFFER_UNSUPPORTED",
    "FRONT",
    "FRONT_AND_BACK",
    "FRONT_FACE",
    "FUNC_ADD",
    "FUNC_REVERSE_SUBTRACT",
    "FUNC_SUBTRACT",
    "FeaturePolicy",
    "FederatedCredential",
    "Feed",
    "FeedEntry",
    "File",
    "FileError",
    "FileList",
    "FileReader",
    "FileSystem",
    "FileSystemDirectoryEntry",
    "FileSystemDirectoryReader",
    "FileSystemEntry",
    "FileSystemFileEntry",
    "FinalizationRegistry",
    "FindInPage",
    "Float32Array",
    "Float64Array",
    "FocusEvent",
    "FontFace",
    "FontFaceSet",
    "FontFaceSetLoadEvent",
    "FormData",
    "FormDataEvent",
    "FragmentDirective",
    "Function",
    "GENERATE_MIPMAP_HINT",
    "GEQUAL",
    "GREATER",
    "GREEN_BITS",
    "GainNode",
    "Gamepad",
    "GamepadButton",
    "GamepadEvent",
    "GamepadHapticActuator",
    "GamepadPose",
    "Geolocation",
    "GeolocationCoordinates",
    "GeolocationPosition",
    "GeolocationPositionError",
    "GestureEvent",
    "Global",
    "Gyroscope",
    "HALF_FLOAT",
    "HAVE_CURRENT_DATA",
    "HAVE_ENOUGH_DATA",
    "HAVE_FUTURE_DATA",
    "HAVE_METADATA",
    "HAVE_NOTHING",
    "HEADERS_RECEIVED",
    "HIDDEN",
    "HIERARCHY_REQUEST_ERR",
    "HIGHPASS",
    "HIGHSHELF",
    "HIGH_FLOAT",
    "HIGH_INT",
    "HORIZONTAL",
    "HORIZONTAL_AXIS",
    "HRTF",
    "HTMLAllCollection",
    "HTMLAnchorElement",
    "HTMLAppletElement",
    "HTMLAreaElement",
    "HTMLAreasCollection",
    "HTMLAudioElement",
    "HTMLBGSoundElement",
    "HTMLBRElement",
    "HTMLBaseElement",
    "HTMLBaseFontElement",
    "HTMLBlockElement",
    "HTMLBlockquoteElement",
    "HTMLBodyElement",
    "HTMLButtonElement",
    "HTMLCanvasElement",
    "HTMLCollection",
    "HTMLCommandElement",
    "HTMLContentElement",
    "HTMLDDElement",
    "HTMLDListElement",
    "HTMLDTElement",
    "HTMLDataElement",
    "HTMLDataListElement",
    "HTMLDetailsElement",
    "HTMLDialogElement",
    "HTMLDirectoryElement",
    "HTMLDivElement",
    "HTMLDocument",
    "HTMLElement",
    "HTMLEmbedElement",
    "HTMLFieldSetElement",
    "HTMLFontElement",
    "HTMLFormControlsCollection",
    "HTMLFormElement",
    "HTMLFrameElement",
    "HTMLFrameSetElement",
    "HTMLHRElement",
    "HTMLHeadElement",
    "HTMLHeadingElement",
    "HTMLHtmlElement",
    "HTMLIFrameElement",
    "HTMLImageElement",
    "HTMLInputElement",
    "HTMLIsIndexElement",
    "HTMLKeygenElement",
    "HTMLLIElement",
    "HTMLLabelElement",
    "HTMLLegendElement",
    "HTMLLinkElement",
    "HTMLMapElement",
    "HTMLMarqueeElement",
    "HTMLMediaElement",
    "HTMLMenuElement",
    "HTMLMenuItemElement",
    "HTMLMetaElement",
    "HTMLMeterElement",
    "HTMLModElement",
    "HTMLNextIdElement",
    "HTMLOListElement",
    "HTMLObjectElement",
    "HTMLOptGroupElement",
    "HTMLOptionElement",
    "HTMLOptionsCollection",
    "HTMLOutputElement",
    "HTMLParagraphElement",
    "HTMLParamElement",
    "HTMLPhraseElement",
    "HTMLPictureElement",
    "HTMLPreElement",
    "HTMLProgressElement",
    "HTMLPropertiesCollection",
    "HTMLQuoteElement",
    "HTMLScriptElement",
    "HTMLSelectElement",
    "HTMLShadowElement",
    "HTMLSlotElement",
    "HTMLSourceElement",
    "HTMLSpanElement",
    "HTMLStyleElement",
    "HTMLTableCaptionElement",
    "HTMLTableCellElement",
    "HTMLTableColElement",
    "HTMLTableDataCellElement",
    "HTMLTableElement",
    "HTMLTableHeaderCellElement",
    "HTMLTableRowElement",
    "HTMLTableSectionElement",
    "HTMLTemplateElement",
    "HTMLTextAreaElement",
    "HTMLTimeElement",
    "HTMLTitleElement",
    "HTMLTrackElement",
    "HTMLUListElement",
    "HTMLUnknownElement",
    "HTMLVideoElement",
    "HashChangeEvent",
    "Headers",
    "History",
    "Hz",
    "ICE_CHECKING",
    "ICE_CLOSED",
    "ICE_COMPLETED",
    "ICE_CONNECTED",
    "ICE_FAILED",
    "ICE_GATHERING",
    "ICE_WAITING",
    "IDBCursor",
    "IDBCursorWithValue",
    "IDBDatabase",
    "IDBDatabaseException",
    "IDBFactory",
    "IDBFileHandle",
    "IDBFileRequest",
    "IDBIndex",
    "IDBKeyRange",
    "IDBMutableFile",
    "IDBObjectStore",
    "IDBOpenDBRequest",
    "IDBRequest",
    "IDBTransaction",
    "IDBVersionChangeEvent",
    "IDLE",
    "IIRFilterNode",
    "IMPLEMENTATION_COLOR_READ_FORMAT",
    "IMPLEMENTATION_COLOR_READ_TYPE",
    "IMPORT_RULE",
    "INCR",
    "INCR_WRAP",
    "INDEX_SIZE_ERR",
    "INSTALL",
    "INSTALLED",
    "INT",
    "INTERLEAVED_ATTRIBS",
    "INT_2_10_10_10_REV",
    "INT_SAMPLER_2D",
    "INT_SAMPLER_2D_ARRAY",
    "INT_SAMPLER_3D",
    "INT_SAMPLER_CUBE",
    "INT_VEC2",
    "INT_VEC3",
    "INT_VEC4",
    "INUSE_ATTRIBUTE_ERR",
    "INVALID_ACCESS_ERR",
    "INVALID_CHARACTER_ERR",
    "INVALID_ENUM",
    "INVALID_EXPRESSION_ERR",
    "INVALID_FRAMEBUFFER_OPERATION",
    "INVALID_INDEX",
    "INVALID_MODIFICATION_ERR",
    "INVALID_NODE_TYPE_ERR",
    "INVALID_OPERATION",
    "INVALID_STATE_ERR",
    "INVALID_VALUE",
    "INVERSE_DISTANCE",
    "INVERT",
    "IceCandidate",
    "IdleDeadline",
    "Image",
    "ImageBitmap",
    "ImageBitmapRenderingContext",
    "ImageCapture",
    "ImageData",
    "Infinity",
    "InputDeviceCapabilities",
    "InputDeviceInfo",
    "InputEvent",
    "InputMethodContext",
    "InstallState",
    "InstallTrigger",
    "Instance",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "Intent",
    "InternalError",
    "IntersectionObserver",
    "IntersectionObserverEntry",
    "Intl",
    "IsSearchProviderInstalled",
    "Iterator",
    "JSON",
    "Java Deployment Toolkit 7.0.250.17",
    "Java(TM) Platform SE 7 U25",
    "KEEP",
    "KEYDOWN",
    "KEYFRAMES_RULE",
    "KEYFRAME_RULE",
    "KEYPRESS",
    "KEYUP",
    "Key",
    "KeyEvent",
    "KeyOperation",
    "KeyPair",
    "Keyboard",
    "KeyboardEvent",
    "KeyboardLayoutMap",
    "KeyframeEffect",
    "LENGTHADJUST_SPACING",
    "LENGTHADJUST_SPACINGANDGLYPHS",
    "LENGTHADJUST_UNKNOWN",
    "LEQUAL",
    "LESS",
    "LINEAR",
    "LINEAR_DISTANCE",
    "LINEAR_MIPMAP_LINEAR",
    "LINEAR_MIPMAP_NEAREST",
    "LINES",
    "LINE_LOOP",
    "LINE_STRIP",
    "LINE_WIDTH",
    "LINK_STATUS",
    "LINUX",
    "LIVE",
    "LN10",
    "LN2",
    "LOADED",
    "LOADING",
    "LOCALE",
    "LOG10E",
    "LOG2E",
    "LOWPASS",
    "LOWSHELF",
    "LOW_FLOAT",
    "LOW_INT",
    "LSException",
    "LSParserFilter",
    "LUMINANCE",
    "LUMINANCE_ALPHA",
    "LargestContentfulPaint",
    "LayoutShift",
    "LayoutShiftAttribution",
    "LinearAccelerationSensor",
    "LinkError",
    "ListFormat",
    "LocalMediaStream",
    "Locale",
    "Location",
    "Lock",
    "LockManager",
    "MAC",
    "MAX",
    "MAX_3D_TEXTURE_SIZE",
    "MAX_ARRAY_TEXTURE_LAYERS",
    "MAX_CLIENT_WAIT_TIMEOUT_WEBGL",
    "MAX_COLOR_ATTACHMENTS",
    "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS",
    "MAX_COMBINED_TEXTURE_IMAGE_UNITS",
    "MAX_COMBINED_UNIFORM_BLOCKS",
    "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS",
    "MAX_CUBE_MAP_TEXTURE_SIZE",
    "MAX_DRAW_BUFFERS",
    "MAX_ELEMENTS_INDICES",
    "MAX_ELEMENTS_VERTICES",
    "MAX_ELEMENT_INDEX",
    "MAX_FRAGMENT_INPUT_COMPONENTS",
    "MAX_FRAGMENT_UNIFORM_BLOCKS",
    "MAX_FRAGMENT_UNIFORM_COMPONENTS",
    "MAX_FRAGMENT_UNIFORM_VECTORS",
    "MAX_PROGRAM_TEXEL_OFFSET",
    "MAX_RENDERBUFFER_SIZE",
    "MAX_SAFE_INTEGER",
    "MAX_SAMPLES",
    "MAX_SERVER_WAIT_TIMEOUT",
    "MAX_TEXTURE_IMAGE_UNITS",
    "MAX_TEXTURE_LOD_BIAS",
    "MAX_TEXTURE_MAX_ANISOTROPY_EXT",
    "MAX_TEXTURE_SIZE",
    "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS",
    "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS",
    "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS",
    "MAX_UNIFORM_BLOCK_SIZE",
    "MAX_UNIFORM_BUFFER_BINDINGS",
    "MAX_VALUE",
    "MAX_VARYING_COMPONENTS",
    "MAX_VARYING_VECTORS",
    "MAX_VERTEX_ATTRIBS",
    "MAX_VERTEX_OUTPUT_COMPONENTS",
    "MAX_VERTEX_TEXTURE_IMAGE_UNITS",
    "MAX_VERTEX_UNIFORM_BLOCKS",
    "MAX_VERTEX_UNIFORM_COMPONENTS",
    "MAX_VERTEX_UNIFORM_VECTORS",
    "MAX_VIEWPORT_DIMS",
    "MEDIA_ERR_ABORTED",
    "MEDIA_ERR_DECODE",
    "MEDIA_ERR_ENCRYPTED",
    "MEDIA_ERR_NETWORK",
    "MEDIA_ERR_SRC_NOT_SUPPORTED",
    "MEDIA_KEYERR_CLIENT",
    "MEDIA_KEYERR_DOMAIN",
    "MEDIA_KEYERR_HARDWARECHANGE",
    "MEDIA_KEYERR_OUTPUT",
    "MEDIA_KEYERR_SERVICE",
    "MEDIA_KEYERR_UNKNOWN",
    "MEDIA_RULE",
    "MEDIUM_FLOAT",
    "MEDIUM_INT",
    "META_MASK",
    "MIDIAccess",
    "MIDIConnectionEvent",
    "MIDIInput",
    "MIDIInputMap",
    "MIDIMessageEvent",
    "MIDIOutput",
    "MIDIOutputMap",
    "MIDIPort",
    "MIN",
    "MIN_PROGRAM_TEXEL_OFFSET",
    "MIN_SAFE_INTEGER",
    "MIN_VALUE",
    "MIRRORED_REPEAT",
    "MODE_ASYNCHRONOUS",
    "MODE_SYNCHRONOUS",
    "MODIFICATION",
    "MOUSEDOWN",
    "MOUSEDRAG",
    "MOUSEMOVE",
    "MOUSEOUT",
    "MOUSEOVER",
    "MOUSEUP",
    "MOZ_KEYFRAMES_RULE",
    "MOZ_KEYFRAME_RULE",
    "MOZ_SOURCE_CURSOR",
    "MOZ_SOURCE_ERASER",
    "MOZ_SOURCE_KEYBOARD",
    "MOZ_SOURCE_MOUSE",
    "MOZ_SOURCE_PEN",
    "MOZ_SOURCE_TOUCH",
    "MOZ_SOURCE_UNKNOWN",
    "MSBehaviorUrnsCollection",
    "MSBlobBuilder",
    "MSCSSMatrix",
    "MSCSSProperties",
    "MSCSSRuleList",
    "MSCompatibleInfo",
    "MSCompatibleInfoCollection",
    "MSCurrentStyleCSSProperties",
    "MSEventObj",
    "MSGESTURE_FLAG_BEGIN",
    "MSGESTURE_FLAG_CANCEL",
    "MSGESTURE_FLAG_END",
    "MSGESTURE_FLAG_INERTIA",
    "MSGESTURE_FLAG_NONE",
    "MSGesture",
    "MSGestureEvent",
    "MSGraphicsTrust",
    "MSInputMethodContext",
    "MSManipulationEvent",
    "MSMediaKeyError",
    "MSMediaKeyMessageEvent",
    "MSMediaKeyNeededEvent",
    "MSMediaKeySession",
    "MSMediaKeys",
    "MSMimeTypesCollection",
    "MSPOINTER_TYPE_MOUSE",
    "MSPOINTER_TYPE_PEN",
    "MSPOINTER_TYPE_TOUCH",
    "MSPluginsCollection",
    "MSPointerEvent",
    "MSRangeCollection",
    "MSSiteModeEvent",
    "MSStream",
    "MSStreamReader",
    "MSStyleCSSProperties",
    "MS_ASYNC_CALLBACK_STATUS_ASSIGN_DELEGATE",
    "MS_ASYNC_CALLBACK_STATUS_CANCEL",
    "MS_ASYNC_CALLBACK_STATUS_CHOOSEANY",
    "MS_ASYNC_CALLBACK_STATUS_ERROR",
    "MS_ASYNC_CALLBACK_STATUS_JOIN",
    "MS_ASYNC_OP_STATUS_CANCELED",
    "MS_ASYNC_OP_STATUS_ERROR",
    "MS_ASYNC_OP_STATUS_SUCCESS",
    "MS_MANIPULATION_STATE_ACTIVE",
    "MS_MANIPULATION_STATE_CANCELLED",
    "MS_MANIPULATION_STATE_COMMITTED",
    "MS_MANIPULATION_STATE_DRAGGING",
    "MS_MANIPULATION_STATE_INERTIA",
    "MS_MANIPULATION_STATE_PRESELECT",
    "MS_MANIPULATION_STATE_SELECTING",
    "MS_MANIPULATION_STATE_STOPPED",
    "MS_MEDIA_ERR_ENCRYPTED",
    "MS_MEDIA_KEYERR_CLIENT",
    "MS_MEDIA_KEYERR_DOMAIN",
    "MS_MEDIA_KEYERR_HARDWARECHANGE",
    "MS_MEDIA_KEYERR_OUTPUT",
    "MS_MEDIA_KEYERR_SERVICE",
    "MS_MEDIA_KEYERR_UNKNOWN",
    "Map",
    "Math",
    "MathMLElement",
    "MediaCapabilities",
    "MediaCapabilitiesInfo",
    "MediaController",
    "MediaDeviceInfo",
    "MediaDevices",
    "MediaElementAudioSourceNode",
    "MediaEncryptedEvent",
    "MediaError",
    "MediaKeyError",
    "MediaKeyEvent",
    "MediaKeyMessageEvent",
    "MediaKeyNeededEvent",
    "MediaKeySession",
    "MediaKeyStatusMap",
    "MediaKeySystemAccess",
    "MediaKeys",
    "MediaList",
    "MediaMetadata",
    "MediaQueryList",
    "MediaQueryListEvent",
    "MediaRecorder",
    "MediaRecorderErrorEvent",
    "MediaSession",
    "MediaSettingsRange",
    "MediaSource",
    "MediaStream",
    "MediaStreamAudioDestinationNode",
    "MediaStreamAudioSourceNode",
    "MediaStreamEvent",
    "MediaStreamTrack",
    "MediaStreamTrackAudioSourceNode",
    "MediaStreamTrackEvent",
    "Memory",
    "MessageChannel",
    "MessageEvent",
    "MessagePort",
    "Methods",
    "Microsoft\xAE DRM",
    "MimeType",
    "MimeTypeArray",
    "Module",
    "MouseEvent",
    "MouseScrollEvent",
    "MouseWheelEvent",
    "MozAnimation",
    "MozAnimationDelay",
    "MozAnimationDirection",
    "MozAnimationDuration",
    "MozAnimationFillMode",
    "MozAnimationIterationCount",
    "MozAnimationName",
    "MozAnimationPlayState",
    "MozAnimationTimingFunction",
    "MozAppearance",
    "MozBackfaceVisibility",
    "MozBinding",
    "MozBorderBottomColors",
    "MozBorderEnd",
    "MozBorderEndColor",
    "MozBorderEndStyle",
    "MozBorderEndWidth",
    "MozBorderImage",
    "MozBorderLeftColors",
    "MozBorderRightColors",
    "MozBorderStart",
    "MozBorderStartColor",
    "MozBorderStartStyle",
    "MozBorderStartWidth",
    "MozBorderTopColors",
    "MozBoxAlign",
    "MozBoxDirection",
    "MozBoxFlex",
    "MozBoxOrdinalGroup",
    "MozBoxOrient",
    "MozBoxPack",
    "MozBoxSizing",
    "MozCSSKeyframeRule",
    "MozCSSKeyframesRule",
    "MozColumnCount",
    "MozColumnFill",
    "MozColumnGap",
    "MozColumnRule",
    "MozColumnRuleColor",
    "MozColumnRuleStyle",
    "MozColumnRuleWidth",
    "MozColumnWidth",
    "MozColumns",
    "MozContactChangeEvent",
    "MozFloatEdge",
    "MozFontFeatureSettings",
    "MozFontLanguageOverride",
    "MozForceBrokenImageIcon",
    "MozHyphens",
    "MozImageRegion",
    "MozMarginEnd",
    "MozMarginStart",
    "MozMmsEvent",
    "MozMmsMessage",
    "MozMobileMessageThread",
    "MozOSXFontSmoothing",
    "MozOrient",
    "MozOutlineRadius",
    "MozOutlineRadiusBottomleft",
    "MozOutlineRadiusBottomright",
    "MozOutlineRadiusTopleft",
    "MozOutlineRadiusTopright",
    "MozPaddingEnd",
    "MozPaddingStart",
    "MozPerspective",
    "MozPerspectiveOrigin",
    "MozPowerManager",
    "MozSettingsEvent",
    "MozSmsEvent",
    "MozSmsMessage",
    "MozStackSizing",
    "MozTabSize",
    "MozTextAlignLast",
    "MozTextDecorationColor",
    "MozTextDecorationLine",
    "MozTextDecorationStyle",
    "MozTextSizeAdjust",
    "MozTransform",
    "MozTransformOrigin",
    "MozTransformStyle",
    "MozTransition",
    "MozTransitionDelay",
    "MozTransitionDuration",
    "MozTransitionProperty",
    "MozTransitionTimingFunction",
    "MozUserFocus",
    "MozUserInput",
    "MozUserModify",
    "MozUserSelect",
    "MozWindowDragging",
    "MozWindowShadow",
    "MutationEvent",
    "MutationObserver",
    "MutationRecord",
    "NAMESPACE_ERR",
    "NAMESPACE_RULE",
    "NEAREST",
    "NEAREST_MIPMAP_LINEAR",
    "NEAREST_MIPMAP_NEAREST",
    "NEGATIVE_INFINITY",
    "NETWORK_EMPTY",
    "NETWORK_ERR",
    "NETWORK_IDLE",
    "NETWORK_LOADED",
    "NETWORK_LOADING",
    "NETWORK_NO_SOURCE",
    "NEVER",
    "NEW",
    "NEXT",
    "NEXT_NO_DUPLICATE",
    "NICEST",
    "NODE_AFTER",
    "NODE_BEFORE",
    "NODE_BEFORE_AND_AFTER",
    "NODE_INSIDE",
    "NONE",
    "NON_TRANSIENT_ERR",
    "NOTATION_NODE",
    "NOTCH",
    "NOTEQUAL",
    "NOT_ALLOWED_ERR",
    "NOT_FOUND_ERR",
    "NOT_INSTALLED",
    "NOT_READABLE_ERR",
    "NOT_SUPPORTED_ERR",
    "NO_DATA_ALLOWED_ERR",
    "NO_ERR",
    "NO_ERROR",
    "NO_MODIFICATION_ALLOWED_ERR",
    "NO_UPDATE",
    "NUMBER_TYPE",
    "NUM_COMPRESSED_TEXTURE_FORMATS",
    "NaN",
    "NamedNodeMap",
    "Native Client",
    "NavigationPreloadManager",
    "Navigator",
    "NearbyLinks",
    "NetworkInformation",
    "Node",
    "NodeFilter",
    "NodeIterator",
    "NodeList",
    "Notation",
    "Notification",
    "NotifyPaintEvent",
    "Number",
    "NumberFormat",
    "OBJECT_TYPE",
    "OBSOLETE",
    "OES_element_index_uint",
    "OES_standard_derivatives",
    "OES_texture_float",
    "OES_texture_float_linear",
    "OK",
    "ONE",
    "ONE_MINUS_CONSTANT_ALPHA",
    "ONE_MINUS_CONSTANT_COLOR",
    "ONE_MINUS_DST_ALPHA",
    "ONE_MINUS_DST_COLOR",
    "ONE_MINUS_SRC_ALPHA",
    "ONE_MINUS_SRC_COLOR",
    "OPEN",
    "OPENBSD",
    "OPENED",
    "OPENING",
    "ORDERED_NODE_ITERATOR_TYPE",
    "ORDERED_NODE_SNAPSHOT_TYPE",
    "OS_UPDATE",
    "OTHER_ERROR",
    "OUT_OF_MEMORY",
    "Object",
    "OfflineAudioCompletionEvent",
    "OfflineAudioContext",
    "OfflineResourceList",
    "OffscreenCanvas",
    "OffscreenCanvasRenderingContext2D",
    "OnInstalledReason",
    "OnRestartRequiredReason",
    "Option",
    "OrientationSensor",
    "OscillatorNode",
    "OverconstrainedError",
    "OverconstrainedErrorEvent",
    "OverflowEvent",
    "PACKAGE",
    "PACK_ALIGNMENT",
    "PACK_ROW_LENGTH",
    "PACK_SKIP_PIXELS",
    "PACK_SKIP_ROWS",
    "PAGE_RULE",
    "PARSE_ERR",
    "PATHSEG_ARC_ABS",
    "PATHSEG_ARC_REL",
    "PATHSEG_CLOSEPATH",
    "PATHSEG_CURVETO_CUBIC_ABS",
    "PATHSEG_CURVETO_CUBIC_REL",
    "PATHSEG_CURVETO_CUBIC_SMOOTH_ABS",
    "PATHSEG_CURVETO_CUBIC_SMOOTH_REL",
    "PATHSEG_CURVETO_QUADRATIC_ABS",
    "PATHSEG_CURVETO_QUADRATIC_REL",
    "PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS",
    "PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL",
    "PATHSEG_LINETO_ABS",
    "PATHSEG_LINETO_HORIZONTAL_ABS",
    "PATHSEG_LINETO_HORIZONTAL_REL",
    "PATHSEG_LINETO_REL",
    "PATHSEG_LINETO_VERTICAL_ABS",
    "PATHSEG_LINETO_VERTICAL_REL",
    "PATHSEG_MOVETO_ABS",
    "PATHSEG_MOVETO_REL",
    "PATHSEG_UNKNOWN",
    "PATH_EXISTS_ERR",
    "PEAKING",
    "PERIODIC",
    "PERMISSION_DENIED",
    "PERSISTENT",
    "PI",
    "PIXEL_PACK_BUFFER",
    "PIXEL_PACK_BUFFER_BINDING",
    "PIXEL_UNPACK_BUFFER",
    "PIXEL_UNPACK_BUFFER_BINDING",
    "PLAYING_STATE",
    "POINTS",
    "POLYGON_OFFSET_FACTOR",
    "POLYGON_OFFSET_FILL",
    "POLYGON_OFFSET_UNITS",
    "POSITION_UNAVAILABLE",
    "POSITIVE_INFINITY",
    "PREV",
    "PREV_NO_DUPLICATE",
    "PROCESSING_INSTRUCTION_NODE",
    "PageChangeEvent",
    "PageTransitionEvent",
    "PaintRequest",
    "PaintRequestList",
    "PannerNode",
    "PasswordCredential",
    "Path2D",
    "PaymentAddress",
    "PaymentInstruments",
    "PaymentManager",
    "PaymentMethodChangeEvent",
    "PaymentRequest",
    "PaymentRequestUpdateEvent",
    "PaymentResponse",
    "Performance",
    "PerformanceElementTiming",
    "PerformanceEntry",
    "PerformanceEventTiming",
    "PerformanceLongTaskTiming",
    "PerformanceMark",
    "PerformanceMeasure",
    "PerformanceNavigation",
    "PerformanceNavigationTiming",
    "PerformanceObserver",
    "PerformanceObserverEntryList",
    "PerformancePaintTiming",
    "PerformanceResourceTiming",
    "PerformanceServerTiming",
    "PerformanceTiming",
    "PeriodicSyncManager",
    "PeriodicWave",
    "PermissionStatus",
    "Permissions",
    "PhotoCapabilities",
    "PictureInPictureWindow",
    "PlatformArch",
    "PlatformNaclArch",
    "PlatformOs",
    "Plugin",
    "PluginArray",
    "PluralRules",
    "PointerEvent",
    "PopStateEvent",
    "PopupBlockedEvent",
    "Position",
    "PositionError",
    "Presentation",
    "PresentationAvailability",
    "PresentationConnection",
    "PresentationConnectionAvailableEvent",
    "PresentationConnectionCloseEvent",
    "PresentationConnectionList",
    "PresentationReceiver",
    "PresentationRequest",
    "ProcessingInstruction",
    "ProgressEvent",
    "Promise",
    "PromiseRejectionEvent",
    "PropertyNodeList",
    "Proxy",
    "PublicKeyCredential",
    "PushManager",
    "PushSubscription",
    "PushSubscriptionOptions",
    "Q",
    "QUERY_RESULT",
    "QUERY_RESULT_AVAILABLE",
    "QUOTA_ERR",
    "QUOTA_EXCEEDED_ERR",
    "QueryInterface",
    "R11F_G11F_B10F",
    "R16F",
    "R16I",
    "R16UI",
    "R32F",
    "R32I",
    "R32UI",
    "R8",
    "R8I",
    "R8UI",
    "R8_SNORM",
    "RASTERIZER_DISCARD",
    "READY_TO_RUN",
    "READ_BUFFER",
    "READ_FRAMEBUFFER",
    "READ_FRAMEBUFFER_BINDING",
    "READ_ONLY",
    "READ_ONLY_ERR",
    "READ_WRITE",
    "RED",
    "RED_BITS",
    "RED_INTEGER",
    "REMOVAL",
    "RENDERBUFFER",
    "RENDERBUFFER_ALPHA_SIZE",
    "RENDERBUFFER_BINDING",
    "RENDERBUFFER_BLUE_SIZE",
    "RENDERBUFFER_DEPTH_SIZE",
    "RENDERBUFFER_GREEN_SIZE",
    "RENDERBUFFER_HEIGHT",
    "RENDERBUFFER_INTERNAL_FORMAT",
    "RENDERBUFFER_RED_SIZE",
    "RENDERBUFFER_SAMPLES",
    "RENDERBUFFER_STENCIL_SIZE",
    "RENDERBUFFER_WIDTH",
    "RENDERER",
    "RENDERING_INTENT_ABSOLUTE_COLORIMETRIC",
    "RENDERING_INTENT_AUTO",
    "RENDERING_INTENT_PERCEPTUAL",
    "RENDERING_INTENT_RELATIVE_COLORIMETRIC",
    "RENDERING_INTENT_SATURATION",
    "RENDERING_INTENT_UNKNOWN",
    "REPEAT",
    "REPLACE",
    "RG",
    "RG16F",
    "RG16I",
    "RG16UI",
    "RG32F",
    "RG32I",
    "RG32UI",
    "RG8",
    "RG8I",
    "RG8UI",
    "RG8_SNORM",
    "RGB",
    "RGB10_A2",
    "RGB10_A2UI",
    "RGB16F",
    "RGB16I",
    "RGB16UI",
    "RGB32F",
    "RGB32I",
    "RGB32UI",
    "RGB565",
    "RGB5_A1",
    "RGB8",
    "RGB8I",
    "RGB8UI",
    "RGB8_SNORM",
    "RGB9_E5",
    "RGBA",
    "RGBA16F",
    "RGBA16I",
    "RGBA16UI",
    "RGBA32F",
    "RGBA32I",
    "RGBA32UI",
    "RGBA4",
    "RGBA8",
    "RGBA8I",
    "RGBA8UI",
    "RGBA8_SNORM",
    "RGBA_INTEGER",
    "RGBColor",
    "RGB_INTEGER",
    "RG_INTEGER",
    "ROTATION_CLOCKWISE",
    "ROTATION_COUNTERCLOCKWISE",
    "RTCCertificate",
    "RTCDTMFSender",
    "RTCDTMFToneChangeEvent",
    "RTCDataChannel",
    "RTCDataChannelEvent",
    "RTCDtlsTransport",
    "RTCError",
    "RTCErrorEvent",
    "RTCIceCandidate",
    "RTCIceTransport",
    "RTCPeerConnection",
    "RTCPeerConnectionIceErrorEvent",
    "RTCPeerConnectionIceEvent",
    "RTCRtpReceiver",
    "RTCRtpSender",
    "RTCRtpTransceiver",
    "RTCSctpTransport",
    "RTCSessionDescription",
    "RTCStatsReport",
    "RTCTrackEvent",
    "RUNNING",
    "RadioNodeList",
    "Range",
    "RangeError",
    "RangeException",
    "ReadableByteStream",
    "ReadableStream",
    "ReadableStreamDefaultReader",
    "RecordErrorEvent",
    "Rect",
    "ReferenceError",
    "Reflect",
    "RegExp",
    "RelativeOrientationSensor",
    "RelativeTimeFormat",
    "RemotePlayback",
    "ReportingObserver",
    "Request",
    "RequestUpdateCheckStatus",
    "ResizeObserver",
    "ResizeObserverEntry",
    "ResizeObserverSize",
    "Response",
    "RunningState",
    "RuntimeError",
    "SAMPLER_2D",
    "SAMPLER_2D_ARRAY",
    "SAMPLER_2D_ARRAY_SHADOW",
    "SAMPLER_2D_SHADOW",
    "SAMPLER_3D",
    "SAMPLER_BINDING",
    "SAMPLER_CUBE",
    "SAMPLER_CUBE_SHADOW",
    "SAMPLES",
    "SAMPLE_ALPHA_TO_COVERAGE",
    "SAMPLE_BUFFERS",
    "SAMPLE_COVERAGE",
    "SAMPLE_COVERAGE_INVERT",
    "SAMPLE_COVERAGE_VALUE",
    "SAWTOOTH",
    "SCHEDULED_STATE",
    "SCISSOR_BOX",
    "SCISSOR_TEST",
    "SCROLL_PAGE_DOWN",
    "SCROLL_PAGE_UP",
    "SDP_ANSWER",
    "SDP_OFFER",
    "SDP_PRANSWER",
    "SECURITY_ERR",
    "SELECT",
    "SEPARATE_ATTRIBS",
    "SERIALIZE_ERR",
    "SEVERITY_ERROR",
    "SEVERITY_FATAL_ERROR",
    "SEVERITY_WARNING",
    "SHADER_COMPILER",
    "SHADER_TYPE",
    "SHADING_LANGUAGE_VERSION",
    "SHARED_MODULE_UPDATE",
    "SHIFT_MASK",
    "SHORT",
    "SHOWING",
    "SHOW_ALL",
    "SHOW_ATTRIBUTE",
    "SHOW_CDATA_SECTION",
    "SHOW_COMMENT",
    "SHOW_DOCUMENT",
    "SHOW_DOCUMENT_FRAGMENT",
    "SHOW_DOCUMENT_TYPE",
    "SHOW_ELEMENT",
    "SHOW_ENTITY",
    "SHOW_ENTITY_REFERENCE",
    "SHOW_NOTATION",
    "SHOW_PROCESSING_INSTRUCTION",
    "SHOW_TEXT",
    "SIGNALED",
    "SIGNED_NORMALIZED",
    "SINE",
    "SKIN",
    "SOUNDFIELD",
    "SQLError",
    "SQLException",
    "SQLResultSet",
    "SQLResultSetRowList",
    "SQLTransaction",
    "SQRT1_2",
    "SQRT2",
    "SQUARE",
    "SRC_ALPHA",
    "SRC_ALPHA_SATURATE",
    "SRC_COLOR",
    "SRGB",
    "SRGB8",
    "SRGB8_ALPHA8",
    "START_TO_END",
    "START_TO_START",
    "STATIC_COPY",
    "STATIC_DRAW",
    "STATIC_READ",
    "STENCIL",
    "STENCIL_ATTACHMENT",
    "STENCIL_BACK_FAIL",
    "STENCIL_BACK_FUNC",
    "STENCIL_BACK_PASS_DEPTH_FAIL",
    "STENCIL_BACK_PASS_DEPTH_PASS",
    "STENCIL_BACK_REF",
    "STENCIL_BACK_VALUE_MASK",
    "STENCIL_BACK_WRITEMASK",
    "STENCIL_BITS",
    "STENCIL_BUFFER_BIT",
    "STENCIL_CLEAR_VALUE",
    "STENCIL_FAIL",
    "STENCIL_FUNC",
    "STENCIL_INDEX",
    "STENCIL_INDEX8",
    "STENCIL_PASS_DEPTH_FAIL",
    "STENCIL_PASS_DEPTH_PASS",
    "STENCIL_REF",
    "STENCIL_TEST",
    "STENCIL_VALUE_MASK",
    "STENCIL_WRITEMASK",
    "STREAM_COPY",
    "STREAM_DRAW",
    "STREAM_READ",
    "STRING_TYPE",
    "STYLE_RULE",
    "SUBPIXEL_BITS",
    "SUPPORTS_RULE",
    "SVGAElement",
    "SVGAltGlyphDefElement",
    "SVGAltGlyphElement",
    "SVGAltGlyphItemElement",
    "SVGAngle",
    "SVGAnimateColorElement",
    "SVGAnimateElement",
    "SVGAnimateMotionElement",
    "SVGAnimateTransformElement",
    "SVGAnimatedAngle",
    "SVGAnimatedBoolean",
    "SVGAnimatedEnumeration",
    "SVGAnimatedInteger",
    "SVGAnimatedLength",
    "SVGAnimatedLengthList",
    "SVGAnimatedNumber",
    "SVGAnimatedNumberList",
    "SVGAnimatedPreserveAspectRatio",
    "SVGAnimatedRect",
    "SVGAnimatedString",
    "SVGAnimatedTransformList",
    "SVGAnimationElement",
    "SVGCircleElement",
    "SVGClipPathElement",
    "SVGColor",
    "SVGComponentTransferFunctionElement",
    "SVGCursorElement",
    "SVGDefsElement",
    "SVGDescElement",
    "SVGDiscardElement",
    "SVGDocument",
    "SVGElement",
    "SVGElementInstance",
    "SVGElementInstanceList",
    "SVGEllipseElement",
    "SVGException",
    "SVGFEBlendElement",
    "SVGFEColorMatrixElement",
    "SVGFEComponentTransferElement",
    "SVGFECompositeElement",
    "SVGFEConvolveMatrixElement",
    "SVGFEDiffuseLightingElement",
    "SVGFEDisplacementMapElement",
    "SVGFEDistantLightElement",
    "SVGFEDropShadowElement",
    "SVGFEFloodElement",
    "SVGFEFuncAElement",
    "SVGFEFuncBElement",
    "SVGFEFuncGElement",
    "SVGFEFuncRElement",
    "SVGFEGaussianBlurElement",
    "SVGFEImageElement",
    "SVGFEMergeElement",
    "SVGFEMergeNodeElement",
    "SVGFEMorphologyElement",
    "SVGFEOffsetElement",
    "SVGFEPointLightElement",
    "SVGFESpecularLightingElement",
    "SVGFESpotLightElement",
    "SVGFETileElement",
    "SVGFETurbulenceElement",
    "SVGFilterElement",
    "SVGFontElement",
    "SVGFontFaceElement",
    "SVGFontFaceFormatElement",
    "SVGFontFaceNameElement",
    "SVGFontFaceSrcElement",
    "SVGFontFaceUriElement",
    "SVGForeignObjectElement",
    "SVGGElement",
    "SVGGeometryElement",
    "SVGGlyphElement",
    "SVGGlyphRefElement",
    "SVGGradientElement",
    "SVGGraphicsElement",
    "SVGHKernElement",
    "SVGImageElement",
    "SVGLength",
    "SVGLengthList",
    "SVGLineElement",
    "SVGLinearGradientElement",
    "SVGMPathElement",
    "SVGMarkerElement",
    "SVGMaskElement",
    "SVGMatrix",
    "SVGMetadataElement",
    "SVGMissingGlyphElement",
    "SVGNumber",
    "SVGNumberList",
    "SVGPaint",
    "SVGPathElement",
    "SVGPathSeg",
    "SVGPathSegArcAbs",
    "SVGPathSegArcRel",
    "SVGPathSegClosePath",
    "SVGPathSegCurvetoCubicAbs",
    "SVGPathSegCurvetoCubicRel",
    "SVGPathSegCurvetoCubicSmoothAbs",
    "SVGPathSegCurvetoCubicSmoothRel",
    "SVGPathSegCurvetoQuadraticAbs",
    "SVGPathSegCurvetoQuadraticRel",
    "SVGPathSegCurvetoQuadraticSmoothAbs",
    "SVGPathSegCurvetoQuadraticSmoothRel",
    "SVGPathSegLinetoAbs",
    "SVGPathSegLinetoHorizontalAbs",
    "SVGPathSegLinetoHorizontalRel",
    "SVGPathSegLinetoRel",
    "SVGPathSegLinetoVerticalAbs",
    "SVGPathSegLinetoVerticalRel",
    "SVGPathSegList",
    "SVGPathSegMovetoAbs",
    "SVGPathSegMovetoRel",
    "SVGPatternElement",
    "SVGPoint",
    "SVGPointList",
    "SVGPolygonElement",
    "SVGPolylineElement",
    "SVGPreserveAspectRatio",
    "SVGRadialGradientElement",
    "SVGRect",
    "SVGRectElement",
    "SVGRenderingIntent",
    "SVGSVGElement",
    "SVGScriptElement",
    "SVGSetElement",
    "SVGStopElement",
    "SVGStringList",
    "SVGStyleElement",
    "SVGSwitchElement",
    "SVGSymbolElement",
    "SVGTRefElement",
    "SVGTSpanElement",
    "SVGTextContentElement",
    "SVGTextElement",
    "SVGTextPathElement",
    "SVGTextPositioningElement",
    "SVGTitleElement",
    "SVGTransform",
    "SVGTransformList",
    "SVGUnitTypes",
    "SVGUseElement",
    "SVGVKernElement",
    "SVGViewElement",
    "SVGViewSpec",
    "SVGZoomAndPan",
    "SVGZoomEvent",
    "SVG_ANGLETYPE_DEG",
    "SVG_ANGLETYPE_GRAD",
    "SVG_ANGLETYPE_RAD",
    "SVG_ANGLETYPE_UNKNOWN",
    "SVG_ANGLETYPE_UNSPECIFIED",
    "SVG_CHANNEL_A",
    "SVG_CHANNEL_B",
    "SVG_CHANNEL_G",
    "SVG_CHANNEL_R",
    "SVG_CHANNEL_UNKNOWN",
    "SVG_COLORTYPE_CURRENTCOLOR",
    "SVG_COLORTYPE_RGBCOLOR",
    "SVG_COLORTYPE_RGBCOLOR_ICCCOLOR",
    "SVG_COLORTYPE_UNKNOWN",
    "SVG_EDGEMODE_DUPLICATE",
    "SVG_EDGEMODE_NONE",
    "SVG_EDGEMODE_UNKNOWN",
    "SVG_EDGEMODE_WRAP",
    "SVG_FEBLEND_MODE_COLOR",
    "SVG_FEBLEND_MODE_COLOR_BURN",
    "SVG_FEBLEND_MODE_COLOR_DODGE",
    "SVG_FEBLEND_MODE_DARKEN",
    "SVG_FEBLEND_MODE_DIFFERENCE",
    "SVG_FEBLEND_MODE_EXCLUSION",
    "SVG_FEBLEND_MODE_HARD_LIGHT",
    "SVG_FEBLEND_MODE_HUE",
    "SVG_FEBLEND_MODE_LIGHTEN",
    "SVG_FEBLEND_MODE_LUMINOSITY",
    "SVG_FEBLEND_MODE_MULTIPLY",
    "SVG_FEBLEND_MODE_NORMAL",
    "SVG_FEBLEND_MODE_OVERLAY",
    "SVG_FEBLEND_MODE_SATURATION",
    "SVG_FEBLEND_MODE_SCREEN",
    "SVG_FEBLEND_MODE_SOFT_LIGHT",
    "SVG_FEBLEND_MODE_UNKNOWN",
    "SVG_FECOLORMATRIX_TYPE_HUEROTATE",
    "SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA",
    "SVG_FECOLORMATRIX_TYPE_MATRIX",
    "SVG_FECOLORMATRIX_TYPE_SATURATE",
    "SVG_FECOLORMATRIX_TYPE_UNKNOWN",
    "SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE",
    "SVG_FECOMPONENTTRANSFER_TYPE_GAMMA",
    "SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY",
    "SVG_FECOMPONENTTRANSFER_TYPE_LINEAR",
    "SVG_FECOMPONENTTRANSFER_TYPE_TABLE",
    "SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN",
    "SVG_FECOMPOSITE_OPERATOR_ARITHMETIC",
    "SVG_FECOMPOSITE_OPERATOR_ATOP",
    "SVG_FECOMPOSITE_OPERATOR_IN",
    "SVG_FECOMPOSITE_OPERATOR_OUT",
    "SVG_FECOMPOSITE_OPERATOR_OVER",
    "SVG_FECOMPOSITE_OPERATOR_UNKNOWN",
    "SVG_FECOMPOSITE_OPERATOR_XOR",
    "SVG_INVALID_VALUE_ERR",
    "SVG_LENGTHTYPE_CM",
    "SVG_LENGTHTYPE_EMS",
    "SVG_LENGTHTYPE_EXS",
    "SVG_LENGTHTYPE_IN",
    "SVG_LENGTHTYPE_MM",
    "SVG_LENGTHTYPE_NUMBER",
    "SVG_LENGTHTYPE_PC",
    "SVG_LENGTHTYPE_PERCENTAGE",
    "SVG_LENGTHTYPE_PT",
    "SVG_LENGTHTYPE_PX",
    "SVG_LENGTHTYPE_UNKNOWN",
    "SVG_MARKERUNITS_STROKEWIDTH",
    "SVG_MARKERUNITS_UNKNOWN",
    "SVG_MARKERUNITS_USERSPACEONUSE",
    "SVG_MARKER_ORIENT_ANGLE",
    "SVG_MARKER_ORIENT_AUTO",
    "SVG_MARKER_ORIENT_UNKNOWN",
    "SVG_MASKTYPE_ALPHA",
    "SVG_MASKTYPE_LUMINANCE",
    "SVG_MATRIX_NOT_INVERTABLE",
    "SVG_MEETORSLICE_MEET",
    "SVG_MEETORSLICE_SLICE",
    "SVG_MEETORSLICE_UNKNOWN",
    "SVG_MORPHOLOGY_OPERATOR_DILATE",
    "SVG_MORPHOLOGY_OPERATOR_ERODE",
    "SVG_MORPHOLOGY_OPERATOR_UNKNOWN",
    "SVG_PAINTTYPE_CURRENTCOLOR",
    "SVG_PAINTTYPE_NONE",
    "SVG_PAINTTYPE_RGBCOLOR",
    "SVG_PAINTTYPE_RGBCOLOR_ICCCOLOR",
    "SVG_PAINTTYPE_UNKNOWN",
    "SVG_PAINTTYPE_URI",
    "SVG_PAINTTYPE_URI_CURRENTCOLOR",
    "SVG_PAINTTYPE_URI_NONE",
    "SVG_PAINTTYPE_URI_RGBCOLOR",
    "SVG_PAINTTYPE_URI_RGBCOLOR_ICCCOLOR",
    "SVG_PRESERVEASPECTRATIO_NONE",
    "SVG_PRESERVEASPECTRATIO_UNKNOWN",
    "SVG_PRESERVEASPECTRATIO_XMAXYMAX",
    "SVG_PRESERVEASPECTRATIO_XMAXYMID",
    "SVG_PRESERVEASPECTRATIO_XMAXYMIN",
    "SVG_PRESERVEASPECTRATIO_XMIDYMAX",
    "SVG_PRESERVEASPECTRATIO_XMIDYMID",
    "SVG_PRESERVEASPECTRATIO_XMIDYMIN",
    "SVG_PRESERVEASPECTRATIO_XMINYMAX",
    "SVG_PRESERVEASPECTRATIO_XMINYMID",
    "SVG_PRESERVEASPECTRATIO_XMINYMIN",
    "SVG_SPREADMETHOD_PAD",
    "SVG_SPREADMETHOD_REFLECT",
    "SVG_SPREADMETHOD_REPEAT",
    "SVG_SPREADMETHOD_UNKNOWN",
    "SVG_STITCHTYPE_NOSTITCH",
    "SVG_STITCHTYPE_STITCH",
    "SVG_STITCHTYPE_UNKNOWN",
    "SVG_TRANSFORM_MATRIX",
    "SVG_TRANSFORM_ROTATE",
    "SVG_TRANSFORM_SCALE",
    "SVG_TRANSFORM_SKEWX",
    "SVG_TRANSFORM_SKEWY",
    "SVG_TRANSFORM_TRANSLATE",
    "SVG_TRANSFORM_UNKNOWN",
    "SVG_TURBULENCE_TYPE_FRACTALNOISE",
    "SVG_TURBULENCE_TYPE_TURBULENCE",
    "SVG_TURBULENCE_TYPE_UNKNOWN",
    "SVG_UNIT_TYPE_OBJECTBOUNDINGBOX",
    "SVG_UNIT_TYPE_UNKNOWN",
    "SVG_UNIT_TYPE_USERSPACEONUSE",
    "SVG_WRONG_TYPE_ERR",
    "SVG_ZOOMANDPAN_DISABLE",
    "SVG_ZOOMANDPAN_MAGNIFY",
    "SVG_ZOOMANDPAN_UNKNOWN",
    "SYNC_CONDITION",
    "SYNC_FENCE",
    "SYNC_FLAGS",
    "SYNC_FLUSH_COMMANDS_BIT",
    "SYNC_GPU_COMMANDS_COMPLETE",
    "SYNC_STATUS",
    "SYNTAX_ERR",
    "SavedPages",
    "Screen",
    "ScreenOrientation",
    "Script",
    "ScriptEngine",
    "ScriptEngineBuildVersion",
    "ScriptEngineMajorVersion",
    "ScriptEngineMinorVersion",
    "ScriptProcessorNode",
    "ScrollAreaEvent",
    "SecurityPolicyViolationEvent",
    "Selection",
    "Sensor",
    "SensorErrorEvent",
    "ServiceWorker",
    "ServiceWorkerContainer",
    "ServiceWorkerMessageEvent",
    "ServiceWorkerRegistration",
    "SessionDescription",
    "Set",
    "ShadowRoot",
    "SharedArrayBuffer",
    "SharedWorker",
    "SimpleGestureEvent",
    "SourceBuffer",
    "SourceBufferList",
    "SpeechSynthesis",
    "SpeechSynthesisErrorEvent",
    "SpeechSynthesisEvent",
    "SpeechSynthesisUtterance",
    "SpeechSynthesisVoice",
    "StaticRange",
    "StereoPannerNode",
    "StopIteration",
    "Storage",
    "StorageEvent",
    "StorageManager",
    "String",
    "StyleMedia",
    "StylePropertyMap",
    "StylePropertyMapReadOnly",
    "StyleSheet",
    "StyleSheetList",
    "StyleSheetPageList",
    "SubmitEvent",
    "SubtleCrypto",
    "Symbol",
    "SyncManager",
    "SyntaxError",
    "TEMPORARY",
    "TEXTPATH_METHODTYPE_ALIGN",
    "TEXTPATH_METHODTYPE_STRETCH",
    "TEXTPATH_METHODTYPE_UNKNOWN",
    "TEXTPATH_SPACINGTYPE_AUTO",
    "TEXTPATH_SPACINGTYPE_EXACT",
    "TEXTPATH_SPACINGTYPE_UNKNOWN",
    "TEXTURE",
    "TEXTURE0",
    "TEXTURE1",
    "TEXTURE10",
    "TEXTURE11",
    "TEXTURE12",
    "TEXTURE13",
    "TEXTURE14",
    "TEXTURE15",
    "TEXTURE16",
    "TEXTURE17",
    "TEXTURE18",
    "TEXTURE19",
    "TEXTURE2",
    "TEXTURE20",
    "TEXTURE21",
    "TEXTURE22",
    "TEXTURE23",
    "TEXTURE24",
    "TEXTURE25",
    "TEXTURE26",
    "TEXTURE27",
    "TEXTURE28",
    "TEXTURE29",
    "TEXTURE3",
    "TEXTURE30",
    "TEXTURE31",
    "TEXTURE4",
    "TEXTURE5",
    "TEXTURE6",
    "TEXTURE7",
    "TEXTURE8",
    "TEXTURE9",
    "TEXTURE_2D",
    "TEXTURE_2D_ARRAY",
    "TEXTURE_3D",
    "TEXTURE_BASE_LEVEL",
    "TEXTURE_BINDING_2D",
    "TEXTURE_BINDING_2D_ARRAY",
    "TEXTURE_BINDING_3D",
    "TEXTURE_BINDING_CUBE_MAP",
    "TEXTURE_COMPARE_FUNC",
    "TEXTURE_COMPARE_MODE",
    "TEXTURE_CUBE_MAP",
    "TEXTURE_CUBE_MAP_NEGATIVE_X",
    "TEXTURE_CUBE_MAP_NEGATIVE_Y",
    "TEXTURE_CUBE_MAP_NEGATIVE_Z",
    "TEXTURE_CUBE_MAP_POSITIVE_X",
    "TEXTURE_CUBE_MAP_POSITIVE_Y",
    "TEXTURE_CUBE_MAP_POSITIVE_Z",
    "TEXTURE_IMMUTABLE_FORMAT",
    "TEXTURE_IMMUTABLE_LEVELS",
    "TEXTURE_MAG_FILTER",
    "TEXTURE_MAX_ANISOTROPY_EXT",
    "TEXTURE_MAX_LEVEL",
    "TEXTURE_MAX_LOD",
    "TEXTURE_MIN_FILTER",
    "TEXTURE_MIN_LOD",
    "TEXTURE_WRAP_R",
    "TEXTURE_WRAP_S",
    "TEXTURE_WRAP_T",
    "TEXT_NODE",
    "THROTTLED",
    "TIMEOUT",
    "TIMEOUT_ERR",
    "TIMEOUT_EXPIRED",
    "TIMEOUT_IGNORED",
    "TOO_LARGE_ERR",
    "TRANSACTION_INACTIVE_ERR",
    "TRANSFORM_FEEDBACK",
    "TRANSFORM_FEEDBACK_ACTIVE",
    "TRANSFORM_FEEDBACK_BINDING",
    "TRANSFORM_FEEDBACK_BUFFER",
    "TRANSFORM_FEEDBACK_BUFFER_BINDING",
    "TRANSFORM_FEEDBACK_BUFFER_MODE",
    "TRANSFORM_FEEDBACK_BUFFER_SIZE",
    "TRANSFORM_FEEDBACK_BUFFER_START",
    "TRANSFORM_FEEDBACK_PAUSED",
    "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN",
    "TRANSFORM_FEEDBACK_VARYINGS",
    "TRIANGLE",
    "TRIANGLES",
    "TRIANGLE_FAN",
    "TRIANGLE_STRIP",
    "TYPE_BACK_FORWARD",
    "TYPE_ERR",
    "TYPE_MISMATCH_ERR",
    "TYPE_NAVIGATE",
    "TYPE_RELOAD",
    "TYPE_RESERVED",
    "Table",
    "TaskAttributionTiming",
    "Text",
    "TextDecoder",
    "TextDecoderStream",
    "TextEncoder",
    "TextEncoderStream",
    "TextEvent",
    "TextMetrics",
    "TextRange",
    "TextRangeCollection",
    "TextTrack",
    "TextTrackCue",
    "TextTrackCueList",
    "TextTrackList",
    "TimeEvent",
    "TimeRanges",
    "Touch",
    "TouchEvent",
    "TouchList",
    "TrackEvent",
    "TransformStream",
    "TransitionEvent",
    "TreeWalker",
    "TrustedHTML",
    "TrustedScript",
    "TrustedScriptURL",
    "TrustedTypePolicy",
    "TrustedTypePolicyFactory",
    "TypeError",
    "U2F",
    "UIEvent",
    "UNCACHED",
    "UNIFORM_ARRAY_STRIDE",
    "UNIFORM_BLOCK_ACTIVE_UNIFORMS",
    "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES",
    "UNIFORM_BLOCK_BINDING",
    "UNIFORM_BLOCK_DATA_SIZE",
    "UNIFORM_BLOCK_INDEX",
    "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER",
    "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER",
    "UNIFORM_BUFFER",
    "UNIFORM_BUFFER_BINDING",
    "UNIFORM_BUFFER_OFFSET_ALIGNMENT",
    "UNIFORM_BUFFER_SIZE",
    "UNIFORM_BUFFER_START",
    "UNIFORM_IS_ROW_MAJOR",
    "UNIFORM_MATRIX_STRIDE",
    "UNIFORM_OFFSET",
    "UNIFORM_SIZE",
    "UNIFORM_TYPE",
    "UNKNOWN_ERR",
    "UNKNOWN_RULE",
    "UNMASKED_RENDERER_WEBGL",
    "UNMASKED_VENDOR_WEBGL",
    "UNORDERED_NODE_ITERATOR_TYPE",
    "UNORDERED_NODE_SNAPSHOT_TYPE",
    "UNPACK_ALIGNMENT",
    "UNPACK_COLORSPACE_CONVERSION_WEBGL",
    "UNPACK_FLIP_Y_WEBGL",
    "UNPACK_IMAGE_HEIGHT",
    "UNPACK_PREMULTIPLY_ALPHA_WEBGL",
    "UNPACK_ROW_LENGTH",
    "UNPACK_SKIP_IMAGES",
    "UNPACK_SKIP_PIXELS",
    "UNPACK_SKIP_ROWS",
    "UNSCHEDULED_STATE",
    "UNSENT",
    "UNSIGNALED",
    "UNSIGNED_BYTE",
    "UNSIGNED_INT",
    "UNSIGNED_INT_10F_11F_11F_REV",
    "UNSIGNED_INT_24_8",
    "UNSIGNED_INT_2_10_10_10_REV",
    "UNSIGNED_INT_5_9_9_9_REV",
    "UNSIGNED_INT_SAMPLER_2D",
    "UNSIGNED_INT_SAMPLER_2D_ARRAY",
    "UNSIGNED_INT_SAMPLER_3D",
    "UNSIGNED_INT_SAMPLER_CUBE",
    "UNSIGNED_INT_VEC2",
    "UNSIGNED_INT_VEC3",
    "UNSIGNED_INT_VEC4",
    "UNSIGNED_NORMALIZED",
    "UNSIGNED_SHORT",
    "UNSIGNED_SHORT_4_4_4_4",
    "UNSIGNED_SHORT_5_5_5_1",
    "UNSIGNED_SHORT_5_6_5",
    "UNSPECIFIED_EVENT_TYPE_ERR",
    "UPDATE",
    "UPDATEREADY",
    "UPDATE_AVAILABLE",
    "URIError",
    "URL",
    "URLSearchParams",
    "URLUnencoded",
    "URL_MISMATCH_ERR",
    "USB",
    "USBAlternateInterface",
    "USBConfiguration",
    "USBConnectionEvent",
    "USBDevice",
    "USBEndpoint",
    "USBInTransferResult",
    "USBInterface",
    "USBIsochronousInTransferPacket",
    "USBIsochronousInTransferResult",
    "USBIsochronousOutTransferPacket",
    "USBIsochronousOutTransferResult",
    "USBOutTransferResult",
    "UTC",
    "Uint16Array",
    "Uint32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "UserActivation",
    "UserMessageHandler",
    "UserMessageHandlersNamespace",
    "UserProximityEvent",
    "VALIDATE_STATUS",
    "VALIDATION_ERR",
    "VARIABLES_RULE",
    "VBArray",
    "VENDOR",
    "VERSION",
    "VERSION_CHANGE",
    "VERSION_ERR",
    "VERTEX_ARRAY_BINDING",
    "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING",
    "VERTEX_ATTRIB_ARRAY_DIVISOR",
    "VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE",
    "VERTEX_ATTRIB_ARRAY_ENABLED",
    "VERTEX_ATTRIB_ARRAY_INTEGER",
    "VERTEX_ATTRIB_ARRAY_NORMALIZED",
    "VERTEX_ATTRIB_ARRAY_POINTER",
    "VERTEX_ATTRIB_ARRAY_SIZE",
    "VERTEX_ATTRIB_ARRAY_STRIDE",
    "VERTEX_ATTRIB_ARRAY_TYPE",
    "VERTEX_SHADER",
    "VERTICAL",
    "VERTICAL_AXIS",
    "VER_ERR",
    "VIEWPORT",
    "VIEWPORT_RULE",
    "VRDisplay",
    "VRDisplayCapabilities",
    "VRDisplayEvent",
    "VREyeParameters",
    "VRFieldOfView",
    "VRFrameData",
    "VRPose",
    "VRStageParameters",
    "VTTCue",
    "VTTRegion",
    "ValidityState",
    "VideoPlaybackQuality",
    "VideoStreamTrack",
    "VideoTrack",
    "VideoTrackList",
    "VisualViewport",
    "WAIT_FAILED",
    "WEBGL_compressed_texture_s3tc",
    "WEBGL_debug_renderer_info",
    "WEBKIT_FILTER_RULE",
    "WEBKIT_FORCE_AT_FORCE_MOUSE_DOWN",
    "WEBKIT_FORCE_AT_MOUSE_DOWN",
    "WEBKIT_KEYFRAMES_RULE",
    "WEBKIT_KEYFRAME_RULE",
    "WEBKIT_REGION_RULE",
    "WIN",
    "WRONG_DOCUMENT_ERR",
    "WakeLock",
    "WakeLockSentinel",
    "WaveShaperNode",
    "WeakMap",
    "WeakRef",
    "WeakSet",
    "WebAssembly",
    "WebGL2RenderingContext",
    "WebGLActiveInfo",
    "WebGLBuffer",
    "WebGLContextEvent",
    "WebGLFramebuffer",
    "WebGLObject",
    "WebGLProgram",
    "WebGLQuery",
    "WebGLRenderbuffer",
    "WebGLRenderingContext",
    "WebGLSampler",
    "WebGLShader",
    "WebGLShaderPrecisionFormat",
    "WebGLSync",
    "WebGLTexture",
    "WebGLTransformFeedback",
    "WebGLUniformLocation",
    "WebGLVertexArray",
    "WebGLVertexArrayObject",
    "WebKit built-in PDF",
    "WebKitAnimationEvent",
    "WebKitBlobBuilder",
    "WebKitCSSFilterRule",
    "WebKitCSSFilterValue",
    "WebKitCSSKeyframeRule",
    "WebKitCSSKeyframesRule",
    "WebKitCSSMatrix",
    "WebKitCSSRegionRule",
    "WebKitCSSTransformValue",
    "WebKitDataCue",
    "WebKitGamepad",
    "WebKitMediaKeyError",
    "WebKitMediaKeyMessageEvent",
    "WebKitMediaKeyNeededEvent",
    "WebKitMediaKeySession",
    "WebKitMediaKeys",
    "WebKitMediaSource",
    "WebKitMutationObserver",
    "WebKitNamespace",
    "WebKitPlaybackTargetAvailabilityEvent",
    "WebKitPoint",
    "WebKitShadowRoot",
    "WebKitSourceBuffer",
    "WebKitSourceBufferList",
    "WebKitTransitionEvent",
    "WebSocket",
    "WebkitAlignContent",
    "WebkitAlignItems",
    "WebkitAlignSelf",
    "WebkitAnimation",
    "WebkitAnimationDelay",
    "WebkitAnimationDirection",
    "WebkitAnimationDuration",
    "WebkitAnimationFillMode",
    "WebkitAnimationIterationCount",
    "WebkitAnimationName",
    "WebkitAnimationPlayState",
    "WebkitAnimationTimingFunction",
    "WebkitAppearance",
    "WebkitBackfaceVisibility",
    "WebkitBackgroundClip",
    "WebkitBackgroundOrigin",
    "WebkitBackgroundSize",
    "WebkitBorderBottomLeftRadius",
    "WebkitBorderBottomRightRadius",
    "WebkitBorderImage",
    "WebkitBorderRadius",
    "WebkitBorderTopLeftRadius",
    "WebkitBorderTopRightRadius",
    "WebkitBoxAlign",
    "WebkitBoxDirection",
    "WebkitBoxFlex",
    "WebkitBoxOrdinalGroup",
    "WebkitBoxOrient",
    "WebkitBoxPack",
    "WebkitBoxShadow",
    "WebkitBoxSizing",
    "WebkitFilter",
    "WebkitFlex",
    "WebkitFlexBasis",
    "WebkitFlexDirection",
    "WebkitFlexFlow",
    "WebkitFlexGrow",
    "WebkitFlexShrink",
    "WebkitFlexWrap",
    "WebkitJustifyContent",
    "WebkitLineClamp",
    "WebkitMask",
    "WebkitMaskClip",
    "WebkitMaskComposite",
    "WebkitMaskImage",
    "WebkitMaskOrigin",
    "WebkitMaskPosition",
    "WebkitMaskPositionX",
    "WebkitMaskPositionY",
    "WebkitMaskRepeat",
    "WebkitMaskSize",
    "WebkitOrder",
    "WebkitPerspective",
    "WebkitPerspectiveOrigin",
    "WebkitTextFillColor",
    "WebkitTextSizeAdjust",
    "WebkitTextStroke",
    "WebkitTextStrokeColor",
    "WebkitTextStrokeWidth",
    "WebkitTransform",
    "WebkitTransformOrigin",
    "WebkitTransformStyle",
    "WebkitTransition",
    "WebkitTransitionDelay",
    "WebkitTransitionDuration",
    "WebkitTransitionProperty",
    "WebkitTransitionTimingFunction",
    "WebkitUserSelect",
    "WheelEvent",
    "Window",
    "Windows Media Player Plug-in Dynamic Link Library",
    "Windows Presentation Foundation",
    "Worker",
    "Worklet",
    "WritableStream",
    "WritableStreamDefaultWriter",
    "X86_32",
    "X86_64",
    "XMLDocument",
    "XMLHttpRequest",
    "XMLHttpRequestEventTarget",
    "XMLHttpRequestException",
    "XMLHttpRequestProgressEvent",
    "XMLHttpRequestUpload",
    "XMLSerializer",
    "XMLStylesheetProcessingInstruction",
    "XPathEvaluator",
    "XPathException",
    "XPathExpression",
    "XPathNSResolver",
    "XPathResult",
    "XR",
    "XRBoundedReferenceSpace",
    "XRDOMOverlayState",
    "XRFrame",
    "XRHitTestResult",
    "XRHitTestSource",
    "XRInputSource",
    "XRInputSourceArray",
    "XRInputSourceEvent",
    "XRInputSourcesChangeEvent",
    "XRLayer",
    "XRPose",
    "XRRay",
    "XRReferenceSpace",
    "XRReferenceSpaceEvent",
    "XRRenderState",
    "XRRigidTransform",
    "XRSession",
    "XRSessionEvent",
    "XRSpace",
    "XRSystem",
    "XRTransientInputHitTestResult",
    "XRTransientInputHitTestSource",
    "XRView",
    "XRViewerPose",
    "XRViewport",
    "XRWebGLLayer",
    "XSLTProcessor",
    "ZERO",
    "_XD0M_",
    "_YD0M_",
    "__defineGetter__",
    "__defineSetter__",
    "__lookupGetter__",
    "__lookupSetter__",
    "__opera",
    "__proto__",
    "__relevantExtensionKeys",
    "_browserjsran",
    "a",
    "aLink",
    "abbr",
    "abort",
    "aborted",
    "abs",
    "absolute",
    "acceleration",
    "accelerationIncludingGravity",
    "accelerator",
    "accept",
    "acceptCharset",
    "acceptNode",
    "accessKey",
    "accessKeyLabel",
    "accuracy",
    "acos",
    "acosh",
    "action",
    "actionURL",
    "actions",
    "activated",
    "active",
    "activeCues",
    "activeElement",
    "activeSourceBuffers",
    "activeSourceCount",
    "activeTexture",
    "activeVRDisplays",
    "actualBoundingBoxAscent",
    "actualBoundingBoxDescent",
    "actualBoundingBoxLeft",
    "actualBoundingBoxRight",
    "add",
    "addAll",
    "addBehavior",
    "addCandidate",
    "addColorStop",
    "addCue",
    "addElement",
    "addEventListener",
    "addFilter",
    "addFromString",
    "addFromUri",
    "addIceCandidate",
    "addImport",
    "addListener",
    "addModule",
    "addNamed",
    "addPageRule",
    "addPath",
    "addPointer",
    "addRange",
    "addRegion",
    "addRule",
    "addRules",
    "addSearchEngine",
    "addSourceBuffer",
    "addStream",
    "addTextTrack",
    "addTrack",
    "addTransceiver",
    "addWakeLockListener",
    "added",
    "addedNodes",
    "additionalName",
    "additiveSymbols",
    "addons",
    "address",
    "addressLine",
    "adoptNode",
    "adoptText",
    "adoptedCallback",
    "adoptedStyleSheets",
    "adr",
    "advance",
    "after",
    "album",
    "alert",
    "algorithm",
    "align",
    "align-content",
    "align-items",
    "align-self",
    "alignContent",
    "alignItems",
    "alignSelf",
    "alignmentBaseline",
    "alinkColor",
    "all",
    "allSettled",
    "allow",
    "allowFullscreen",
    "allowPaymentRequest",
    "allowTransparency",
    "allowedDirections",
    "allowedFeatures",
    "allowsFeature",
    "alpha",
    "alphabeticBaseline",
    "alt",
    "altGraphKey",
    "altHtml",
    "altKey",
    "altLeft",
    "alternate",
    "alternateSetting",
    "alternates",
    "altitude",
    "altitudeAccuracy",
    "amplitude",
    "ancestorOrigins",
    "anchor",
    "anchorNode",
    "anchorOffset",
    "anchors",
    "and",
    "angle",
    "angularAcceleration",
    "angularVelocity",
    "animVal",
    "animate",
    "animatedInstanceRoot",
    "animatedNormalizedPathSegList",
    "animatedPathSegList",
    "animatedPoints",
    "animation",
    "animation-delay",
    "animation-direction",
    "animation-duration",
    "animation-fill-mode",
    "animation-iteration-count",
    "animation-name",
    "animation-play-state",
    "animation-timing-function",
    "animationDelay",
    "animationDirection",
    "animationDuration",
    "animationFillMode",
    "animationIterationCount",
    "animationName",
    "animationPlayState",
    "animationStartTime",
    "animationTimingFunction",
    "animationsPaused",
    "anniversary",
    "antialias",
    "any",
    "app",
    "appCodeName",
    "appMinorVersion",
    "appName",
    "appNotifications",
    "appVersion",
    "appearance",
    "append",
    "appendBuffer",
    "appendChild",
    "appendData",
    "appendItem",
    "appendMedium",
    "appendNamed",
    "appendRule",
    "appendStream",
    "appendWindowEnd",
    "appendWindowStart",
    "appleTrailingWord",
    "applets",
    "application/apple-default-browser",
    "application/asx",
    "application/java-deployment-toolkit",
    "application/pdf",
    "application/postscript",
    "application/x-drm",
    "application/x-drm-v2",
    "application/x-google-chrome-pdf",
    "application/x-java-applet",
    "application/x-java-applet;deploy=10.25.2",
    "application/x-java-applet;javafx=2.2.25",
    "application/x-java-applet;jpi-version=1.7.0_25",
    "application/x-java-applet;version=1.1",
    "application/x-java-applet;version=1.1.1",
    "application/x-java-applet;version=1.1.2",
    "application/x-java-applet;version=1.1.3",
    "application/x-java-applet;version=1.2",
    "application/x-java-applet;version=1.2.1",
    "application/x-java-applet;version=1.2.2",
    "application/x-java-applet;version=1.3",
    "application/x-java-applet;version=1.3.1",
    "application/x-java-applet;version=1.4",
    "application/x-java-applet;version=1.4.1",
    "application/x-java-applet;version=1.4.2",
    "application/x-java-applet;version=1.5",
    "application/x-java-applet;version=1.6",
    "application/x-java-applet;version=1.7",
    "application/x-java-bean",
    "application/x-java-bean;jpi-version=1.7.0_25",
    "application/x-java-bean;version=1.1",
    "application/x-java-bean;version=1.1.1",
    "application/x-java-bean;version=1.1.2",
    "application/x-java-bean;version=1.1.3",
    "application/x-java-bean;version=1.2",
    "application/x-java-bean;version=1.2.1",
    "application/x-java-bean;version=1.2.2",
    "application/x-java-bean;version=1.3",
    "application/x-java-bean;version=1.3.1",
    "application/x-java-bean;version=1.4",
    "application/x-java-bean;version=1.4.1",
    "application/x-java-bean;version=1.4.2",
    "application/x-java-bean;version=1.5",
    "application/x-java-bean;version=1.6",
    "application/x-java-bean;version=1.7",
    "application/x-java-vm",
    "application/x-java-vm-npruntime",
    "application/x-mplayer2",
    "application/x-ms-xbap",
    "application/x-nacl",
    "application/x-pnacl",
    "application/xaml+xml",
    "applicationCache",
    "applicationServerKey",
    "apply",
    "applyConstraints",
    "applyElement",
    "arc",
    "arcTo",
    "archive",
    "areas",
    "arguments",
    "aria-activedescendant",
    "aria-busy",
    "aria-checked",
    "aria-controls",
    "aria-describedby",
    "aria-disabled",
    "aria-expanded",
    "aria-flowto",
    "aria-haspopup",
    "aria-hidden",
    "aria-invalid",
    "aria-labelledby",
    "aria-level",
    "aria-live",
    "aria-multiselectable",
    "aria-owns",
    "aria-posinset",
    "aria-pressed",
    "aria-readonly",
    "aria-relevant",
    "aria-required",
    "aria-secret",
    "aria-selected",
    "aria-setsize",
    "aria-valuemax",
    "aria-valuemin",
    "aria-valuenow",
    "ariaAtomic",
    "ariaAutoComplete",
    "ariaBusy",
    "ariaChecked",
    "ariaColCount",
    "ariaColIndex",
    "ariaColSpan",
    "ariaCurrent",
    "ariaDescription",
    "ariaDisabled",
    "ariaExpanded",
    "ariaHasPopup",
    "ariaHidden",
    "ariaKeyShortcuts",
    "ariaLabel",
    "ariaLevel",
    "ariaLive",
    "ariaModal",
    "ariaMultiLine",
    "ariaMultiSelectable",
    "ariaOrientation",
    "ariaPlaceholder",
    "ariaPosInSet",
    "ariaPressed",
    "ariaReadOnly",
    "ariaRelevant",
    "ariaRequired",
    "ariaRoleDescription",
    "ariaRowCount",
    "ariaRowIndex",
    "ariaRowSpan",
    "ariaSelected",
    "ariaSetSize",
    "ariaSort",
    "ariaValueMax",
    "ariaValueMin",
    "ariaValueNow",
    "ariaValueText",
    "arrayBuffer",
    "artist",
    "artwork",
    "as",
    "asIntN",
    "asUintN",
    "asin",
    "asinh",
    "assert",
    "assign",
    "assignedElements",
    "assignedNodes",
    "assignedSlot",
    "async",
    "asyncIterator",
    "atEnd",
    "atan",
    "atan2",
    "atanh",
    "atob",
    "atomic",
    "attachEvent",
    "attachInternals",
    "attachShader",
    "attachShadow",
    "attachments",
    "attack",
    "attestationObject",
    "attrChange",
    "attrName",
    "attributeChangedCallback",
    "attributeFilter",
    "attributeName",
    "attributeNamespace",
    "attributeOldValue",
    "attributeStyleMap",
    "attributes",
    "attribution",
    "audio/x-ms-wax",
    "audio/x-ms-wma",
    "audioBitsPerSecond",
    "audioTracks",
    "audioWorklet",
    "authenticatedSignedWrites",
    "authenticatorData",
    "autoIncrement",
    "autobuffer",
    "autocapitalize",
    "autocomplete",
    "autocorrect",
    "autofocus",
    "automationRate",
    "autoplay",
    "availHeight",
    "availLeft",
    "availTop",
    "availWidth",
    "availability",
    "available",
    "aversion",
    "ax",
    "axes",
    "axis",
    "ay",
    "azimuth",
    "b",
    "back",
    "backdropFilter",
    "backface-visibility",
    "backfaceVisibility",
    "background",
    "background-attachment",
    "background-blend-mode",
    "background-clip",
    "background-color",
    "background-image",
    "background-origin",
    "background-position",
    "background-position-x",
    "background-position-y",
    "background-repeat",
    "background-size",
    "backgroundAttachment",
    "backgroundBlendMode",
    "backgroundClip",
    "backgroundColor",
    "backgroundFetch",
    "backgroundImage",
    "backgroundOrigin",
    "backgroundPosition",
    "backgroundPositionX",
    "backgroundPositionY",
    "backgroundRepeat",
    "backgroundRepeatX",
    "backgroundRepeatY",
    "backgroundSize",
    "badInput",
    "badge",
    "balance",
    "baseFrequencyX",
    "baseFrequencyY",
    "baseLatency",
    "baseLayer",
    "baseName",
    "baseNode",
    "baseOffset",
    "baseURI",
    "baseVal",
    "baselineShift",
    "battery",
    "bday",
    "before",
    "beginElement",
    "beginElementAt",
    "beginPath",
    "beginQuery",
    "beginTransformFeedback",
    "behavior",
    "behaviorCookie",
    "behaviorPart",
    "behaviorUrns",
    "beta",
    "bezierCurveTo",
    "bgColor",
    "bgProperties",
    "bias",
    "big",
    "binaryType",
    "bind",
    "bindAttribLocation",
    "bindBuffer",
    "bindBufferBase",
    "bindBufferRange",
    "bindFramebuffer",
    "bindRenderbuffer",
    "bindSampler",
    "bindTexture",
    "bindTransformFeedback",
    "bindVertexArray",
    "blendColor",
    "blendEquation",
    "blendEquationSeparate",
    "blendFunc",
    "blendFuncSeparate",
    "blink",
    "blitFramebuffer",
    "blob",
    "block-size",
    "blockDirection",
    "blockSize",
    "blockedURI",
    "blue",
    "bluetooth",
    "blur",
    "body",
    "bodyUsed",
    "bold",
    "bookmarks",
    "booleanValue",
    "border",
    "border-block",
    "border-block-color",
    "border-block-end",
    "border-block-end-color",
    "border-block-end-style",
    "border-block-end-width",
    "border-block-start",
    "border-block-start-color",
    "border-block-start-style",
    "border-block-start-width",
    "border-block-style",
    "border-block-width",
    "border-bottom",
    "border-bottom-color",
    "border-bottom-left-radius",
    "border-bottom-right-radius",
    "border-bottom-style",
    "border-bottom-width",
    "border-collapse",
    "border-color",
    "border-end-end-radius",
    "border-end-start-radius",
    "border-image",
    "border-image-outset",
    "border-image-repeat",
    "border-image-slice",
    "border-image-source",
    "border-image-width",
    "border-inline",
    "border-inline-color",
    "border-inline-end",
    "border-inline-end-color",
    "border-inline-end-style",
    "border-inline-end-width",
    "border-inline-start",
    "border-inline-start-color",
    "border-inline-start-style",
    "border-inline-start-width",
    "border-inline-style",
    "border-inline-width",
    "border-left",
    "border-left-color",
    "border-left-style",
    "border-left-width",
    "border-radius",
    "border-right",
    "border-right-color",
    "border-right-style",
    "border-right-width",
    "border-spacing",
    "border-start-end-radius",
    "border-start-start-radius",
    "border-style",
    "border-top",
    "border-top-color",
    "border-top-left-radius",
    "border-top-right-radius",
    "border-top-style",
    "border-top-width",
    "border-width",
    "borderBlock",
    "borderBlockColor",
    "borderBlockEnd",
    "borderBlockEndColor",
    "borderBlockEndStyle",
    "borderBlockEndWidth",
    "borderBlockStart",
    "borderBlockStartColor",
    "borderBlockStartStyle",
    "borderBlockStartWidth",
    "borderBlockStyle",
    "borderBlockWidth",
    "borderBottom",
    "borderBottomColor",
    "borderBottomLeftRadius",
    "borderBottomRightRadius",
    "borderBottomStyle",
    "borderBottomWidth",
    "borderBoxSize",
    "borderCollapse",
    "borderColor",
    "borderColorDark",
    "borderColorLight",
    "borderEndEndRadius",
    "borderEndStartRadius",
    "borderImage",
    "borderImageOutset",
    "borderImageRepeat",
    "borderImageSlice",
    "borderImageSource",
    "borderImageWidth",
    "borderInline",
    "borderInlineColor",
    "borderInlineEnd",
    "borderInlineEndColor",
    "borderInlineEndStyle",
    "borderInlineEndWidth",
    "borderInlineStart",
    "borderInlineStartColor",
    "borderInlineStartStyle",
    "borderInlineStartWidth",
    "borderInlineStyle",
    "borderInlineWidth",
    "borderLeft",
    "borderLeftColor",
    "borderLeftStyle",
    "borderLeftWidth",
    "borderRadius",
    "borderRight",
    "borderRightColor",
    "borderRightStyle",
    "borderRightWidth",
    "borderSpacing",
    "borderStartEndRadius",
    "borderStartStartRadius",
    "borderStyle",
    "borderTop",
    "borderTopColor",
    "borderTopLeftRadius",
    "borderTopRightRadius",
    "borderTopStyle",
    "borderTopWidth",
    "borderWidth",
    "bottom",
    "bottomMargin",
    "bound",
    "boundElements",
    "boundingClientRect",
    "boundingHeight",
    "boundingLeft",
    "boundingTop",
    "boundingWidth",
    "bounds",
    "boundsGeometry",
    "box-decoration-break",
    "box-shadow",
    "box-sizing",
    "boxDecorationBreak",
    "boxShadow",
    "boxSizing",
    "break-after",
    "break-before",
    "break-inside",
    "breakAfter",
    "breakBefore",
    "breakInside",
    "breakType",
    "broadcast",
    "browserLanguage",
    "btoa",
    "bubbles",
    "buffer",
    "bufferData",
    "bufferDepth",
    "bufferSize",
    "bufferSubData",
    "buffered",
    "bufferedAmount",
    "bufferedAmountLowThreshold",
    "bufferedRendering",
    "buildID",
    "buildNumber",
    "button",
    "buttonID",
    "buttons",
    "byteLength",
    "byteOffset",
    "bytesWritten",
    "c",
    "cache",
    "caches",
    "calendar",
    "call",
    "caller",
    "canBeFormatted",
    "canBeMounted",
    "canBeShared",
    "canHaveChildren",
    "canHaveHTML",
    "canInsertDTMF",
    "canMakePayment",
    "canPlayType",
    "canPresent",
    "canTrickleIceCandidates",
    "cancel",
    "cancelAndHoldAtTime",
    "cancelAnimationFrame",
    "cancelBubble",
    "cancelIdleCallback",
    "cancelScheduledValues",
    "cancelVideoFrameCallback",
    "cancelWatchAvailability",
    "cancelable",
    "candidate",
    "canonicalUUID",
    "canvas",
    "capabilities",
    "caption",
    "caption-side",
    "captionSide",
    "capture",
    "captureEvents",
    "captureStackTrace",
    "captureStream",
    "caret-color",
    "caretBidiLevel",
    "caretColor",
    "caretPositionFromPoint",
    "caretRangeFromPoint",
    "caseFirst",
    "cast",
    "catch",
    "category",
    "cbrt",
    "cd",
    "ceil",
    "cellIndex",
    "cellPadding",
    "cellSpacing",
    "cells",
    "ch",
    "chOff",
    "chain",
    "challenge",
    "changeType",
    "changeVersion",
    "changedTouches",
    "channel",
    "channelCount",
    "channelCountMode",
    "channelInterpretation",
    "char",
    "charAt",
    "charCode",
    "charCodeAt",
    "charIndex",
    "charLength",
    "characterData",
    "characterDataOldValue",
    "characterSet",
    "characteristic",
    "charging",
    "chargingTime",
    "charset",
    "check",
    "checkEnclosure",
    "checkFramebufferStatus",
    "checkInstalled",
    "checkIntersection",
    "checkValidity",
    "checked",
    "childElementCount",
    "childList",
    "childNodes",
    "children",
    "chrome",
    "ciphertext",
    "cite",
    "city",
    "claimInterface",
    "claimed",
    "classList",
    "className",
    "classid",
    "clear",
    "clearAppBadge",
    "clearAttributes",
    "clearBufferfi",
    "clearBufferfv",
    "clearBufferiv",
    "clearBufferuiv",
    "clearColor",
    "clearData",
    "clearDepth",
    "clearHalt",
    "clearImmediate",
    "clearInterval",
    "clearLiveSeekableRange",
    "clearMarks",
    "clearMeasures",
    "clearParameters",
    "clearRect",
    "clearResourceTimings",
    "clearShadow",
    "clearStencil",
    "clearTimeout",
    "clearWatch",
    "click",
    "clickCount",
    "clientDataJSON",
    "clientHeight",
    "clientInformation",
    "clientLeft",
    "clientRect",
    "clientRects",
    "clientTop",
    "clientWaitSync",
    "clientWidth",
    "clientX",
    "clientY",
    "clip",
    "clip-path",
    "clip-rule",
    "clipBottom",
    "clipLeft",
    "clipPath",
    "clipPathUnits",
    "clipRight",
    "clipRule",
    "clipTop",
    "clipboard",
    "clipboardData",
    "clone",
    "cloneContents",
    "cloneNode",
    "cloneRange",
    "close",
    "closePath",
    "closed",
    "closest",
    "clz",
    "clz32",
    "cm",
    "cmp",
    "code",
    "codeBase",
    "codePointAt",
    "codeType",
    "colSpan",
    "collapse",
    "collapseToEnd",
    "collapseToStart",
    "collapsed",
    "collation",
    "collect",
    "colno",
    "color",
    "color-adjust",
    "color-interpolation",
    "color-interpolation-filters",
    "colorAdjust",
    "colorDepth",
    "colorInterpolation",
    "colorInterpolationFilters",
    "colorMask",
    "colorProfile",
    "colorRendering",
    "colorScheme",
    "colorType",
    "cols",
    "column",
    "column-count",
    "column-fill",
    "column-gap",
    "column-rule",
    "column-rule-color",
    "column-rule-style",
    "column-rule-width",
    "column-span",
    "column-width",
    "columnCount",
    "columnFill",
    "columnGap",
    "columnNumber",
    "columnRule",
    "columnRuleColor",
    "columnRuleStyle",
    "columnRuleWidth",
    "columnSpan",
    "columnWidth",
    "columns",
    "command",
    "commit",
    "commitLoadTime",
    "commitPreferences",
    "commitStyles",
    "commonAncestorContainer",
    "compact",
    "compare",
    "compareBoundaryPoints",
    "compareDocumentPosition",
    "compareEndPoints",
    "compareExchange",
    "compareNode",
    "comparePoint",
    "compatMode",
    "compatible",
    "compile",
    "compileShader",
    "compileStreaming",
    "complete",
    "component",
    "componentFromPoint",
    "composed",
    "composedPath",
    "composite",
    "compositionEndOffset",
    "compositionStartOffset",
    "compressedTexImage2D",
    "compressedTexImage3D",
    "compressedTexSubImage2D",
    "compressedTexSubImage3D",
    "computedStyleMap",
    "concat",
    "conditionText",
    "coneInnerAngle",
    "coneOuterAngle",
    "coneOuterGain",
    "configuration",
    "configurationName",
    "configurationValue",
    "configurations",
    "confirm",
    "confirmComposition",
    "confirmSiteSpecificTrackingException",
    "confirmWebWideTrackingException",
    "connect",
    "connectEnd",
    "connectStart",
    "connected",
    "connectedCallback",
    "connection",
    "connectionInfo",
    "connectionList",
    "connectionSpeed",
    "connectionState",
    "connections",
    "console",
    "consoleHistory",
    "consolidate",
    "constraint",
    "constrictionActive",
    "construct",
    "constructor",
    "contactID",
    "contain",
    "containIntrinsicSize",
    "containerId",
    "containerName",
    "containerSrc",
    "containerType",
    "contains",
    "containsNode",
    "content",
    "contentBoxSize",
    "contentDocument",
    "contentEditable",
    "contentHint",
    "contentOverflow",
    "contentRect",
    "contentScriptType",
    "contentStyleType",
    "contentType",
    "contentWindow",
    "context",
    "contextMenu",
    "contextmenu",
    "continue",
    "continuePrimaryKey",
    "continuous",
    "control",
    "controlTransferIn",
    "controlTransferOut",
    "controller",
    "controls",
    "controlsList",
    "convertToBlob",
    "convertToSpecifiedUnits",
    "cookie",
    "cookieEnabled",
    "coords",
    "copyBufferSubData",
    "copyFromChannel",
    "copyTexImage2D",
    "copyTexSubImage2D",
    "copyTexSubImage3D",
    "copyToChannel",
    "copyWithin",
    "correspondingElement",
    "correspondingUseElement",
    "corruptedVideoFrames",
    "cos",
    "cosh",
    "count",
    "countReset",
    "counter-increment",
    "counter-reset",
    "counter-set",
    "counterIncrement",
    "counterReset",
    "counterSet",
    "country",
    "cpuClass",
    "cpuSleepAllowed",
    "create",
    "createAnalyser",
    "createAnswer",
    "createAttribute",
    "createAttributeNS",
    "createBiquadFilter",
    "createBuffer",
    "createBufferSource",
    "createCDATASection",
    "createCSSStyleSheet",
    "createCaption",
    "createChannelMerger",
    "createChannelSplitter",
    "createComment",
    "createConstantSource",
    "createContextualFragment",
    "createControlRange",
    "createConvolver",
    "createDTMFSender",
    "createDataChannel",
    "createDelay",
    "createDelayNode",
    "createDocument",
    "createDocumentFragment",
    "createDocumentType",
    "createDynamicsCompressor",
    "createElement",
    "createElementNS",
    "createEntityReference",
    "createEvent",
    "createEventObject",
    "createExpression",
    "createFramebuffer",
    "createFunction",
    "createGain",
    "createGainNode",
    "createHTML",
    "createHTMLDocument",
    "createIIRFilter",
    "createImageBitmap",
    "createImageData",
    "createIndex",
    "createJavaScriptNode",
    "createLinearGradient",
    "createMediaElementSource",
    "createMediaKeys",
    "createMediaStreamDestination",
    "createMediaStreamSource",
    "createMediaStreamTrackSource",
    "createMutableFile",
    "createNSResolver",
    "createNodeIterator",
    "createNotification",
    "createObjectStore",
    "createObjectURL",
    "createOffer",
    "createOscillator",
    "createPanner",
    "createPattern",
    "createPeriodicWave",
    "createPolicy",
    "createPopup",
    "createProcessingInstruction",
    "createProgram",
    "createQuery",
    "createRadialGradient",
    "createRange",
    "createRangeCollection",
    "createReader",
    "createRenderbuffer",
    "createSVGAngle",
    "createSVGLength",
    "createSVGMatrix",
    "createSVGNumber",
    "createSVGPathSegArcAbs",
    "createSVGPathSegArcRel",
    "createSVGPathSegClosePath",
    "createSVGPathSegCurvetoCubicAbs",
    "createSVGPathSegCurvetoCubicRel",
    "createSVGPathSegCurvetoCubicSmoothAbs",
    "createSVGPathSegCurvetoCubicSmoothRel",
    "createSVGPathSegCurvetoQuadraticAbs",
    "createSVGPathSegCurvetoQuadraticRel",
    "createSVGPathSegCurvetoQuadraticSmoothAbs",
    "createSVGPathSegCurvetoQuadraticSmoothRel",
    "createSVGPathSegLinetoAbs",
    "createSVGPathSegLinetoHorizontalAbs",
    "createSVGPathSegLinetoHorizontalRel",
    "createSVGPathSegLinetoRel",
    "createSVGPathSegLinetoVerticalAbs",
    "createSVGPathSegLinetoVerticalRel",
    "createSVGPathSegMovetoAbs",
    "createSVGPathSegMovetoRel",
    "createSVGPoint",
    "createSVGRect",
    "createSVGTransform",
    "createSVGTransformFromMatrix",
    "createSampler",
    "createScript",
    "createScriptProcessor",
    "createScriptURL",
    "createSession",
    "createShader",
    "createShadowRoot",
    "createStereoPanner",
    "createStyleSheet",
    "createTBody",
    "createTFoot",
    "createTHead",
    "createTextNode",
    "createTextRange",
    "createTexture",
    "createTouch",
    "createTouchList",
    "createTransformFeedback",
    "createTreeWalker",
    "createVertexArray",
    "createWaveShaper",
    "creationTime",
    "credentials",
    "crossOrigin",
    "crossOriginIsolated",
    "crypto",
    "csi",
    "csp",
    "cssFloat",
    "cssRules",
    "cssText",
    "cssValueType",
    "ctrlKey",
    "ctrlLeft",
    "cues",
    "cullFace",
    "currency",
    "currencyDisplay",
    "current",
    "currentDirection",
    "currentLocalDescription",
    "currentNode",
    "currentPage",
    "currentRect",
    "currentRemoteDescription",
    "currentScale",
    "currentScript",
    "currentSrc",
    "currentState",
    "currentStyle",
    "currentTarget",
    "currentTime",
    "currentTranslate",
    "currentView",
    "cursor",
    "curve",
    "customElements",
    "customError",
    "customSections",
    "cx",
    "cy",
    "d",
    "data",
    "dataFld",
    "dataFormatAs",
    "dataLoss",
    "dataLossMessage",
    "dataPageSize",
    "dataSrc",
    "dataTransfer",
    "database",
    "databases",
    "dataset",
    "dateTime",
    "day",
    "db",
    "debug",
    "debuggerEnabled",
    "declare",
    "decode",
    "decodeAudioData",
    "decodeURI",
    "decodeURIComponent",
    "decodedBodySize",
    "decoding",
    "decodingInfo",
    "decrypt",
    "default",
    "defaultCharset",
    "defaultChecked",
    "defaultMuted",
    "defaultPlaybackRate",
    "defaultPolicy",
    "defaultPrevented",
    "defaultRequest",
    "defaultSelected",
    "defaultStatus",
    "defaultURL",
    "defaultValue",
    "defaultView",
    "defaultstatus",
    "defer",
    "define",
    "defineMagicFunction",
    "defineMagicVariable",
    "defineProperties",
    "defineProperty",
    "deg",
    "delay",
    "delayTime",
    "delegatesFocus",
    "delete",
    "deleteBuffer",
    "deleteCaption",
    "deleteCell",
    "deleteContents",
    "deleteData",
    "deleteDatabase",
    "deleteFramebuffer",
    "deleteFromDocument",
    "deleteIndex",
    "deleteMedium",
    "deleteObjectStore",
    "deleteProgram",
    "deleteProperty",
    "deleteQuery",
    "deleteRenderbuffer",
    "deleteRow",
    "deleteRule",
    "deleteSampler",
    "deleteShader",
    "deleteSync",
    "deleteTFoot",
    "deleteTHead",
    "deleteTexture",
    "deleteTransformFeedback",
    "deleteVertexArray",
    "deliverChangeRecords",
    "delivery",
    "deliveryInfo",
    "deliveryStatus",
    "deliveryTimestamp",
    "delta",
    "deltaMode",
    "deltaX",
    "deltaY",
    "deltaZ",
    "dependentLocality",
    "depthFar",
    "depthFunc",
    "depthMask",
    "depthNear",
    "depthRange",
    "deref",
    "deriveBits",
    "deriveKey",
    "description",
    "deselectAll",
    "designMode",
    "desiredSize",
    "destination",
    "destinationURL",
    "detach",
    "detachEvent",
    "detachShader",
    "detail",
    "details",
    "detect",
    "detune",
    "device",
    "deviceClass",
    "deviceId",
    "deviceMemory",
    "devicePixelContentBoxSize",
    "devicePixelRatio",
    "deviceProtocol",
    "deviceSessionId",
    "deviceSubclass",
    "deviceVersionMajor",
    "deviceVersionMinor",
    "deviceVersionSubminor",
    "deviceXDPI",
    "deviceYDPI",
    "didTimeout",
    "diffuseConstant",
    "digest",
    "dimensions",
    "dir",
    "dirName",
    "dirXml",
    "direction",
    "dirxml",
    "disable",
    "disablePictureInPicture",
    "disableRemotePlayback",
    "disableVertexAttribArray",
    "disabled",
    "dischargingTime",
    "disconnect",
    "disconnectedCallback",
    "dispatch",
    "dispatchEvent",
    "dispatchToListener",
    "display",
    "displayId",
    "displayName",
    "disposition",
    "distanceModel",
    "div",
    "divisor",
    "djsapi",
    "djsproxy",
    "doImport",
    "doNotTrack",
    "doScroll",
    "doctype",
    "document",
    "documentElement",
    "documentMode",
    "documentURI",
    "dolphin",
    "dolphinGameCenter",
    "dolphininfo",
    "dolphinmeta",
    "domComplete",
    "domContentLoadedEventEnd",
    "domContentLoadedEventStart",
    "domInteractive",
    "domLoading",
    "domOverlayState",
    "domain",
    "domainLookupEnd",
    "domainLookupStart",
    "dominant-baseline",
    "dominantBaseline",
    "done",
    "dopplerFactor",
    "dotAll",
    "downDegrees",
    "downlink",
    "download",
    "downloadTotal",
    "downloaded",
    "dpcm",
    "dpi",
    "dppx",
    "dragDrop",
    "draggable",
    "drawArrays",
    "drawArraysInstanced",
    "drawArraysInstancedANGLE",
    "drawBuffers",
    "drawCustomFocusRing",
    "drawElements",
    "drawElementsInstanced",
    "drawElementsInstancedANGLE",
    "drawFocusIfNeeded",
    "drawImage",
    "drawImageFromRect",
    "drawRangeElements",
    "drawSystemFocusRing",
    "drawingBufferHeight",
    "drawingBufferWidth",
    "dropEffect",
    "droppedVideoFrames",
    "dropzone",
    "dtmf",
    "dump",
    "duplicate",
    "durability",
    "duration",
    "dvname",
    "dvnum",
    "dx",
    "dy",
    "dynsrc",
    "e",
    "edgeMode",
    "effect",
    "effectAllowed",
    "effectiveDirective",
    "effectiveType",
    "elapsedTime",
    "element",
    "elementFromPoint",
    "elementTiming",
    "elements",
    "elementsFromPoint",
    "elevation",
    "ellipse",
    "em",
    "emHeightAscent",
    "emHeightDescent",
    "email",
    "embeds",
    "emma",
    "empty",
    "empty-cells",
    "emptyCells",
    "emptyHTML",
    "emptyScript",
    "emulatedPosition",
    "enable",
    "enableBackground",
    "enableDelegations",
    "enableStyleSheetsForSet",
    "enableVertexAttribArray",
    "enabled",
    "enabledPlugin",
    "encode",
    "encodeInto",
    "encodeURI",
    "encodeURIComponent",
    "encodedBodySize",
    "encoding",
    "encodingInfo",
    "encrypt",
    "enctype",
    "end",
    "endContainer",
    "endElement",
    "endElementAt",
    "endOfStream",
    "endOffset",
    "endQuery",
    "endTime",
    "endTransformFeedback",
    "ended",
    "endpoint",
    "endpointNumber",
    "endpoints",
    "endsWith",
    "enterKeyHint",
    "entities",
    "entries",
    "entryType",
    "enumerate",
    "enumerateDevices",
    "enumerateEditable",
    "environmentBlendMode",
    "epubCaptionSide",
    "epubTextCombine",
    "epubTextEmphasis",
    "epubTextEmphasisColor",
    "epubTextEmphasisStyle",
    "epubTextOrientation",
    "epubTextTransform",
    "epubWordBreak",
    "epubWritingMode",
    "equals",
    "era",
    "error",
    "errorCode",
    "errorDetail",
    "errorText",
    "escape",
    "estimate",
    "eval",
    "evaluate",
    "event",
    "eventPhase",
    "every",
    "ex",
    "exception",
    "exchange",
    "exec",
    "execCommand",
    "execCommandShowHelp",
    "execScript",
    "executeSql",
    "exitFullscreen",
    "exitPictureInPicture",
    "exitPointerLock",
    "exitPresent",
    "exp",
    "expand",
    "expandEntityReferences",
    "expando",
    "expansion",
    "expiration",
    "expirationTime",
    "expires",
    "expiryDate",
    "explicitOriginalTarget",
    "expm1",
    "exponent",
    "exponentialRampToValueAtTime",
    "exportKey",
    "exports",
    "extend",
    "extensions",
    "extentNode",
    "extentOffset",
    "external",
    "externalResourcesRequired",
    "extractContents",
    "extractable",
    "eye",
    "f",
    "face",
    "factoryReset",
    "failureReason",
    "fallback",
    "family",
    "familyName",
    "farthestViewportElement",
    "fastSeek",
    "fatal",
    "featurePolicy",
    "featureSettings",
    "features",
    "fenceSync",
    "fetch",
    "fetchStart",
    "fftSize",
    "fgColor",
    "fieldOfView",
    "file",
    "fileCreatedDate",
    "fileHandle",
    "fileModifiedDate",
    "fileName",
    "fileSize",
    "fileUpdatedDate",
    "filename",
    "files",
    "filesystem",
    "fill",
    "fill-opacity",
    "fill-rule",
    "fillLightMode",
    "fillOpacity",
    "fillRect",
    "fillRule",
    "fillStyle",
    "fillText",
    "filter",
    "filterResX",
    "filterResY",
    "filterUnits",
    "filters",
    "finally",
    "find",
    "findIndex",
    "findRule",
    "findText",
    "finish",
    "finishDocumentLoadTime",
    "finishLoadTime",
    "finished",
    "fireEvent",
    "firesTouchEvents",
    "first",
    "firstChild",
    "firstElementChild",
    "firstPage",
    "firstPaintAfterLoadTime",
    "firstPaintTime",
    "fixed",
    "flags",
    "flat",
    "flatMap",
    "flex",
    "flex-basis",
    "flex-direction",
    "flex-flow",
    "flex-grow",
    "flex-shrink",
    "flex-wrap",
    "flexBasis",
    "flexDirection",
    "flexFlow",
    "flexGrow",
    "flexShrink",
    "flexWrap",
    "flipX",
    "flipY",
    "float",
    "flood-color",
    "flood-opacity",
    "floodColor",
    "floodOpacity",
    "floor",
    "flush",
    "focus",
    "focusNode",
    "focusOffset",
    "font",
    "font-family",
    "font-feature-settings",
    "font-kerning",
    "font-language-override",
    "font-size",
    "font-size-adjust",
    "font-stretch",
    "font-style",
    "font-synthesis",
    "font-variant",
    "font-variant-alternates",
    "font-variant-caps",
    "font-variant-east-asian",
    "font-variant-ligatures",
    "font-variant-numeric",
    "font-variant-position",
    "font-weight",
    "fontBoundingBoxAscent",
    "fontBoundingBoxDescent",
    "fontDisplay",
    "fontFamily",
    "fontFeatureSettings",
    "fontKerning",
    "fontLanguageOverride",
    "fontOpticalSizing",
    "fontSize",
    "fontSizeAdjust",
    "fontSmoothingEnabled",
    "fontStretch",
    "fontStyle",
    "fontSynthesis",
    "fontVariant",
    "fontVariantAlternates",
    "fontVariantCaps",
    "fontVariantEastAsian",
    "fontVariantLigatures",
    "fontVariantNumeric",
    "fontVariantPosition",
    "fontVariationSettings",
    "fontWeight",
    "fontcolor",
    "fontfaces",
    "fonts",
    "fontsize",
    "for",
    "forEach",
    "force",
    "forceRedraw",
    "form",
    "formAction",
    "formData",
    "formEnctype",
    "formMethod",
    "formNoValidate",
    "formTarget",
    "format",
    "formatRange",
    "formatRangeToParts",
    "formatToParts",
    "forms",
    "forward",
    "forwardX",
    "forwardY",
    "forwardZ",
    "foundation",
    "fr",
    "fragmentDirective",
    "frame",
    "frameBorder",
    "frameElement",
    "frameSpacing",
    "framebuffer",
    "framebufferHeight",
    "framebufferRenderbuffer",
    "framebufferTexture2D",
    "framebufferTextureLayer",
    "framebufferWidth",
    "frames",
    "freeSpace",
    "freeze",
    "frequency",
    "frequencyBinCount",
    "from",
    "fromCharCode",
    "fromCodePoint",
    "fromElement",
    "fromEntries",
    "fromFloat32Array",
    "fromFloat64Array",
    "fromMatrix",
    "fromPoint",
    "fromQuad",
    "fromRect",
    "frontFace",
    "fround",
    "fullPath",
    "fullScreen",
    "fullscreen",
    "fullscreenElement",
    "fullscreenEnabled",
    "fx",
    "fy",
    "gain",
    "gamepad",
    "gamma",
    "gap",
    "gatheringState",
    "gatt",
    "genderIdentity",
    "generateCertificate",
    "generateKey",
    "generateMipmap",
    "generateRequest",
    "geolocation",
    "gestureObject",
    "get",
    "getActiveAttrib",
    "getActiveUniform",
    "getActiveUniformBlockName",
    "getActiveUniformBlockParameter",
    "getActiveUniforms",
    "getAdditionalLanguages",
    "getAdjacentText",
    "getAll",
    "getAllKeys",
    "getAllResponseHeaders",
    "getAllowlistForFeature",
    "getAnimations",
    "getAsFile",
    "getAsString",
    "getAttachedShaders",
    "getAttribLocation",
    "getAttribute",
    "getAttributeNS",
    "getAttributeNames",
    "getAttributeNode",
    "getAttributeNodeNS",
    "getAttributeType",
    "getAudioTracks",
    "getAvailability",
    "getBBox",
    "getBattery",
    "getBigInt64",
    "getBigUint64",
    "getBlob",
    "getBookmark",
    "getBoundingClientRect",
    "getBounds",
    "getBufferParameter",
    "getBufferSubData",
    "getByteFrequencyData",
    "getByteTimeDomainData",
    "getCSSCanvasContext",
    "getCTM",
    "getCandidateWindowClientRect",
    "getCanonicalLocales",
    "getCapabilities",
    "getChannelData",
    "getCharNumAtPosition",
    "getCharacteristic",
    "getCharacteristics",
    "getClientExtensionResults",
    "getClientRect",
    "getClientRects",
    "getCoalescedEvents",
    "getCompositionAlternatives",
    "getComputedStyle",
    "getComputedTextLength",
    "getComputedTiming",
    "getConfiguration",
    "getConstraints",
    "getContext",
    "getContextAttributes",
    "getContributingSources",
    "getCount",
    "getCounterValue",
    "getCueAsHTML",
    "getCueById",
    "getCurrentPosition",
    "getCurrentTime",
    "getData",
    "getDatabaseNames",
    "getDate",
    "getDay",
    "getDefaultComputedStyle",
    "getDescriptor",
    "getDescriptors",
    "getDestinationInsertionPoints",
    "getDetails",
    "getDevices",
    "getDirectory",
    "getDisplayMedia",
    "getDistributedNodes",
    "getEditable",
    "getElementById",
    "getElementsByClassName",
    "getElementsByName",
    "getElementsByTagName",
    "getElementsByTagNameNS",
    "getEnclosureList",
    "getEndPositionOfChar",
    "getEntries",
    "getEntriesByName",
    "getEntriesByType",
    "getError",
    "getExtension",
    "getExtentOfChar",
    "getEyeParameters",
    "getFeature",
    "getFile",
    "getFiles",
    "getFilesAndDirectories",
    "getFingerprints",
    "getFloat32",
    "getFloat64",
    "getFloatFrequencyData",
    "getFloatTimeDomainData",
    "getFloatValue",
    "getFragDataLocation",
    "getFrameData",
    "getFramebufferAttachmentParameter",
    "getFrequencyResponse",
    "getFullYear",
    "getGamepads",
    "getHitTestResults",
    "getHitTestResultsForTransientInput",
    "getHours",
    "getIdentityAssertion",
    "getIds",
    "getImageData",
    "getIndexedParameter",
    "getInstalled",
    "getInstalledRelatedApps",
    "getInt16",
    "getInt32",
    "getInt8",
    "getInternalformatParameter",
    "getIntersectionList",
    "getIsInstalled",
    "getItem",
    "getItems",
    "getKey",
    "getKeyframes",
    "getLayers",
    "getLayoutMap",
    "getLineDash",
    "getLocalCandidates",
    "getLocalParameters",
    "getLocalStreams",
    "getLocalizationResource",
    "getMarks",
    "getMatchedCSSRules",
    "getMeasures",
    "getMetadata",
    "getMilliseconds",
    "getMinutes",
    "getModifierState",
    "getMonth",
    "getNamedItem",
    "getNamedItemNS",
    "getNativeFramebufferScaleFactor",
    "getNotifications",
    "getNotifier",
    "getNumberOfChars",
    "getOffsetReferenceSpace",
    "getOutputTimestamp",
    "getOverrideHistoryNavigationMode",
    "getOverrideStyle",
    "getOwnPropertyDescriptor",
    "getOwnPropertyDescriptors",
    "getOwnPropertyNames",
    "getOwnPropertySymbols",
    "getParameter",
    "getParameters",
    "getParent",
    "getPathSegAtLength",
    "getPhotoCapabilities",
    "getPhotoSettings",
    "getPointAtLength",
    "getPose",
    "getPredictedEvents",
    "getPreference",
    "getPreferenceDefault",
    "getPresentationAttribute",
    "getPreventDefault",
    "getPrimaryService",
    "getPrimaryServices",
    "getProgramInfoLog",
    "getProgramParameter",
    "getPropertyCSSValue",
    "getPropertyPriority",
    "getPropertyShorthand",
    "getPropertyType",
    "getPropertyValue",
    "getPrototypeOf",
    "getQuery",
    "getQueryParameter",
    "getRGBColorValue",
    "getRandomValues",
    "getRangeAt",
    "getReader",
    "getReceivers",
    "getRectValue",
    "getRegistration",
    "getRegistrations",
    "getRemoteCandidates",
    "getRemoteCertificates",
    "getRemoteParameters",
    "getRemoteStreams",
    "getRenderbufferParameter",
    "getResponseHeader",
    "getRevision",
    "getRoot",
    "getRootNode",
    "getRotationOfChar",
    "getRules",
    "getSVGDocument",
    "getSamplerParameter",
    "getScreenCTM",
    "getSeconds",
    "getSelectedCandidatePair",
    "getSelection",
    "getSelf",
    "getSenders",
    "getService",
    "getSettings",
    "getShaderInfoLog",
    "getShaderParameter",
    "getShaderPrecisionFormat",
    "getShaderSource",
    "getSimpleDuration",
    "getSiteIcons",
    "getSources",
    "getSpeculativeParserUrls",
    "getStartDate",
    "getStartPositionOfChar",
    "getStartTime",
    "getState",
    "getStats",
    "getStatusForPolicy",
    "getStorageUpdates",
    "getStreamById",
    "getStringValue",
    "getSubStringLength",
    "getSubscription",
    "getSupportedConstraints",
    "getSupportedExtensions",
    "getSupportedFormats",
    "getSyncParameter",
    "getSynchronizationSources",
    "getTags",
    "getTargetRanges",
    "getTexParameter",
    "getTime",
    "getTimezoneOffset",
    "getTiming",
    "getTotalLength",
    "getTrackById",
    "getTracks",
    "getTransceivers",
    "getTransform",
    "getTransformFeedbackVarying",
    "getTransformToElement",
    "getTransports",
    "getType",
    "getTypeMapping",
    "getUTCDate",
    "getUTCDay",
    "getUTCFullYear",
    "getUTCHours",
    "getUTCMilliseconds",
    "getUTCMinutes",
    "getUTCMonth",
    "getUTCSeconds",
    "getUint16",
    "getUint32",
    "getUint8",
    "getUniform",
    "getUniformBlockIndex",
    "getUniformIndices",
    "getUniformLocation",
    "getUserMedia",
    "getVRDisplays",
    "getValues",
    "getVarDate",
    "getVariableValue",
    "getVertexAttrib",
    "getVertexAttribOffset",
    "getVideoPlaybackQuality",
    "getVideoTracks",
    "getViewerPose",
    "getViewport",
    "getVoices",
    "getWakeLockState",
    "getWriter",
    "getYear",
    "givenName",
    "global",
    "globalAlpha",
    "globalCompositeOperation",
    "globalThis",
    "glyphOrientationHorizontal",
    "glyphOrientationVertical",
    "glyphRef",
    "go",
    "grabFrame",
    "grad",
    "gradientTransform",
    "gradientUnits",
    "grammars",
    "green",
    "grid",
    "grid-area",
    "grid-auto-columns",
    "grid-auto-flow",
    "grid-auto-rows",
    "grid-column",
    "grid-column-end",
    "grid-column-gap",
    "grid-column-start",
    "grid-gap",
    "grid-row",
    "grid-row-end",
    "grid-row-gap",
    "grid-row-start",
    "grid-template",
    "grid-template-areas",
    "grid-template-columns",
    "grid-template-rows",
    "gridArea",
    "gridAutoColumns",
    "gridAutoFlow",
    "gridAutoRows",
    "gridColumn",
    "gridColumnEnd",
    "gridColumnGap",
    "gridColumnStart",
    "gridGap",
    "gridRow",
    "gridRowEnd",
    "gridRowGap",
    "gridRowStart",
    "gridTemplate",
    "gridTemplateAreas",
    "gridTemplateColumns",
    "gridTemplateRows",
    "gripSpace",
    "group",
    "groupCollapsed",
    "groupEnd",
    "groupId",
    "grow",
    "hadRecentInput",
    "hand",
    "handedness",
    "hangingBaseline",
    "hangingPunctuation",
    "hapticActuators",
    "hardwareConcurrency",
    "has",
    "hasAttribute",
    "hasAttributeNS",
    "hasAttributes",
    "hasBeenActive",
    "hasChildNodes",
    "hasComposition",
    "hasEnrolledInstrument",
    "hasExtension",
    "hasExternalDisplay",
    "hasFeature",
    "hasFocus",
    "hasInstance",
    "hasLayout",
    "hasListener",
    "hasListeners",
    "hasOrientation",
    "hasOwnProperty",
    "hasPointerCapture",
    "hasPosition",
    "hasReading",
    "hasStorageAccess",
    "hash",
    "head",
    "headers",
    "heading",
    "height",
    "hidden",
    "hide",
    "hideFocus",
    "high",
    "highWaterMark",
    "hint",
    "history",
    "honorificPrefix",
    "honorificSuffix",
    "horizontalOverflow",
    "host",
    "hostCandidate",
    "hostname",
    "hour",
    "hour12",
    "hourCycle",
    "href",
    "hrefTranslate",
    "hreflang",
    "hspace",
    "html5TagCheckInerface",
    "htmlFor",
    "htmlText",
    "httpEquiv",
    "httpRequestStatusCode",
    "hwTimestamp",
    "hyphens",
    "hypot",
    "iccId",
    "iceConnectionState",
    "iceGatheringState",
    "iceTransport",
    "icon",
    "iconURL",
    "id",
    "identifier",
    "identity",
    "ideographicBaseline",
    "idpLoginUrl",
    "ignoreBOM",
    "ignoreCase",
    "ignoreDepthValues",
    "ignoreMutedMedia",
    "ignorePunctuation",
    "image-orientation",
    "image-rendering",
    "imageHeight",
    "imageOrientation",
    "imageRendering",
    "imageSizes",
    "imageSmoothingEnabled",
    "imageSmoothingQuality",
    "imageSrcset",
    "imageWidth",
    "images",
    "ime-mode",
    "imeMode",
    "implementation",
    "import",
    "importKey",
    "importNode",
    "importStylesheet",
    "imports",
    "impp",
    "imul",
    "in",
    "in1",
    "in2",
    "inBandMetadataTrackDispatchType",
    "inRange",
    "includes",
    "incremental",
    "indeterminate",
    "index",
    "indexNames",
    "indexOf",
    "indexedDB",
    "indicate",
    "inertiaDestinationX",
    "inertiaDestinationY",
    "info",
    "init",
    "initAnimationEvent",
    "initBeforeLoadEvent",
    "initClipboardEvent",
    "initCloseEvent",
    "initCommandEvent",
    "initCompositionEvent",
    "initCustomEvent",
    "initData",
    "initDataType",
    "initDeviceMotionEvent",
    "initDeviceOrientationEvent",
    "initDragEvent",
    "initErrorEvent",
    "initEvent",
    "initFocusEvent",
    "initGestureEvent",
    "initHashChangeEvent",
    "initKeyEvent",
    "initKeyboardEvent",
    "initMSManipulationEvent",
    "initMessageEvent",
    "initMouseEvent",
    "initMouseScrollEvent",
    "initMouseWheelEvent",
    "initMutationEvent",
    "initNSMouseEvent",
    "initOverflowEvent",
    "initPageEvent",
    "initPageTransitionEvent",
    "initPointerEvent",
    "initPopStateEvent",
    "initProgressEvent",
    "initScrollAreaEvent",
    "initSimpleGestureEvent",
    "initStorageEvent",
    "initTextEvent",
    "initTimeEvent",
    "initTouchEvent",
    "initTransitionEvent",
    "initUIEvent",
    "initWebKitAnimationEvent",
    "initWebKitTransitionEvent",
    "initWebKitWheelEvent",
    "initWheelEvent",
    "initialTime",
    "initialize",
    "initiatorType",
    "inline-size",
    "inlineSize",
    "inlineVerticalFieldOfView",
    "inner",
    "innerHTML",
    "innerHeight",
    "innerText",
    "innerWidth",
    "input",
    "inputBuffer",
    "inputEncoding",
    "inputMethod",
    "inputMode",
    "inputSource",
    "inputSources",
    "inputType",
    "inputs",
    "insertAdjacentElement",
    "insertAdjacentHTML",
    "insertAdjacentText",
    "insertBefore",
    "insertCell",
    "insertDTMF",
    "insertData",
    "insertId",
    "insertItemBefore",
    "insertNode",
    "insertRow",
    "insertRule",
    "inset",
    "inset-block",
    "inset-block-end",
    "inset-block-start",
    "inset-inline",
    "inset-inline-end",
    "inset-inline-start",
    "insetBlock",
    "insetBlockEnd",
    "insetBlockStart",
    "insetInline",
    "insetInlineEnd",
    "insetInlineStart",
    "install",
    "installChrome",
    "installPackage",
    "installState",
    "installing",
    "instanceRoot",
    "instantiate",
    "instantiateStreaming",
    "instruments",
    "integrity",
    "interactionMode",
    "intercept",
    "interfaceClass",
    "interfaceName",
    "interfaceNumber",
    "interfaceProtocol",
    "interfaceSubclass",
    "interfaces",
    "interimResults",
    "internalSubset",
    "interpretation",
    "intersectionRatio",
    "intersectionRect",
    "intersectsNode",
    "interval",
    "invalidIteratorState",
    "invalidateFramebuffer",
    "invalidateSubFramebuffer",
    "inverse",
    "invertSelf",
    "is",
    "is2D",
    "isActive",
    "isAlternate",
    "isArray",
    "isBingCurrentSearchDefault",
    "isBuffer",
    "isCandidateWindowVisible",
    "isChar",
    "isCollapsed",
    "isComposing",
    "isConcatSpreadable",
    "isConnected",
    "isContentEditable",
    "isContentHandlerRegistered",
    "isContextLost",
    "isDefaultNamespace",
    "isDirectory",
    "isDisabled",
    "isEnabled",
    "isEqual",
    "isEqualNode",
    "isExtensible",
    "isExternalCTAP2SecurityKeySupported",
    "isFile",
    "isFinite",
    "isFramebuffer",
    "isFrozen",
    "isGenerator",
    "isHTML",
    "isHistoryNavigation",
    "isId",
    "isIdentity",
    "isInjected",
    "isInstalled",
    "isInteger",
    "isIntersecting",
    "isLockFree",
    "isMap",
    "isMultiLine",
    "isNaN",
    "isOpen",
    "isPointInFill",
    "isPointInPath",
    "isPointInRange",
    "isPointInStroke",
    "isPrefAlternate",
    "isPresenting",
    "isPrimary",
    "isProgram",
    "isPropertyImplicit",
    "isProtocolHandlerRegistered",
    "isPrototypeOf",
    "isQuery",
    "isRenderbuffer",
    "isSafeInteger",
    "isSameNode",
    "isSampler",
    "isScript",
    "isScriptURL",
    "isSealed",
    "isSecureContext",
    "isSessionSupported",
    "isShader",
    "isSupported",
    "isSync",
    "isTextEdit",
    "isTexture",
    "isTransformFeedback",
    "isTrusted",
    "isTypeSupported",
    "isTypeSupportedWithFeatures",
    "isUserVerifyingPlatformAuthenticatorAvailable",
    "isVertexArray",
    "isView",
    "isVisible",
    "isochronousTransferIn",
    "isochronousTransferOut",
    "isolation",
    "italics",
    "item",
    "itemId",
    "itemProp",
    "itemRef",
    "itemScope",
    "itemType",
    "itemValue",
    "items",
    "iterateNext",
    "iterator",
    "javaEnabled",
    "jobTitle",
    "join",
    "jsHeapSizeLimit",
    "json",
    "justify-content",
    "justify-items",
    "justify-self",
    "justifyContent",
    "justifyItems",
    "justifySelf",
    "k1",
    "k2",
    "k3",
    "k4",
    "kHz",
    "keepalive",
    "kernelMatrix",
    "kernelUnitLengthX",
    "kernelUnitLengthY",
    "kerning",
    "key",
    "keyCode",
    "keyFor",
    "keyIdentifier",
    "keyLightEnabled",
    "keyLocation",
    "keyPath",
    "keyStatuses",
    "keySystem",
    "keyText",
    "keyUsage",
    "keyboard",
    "keys",
    "keytype",
    "kind",
    "knee",
    "label",
    "labels",
    "lang",
    "language",
    "languages",
    "largeArcFlag",
    "lastActivePanel",
    "lastChild",
    "lastElementChild",
    "lastEventId",
    "lastIndex",
    "lastIndexOf",
    "lastInputTime",
    "lastMatch",
    "lastMessageSubject",
    "lastMessageType",
    "lastModified",
    "lastModifiedDate",
    "lastPage",
    "lastParen",
    "lastState",
    "lastStyleSheetSet",
    "latitude",
    "layerX",
    "layerY",
    "layoutFlow",
    "layoutGrid",
    "layoutGridChar",
    "layoutGridLine",
    "layoutGridMode",
    "layoutGridType",
    "lbound",
    "left",
    "leftContext",
    "leftDegrees",
    "leftMargin",
    "leftProjectionMatrix",
    "leftViewMatrix",
    "length",
    "lengthAdjust",
    "lengthComputable",
    "letter-spacing",
    "letterSpacing",
    "level",
    "lighting-color",
    "lightingColor",
    "limitingConeAngle",
    "line",
    "line-break",
    "line-height",
    "lineAlign",
    "lineBreak",
    "lineCap",
    "lineDashOffset",
    "lineHeight",
    "lineJoin",
    "lineNumber",
    "lineTo",
    "lineWidth",
    "linearAcceleration",
    "linearRampToValueAtTime",
    "linearVelocity",
    "lineno",
    "lines",
    "link",
    "linkColor",
    "linkProgram",
    "links",
    "list",
    "list-style",
    "list-style-image",
    "list-style-position",
    "list-style-type",
    "listStyle",
    "listStyleImage",
    "listStylePosition",
    "listStyleType",
    "listener",
    "load",
    "loadEventEnd",
    "loadEventStart",
    "loadTime",
    "loadTimes",
    "loaded",
    "loading",
    "localDescription",
    "localName",
    "localService",
    "localStorage",
    "locale",
    "localeCompare",
    "location",
    "locationbar",
    "lock",
    "locked",
    "lockedFile",
    "locks",
    "log",
    "log10",
    "log1p",
    "log2",
    "logicalXDPI",
    "logicalYDPI",
    "longDesc",
    "longitude",
    "lookupNamespaceURI",
    "lookupPrefix",
    "loop",
    "loopEnd",
    "loopStart",
    "looping",
    "low",
    "lower",
    "lowerBound",
    "lowerOpen",
    "lowsrc",
    "m11",
    "m12",
    "m13",
    "m14",
    "m21",
    "m22",
    "m23",
    "m24",
    "m31",
    "m32",
    "m33",
    "m34",
    "m41",
    "m42",
    "m43",
    "m44",
    "makeXRCompatible",
    "manifest",
    "manufacturer",
    "manufacturerName",
    "map",
    "mapping",
    "margin",
    "margin-block",
    "margin-block-end",
    "margin-block-start",
    "margin-bottom",
    "margin-inline",
    "margin-inline-end",
    "margin-inline-start",
    "margin-left",
    "margin-right",
    "margin-top",
    "marginBlock",
    "marginBlockEnd",
    "marginBlockStart",
    "marginBottom",
    "marginHeight",
    "marginInline",
    "marginInlineEnd",
    "marginInlineStart",
    "marginLeft",
    "marginRight",
    "marginTop",
    "marginWidth",
    "mark",
    "markTimeline",
    "marker",
    "marker-end",
    "marker-mid",
    "marker-offset",
    "marker-start",
    "markerEnd",
    "markerHeight",
    "markerMid",
    "markerOffset",
    "markerStart",
    "markerUnits",
    "markerWidth",
    "marks",
    "mask",
    "mask-clip",
    "mask-composite",
    "mask-image",
    "mask-mode",
    "mask-origin",
    "mask-position",
    "mask-position-x",
    "mask-position-y",
    "mask-repeat",
    "mask-size",
    "mask-type",
    "maskClip",
    "maskComposite",
    "maskContentUnits",
    "maskImage",
    "maskMode",
    "maskOrigin",
    "maskPosition",
    "maskPositionX",
    "maskPositionY",
    "maskRepeat",
    "maskSize",
    "maskType",
    "maskUnits",
    "match",
    "matchAll",
    "matchMedia",
    "matchMedium",
    "matches",
    "matrix",
    "matrixTransform",
    "max",
    "max-block-size",
    "max-height",
    "max-inline-size",
    "max-width",
    "maxActions",
    "maxAlternatives",
    "maxBlockSize",
    "maxChannelCount",
    "maxChannels",
    "maxConnectionsPerServer",
    "maxDecibels",
    "maxDistance",
    "maxHeight",
    "maxInlineSize",
    "maxLayers",
    "maxLength",
    "maxMessageSize",
    "maxPacketLifeTime",
    "maxRetransmits",
    "maxTouchPoints",
    "maxValue",
    "maxWidth",
    "maxZoom",
    "maximize",
    "maximumFractionDigits",
    "measure",
    "measureText",
    "media",
    "mediaCapabilities",
    "mediaDevices",
    "mediaElement",
    "mediaGroup",
    "mediaKeys",
    "mediaSession",
    "mediaStream",
    "mediaText",
    "meetOrSlice",
    "memory",
    "menubar",
    "mergeAttributes",
    "message",
    "messageClass",
    "messageHandlers",
    "messageType",
    "metaKey",
    "metadata",
    "method",
    "methodDetails",
    "methodName",
    "mid",
    "mimeType",
    "mimeTypes",
    "min",
    "min-block-size",
    "min-height",
    "min-inline-size",
    "min-width",
    "minBlockSize",
    "minDecibels",
    "minHeight",
    "minInlineSize",
    "minLength",
    "minValue",
    "minWidth",
    "minZoom",
    "minimize",
    "minimumFractionDigits",
    "minimumIntegerDigits",
    "minute",
    "miterLimit",
    "mix-blend-mode",
    "mixBlendMode",
    "mm",
    "mode",
    "modify",
    "month",
    "motion",
    "motionOffset",
    "motionPath",
    "motionRotation",
    "mount",
    "move",
    "moveBy",
    "moveEnd",
    "moveFirst",
    "moveFocusDown",
    "moveFocusLeft",
    "moveFocusRight",
    "moveFocusUp",
    "moveNext",
    "moveRow",
    "moveStart",
    "moveTo",
    "moveToBookmark",
    "moveToElementText",
    "moveToPoint",
    "movementX",
    "movementY",
    "mozAdd",
    "mozAnimationStartTime",
    "mozAnon",
    "mozApps",
    "mozAudioCaptured",
    "mozAudioChannelType",
    "mozAutoplayEnabled",
    "mozCancelAnimationFrame",
    "mozCancelFullScreen",
    "mozCancelRequestAnimationFrame",
    "mozCaptureStream",
    "mozCaptureStreamUntilEnded",
    "mozClearDataAt",
    "mozContact",
    "mozContacts",
    "mozCreateFileHandle",
    "mozCurrentTransform",
    "mozCurrentTransformInverse",
    "mozCursor",
    "mozDash",
    "mozDashOffset",
    "mozDecodedFrames",
    "mozExitPointerLock",
    "mozFillRule",
    "mozFragmentEnd",
    "mozFrameDelay",
    "mozFullScreen",
    "mozFullScreenElement",
    "mozFullScreenEnabled",
    "mozGetAll",
    "mozGetAllKeys",
    "mozGetAsFile",
    "mozGetDataAt",
    "mozGetMetadata",
    "mozGetUserMedia",
    "mozHasAudio",
    "mozHasItem",
    "mozHidden",
    "mozImageSmoothingEnabled",
    "mozIndexedDB",
    "mozInnerScreenX",
    "mozInnerScreenY",
    "mozInputSource",
    "mozIsTextField",
    "mozItem",
    "mozItemCount",
    "mozItems",
    "mozLength",
    "mozLockOrientation",
    "mozMatchesSelector",
    "mozMovementX",
    "mozMovementY",
    "mozOpaque",
    "mozOrientation",
    "mozPaintCount",
    "mozPaintedFrames",
    "mozParsedFrames",
    "mozPay",
    "mozPointerLockElement",
    "mozPresentedFrames",
    "mozPreservesPitch",
    "mozPressure",
    "mozPrintCallback",
    "mozRTCIceCandidate",
    "mozRTCPeerConnection",
    "mozRTCSessionDescription",
    "mozRemove",
    "mozRequestAnimationFrame",
    "mozRequestFullScreen",
    "mozRequestPointerLock",
    "mozSetDataAt",
    "mozSetImageElement",
    "mozSourceNode",
    "mozSrcObject",
    "mozSystem",
    "mozTCPSocket",
    "mozTextStyle",
    "mozTypesAt",
    "mozUnlockOrientation",
    "mozUserCancelled",
    "mozVisibilityState",
    "ms",
    "msAnimation",
    "msAnimationDelay",
    "msAnimationDirection",
    "msAnimationDuration",
    "msAnimationFillMode",
    "msAnimationIterationCount",
    "msAnimationName",
    "msAnimationPlayState",
    "msAnimationStartTime",
    "msAnimationTimingFunction",
    "msBackfaceVisibility",
    "msBlockProgression",
    "msCSSOMElementFloatMetrics",
    "msCaching",
    "msCachingEnabled",
    "msCancelRequestAnimationFrame",
    "msCapsLockWarningOff",
    "msClearImmediate",
    "msClose",
    "msContentZoomChaining",
    "msContentZoomFactor",
    "msContentZoomLimit",
    "msContentZoomLimitMax",
    "msContentZoomLimitMin",
    "msContentZoomSnap",
    "msContentZoomSnapPoints",
    "msContentZoomSnapType",
    "msContentZooming",
    "msConvertURL",
    "msCrypto",
    "msDoNotTrack",
    "msElementsFromPoint",
    "msElementsFromRect",
    "msExitFullscreen",
    "msExtendedCode",
    "msFillRule",
    "msFirstPaint",
    "msFlex",
    "msFlexAlign",
    "msFlexDirection",
    "msFlexFlow",
    "msFlexItemAlign",
    "msFlexLinePack",
    "msFlexNegative",
    "msFlexOrder",
    "msFlexPack",
    "msFlexPositive",
    "msFlexPreferredSize",
    "msFlexWrap",
    "msFlowFrom",
    "msFlowInto",
    "msFontFeatureSettings",
    "msFullscreenElement",
    "msFullscreenEnabled",
    "msGetInputContext",
    "msGetRegionContent",
    "msGetUntransformedBounds",
    "msGraphicsTrustStatus",
    "msGridColumn",
    "msGridColumnAlign",
    "msGridColumnSpan",
    "msGridColumns",
    "msGridRow",
    "msGridRowAlign",
    "msGridRowSpan",
    "msGridRows",
    "msHidden",
    "msHighContrastAdjust",
    "msHyphenateLimitChars",
    "msHyphenateLimitLines",
    "msHyphenateLimitZone",
    "msHyphens",
    "msImageSmoothingEnabled",
    "msImeAlign",
    "msIndexedDB",
    "msInterpolationMode",
    "msIsStaticHTML",
    "msKeySystem",
    "msKeys",
    "msLaunchUri",
    "msLockOrientation",
    "msManipulationViewsEnabled",
    "msMatchMedia",
    "msMatchesSelector",
    "msMaxTouchPoints",
    "msOrientation",
    "msOverflowStyle",
    "msPerspective",
    "msPerspectiveOrigin",
    "msPlayToDisabled",
    "msPlayToPreferredSourceUri",
    "msPlayToPrimary",
    "msPointerEnabled",
    "msRegionOverflow",
    "msReleasePointerCapture",
    "msRequestAnimationFrame",
    "msRequestFullscreen",
    "msSaveBlob",
    "msSaveOrOpenBlob",
    "msScrollChaining",
    "msScrollLimit",
    "msScrollLimitXMax",
    "msScrollLimitXMin",
    "msScrollLimitYMax",
    "msScrollLimitYMin",
    "msScrollRails",
    "msScrollSnapPointsX",
    "msScrollSnapPointsY",
    "msScrollSnapType",
    "msScrollSnapX",
    "msScrollSnapY",
    "msScrollTranslation",
    "msSetImmediate",
    "msSetMediaKeys",
    "msSetPointerCapture",
    "msTextCombineHorizontal",
    "msTextSizeAdjust",
    "msToBlob",
    "msTouchAction",
    "msTouchSelect",
    "msTraceAsyncCallbackCompleted",
    "msTraceAsyncCallbackStarting",
    "msTraceAsyncOperationCompleted",
    "msTraceAsyncOperationStarting",
    "msTransform",
    "msTransformOrigin",
    "msTransformStyle",
    "msTransition",
    "msTransitionDelay",
    "msTransitionDuration",
    "msTransitionProperty",
    "msTransitionTimingFunction",
    "msUnlockOrientation",
    "msUpdateAsyncCallbackRelation",
    "msUserSelect",
    "msVisibilityState",
    "msWrapFlow",
    "msWrapMargin",
    "msWrapThrough",
    "msWriteProfilerMark",
    "msZoom",
    "msZoomTo",
    "mt",
    "mul",
    "multiEntry",
    "multiSelectionObj",
    "multiline",
    "multiple",
    "multiply",
    "multiplySelf",
    "mutableFile",
    "muted",
    "n",
    "name",
    "nameProp",
    "namedItem",
    "namedRecordset",
    "names",
    "namespaceURI",
    "namespaces",
    "naturalHeight",
    "naturalWidth",
    "navigate",
    "navigation",
    "navigationMode",
    "navigationPreload",
    "navigationStart",
    "navigationType",
    "navigator",
    "near",
    "nearestViewportElement",
    "negative",
    "negotiated",
    "netscape",
    "networkState",
    "newScale",
    "newTranslate",
    "newURL",
    "newValue",
    "newValueSpecifiedUnits",
    "newVersion",
    "newhome",
    "next",
    "nextElementSibling",
    "nextHopProtocol",
    "nextNode",
    "nextPage",
    "nextSibling",
    "nickname",
    "noHref",
    "noModule",
    "noResize",
    "noShade",
    "noValidate",
    "noWrap",
    "node",
    "nodeName",
    "nodeType",
    "nodeValue",
    "nonce",
    "normalize",
    "normalizedPathSegList",
    "notationName",
    "notations",
    "note",
    "noteGrainOn",
    "noteOff",
    "noteOn",
    "notify",
    "now",
    "npnNegotiatedProtocol",
    "numOctaves",
    "number",
    "numberOfChannels",
    "numberOfInputs",
    "numberOfItems",
    "numberOfOutputs",
    "numberValue",
    "numberingSystem",
    "numeric",
    "oMatchesSelector",
    "object",
    "object-fit",
    "object-position",
    "objectFit",
    "objectPosition",
    "objectStore",
    "objectStoreNames",
    "observe",
    "observedAttributes",
    "of",
    "offscreenBuffering",
    "offset",
    "offset-anchor",
    "offset-block-end",
    "offset-block-start",
    "offset-distance",
    "offset-inline-end",
    "offset-inline-start",
    "offset-path",
    "offset-rotate",
    "offsetAnchor",
    "offsetBlockEnd",
    "offsetBlockStart",
    "offsetDistance",
    "offsetHeight",
    "offsetInlineEnd",
    "offsetInlineStart",
    "offsetLeft",
    "offsetNode",
    "offsetParent",
    "offsetPath",
    "offsetRotate",
    "offsetTop",
    "offsetWidth",
    "offsetX",
    "offsetY",
    "ok",
    "oldURL",
    "oldValue",
    "oldVersion",
    "olderShadowRoot",
    "onDownloadProgress",
    "onInstallStageChanged",
    "onLine",
    "onabort",
    "onabsolutedeviceorientation",
    "onactivate",
    "onactive",
    "onaddsourcebuffer",
    "onaddstream",
    "onaddtrack",
    "onafterprint",
    "onafterscriptexecute",
    "onafterupdate",
    "onanimationcancel",
    "onanimationend",
    "onanimationiteration",
    "onanimationstart",
    "onappinstalled",
    "onaudioend",
    "onaudioprocess",
    "onaudiostart",
    "onautocomplete",
    "onautocompleteerror",
    "onauxclick",
    "onbeforeactivate",
    "onbeforecopy",
    "onbeforecut",
    "onbeforedeactivate",
    "onbeforeeditfocus",
    "onbeforeinput",
    "onbeforeinstallprompt",
    "onbeforeload",
    "onbeforepaste",
    "onbeforeprint",
    "onbeforescriptexecute",
    "onbeforeunload",
    "onbeforeupdate",
    "onbeforexrselect",
    "onbegin",
    "onblocked",
    "onblur",
    "onbounce",
    "onboundary",
    "onbufferedamountlow",
    "oncached",
    "oncancel",
    "oncandidatewindowhide",
    "oncandidatewindowshow",
    "oncandidatewindowupdate",
    "oncanplay",
    "oncanplaythrough",
    "once",
    "oncellchange",
    "onchange",
    "oncharacteristicvaluechanged",
    "onchargingchange",
    "onchargingtimechange",
    "onchecking",
    "onclick",
    "onclose",
    "onclosing",
    "oncompassneedscalibration",
    "oncomplete",
    "onconnect",
    "onconnecting",
    "onconnectionavailable",
    "onconnectionstatechange",
    "oncontactchange",
    "oncontextmenu",
    "oncontrollerchange",
    "oncontrolselect",
    "oncopy",
    "oncuechange",
    "oncut",
    "ondataavailable",
    "ondatachannel",
    "ondatasetchanged",
    "ondatasetcomplete",
    "ondblclick",
    "ondeactivate",
    "ondevicechange",
    "ondevicelight",
    "ondevicemotion",
    "ondeviceorientation",
    "ondeviceorientationabsolute",
    "ondeviceproximity",
    "ondischargingtimechange",
    "ondisconnect",
    "ondisplay",
    "ondownloading",
    "ondrag",
    "ondragend",
    "ondragenter",
    "ondragexit",
    "ondragleave",
    "ondragover",
    "ondragstart",
    "ondrop",
    "ondurationchange",
    "onemptied",
    "onencrypted",
    "onend",
    "onended",
    "onenter",
    "onenterpictureinpicture",
    "onerror",
    "onerrorupdate",
    "onexit",
    "onfilterchange",
    "onfinish",
    "onfocus",
    "onfocusin",
    "onfocusout",
    "onformdata",
    "onfreeze",
    "onfullscreenchange",
    "onfullscreenerror",
    "ongatheringstatechange",
    "ongattserverdisconnected",
    "ongesturechange",
    "ongestureend",
    "ongesturestart",
    "ongotpointercapture",
    "onhashchange",
    "onhelp",
    "onicecandidate",
    "onicecandidateerror",
    "oniceconnectionstatechange",
    "onicegatheringstatechange",
    "oninactive",
    "oninput",
    "oninputsourceschange",
    "oninvalid",
    "onkeydown",
    "onkeypress",
    "onkeystatuseschange",
    "onkeyup",
    "onlanguagechange",
    "onlayoutcomplete",
    "onleavepictureinpicture",
    "onlevelchange",
    "onload",
    "onloadT",
    "onloadeddata",
    "onloadedmetadata",
    "onloadend",
    "onloading",
    "onloadingdone",
    "onloadingerror",
    "onloadstart",
    "onlosecapture",
    "onlostpointercapture",
    "only",
    "onmark",
    "onmessage",
    "onmessageerror",
    "onmidimessage",
    "onmousedown",
    "onmouseenter",
    "onmouseleave",
    "onmousemove",
    "onmouseout",
    "onmouseover",
    "onmouseup",
    "onmousewheel",
    "onmove",
    "onmoveend",
    "onmovestart",
    "onmozfullscreenchange",
    "onmozfullscreenerror",
    "onmozorientationchange",
    "onmozpointerlockchange",
    "onmozpointerlockerror",
    "onmscontentzoom",
    "onmsfullscreenchange",
    "onmsfullscreenerror",
    "onmsgesturechange",
    "onmsgesturedoubletap",
    "onmsgestureend",
    "onmsgesturehold",
    "onmsgesturestart",
    "onmsgesturetap",
    "onmsgotpointercapture",
    "onmsinertiastart",
    "onmslostpointercapture",
    "onmsmanipulationstatechanged",
    "onmsneedkey",
    "onmsorientationchange",
    "onmspointercancel",
    "onmspointerdown",
    "onmspointerenter",
    "onmspointerhover",
    "onmspointerleave",
    "onmspointermove",
    "onmspointerout",
    "onmspointerover",
    "onmspointerup",
    "onmssitemodejumplistitemremoved",
    "onmsthumbnailclick",
    "onmute",
    "onnegotiationneeded",
    "onnomatch",
    "onnoupdate",
    "onobsolete",
    "onoffline",
    "ononline",
    "onopen",
    "onorientationchange",
    "onoverconstrained",
    "onpage",
    "onpagechange",
    "onpagehide",
    "onpageshow",
    "onpaste",
    "onpause",
    "onpayerdetailchange",
    "onpaymentmethodchange",
    "onplay",
    "onplaying",
    "onpluginstreamstart",
    "onpointercancel",
    "onpointerdown",
    "onpointerenter",
    "onpointerleave",
    "onpointerlockchange",
    "onpointerlockerror",
    "onpointermove",
    "onpointerout",
    "onpointerover",
    "onpointerrawupdate",
    "onpointerup",
    "onpopstate",
    "onprocessorerror",
    "onprogress",
    "onpropertychange",
    "onratechange",
    "onreading",
    "onreadystatechange",
    "onrejectionhandled",
    "onrelease",
    "onremove",
    "onremovesourcebuffer",
    "onremovestream",
    "onremovetrack",
    "onrepeat",
    "onreset",
    "onresize",
    "onresizeend",
    "onresizestart",
    "onresourcetimingbufferfull",
    "onresult",
    "onresume",
    "onrowenter",
    "onrowexit",
    "onrowsdelete",
    "onrowsinserted",
    "onscroll",
    "onsearch",
    "onsecuritypolicyviolation",
    "onseeked",
    "onseeking",
    "onselect",
    "onselectedcandidatepairchange",
    "onselectend",
    "onselectionchange",
    "onselectstart",
    "onshippingaddresschange",
    "onshippingoptionchange",
    "onshow",
    "onsignalingstatechange",
    "onsoundend",
    "onsoundstart",
    "onsourceclose",
    "onsourceclosed",
    "onsourceended",
    "onsourceopen",
    "onspeechend",
    "onspeechstart",
    "onsqueeze",
    "onsqueezeend",
    "onsqueezestart",
    "onstalled",
    "onstart",
    "onstatechange",
    "onstop",
    "onstorage",
    "onstoragecommit",
    "onsubmit",
    "onsuccess",
    "onsuspend",
    "onterminate",
    "ontextinput",
    "ontimeout",
    "ontimeupdate",
    "ontoggle",
    "ontonechange",
    "ontouchcancel",
    "ontouchend",
    "ontouchmove",
    "ontouchstart",
    "ontrack",
    "ontransitioncancel",
    "ontransitionend",
    "ontransitionrun",
    "ontransitionstart",
    "onunhandledrejection",
    "onunload",
    "onunmute",
    "onupdate",
    "onupdateend",
    "onupdatefound",
    "onupdateready",
    "onupdatestart",
    "onupgradeneeded",
    "onuserproximity",
    "onversionchange",
    "onvisibilitychange",
    "onvoiceschanged",
    "onvolumechange",
    "onvrdisplayactivate",
    "onvrdisplayconnect",
    "onvrdisplaydeactivate",
    "onvrdisplaydisconnect",
    "onvrdisplaypresentchange",
    "onwaiting",
    "onwaitingforkey",
    "onwarning",
    "onwebkitanimationend",
    "onwebkitanimationiteration",
    "onwebkitanimationstart",
    "onwebkitcurrentplaybacktargetiswirelesschanged",
    "onwebkitfullscreenchange",
    "onwebkitfullscreenerror",
    "onwebkitkeyadded",
    "onwebkitkeyerror",
    "onwebkitkeymessage",
    "onwebkitmouseforcechanged",
    "onwebkitmouseforcedown",
    "onwebkitmouseforceup",
    "onwebkitmouseforcewillbegin",
    "onwebkitneedkey",
    "onwebkitorientationchange",
    "onwebkitplaybacktargetavailabilitychanged",
    "onwebkitpointerlockchange",
    "onwebkitpointerlockerror",
    "onwebkitresourcetimingbufferfull",
    "onwebkittransitionend",
    "onwheel",
    "onzoom",
    "opacity",
    "open",
    "openCursor",
    "openDatabase",
    "openKeyCursor",
    "opened",
    "opener",
    "opera",
    "operationType",
    "operator",
    "opr",
    "opsProfile",
    "optimum",
    "options",
    "or",
    "order",
    "orderX",
    "orderY",
    "ordered",
    "org",
    "organization",
    "orient",
    "orientAngle",
    "orientType",
    "orientation",
    "orientationX",
    "orientationY",
    "orientationZ",
    "origin",
    "originalPolicy",
    "originalTarget",
    "orphans",
    "oscpu",
    "outcome",
    "outerHTML",
    "outerHeight",
    "outerText",
    "outerWidth",
    "outline",
    "outline-color",
    "outline-offset",
    "outline-style",
    "outline-width",
    "outlineColor",
    "outlineOffset",
    "outlineStyle",
    "outlineWidth",
    "outputBuffer",
    "outputLatency",
    "outputs",
    "overflow",
    "overflow-anchor",
    "overflow-block",
    "overflow-inline",
    "overflow-wrap",
    "overflow-x",
    "overflow-y",
    "overflowAnchor",
    "overflowBlock",
    "overflowInline",
    "overflowWrap",
    "overflowX",
    "overflowY",
    "overrideMimeType",
    "oversample",
    "overscroll-behavior",
    "overscroll-behavior-block",
    "overscroll-behavior-inline",
    "overscroll-behavior-x",
    "overscroll-behavior-y",
    "overscrollBehavior",
    "overscrollBehaviorBlock",
    "overscrollBehaviorInline",
    "overscrollBehaviorX",
    "overscrollBehaviorY",
    "ownKeys",
    "ownerDocument",
    "ownerElement",
    "ownerNode",
    "ownerRule",
    "ownerSVGElement",
    "owningElement",
    "p1",
    "p2",
    "p3",
    "p4",
    "packetSize",
    "packets",
    "pad",
    "padEnd",
    "padStart",
    "padding",
    "padding-block",
    "padding-block-end",
    "padding-block-start",
    "padding-bottom",
    "padding-inline",
    "padding-inline-end",
    "padding-inline-start",
    "padding-left",
    "padding-right",
    "padding-top",
    "paddingBlock",
    "paddingBlockEnd",
    "paddingBlockStart",
    "paddingBottom",
    "paddingInline",
    "paddingInlineEnd",
    "paddingInlineStart",
    "paddingLeft",
    "paddingRight",
    "paddingTop",
    "page",
    "page-break-after",
    "page-break-before",
    "page-break-inside",
    "pageBreakAfter",
    "pageBreakBefore",
    "pageBreakInside",
    "pageCount",
    "pageLeft",
    "pageT",
    "pageTop",
    "pageX",
    "pageXOffset",
    "pageY",
    "pageYOffset",
    "pages",
    "paint-order",
    "paintOrder",
    "paintRequests",
    "paintType",
    "paintWorklet",
    "palette",
    "pan",
    "panningModel",
    "parameters",
    "parent",
    "parentElement",
    "parentNode",
    "parentRule",
    "parentStyleSheet",
    "parentTextEdit",
    "parentWindow",
    "parse",
    "parseAll",
    "parseFloat",
    "parseFromString",
    "parseInt",
    "part",
    "participants",
    "passive",
    "password",
    "pasteHTML",
    "path",
    "pathLength",
    "pathSegList",
    "pathSegType",
    "pathSegTypeAsLetter",
    "pathname",
    "pattern",
    "patternContentUnits",
    "patternMismatch",
    "patternTransform",
    "patternUnits",
    "pause",
    "pauseAnimations",
    "pauseOnExit",
    "pauseTransformFeedback",
    "paused",
    "payerEmail",
    "payerName",
    "payerPhone",
    "paymentManager",
    "pc",
    "peerIdentity",
    "pending",
    "pendingLocalDescription",
    "pendingRemoteDescription",
    "percent",
    "performance",
    "periodicSync",
    "permission",
    "permissionState",
    "permissions",
    "persist",
    "persisted",
    "personalbar",
    "perspective",
    "perspective-origin",
    "perspectiveOrigin",
    "perspectiveOriginX",
    "perspectiveOriginY",
    "phone",
    "phoneticFamilyName",
    "phoneticGivenName",
    "photo",
    "pictureInPictureElement",
    "pictureInPictureEnabled",
    "pictureInPictureWindow",
    "ping",
    "pipeThrough",
    "pipeTo",
    "pitch",
    "pixelBottom",
    "pixelDepth",
    "pixelHeight",
    "pixelLeft",
    "pixelRight",
    "pixelStorei",
    "pixelTop",
    "pixelUnitToMillimeterX",
    "pixelUnitToMillimeterY",
    "pixelWidth",
    "place-content",
    "place-items",
    "place-self",
    "placeContent",
    "placeItems",
    "placeSelf",
    "placeholder",
    "platform",
    "platforms",
    "play",
    "playEffect",
    "playState",
    "playbackRate",
    "playbackState",
    "playbackTime",
    "played",
    "playoutDelayHint",
    "playsInline",
    "plugins",
    "pluginspage",
    "pname",
    "pointer-events",
    "pointerBeforeReferenceNode",
    "pointerEnabled",
    "pointerEvents",
    "pointerId",
    "pointerLockElement",
    "pointerType",
    "points",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "polygonOffset",
    "pop",
    "populateMatrix",
    "popupWindowFeatures",
    "popupWindowName",
    "popupWindowURI",
    "port",
    "port1",
    "port2",
    "ports",
    "posBottom",
    "posHeight",
    "posLeft",
    "posRight",
    "posTop",
    "posWidth",
    "pose",
    "position",
    "positionAlign",
    "positionX",
    "positionY",
    "positionZ",
    "postError",
    "postMessage",
    "postalCode",
    "poster",
    "pow",
    "powerEfficient",
    "powerOff",
    "preMultiplySelf",
    "precision",
    "preferredStyleSheetSet",
    "preferredStylesheetSet",
    "prefix",
    "preload",
    "prepend",
    "presentation",
    "preserveAlpha",
    "preserveAspectRatio",
    "preserveAspectRatioString",
    "pressed",
    "pressure",
    "prevValue",
    "preventDefault",
    "preventExtensions",
    "preventSilentAccess",
    "previousElementSibling",
    "previousNode",
    "previousPage",
    "previousRect",
    "previousScale",
    "previousSibling",
    "previousTranslate",
    "primaryKey",
    "primitiveType",
    "primitiveUnits",
    "principals",
    "print",
    "priority",
    "privateKey",
    "probablySupportsContext",
    "process",
    "processIceMessage",
    "processingEnd",
    "processingStart",
    "product",
    "productId",
    "productName",
    "productSub",
    "profile",
    "profileEnd",
    "profiles",
    "projectionMatrix",
    "promise",
    "prompt",
    "properties",
    "propertyIsEnumerable",
    "propertyName",
    "protocol",
    "protocolLong",
    "prototype",
    "provider",
    "pseudoClass",
    "pseudoElement",
    "pt",
    "publicId",
    "publicKey",
    "published",
    "pulse",
    "push",
    "pushManager",
    "pushNotification",
    "pushState",
    "put",
    "putImageData",
    "px",
    "quadraticCurveTo",
    "qualifier",
    "quaternion",
    "query",
    "queryCommandEnabled",
    "queryCommandIndeterm",
    "queryCommandState",
    "queryCommandSupported",
    "queryCommandText",
    "queryCommandValue",
    "querySelector",
    "querySelectorAll",
    "queryUsageAndQuota",
    "queueMicrotask",
    "quote",
    "quotes",
    "r",
    "r1",
    "r2",
    "race",
    "rad",
    "radiogroup",
    "radiusX",
    "radiusY",
    "random",
    "range",
    "rangeCount",
    "rangeMax",
    "rangeMin",
    "rangeOffset",
    "rangeOverflow",
    "rangeParent",
    "rangeUnderflow",
    "rate",
    "ratio",
    "raw",
    "rawId",
    "read",
    "readAsArrayBuffer",
    "readAsBinaryString",
    "readAsBlob",
    "readAsDataURL",
    "readAsText",
    "readBuffer",
    "readEntries",
    "readOnly",
    "readPixels",
    "readReportRequested",
    "readText",
    "readTransaction",
    "readValue",
    "readable",
    "ready",
    "readyState",
    "reason",
    "reboot",
    "receivedAlert",
    "receivedTime",
    "receiver",
    "receivers",
    "recipient",
    "reconnect",
    "record",
    "recordEnd",
    "recordNumber",
    "recordsAvailable",
    "recordset",
    "rect",
    "red",
    "redEyeReduction",
    "redirect",
    "redirectCount",
    "redirectEnd",
    "redirectStart",
    "redirected",
    "reduce",
    "reduceRight",
    "reduction",
    "refDistance",
    "refX",
    "refY",
    "referenceNode",
    "referenceSpace",
    "referrer",
    "referrerPolicy",
    "refresh",
    "region",
    "regionAnchorX",
    "regionAnchorY",
    "regionId",
    "regions",
    "register",
    "registerContentHandler",
    "registerElement",
    "registerProperty",
    "registerProtocolHandler",
    "reject",
    "rel",
    "relList",
    "relatedAddress",
    "relatedNode",
    "relatedPort",
    "relatedTarget",
    "release",
    "releaseCapture",
    "releaseEvents",
    "releaseInterface",
    "releaseLock",
    "releasePointerCapture",
    "releaseShaderCompiler",
    "reliable",
    "reliableWrite",
    "reload",
    "rem",
    "remainingSpace",
    "remote",
    "remoteDescription",
    "remove",
    "removeAllRanges",
    "removeAttribute",
    "removeAttributeNS",
    "removeAttributeNode",
    "removeBehavior",
    "removeChild",
    "removeCue",
    "removeEventListener",
    "removeFilter",
    "removeImport",
    "removeItem",
    "removeListener",
    "removeNamedItem",
    "removeNamedItemNS",
    "removeNode",
    "removeParameter",
    "removeProperty",
    "removeRange",
    "removeRegion",
    "removeRule",
    "removeRules",
    "removeSiteSpecificTrackingException",
    "removeSourceBuffer",
    "removeStream",
    "removeTrack",
    "removeVariable",
    "removeWakeLockListener",
    "removeWebWideTrackingException",
    "removed",
    "removedNodes",
    "renderHeight",
    "renderState",
    "renderTime",
    "renderWidth",
    "renderbufferStorage",
    "renderbufferStorageMultisample",
    "renderedBuffer",
    "renderingMode",
    "renotify",
    "repeat",
    "replace",
    "replaceAdjacentText",
    "replaceAll",
    "replaceChild",
    "replaceChildren",
    "replaceData",
    "replaceId",
    "replaceItem",
    "replaceNode",
    "replaceState",
    "replaceSync",
    "replaceTrack",
    "replaceWholeText",
    "replaceWith",
    "reportValidity",
    "request",
    "requestAnimationFrame",
    "requestAutocomplete",
    "requestData",
    "requestDevice",
    "requestFrame",
    "requestFullscreen",
    "requestHitTestSource",
    "requestHitTestSourceForTransientInput",
    "requestId",
    "requestIdleCallback",
    "requestMIDIAccess",
    "requestMediaKeySystemAccess",
    "requestPermission",
    "requestPictureInPicture",
    "requestPointerLock",
    "requestPresent",
    "requestQuota",
    "requestReferenceSpace",
    "requestSession",
    "requestStart",
    "requestStorageAccess",
    "requestSubmit",
    "requestTime",
    "requestVideoFrameCallback",
    "requestedLocale",
    "requestingWindow",
    "requireInteraction",
    "required",
    "requiredExtensions",
    "requiredFeatures",
    "reset",
    "resetPose",
    "resetTransform",
    "resize",
    "resizeBy",
    "resizeTo",
    "resolve",
    "resolved",
    "resolvedOptions",
    "resource-history",
    "resourcesFramesExpanded",
    "response",
    "responseBody",
    "responseEnd",
    "responseReady",
    "responseStart",
    "responseText",
    "responseType",
    "responseURL",
    "responseXML",
    "restartIce",
    "restore",
    "result",
    "resultIndex",
    "resultType",
    "results",
    "resume",
    "resumeTransformFeedback",
    "retry",
    "returnValue",
    "rev",
    "reverse",
    "reversed",
    "revocable",
    "revokeObjectURL",
    "rgbColor",
    "right",
    "rightContext",
    "rightDegrees",
    "rightMargin",
    "rightProjectionMatrix",
    "rightViewMatrix",
    "role",
    "rolloffFactor",
    "root",
    "rootBounds",
    "rootElement",
    "rootMargin",
    "rotate",
    "rotateAxisAngle",
    "rotateAxisAngleSelf",
    "rotateFromVector",
    "rotateFromVectorSelf",
    "rotateSelf",
    "rotation",
    "rotationAngle",
    "rotationRate",
    "round",
    "row-gap",
    "rowGap",
    "rowIndex",
    "rowSpan",
    "rows",
    "rowsAffected",
    "rtcpTransport",
    "rtt",
    "ruby-align",
    "ruby-position",
    "rubyAlign",
    "rubyOverhang",
    "rubyPosition",
    "rules",
    "runningState",
    "runtime",
    "runtimeStyle",
    "rx",
    "ry",
    "s",
    "safari",
    "sample",
    "sampleCoverage",
    "sampleRate",
    "samplerParameterf",
    "samplerParameteri",
    "sandbox",
    "save",
    "saveData",
    "scale",
    "scale3d",
    "scale3dSelf",
    "scaleNonUniform",
    "scaleNonUniformSelf",
    "scaleSelf",
    "scheme",
    "scissor",
    "scope",
    "scopeName",
    "scoped",
    "screen",
    "screenBrightness",
    "screenEnabled",
    "screenLeft",
    "screenPixelToMillimeterX",
    "screenPixelToMillimeterY",
    "screenTop",
    "screenX",
    "screenY",
    "script",
    "scriptURL",
    "scripts",
    "scroll",
    "scroll-behavior",
    "scroll-margin",
    "scroll-margin-block",
    "scroll-margin-block-end",
    "scroll-margin-block-start",
    "scroll-margin-bottom",
    "scroll-margin-inline",
    "scroll-margin-inline-end",
    "scroll-margin-inline-start",
    "scroll-margin-left",
    "scroll-margin-right",
    "scroll-margin-top",
    "scroll-padding",
    "scroll-padding-block",
    "scroll-padding-block-end",
    "scroll-padding-block-start",
    "scroll-padding-bottom",
    "scroll-padding-inline",
    "scroll-padding-inline-end",
    "scroll-padding-inline-start",
    "scroll-padding-left",
    "scroll-padding-right",
    "scroll-padding-top",
    "scroll-snap-align",
    "scroll-snap-coordinate",
    "scroll-snap-destination",
    "scroll-snap-points-x",
    "scroll-snap-points-y",
    "scroll-snap-type",
    "scroll-snap-type-x",
    "scroll-snap-type-y",
    "scrollAmount",
    "scrollBehavior",
    "scrollBy",
    "scrollByLines",
    "scrollByPages",
    "scrollDelay",
    "scrollHeight",
    "scrollIntoView",
    "scrollIntoViewIfNeeded",
    "scrollLeft",
    "scrollLeftMax",
    "scrollMargin",
    "scrollMarginBlock",
    "scrollMarginBlockEnd",
    "scrollMarginBlockStart",
    "scrollMarginBottom",
    "scrollMarginInline",
    "scrollMarginInlineEnd",
    "scrollMarginInlineStart",
    "scrollMarginLeft",
    "scrollMarginRight",
    "scrollMarginTop",
    "scrollMaxX",
    "scrollMaxY",
    "scrollPadding",
    "scrollPaddingBlock",
    "scrollPaddingBlockEnd",
    "scrollPaddingBlockStart",
    "scrollPaddingBottom",
    "scrollPaddingInline",
    "scrollPaddingInlineEnd",
    "scrollPaddingInlineStart",
    "scrollPaddingLeft",
    "scrollPaddingRight",
    "scrollPaddingTop",
    "scrollRestoration",
    "scrollSnapAlign",
    "scrollSnapCoordinate",
    "scrollSnapDestination",
    "scrollSnapMargin",
    "scrollSnapMarginBottom",
    "scrollSnapMarginLeft",
    "scrollSnapMarginRight",
    "scrollSnapMarginTop",
    "scrollSnapPointsX",
    "scrollSnapPointsY",
    "scrollSnapStop",
    "scrollSnapType",
    "scrollSnapTypeX",
    "scrollSnapTypeY",
    "scrollTo",
    "scrollTop",
    "scrollTopMax",
    "scrollWidth",
    "scrollX",
    "scrollY",
    "scrollbar-color",
    "scrollbar-width",
    "scrollbar3dLightColor",
    "scrollbarArrowColor",
    "scrollbarBaseColor",
    "scrollbarColor",
    "scrollbarDarkShadowColor",
    "scrollbarFaceColor",
    "scrollbarHighlightColor",
    "scrollbarShadowColor",
    "scrollbarTrackColor",
    "scrollbarWidth",
    "scrollbars",
    "scrolling",
    "scrollingElement",
    "sctp",
    "sctpCauseCode",
    "sdp",
    "sdpLineNumber",
    "sdpMLineIndex",
    "sdpMid",
    "seal",
    "search",
    "searchBox",
    "searchBoxJavaBridge_",
    "searchParams",
    "second",
    "sectionRowIndex",
    "secureConnectionStart",
    "security",
    "seed",
    "seekToNextFrame",
    "seekable",
    "seeking",
    "select",
    "selectAllChildren",
    "selectAlternateInterface",
    "selectConfiguration",
    "selectNode",
    "selectNodeContents",
    "selectNodes",
    "selectSingleNode",
    "selectSubString",
    "selected",
    "selectedIndex",
    "selectedOption",
    "selectedOptions",
    "selectedStyleSheetSet",
    "selectedStylesheetSet",
    "selection",
    "selectionDirection",
    "selectionEnd",
    "selectionStart",
    "selector",
    "selectorText",
    "self",
    "send",
    "sendAsBinary",
    "sendBeacon",
    "sendMessage",
    "sender",
    "sensitivity",
    "sentAlert",
    "sentTimestamp",
    "separator",
    "serialNumber",
    "serializeToString",
    "serverTiming",
    "service",
    "serviceWorker",
    "session",
    "sessionId",
    "sessionStorage",
    "set",
    "setActionHandler",
    "setActive",
    "setAlpha",
    "setAppBadge",
    "setAttribute",
    "setAttributeNS",
    "setAttributeNode",
    "setAttributeNodeNS",
    "setBaseAndExtent",
    "setBigInt64",
    "setBigUint64",
    "setBingCurrentSearchDefault",
    "setCapture",
    "setCodecPreferences",
    "setColor",
    "setCompositeOperation",
    "setConfiguration",
    "setCurrentTime",
    "setCustomValidity",
    "setData",
    "setDate",
    "setDirection",
    "setDragImage",
    "setEnd",
    "setEndAfter",
    "setEndBefore",
    "setEndPoint",
    "setFillColor",
    "setFilterRes",
    "setFloat32",
    "setFloat64",
    "setFloatValue",
    "setFormValue",
    "setFullYear",
    "setHeaderValue",
    "setHours",
    "setIdentityProvider",
    "setImmediate",
    "setInt16",
    "setInt32",
    "setInt8",
    "setInterval",
    "setItem",
    "setKeyframes",
    "setLineCap",
    "setLineDash",
    "setLineJoin",
    "setLineWidth",
    "setLiveSeekableRange",
    "setLocalDescription",
    "setMatrix",
    "setMatrixValue",
    "setMediaKeys",
    "setMilliseconds",
    "setMinutes",
    "setMiterLimit",
    "setMonth",
    "setNamedItem",
    "setNamedItemNS",
    "setNonUserCodeExceptions",
    "setOrientToAngle",
    "setOrientToAuto",
    "setOrientation",
    "setOverrideHistoryNavigationMode",
    "setPaint",
    "setParameter",
    "setParameters",
    "setPeriodicWave",
    "setPointerCapture",
    "setPosition",
    "setPositionState",
    "setPreference",
    "setProperty",
    "setPrototypeOf",
    "setRGBColor",
    "setRGBColorICCColor",
    "setRadius",
    "setRangeText",
    "setRemoteDescription",
    "setRequestHeader",
    "setResizable",
    "setResourceTimingBufferSize",
    "setRotate",
    "setScale",
    "setSeconds",
    "setSelectionRange",
    "setServerCertificate",
    "setShadow",
    "setSinkId",
    "setSkewX",
    "setSkewY",
    "setStart",
    "setStartAfter",
    "setStartBefore",
    "setStdDeviation",
    "setStreams",
    "setStringValue",
    "setStrokeColor",
    "setSuggestResult",
    "setTargetAtTime",
    "setTargetValueAtTime",
    "setTime",
    "setTimeout",
    "setTransform",
    "setTranslate",
    "setUTCDate",
    "setUTCFullYear",
    "setUTCHours",
    "setUTCMilliseconds",
    "setUTCMinutes",
    "setUTCMonth",
    "setUTCSeconds",
    "setUint16",
    "setUint32",
    "setUint8",
    "setUri",
    "setValidity",
    "setValueAtTime",
    "setValueCurveAtTime",
    "setVariable",
    "setVelocity",
    "setVersion",
    "setYear",
    "settingName",
    "settingValue",
    "sex",
    "shaderSource",
    "shadowBlur",
    "shadowColor",
    "shadowOffsetX",
    "shadowOffsetY",
    "shadowRoot",
    "shape",
    "shape-image-threshold",
    "shape-margin",
    "shape-outside",
    "shape-rendering",
    "shapeImageThreshold",
    "shapeMargin",
    "shapeOutside",
    "shapeRendering",
    "sheet",
    "shift",
    "shiftKey",
    "shiftLeft",
    "shippingAddress",
    "shippingOption",
    "shippingType",
    "show",
    "showHelp",
    "showModal",
    "showModalDialog",
    "showModelessDialog",
    "showNotification",
    "sidebar",
    "sign",
    "signal",
    "signalingState",
    "signature",
    "silent",
    "sin",
    "singleNodeValue",
    "sinh",
    "sinkId",
    "sittingToStandingTransform",
    "size",
    "sizeToContent",
    "sizeX",
    "sizeZ",
    "sizes",
    "skewX",
    "skewXSelf",
    "skewY",
    "skewYSelf",
    "slice",
    "slope",
    "slot",
    "small",
    "smil",
    "smooth",
    "smoothingTimeConstant",
    "snapToLines",
    "snapshotItem",
    "snapshotLength",
    "some",
    "sort",
    "sortingCode",
    "source",
    "sourceBuffer",
    "sourceBuffers",
    "sourceCapabilities",
    "sourceFile",
    "sourceIndex",
    "sourceURL",
    "sources",
    "spacing",
    "span",
    "speak",
    "speakAs",
    "speaking",
    "species",
    "specified",
    "specularConstant",
    "specularExponent",
    "speechSynthesis",
    "speed",
    "speedOfSound",
    "spellcheck",
    "splice",
    "split",
    "splitText",
    "spreadMethod",
    "sqrt",
    "src",
    "srcElement",
    "srcFilter",
    "srcObject",
    "srcUrn",
    "srcdoc",
    "srclang",
    "srcset",
    "stack",
    "stackTraceLimit",
    "stacktrace",
    "stageParameters",
    "standalone",
    "standby",
    "start",
    "startContainer",
    "startE",
    "startIce",
    "startLoadTime",
    "startMessages",
    "startNotifications",
    "startOffset",
    "startRendering",
    "startSoftwareUpdate",
    "startTime",
    "startsWith",
    "state",
    "status",
    "statusCode",
    "statusMessage",
    "statusText",
    "statusbar",
    "stdDeviationX",
    "stdDeviationY",
    "stencilFunc",
    "stencilFuncSeparate",
    "stencilMask",
    "stencilMaskSeparate",
    "stencilOp",
    "stencilOpSeparate",
    "step",
    "stepDown",
    "stepMismatch",
    "stepUp",
    "sticky",
    "stitchTiles",
    "stop",
    "stop-color",
    "stop-opacity",
    "stopColor",
    "stopImmediatePropagation",
    "stopNotifications",
    "stopOpacity",
    "stopPropagation",
    "stopped",
    "storage",
    "storageArea",
    "storageName",
    "storageStatus",
    "store",
    "storeSiteSpecificTrackingException",
    "storeWebWideTrackingException",
    "stpVersion",
    "stream",
    "streams",
    "strength",
    "stretch",
    "strike",
    "stringValue",
    "stringify",
    "stroke",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke-width",
    "strokeColor",
    "strokeDasharray",
    "strokeDashoffset",
    "strokeLinecap",
    "strokeLinejoin",
    "strokeMiterlimit",
    "strokeOpacity",
    "strokeRect",
    "strokeStyle",
    "strokeText",
    "strokeWidth",
    "style",
    "styleFloat",
    "styleMap",
    "styleMedia",
    "styleSheet",
    "styleSheetSets",
    "styleSheets",
    "sub",
    "subarray",
    "subject",
    "submit",
    "submitFrame",
    "submitter",
    "subscribe",
    "substr",
    "substring",
    "substringData",
    "subtle",
    "subtree",
    "suffix",
    "suffixes",
    "summary",
    "sup",
    "supported",
    "supportedContentEncodings",
    "supportedEntryTypes",
    "supportedLocalesOf",
    "supports",
    "supportsSession",
    "surfaceScale",
    "surroundContents",
    "suspend",
    "suspendRedraw",
    "swapCache",
    "swapNode",
    "sweepFlag",
    "symbols",
    "sync",
    "sysexEnabled",
    "system",
    "systemCode",
    "systemId",
    "systemLanguage",
    "systemXDPI",
    "systemYDPI",
    "tBodies",
    "tFoot",
    "tHead",
    "tabIndex",
    "tabSize",
    "table",
    "table-layout",
    "tableLayout",
    "tableValues",
    "tag",
    "tagName",
    "tagUrn",
    "tags",
    "taintEnabled",
    "takeHeapSnapshot",
    "takePhoto",
    "takeRecords",
    "tan",
    "tangentialPressure",
    "tanh",
    "target",
    "targetElement",
    "targetRayMode",
    "targetRaySpace",
    "targetTouches",
    "targetX",
    "targetY",
    "tcpType",
    "tee",
    "tel",
    "terminate",
    "test",
    "texImage2D",
    "texImage3D",
    "texParameterf",
    "texParameteri",
    "texStorage2D",
    "texStorage3D",
    "texSubImage2D",
    "texSubImage3D",
    "text",
    "text-align",
    "text-align-last",
    "text-anchor",
    "text-combine-upright",
    "text-decoration",
    "text-decoration-color",
    "text-decoration-line",
    "text-decoration-skip-ink",
    "text-decoration-style",
    "text-decoration-thickness",
    "text-emphasis",
    "text-emphasis-color",
    "text-emphasis-position",
    "text-emphasis-style",
    "text-indent",
    "text-justify",
    "text-orientation",
    "text-overflow",
    "text-rendering",
    "text-shadow",
    "text-transform",
    "text-underline-offset",
    "text-underline-position",
    "text/pdf",
    "textAlign",
    "textAlignLast",
    "textAnchor",
    "textAutospace",
    "textBaseline",
    "textCombineUpright",
    "textContent",
    "textDecoration",
    "textDecorationBlink",
    "textDecorationColor",
    "textDecorationLine",
    "textDecorationLineThrough",
    "textDecorationNone",
    "textDecorationOverline",
    "textDecorationSkipInk",
    "textDecorationStyle",
    "textDecorationThickness",
    "textDecorationUnderline",
    "textEmphasis",
    "textEmphasisColor",
    "textEmphasisPosition",
    "textEmphasisStyle",
    "textIndent",
    "textJustify",
    "textJustifyTrim",
    "textKashida",
    "textKashidaSpace",
    "textLength",
    "textOrientation",
    "textOverflow",
    "textRendering",
    "textShadow",
    "textSizeAdjust",
    "textTracks",
    "textTransform",
    "textUnderlineOffset",
    "textUnderlinePosition",
    "then",
    "threadId",
    "threshold",
    "thresholds",
    "tiltX",
    "tiltY",
    "time",
    "timeEnd",
    "timeLog",
    "timeOrigin",
    "timeRemaining",
    "timeStamp",
    "timeZone",
    "timeZoneName",
    "timecode",
    "timeline",
    "timelineEnd",
    "timelineTime",
    "timeout",
    "timestamp",
    "timestampOffset",
    "timing",
    "title",
    "to",
    "toArray",
    "toBlob",
    "toDataURL",
    "toDateString",
    "toElement",
    "toExponential",
    "toFixed",
    "toFloat32Array",
    "toFloat64Array",
    "toGMTString",
    "toISOString",
    "toJSON",
    "toLocaleDateString",
    "toLocaleFormat",
    "toLocaleLowerCase",
    "toLocaleString",
    "toLocaleTimeString",
    "toLocaleUpperCase",
    "toLowerCase",
    "toMatrix",
    "toMethod",
    "toPrecision",
    "toPrimitive",
    "toSdp",
    "toSource",
    "toStaticHTML",
    "toString",
    "toStringTag",
    "toSum",
    "toTimeString",
    "toUTCString",
    "toUpperCase",
    "toggle",
    "toggleAttribute",
    "toggleLongPressEnabled",
    "tone",
    "toneBuffer",
    "tooLong",
    "tooShort",
    "toolbar",
    "top",
    "topMargin",
    "total",
    "totalFrameDelay",
    "totalJSHeapSize",
    "totalSize",
    "totalVideoFrames",
    "touch-action",
    "touchAction",
    "touched",
    "touches",
    "trace",
    "track",
    "trackVisibility",
    "tran",
    "transaction",
    "transactions",
    "transceiver",
    "transferControlToOffscreen",
    "transferFromImageBitmap",
    "transferImageBitmap",
    "transferIn",
    "transferOut",
    "transferSize",
    "transferToImageBitmap",
    "transform",
    "transform-box",
    "transform-origin",
    "transform-style",
    "transformBox",
    "transformFeedbackVaryings",
    "transformOrigin",
    "transformOriginX",
    "transformOriginY",
    "transformOriginZ",
    "transformPoint",
    "transformString",
    "transformStyle",
    "transformToDocument",
    "transformToFragment",
    "transition",
    "transition-delay",
    "transition-duration",
    "transition-property",
    "transition-timing-function",
    "transitionDelay",
    "transitionDuration",
    "transitionProperty",
    "transitionTimingFunction",
    "translate",
    "translateSelf",
    "translationX",
    "translationY",
    "transport",
    "trim",
    "trimEnd",
    "trimLeft",
    "trimRight",
    "trimStart",
    "trueSpeed",
    "trunc",
    "truncate",
    "trustedTypes",
    "turn",
    "twist",
    "type",
    "typeDetail",
    "typeMismatch",
    "typeMustMatch",
    "types",
    "tz",
    "u2f",
    "ubound",
    "undefined",
    "unescape",
    "uneval",
    "unicode",
    "unicode-bidi",
    "unicodeBidi",
    "unicodeRange",
    "uniform1f",
    "uniform1fv",
    "uniform1i",
    "uniform1iv",
    "uniform1ui",
    "uniform1uiv",
    "uniform2f",
    "uniform2fv",
    "uniform2i",
    "uniform2iv",
    "uniform2ui",
    "uniform2uiv",
    "uniform3f",
    "uniform3fv",
    "uniform3i",
    "uniform3iv",
    "uniform3ui",
    "uniform3uiv",
    "uniform4f",
    "uniform4fv",
    "uniform4i",
    "uniform4iv",
    "uniform4ui",
    "uniform4uiv",
    "uniformBlockBinding",
    "uniformMatrix2fv",
    "uniformMatrix2x3fv",
    "uniformMatrix2x4fv",
    "uniformMatrix3fv",
    "uniformMatrix3x2fv",
    "uniformMatrix3x4fv",
    "uniformMatrix4fv",
    "uniformMatrix4x2fv",
    "uniformMatrix4x3fv",
    "unique",
    "uniqueID",
    "uniqueNumber",
    "unit",
    "unitType",
    "units",
    "unloadEventEnd",
    "unloadEventStart",
    "unlock",
    "unmount",
    "unobserve",
    "unpause",
    "unpauseAnimations",
    "unreadCount",
    "unregister",
    "unregisterContentHandler",
    "unregisterProtocolHandler",
    "unscopables",
    "unselectable",
    "unshift",
    "unsubscribe",
    "unsuspendRedraw",
    "unsuspendRedrawAll",
    "unwatch",
    "unwrapKey",
    "upDegrees",
    "upX",
    "upY",
    "upZ",
    "update",
    "updateCommands",
    "updateEnabled",
    "updateIce",
    "updateInterval",
    "updatePlaybackRate",
    "updateRenderState",
    "updateSettings",
    "updateTiming",
    "updateViaCache",
    "updateWith",
    "updated",
    "updating",
    "upgrade",
    "upload",
    "uploadTotal",
    "uploaded",
    "upper",
    "upperBound",
    "upperOpen",
    "uri",
    "url",
    "urn",
    "urns",
    "usage",
    "usages",
    "usb",
    "usbVersionMajor",
    "usbVersionMinor",
    "usbVersionSubminor",
    "useCurrentView",
    "useGrouping",
    "useMap",
    "useProgram",
    "usedJSHeapSize",
    "usedSpace",
    "user-select",
    "userActivation",
    "userAgent",
    "userChoice",
    "userHandle",
    "userHint",
    "userLanguage",
    "userProfile",
    "userSelect",
    "userVisibleOnly",
    "userZoom",
    "username",
    "usernameFragment",
    "utterance",
    "uuid",
    "v8BreakIterator",
    "v8Parse",
    "vAlign",
    "vLink",
    "valid",
    "validate",
    "validateProgram",
    "validationMessage",
    "validity",
    "value",
    "valueAsDate",
    "valueAsNumber",
    "valueAsString",
    "valueInSpecifiedUnits",
    "valueMissing",
    "valueOf",
    "valueText",
    "valueType",
    "values",
    "variable",
    "variant",
    "vector-effect",
    "vectorEffect",
    "velocityAngular",
    "velocityExpansion",
    "velocityX",
    "velocityY",
    "vendor",
    "vendorId",
    "vendorSub",
    "verify",
    "version",
    "vertexAttrib1f",
    "vertexAttrib1fv",
    "vertexAttrib2f",
    "vertexAttrib2fv",
    "vertexAttrib3f",
    "vertexAttrib3fv",
    "vertexAttrib4f",
    "vertexAttrib4fv",
    "vertexAttribDivisor",
    "vertexAttribDivisorANGLE",
    "vertexAttribI4i",
    "vertexAttribI4iv",
    "vertexAttribI4ui",
    "vertexAttribI4uiv",
    "vertexAttribIPointer",
    "vertexAttribPointer",
    "vertical",
    "vertical-align",
    "verticalAlign",
    "verticalOverflow",
    "vh",
    "vibrate",
    "vibrationActuator",
    "video/x-ms-asf",
    "video/x-ms-asf-plugin",
    "video/x-ms-wm",
    "video/x-ms-wmv",
    "video/x-ms-wvx",
    "videoBitsPerSecond",
    "videoHeight",
    "videoTracks",
    "videoWidth",
    "view",
    "viewBox",
    "viewBoxString",
    "viewTarget",
    "viewTargetString",
    "viewport",
    "viewportAnchorX",
    "viewportAnchorY",
    "viewportElement",
    "views",
    "violatedDirective",
    "visibility",
    "visibilityState",
    "visible",
    "visualViewport",
    "vlinkColor",
    "vmax",
    "vmin",
    "voice",
    "voiceURI",
    "volume",
    "vrml",
    "vspace",
    "vw",
    "w",
    "wait",
    "waitSync",
    "waiting",
    "wake",
    "wakeLock",
    "wand",
    "warn",
    "wasAlternateProtocolAvailable",
    "wasClean",
    "wasDiscarded",
    "wasFetchedViaSpdy",
    "wasNpnNegotiated",
    "watch",
    "watchAvailability",
    "watchPosition",
    "webdriver",
    "webkitAddKey",
    "webkitAlignContent",
    "webkitAlignItems",
    "webkitAlignSelf",
    "webkitAnimation",
    "webkitAnimationDelay",
    "webkitAnimationDirection",
    "webkitAnimationDuration",
    "webkitAnimationFillMode",
    "webkitAnimationIterationCount",
    "webkitAnimationName",
    "webkitAnimationPlayState",
    "webkitAnimationTimingFunction",
    "webkitAppRegion",
    "webkitAppearance",
    "webkitAspectRatio",
    "webkitAudioContext",
    "webkitAudioDecodedByteCount",
    "webkitAudioPannerNode",
    "webkitBackdropFilter",
    "webkitBackfaceVisibility",
    "webkitBackground",
    "webkitBackgroundAttachment",
    "webkitBackgroundClip",
    "webkitBackgroundColor",
    "webkitBackgroundComposite",
    "webkitBackgroundImage",
    "webkitBackgroundOrigin",
    "webkitBackgroundPosition",
    "webkitBackgroundPositionX",
    "webkitBackgroundPositionY",
    "webkitBackgroundRepeat",
    "webkitBackgroundSize",
    "webkitBackingStorePixelRatio",
    "webkitBorderAfter",
    "webkitBorderAfterColor",
    "webkitBorderAfterStyle",
    "webkitBorderAfterWidth",
    "webkitBorderBefore",
    "webkitBorderBeforeColor",
    "webkitBorderBeforeStyle",
    "webkitBorderBeforeWidth",
    "webkitBorderBottomLeftRadius",
    "webkitBorderBottomRightRadius",
    "webkitBorderEnd",
    "webkitBorderEndColor",
    "webkitBorderEndStyle",
    "webkitBorderEndWidth",
    "webkitBorderFit",
    "webkitBorderHorizontalSpacing",
    "webkitBorderImage",
    "webkitBorderImageOutset",
    "webkitBorderImageRepeat",
    "webkitBorderImageSlice",
    "webkitBorderImageSource",
    "webkitBorderImageWidth",
    "webkitBorderRadius",
    "webkitBorderStart",
    "webkitBorderStartColor",
    "webkitBorderStartStyle",
    "webkitBorderStartWidth",
    "webkitBorderTopLeftRadius",
    "webkitBorderTopRightRadius",
    "webkitBorderVerticalSpacing",
    "webkitBoxAlign",
    "webkitBoxDecorationBreak",
    "webkitBoxDirection",
    "webkitBoxFlex",
    "webkitBoxFlexGroup",
    "webkitBoxLines",
    "webkitBoxOrdinalGroup",
    "webkitBoxOrient",
    "webkitBoxPack",
    "webkitBoxReflect",
    "webkitBoxShadow",
    "webkitBoxSizing",
    "webkitCancelAnimationFrame",
    "webkitCancelFullScreen",
    "webkitCancelKeyRequest",
    "webkitCancelRequestAnimationFrame",
    "webkitClearResourceTimings",
    "webkitClipPath",
    "webkitClosedCaptionsVisible",
    "webkitColumnAxis",
    "webkitColumnBreakAfter",
    "webkitColumnBreakBefore",
    "webkitColumnBreakInside",
    "webkitColumnCount",
    "webkitColumnGap",
    "webkitColumnProgression",
    "webkitColumnRule",
    "webkitColumnRuleColor",
    "webkitColumnRuleStyle",
    "webkitColumnRuleWidth",
    "webkitColumnSpan",
    "webkitColumnWidth",
    "webkitColumns",
    "webkitConvertPointFromNodeToPage",
    "webkitConvertPointFromPageToNode",
    "webkitCreateShadowRoot",
    "webkitCurrentFullScreenElement",
    "webkitCurrentPlaybackTargetIsWireless",
    "webkitCursorVisibility",
    "webkitDashboardRegion",
    "webkitDecodedFrameCount",
    "webkitDirectionInvertedFromDevice",
    "webkitDisplayingFullscreen",
    "webkitDroppedFrameCount",
    "webkitEnterFullScreen",
    "webkitEnterFullscreen",
    "webkitEntries",
    "webkitExitFullScreen",
    "webkitExitFullscreen",
    "webkitExitPointerLock",
    "webkitFilter",
    "webkitFlex",
    "webkitFlexBasis",
    "webkitFlexDirection",
    "webkitFlexFlow",
    "webkitFlexGrow",
    "webkitFlexShrink",
    "webkitFlexWrap",
    "webkitFontFeatureSettings",
    "webkitFontKerning",
    "webkitFontSizeDelta",
    "webkitFontSmoothing",
    "webkitForce",
    "webkitFullScreenKeyboardInputAllowed",
    "webkitFullscreenElement",
    "webkitFullscreenEnabled",
    "webkitGenerateKeyRequest",
    "webkitGetAsEntry",
    "webkitGetDatabaseNames",
    "webkitGetEntries",
    "webkitGetEntriesByName",
    "webkitGetEntriesByType",
    "webkitGetFlowByName",
    "webkitGetGamepads",
    "webkitGetImageDataHD",
    "webkitGetNamedFlows",
    "webkitGetRegionFlowRanges",
    "webkitGetUserMedia",
    "webkitHasClosedCaptions",
    "webkitHidden",
    "webkitHighlight",
    "webkitHyphenateCharacter",
    "webkitHyphenateLimitAfter",
    "webkitHyphenateLimitBefore",
    "webkitHyphenateLimitLines",
    "webkitHyphens",
    "webkitIDBCursor",
    "webkitIDBDatabase",
    "webkitIDBDatabaseError",
    "webkitIDBDatabaseException",
    "webkitIDBFactory",
    "webkitIDBIndex",
    "webkitIDBKeyRange",
    "webkitIDBObjectStore",
    "webkitIDBRequest",
    "webkitIDBTransaction",
    "webkitImageSmoothingEnabled",
    "webkitIndexedDB",
    "webkitInitMessageEvent",
    "webkitInitialLetter",
    "webkitIsFullScreen",
    "webkitJustifyContent",
    "webkitKeys",
    "webkitLineAlign",
    "webkitLineBoxContain",
    "webkitLineBreak",
    "webkitLineClamp",
    "webkitLineDash",
    "webkitLineDashOffset",
    "webkitLineGrid",
    "webkitLineSnap",
    "webkitLocale",
    "webkitLockOrientation",
    "webkitLogicalHeight",
    "webkitLogicalWidth",
    "webkitMarginAfter",
    "webkitMarginAfterCollapse",
    "webkitMarginBefore",
    "webkitMarginBeforeCollapse",
    "webkitMarginBottomCollapse",
    "webkitMarginCollapse",
    "webkitMarginEnd",
    "webkitMarginStart",
    "webkitMarginTopCollapse",
    "webkitMarquee",
    "webkitMarqueeDirection",
    "webkitMarqueeIncrement",
    "webkitMarqueeRepetition",
    "webkitMarqueeSpeed",
    "webkitMarqueeStyle",
    "webkitMask",
    "webkitMaskBoxImage",
    "webkitMaskBoxImageOutset",
    "webkitMaskBoxImageRepeat",
    "webkitMaskBoxImageSlice",
    "webkitMaskBoxImageSource",
    "webkitMaskBoxImageWidth",
    "webkitMaskClip",
    "webkitMaskComposite",
    "webkitMaskImage",
    "webkitMaskOrigin",
    "webkitMaskPosition",
    "webkitMaskPositionX",
    "webkitMaskPositionY",
    "webkitMaskRepeat",
    "webkitMaskRepeatX",
    "webkitMaskRepeatY",
    "webkitMaskSize",
    "webkitMaskSourceType",
    "webkitMatchesSelector",
    "webkitMaxLogicalHeight",
    "webkitMaxLogicalWidth",
    "webkitMediaStream",
    "webkitMinLogicalHeight",
    "webkitMinLogicalWidth",
    "webkitNbspMode",
    "webkitNotifications",
    "webkitOfflineAudioContext",
    "webkitOpacity",
    "webkitOrder",
    "webkitOrientation",
    "webkitPaddingAfter",
    "webkitPaddingBefore",
    "webkitPaddingEnd",
    "webkitPaddingStart",
    "webkitPeerConnection00",
    "webkitPersistentStorage",
    "webkitPerspective",
    "webkitPerspectiveOrigin",
    "webkitPerspectiveOriginX",
    "webkitPerspectiveOriginY",
    "webkitPointerLockElement",
    "webkitPostMessage",
    "webkitPreservesPitch",
    "webkitPrintColorAdjust",
    "webkitPutImageDataHD",
    "webkitRTCPeerConnection",
    "webkitRegionOverset",
    "webkitRelativePath",
    "webkitRequestAnimationFrame",
    "webkitRequestFileSystem",
    "webkitRequestFullScreen",
    "webkitRequestFullscreen",
    "webkitRequestPointerLock",
    "webkitResolveLocalFileSystemURL",
    "webkitRtlOrdering",
    "webkitRubyPosition",
    "webkitSetMediaKeys",
    "webkitSetResourceTimingBufferSize",
    "webkitShadowRoot",
    "webkitShapeImageThreshold",
    "webkitShapeMargin",
    "webkitShapeOutside",
    "webkitShowPlaybackTargetPicker",
    "webkitSlice",
    "webkitSpeechGrammar",
    "webkitSpeechGrammarList",
    "webkitSpeechRecognition",
    "webkitSpeechRecognitionError",
    "webkitSpeechRecognitionEvent",
    "webkitStorageInfo",
    "webkitSupportsFullscreen",
    "webkitSvgShadow",
    "webkitTapHighlightColor",
    "webkitTemporaryStorage",
    "webkitTextCombine",
    "webkitTextDecoration",
    "webkitTextDecorationColor",
    "webkitTextDecorationLine",
    "webkitTextDecorationSkip",
    "webkitTextDecorationStyle",
    "webkitTextDecorationsInEffect",
    "webkitTextEmphasis",
    "webkitTextEmphasisColor",
    "webkitTextEmphasisPosition",
    "webkitTextEmphasisStyle",
    "webkitTextFillColor",
    "webkitTextOrientation",
    "webkitTextSecurity",
    "webkitTextSizeAdjust",
    "webkitTextStroke",
    "webkitTextStrokeColor",
    "webkitTextStrokeWidth",
    "webkitTextUnderlinePosition",
    "webkitTextZoom",
    "webkitTransform",
    "webkitTransformOrigin",
    "webkitTransformOriginX",
    "webkitTransformOriginY",
    "webkitTransformOriginZ",
    "webkitTransformStyle",
    "webkitTransition",
    "webkitTransitionDelay",
    "webkitTransitionDuration",
    "webkitTransitionProperty",
    "webkitTransitionTimingFunction",
    "webkitURL",
    "webkitUnlockOrientation",
    "webkitUserDrag",
    "webkitUserModify",
    "webkitUserSelect",
    "webkitVideoDecodedByteCount",
    "webkitVisibilityState",
    "webkitWirelessVideoPlaybackDisabled",
    "webkitWritingMode",
    "webkitdirectory",
    "webkitdropzone",
    "webstore",
    "weekday",
    "weight",
    "whatToShow",
    "wheelDelta",
    "wheelDeltaX",
    "wheelDeltaY",
    "whenDefined",
    "which",
    "white-space",
    "whiteSpace",
    "wholeText",
    "widows",
    "width",
    "will-change",
    "willChange",
    "willValidate",
    "window",
    "withCredentials",
    "word-break",
    "word-spacing",
    "word-wrap",
    "wordBreak",
    "wordSpacing",
    "wordWrap",
    "workerStart",
    "wrap",
    "wrapKey",
    "writable",
    "writableAuxiliaries",
    "write",
    "writeText",
    "writeValue",
    "writeWithoutResponse",
    "writeln",
    "writing-mode",
    "writingMode",
    "x",
    "x1",
    "x2",
    "xChannelSelector",
    "xmlEncoding",
    "xmlStandalone",
    "xmlVersion",
    "xmlbase",
    "xmllang",
    "xmlspace",
    "xor",
    "xr",
    "y",
    "y1",
    "y2",
    "yChannelSelector",
    "yandex",
    "year",
    "z",
    "z-index",
    "zIndex",
    "zoom",
    "zoomAndPan",
    "zoomRectScreen"
  ];
});

// node_modules/uglify-js/tools/node.js
var require_node = __commonJS((exports) => {
  var to_comment = function(value) {
    if (typeof value != "string")
      value = JSON.stringify(value, function(key, value2) {
        return typeof value2 == "function" ? "<[ " + value2 + " ]>" : value2;
      }, 2);
    return "// " + value.replace(/\n/g, "\n// ");
  };
  var describe_ast = function() {
    var out = OutputStream({ beautify: true });
    doitem(AST_Node);
    return out.get() + "\n";
    function doitem(ctor) {
      out.print("AST_" + ctor.TYPE);
      var props = ctor.SELF_PROPS.filter(function(prop) {
        return !/^\$/.test(prop);
      });
      if (props.length > 0) {
        out.space();
        out.with_parens(function() {
          props.forEach(function(prop, i) {
            if (i)
              out.space();
            out.print(prop);
          });
        });
      }
      if (ctor.documentation) {
        out.space();
        out.print_string(ctor.documentation);
      }
      if (ctor.SUBCLASSES.length > 0) {
        out.space();
        out.with_block(function() {
          ctor.SUBCLASSES.sort(function(a, b) {
            return a.TYPE < b.TYPE ? -1 : 1;
          }).forEach(function(ctor2, i) {
            out.indent();
            doitem(ctor2);
            out.newline();
          });
        });
      }
    }
  };
  var infer_options = function(options) {
    var result = exports.minify("", options);
    return result.error && result.error.defs;
  };
  var fs = import.meta.require("fs");
  exports.FILES = [
    "/home/kilian/bun-test/node_modules/uglify-js/lib/utils.js",
    "/home/kilian/bun-test/node_modules/uglify-js/lib/ast.js",
    "/home/kilian/bun-test/node_modules/uglify-js/lib/transform.js",
    "/home/kilian/bun-test/node_modules/uglify-js/lib/parse.js",
    "/home/kilian/bun-test/node_modules/uglify-js/lib/scope.js",
    "/home/kilian/bun-test/node_modules/uglify-js/lib/compress.js",
    "/home/kilian/bun-test/node_modules/uglify-js/lib/output.js",
    "/home/kilian/bun-test/node_modules/uglify-js/lib/sourcemap.js",
    "/home/kilian/bun-test/node_modules/uglify-js/lib/mozilla-ast.js",
    "/home/kilian/bun-test/node_modules/uglify-js/lib/propmangle.js",
    "/home/kilian/bun-test/node_modules/uglify-js/lib/minify.js",
    "/home/kilian/bun-test/node_modules/uglify-js/tools/exports.js"
  ];
  new Function("domprops", "exports", function() {
    var code = exports.FILES.map(function(file) {
      return fs.readFileSync(file, "utf8");
    });
    code.push("exports.describe_ast = " + describe_ast.toString());
    return code.join("\n\n");
  }())(require_domprops(), exports);
  if (+process.env["UGLIFY_BUG_REPORT"]) {
    var $minify = function(files, options) {
      if (typeof options == "undefined")
        options = "<<undefined>>";
      var code = [
        "// UGLIFY_BUG_REPORT",
        to_comment(options)
      ];
      if (typeof files == "string") {
        code.push("");
        code.push("//-------------------------------------------------------------");
        code.push("// INPUT CODE", files);
      } else
        for (var name in files) {
          code.push("");
          code.push("//-------------------------------------------------------------");
          code.push(to_comment(name), files[name]);
        }
      if (options.sourceMap && options.sourceMap.url) {
        code.push("");
        code.push("//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiJ9");
      }
      var result = { code: code.join("\n") };
      if (options.sourceMap)
        result.map = '{"version":3,"sources":[],"names":[],"mappings":""}';
      return result;
    };

    export { $minify as minify };
  }
  exports.default_options = function() {
    var defs = infer_options({ 0: 0 });
    Object.keys(defs).forEach(function(component) {
      var options = {};
      options[component] = { 0: 0 };
      if (options = infer_options(options)) {
        defs[component] = options;
      }
    });
    return defs;
  };
});

// node_modules/html-minifier/src/htmlminifier.js
var trimWhitespace = function(str) {
  return str && str.replace(/^[ \n\r\t\f]+/, "").replace(/[ \n\r\t\f]+$/, "");
};
var collapseWhitespaceAll = function(str) {
  return str && str.replace(/[ \n\r\t\f\xA0]+/g, function(spaces) {
    return spaces === "\t" ? "\t" : spaces.replace(/(^|\xA0+)[^\xA0]+/g, "$1 ");
  });
};
var collapseWhitespace = function(str, options, trimLeft, trimRight, collapseAll) {
  var lineBreakBefore = "", lineBreakAfter = "";
  if (options.preserveLineBreaks) {
    str = str.replace(/^[ \n\r\t\f]*?[\n\r][ \n\r\t\f]*/, function() {
      lineBreakBefore = "\n";
      return "";
    }).replace(/[ \n\r\t\f]*?[\n\r][ \n\r\t\f]*$/, function() {
      lineBreakAfter = "\n";
      return "";
    });
  }
  if (trimLeft) {
    str = str.replace(/^[ \n\r\t\f\xA0]+/, function(spaces) {
      var conservative = !lineBreakBefore && options.conservativeCollapse;
      if (conservative && spaces === "\t") {
        return "\t";
      }
      return spaces.replace(/^[^\xA0]+/, "").replace(/(\xA0+)[^\xA0]+/g, "$1 ") || (conservative ? " " : "");
    });
  }
  if (trimRight) {
    str = str.replace(/[ \n\r\t\f\xA0]+$/, function(spaces) {
      var conservative = !lineBreakAfter && options.conservativeCollapse;
      if (conservative && spaces === "\t") {
        return "\t";
      }
      return spaces.replace(/[^\xA0]+(\xA0+)/g, " $1").replace(/[^\xA0]+$/, "") || (conservative ? " " : "");
    });
  }
  if (collapseAll) {
    str = collapseWhitespaceAll(str);
  }
  return lineBreakBefore + str + lineBreakAfter;
};
var collapseWhitespaceSmart = function(str, prevTag, nextTag, options) {
  var trimLeft = prevTag && !selfClosingInlineTags(prevTag);
  if (trimLeft && !options.collapseInlineTagWhitespace) {
    trimLeft = prevTag.charAt(0) === "/" ? !inlineTags(prevTag.slice(1)) : !inlineTextTags(prevTag);
  }
  var trimRight = nextTag && !selfClosingInlineTags(nextTag);
  if (trimRight && !options.collapseInlineTagWhitespace) {
    trimRight = nextTag.charAt(0) === "/" ? !inlineTextTags(nextTag.slice(1)) : !inlineTags(nextTag);
  }
  return collapseWhitespace(str, options, trimLeft, trimRight, prevTag && nextTag);
};
var isConditionalComment = function(text) {
  return /^\[if\s[^\]]+]|\[endif]$/.test(text);
};
var isIgnoredComment = function(text, options) {
  for (var i = 0, len = options.ignoreCustomComments.length;i < len; i++) {
    if (options.ignoreCustomComments[i].test(text)) {
      return true;
    }
  }
  return false;
};
var isEventAttribute = function(attrName, options) {
  var patterns = options.customEventAttributes;
  if (patterns) {
    for (var i = patterns.length;i--; ) {
      if (patterns[i].test(attrName)) {
        return true;
      }
    }
    return false;
  }
  return /^on[a-z]{3,}$/.test(attrName);
};
var canRemoveAttributeQuotes = function(value) {
  return /^[^ \t\n\f\r"'`=<>]+$/.test(value);
};
var attributesInclude = function(attributes, attribute) {
  for (var i = attributes.length;i--; ) {
    if (attributes[i].name.toLowerCase() === attribute) {
      return true;
    }
  }
  return false;
};
var isAttributeRedundant = function(tag, attrName, attrValue, attrs) {
  attrValue = attrValue ? trimWhitespace(attrValue.toLowerCase()) : "";
  return tag === "script" && attrName === "language" && attrValue === "javascript" || tag === "form" && attrName === "method" && attrValue === "get" || tag === "input" && attrName === "type" && attrValue === "text" || tag === "script" && attrName === "charset" && !attributesInclude(attrs, "src") || tag === "a" && attrName === "name" && attributesInclude(attrs, "id") || tag === "area" && attrName === "shape" && attrValue === "rect";
};
var isScriptTypeAttribute = function(attrValue) {
  attrValue = trimWhitespace(attrValue.split(/;/, 2)[0]).toLowerCase();
  return attrValue === "" || executableScriptsMimetypes(attrValue);
};
var isExecutableScript = function(tag, attrs) {
  if (tag !== "script") {
    return false;
  }
  for (var i = 0, len = attrs.length;i < len; i++) {
    var attrName = attrs[i].name.toLowerCase();
    if (attrName === "type") {
      return isScriptTypeAttribute(attrs[i].value);
    }
  }
  return true;
};
var isStyleLinkTypeAttribute = function(attrValue) {
  attrValue = trimWhitespace(attrValue).toLowerCase();
  return attrValue === "" || attrValue === "text/css";
};
var isStyleSheet = function(tag, attrs) {
  if (tag !== "style") {
    return false;
  }
  for (var i = 0, len = attrs.length;i < len; i++) {
    var attrName = attrs[i].name.toLowerCase();
    if (attrName === "type") {
      return isStyleLinkTypeAttribute(attrs[i].value);
    }
  }
  return true;
};
var isBooleanAttribute = function(attrName, attrValue) {
  return isSimpleBoolean(attrName) || attrName === "draggable" && !isBooleanValue(attrValue);
};
var isUriTypeAttribute = function(attrName, tag) {
  return /^(?:a|area|link|base)$/.test(tag) && attrName === "href" || tag === "img" && /^(?:src|longdesc|usemap)$/.test(attrName) || tag === "object" && /^(?:classid|codebase|data|usemap)$/.test(attrName) || tag === "q" && attrName === "cite" || tag === "blockquote" && attrName === "cite" || (tag === "ins" || tag === "del") && attrName === "cite" || tag === "form" && attrName === "action" || tag === "input" && (attrName === "src" || attrName === "usemap") || tag === "head" && attrName === "profile" || tag === "script" && (attrName === "src" || attrName === "for");
};
var isNumberTypeAttribute = function(attrName, tag) {
  return /^(?:a|area|object|button)$/.test(tag) && attrName === "tabindex" || tag === "input" && (attrName === "maxlength" || attrName === "tabindex") || tag === "select" && (attrName === "size" || attrName === "tabindex") || tag === "textarea" && /^(?:rows|cols|tabindex)$/.test(attrName) || tag === "colgroup" && attrName === "span" || tag === "col" && attrName === "span" || (tag === "th" || tag === "td") && (attrName === "rowspan" || attrName === "colspan");
};
var isLinkType = function(tag, attrs, value) {
  if (tag !== "link") {
    return false;
  }
  for (var i = 0, len = attrs.length;i < len; i++) {
    if (attrs[i].name === "rel" && attrs[i].value === value) {
      return true;
    }
  }
};
var isMediaQuery = function(tag, attrs, attrName) {
  return attrName === "media" && (isLinkType(tag, attrs, "stylesheet") || isStyleSheet(tag, attrs));
};
var isSrcset = function(attrName, tag) {
  return attrName === "srcset" && srcsetTags(tag);
};
var cleanAttributeValue = function(tag, attrName, attrValue, options, attrs) {
  if (isEventAttribute(attrName, options)) {
    attrValue = trimWhitespace(attrValue).replace(/^javascript:\s*/i, "");
    return options.minifyJS(attrValue, true);
  } else if (attrName === "class") {
    attrValue = trimWhitespace(attrValue);
    if (options.sortClassName) {
      attrValue = options.sortClassName(attrValue);
    } else {
      attrValue = collapseWhitespaceAll(attrValue);
    }
    return attrValue;
  } else if (isUriTypeAttribute(attrName, tag)) {
    attrValue = trimWhitespace(attrValue);
    return isLinkType(tag, attrs, "canonical") ? attrValue : options.minifyURLs(attrValue);
  } else if (isNumberTypeAttribute(attrName, tag)) {
    return trimWhitespace(attrValue);
  } else if (attrName === "style") {
    attrValue = trimWhitespace(attrValue);
    if (attrValue) {
      if (/;$/.test(attrValue) && !/&#?[0-9a-zA-Z]+;$/.test(attrValue)) {
        attrValue = attrValue.replace(/\s*;$/, ";");
      }
      attrValue = options.minifyCSS(attrValue, "inline");
    }
    return attrValue;
  } else if (isSrcset(attrName, tag)) {
    attrValue = trimWhitespace(attrValue).split(/\s+,\s*|\s*,\s+/).map(function(candidate) {
      var url = candidate;
      var descriptor = "";
      var match = candidate.match(/\s+([1-9][0-9]*w|[0-9]+(?:\.[0-9]+)?x)$/);
      if (match) {
        url = url.slice(0, -match[0].length);
        var num = +match[1].slice(0, -1);
        var suffix = match[1].slice(-1);
        if (num !== 1 || suffix !== "x") {
          descriptor = " " + num + suffix;
        }
      }
      return options.minifyURLs(url) + descriptor;
    }).join(", ");
  } else if (isMetaViewport(tag, attrs) && attrName === "content") {
    attrValue = attrValue.replace(/\s+/g, "").replace(/[0-9]+\.[0-9]+/g, function(numString) {
      return (+numString).toString();
    });
  } else if (isContentSecurityPolicy(tag, attrs) && attrName.toLowerCase() === "content") {
    return collapseWhitespaceAll(attrValue);
  } else if (options.customAttrCollapse && options.customAttrCollapse.test(attrName)) {
    attrValue = attrValue.replace(/\n+|\r+|\s{2,}/g, "");
  } else if (tag === "script" && attrName === "type") {
    attrValue = trimWhitespace(attrValue.replace(/\s*;\s*/g, ";"));
  } else if (isMediaQuery(tag, attrs, attrName)) {
    attrValue = trimWhitespace(attrValue);
    return options.minifyCSS(attrValue, "media");
  }
  return attrValue;
};
var isMetaViewport = function(tag, attrs) {
  if (tag !== "meta") {
    return false;
  }
  for (var i = 0, len = attrs.length;i < len; i++) {
    if (attrs[i].name === "name" && attrs[i].value === "viewport") {
      return true;
    }
  }
};
var isContentSecurityPolicy = function(tag, attrs) {
  if (tag !== "meta") {
    return false;
  }
  for (var i = 0, len = attrs.length;i < len; i++) {
    if (attrs[i].name.toLowerCase() === "http-equiv" && attrs[i].value.toLowerCase() === "content-security-policy") {
      return true;
    }
  }
};
var ignoreCSS = function(id) {
  return "/* clean-css ignore:start */" + id + "/* clean-css ignore:end */";
};
var wrapCSS = function(text, type) {
  switch (type) {
    case "inline":
      return "*{" + text + "}";
    case "media":
      return "@media " + text + "{a{top:0}}";
    default:
      return text;
  }
};
var unwrapCSS = function(text, type) {
  var matches;
  switch (type) {
    case "inline":
      matches = text.match(/^\*\{([\s\S]*)\}$/);
      break;
    case "media":
      matches = text.match(/^@media ([\s\S]*?)\s*{[\s\S]*}$/);
      break;
  }
  return matches ? matches[1] : text;
};
var cleanConditionalComment = function(comment, options) {
  return options.processConditionalComments ? comment.replace(/^(\[if\s[^\]]+]>)([\s\S]*?)(<!\[endif])$/, function(match, prefix, text, suffix) {
    return prefix + minify2(text, options, true) + suffix;
  }) : comment;
};
var processScript = function(text, options, currentAttrs) {
  for (var i = 0, len = currentAttrs.length;i < len; i++) {
    if (currentAttrs[i].name.toLowerCase() === "type" && options.processScripts.indexOf(currentAttrs[i].value) > -1) {
      return minify2(text, options);
    }
  }
  return text;
};
var canRemoveParentTag = function(optionalStartTag, tag) {
  switch (optionalStartTag) {
    case "html":
    case "head":
      return true;
    case "body":
      return !headerTags(tag);
    case "colgroup":
      return tag === "col";
    case "tbody":
      return tag === "tr";
  }
  return false;
};
var isStartTagMandatory = function(optionalEndTag, tag) {
  switch (tag) {
    case "colgroup":
      return optionalEndTag === "colgroup";
    case "tbody":
      return tableSectionTags(optionalEndTag);
  }
  return false;
};
var canRemovePrecedingTag = function(optionalEndTag, tag) {
  switch (optionalEndTag) {
    case "html":
    case "head":
    case "body":
    case "colgroup":
    case "caption":
      return true;
    case "li":
    case "optgroup":
    case "tr":
      return tag === optionalEndTag;
    case "dt":
    case "dd":
      return descriptionTags(tag);
    case "p":
      return pBlockTags(tag);
    case "rb":
    case "rt":
    case "rp":
      return rubyTags(tag);
    case "rtc":
      return rtcTag(tag);
    case "option":
      return optionTag(tag);
    case "thead":
    case "tbody":
      return tableContentTags(tag);
    case "tfoot":
      return tag === "tbody";
    case "td":
    case "th":
      return cellTags(tag);
  }
  return false;
};
var canDeleteEmptyAttribute = function(tag, attrName, attrValue, options) {
  var isValueEmpty = !attrValue || /^\s*$/.test(attrValue);
  if (!isValueEmpty) {
    return false;
  }
  if (typeof options.removeEmptyAttributes === "function") {
    return options.removeEmptyAttributes(attrName, tag);
  }
  return tag === "input" && attrName === "value" || reEmptyAttribute.test(attrName);
};
var hasAttrName = function(name, attrs) {
  for (var i = attrs.length - 1;i >= 0; i--) {
    if (attrs[i].name === name) {
      return true;
    }
  }
  return false;
};
var canRemoveElement = function(tag, attrs) {
  switch (tag) {
    case "textarea":
      return false;
    case "audio":
    case "script":
    case "video":
      if (hasAttrName("src", attrs)) {
        return false;
      }
      break;
    case "iframe":
      if (hasAttrName("src", attrs) || hasAttrName("srcdoc", attrs)) {
        return false;
      }
      break;
    case "object":
      if (hasAttrName("data", attrs)) {
        return false;
      }
      break;
    case "applet":
      if (hasAttrName("code", attrs)) {
        return false;
      }
      break;
  }
  return true;
};
var canCollapseWhitespace = function(tag) {
  return !/^(?:script|style|pre|textarea)$/.test(tag);
};
var canTrimWhitespace = function(tag) {
  return !/^(?:pre|textarea)$/.test(tag);
};
var normalizeAttr = function(attr, attrs, tag, options) {
  var attrName = options.name(attr.name), attrValue = attr.value;
  if (options.decodeEntities && attrValue) {
    attrValue = decode(attrValue, { isAttributeValue: true });
  }
  if (options.removeRedundantAttributes && isAttributeRedundant(tag, attrName, attrValue, attrs) || options.removeScriptTypeAttributes && tag === "script" && attrName === "type" && isScriptTypeAttribute(attrValue) || options.removeStyleLinkTypeAttributes && (tag === "style" || tag === "link") && attrName === "type" && isStyleLinkTypeAttribute(attrValue)) {
    return;
  }
  if (attrValue) {
    attrValue = cleanAttributeValue(tag, attrName, attrValue, options, attrs);
  }
  if (options.removeEmptyAttributes && canDeleteEmptyAttribute(tag, attrName, attrValue, options)) {
    return;
  }
  if (options.decodeEntities && attrValue) {
    attrValue = attrValue.replace(/&(#?[0-9a-zA-Z]+;)/g, "&amp;$1");
  }
  return {
    attr,
    name: attrName,
    value: attrValue
  };
};
var buildAttr = function(normalized, hasUnarySlash, options, isLast, uidAttr) {
  var { name: attrName, value: attrValue, attr } = normalized, attrQuote = attr.quote, attrFragment, emittedAttrValue;
  if (typeof attrValue !== "undefined" && (!options.removeAttributeQuotes || ~attrValue.indexOf(uidAttr) || !canRemoveAttributeQuotes(attrValue))) {
    if (!options.preventAttributesEscaping) {
      if (typeof options.quoteCharacter === "undefined") {
        var apos = (attrValue.match(/'/g) || []).length;
        var quot = (attrValue.match(/"/g) || []).length;
        attrQuote = apos < quot ? "\'" : '"';
      } else {
        attrQuote = options.quoteCharacter === "\'" ? "\'" : '"';
      }
      if (attrQuote === '"') {
        attrValue = attrValue.replace(/"/g, "&#34;");
      } else {
        attrValue = attrValue.replace(/'/g, "&#39;");
      }
    }
    emittedAttrValue = attrQuote + attrValue + attrQuote;
    if (!isLast && !options.removeTagWhitespace) {
      emittedAttrValue += " ";
    }
  } else if (isLast && !hasUnarySlash && !/\/$/.test(attrValue)) {
    emittedAttrValue = attrValue;
  } else {
    emittedAttrValue = attrValue + " ";
  }
  if (typeof attrValue === "undefined" || options.collapseBooleanAttributes && isBooleanAttribute(attrName.toLowerCase(), attrValue.toLowerCase())) {
    attrFragment = attrName;
    if (!isLast) {
      attrFragment += " ";
    }
  } else {
    attrFragment = attrName + attr.customAssign + emittedAttrValue;
  }
  return attr.customOpen + attrFragment + attr.customClose;
};
var identity = function(value) {
  return value;
};
var processOptions = function(values) {
  var options = {
    name: function(name) {
      return name.toLowerCase();
    },
    canCollapseWhitespace,
    canTrimWhitespace,
    html5: true,
    ignoreCustomComments: [/^!/],
    ignoreCustomFragments: [
      /<%[\s\S]*?%>/,
      /<\?[\s\S]*?\?>/
    ],
    includeAutoGeneratedTags: true,
    log: identity,
    minifyCSS: identity,
    minifyJS: identity,
    minifyURLs: identity
  };
  Object.keys(values).forEach(function(key) {
    var value = values[key];
    if (key === "caseSensitive") {
      if (value) {
        options.name = identity;
      }
    } else if (key === "log") {
      if (typeof value === "function") {
        options.log = value;
      }
    } else if (key === "minifyCSS" && typeof value !== "function") {
      if (!value) {
        return;
      }
      if (typeof value !== "object") {
        value = {};
      }
      options.minifyCSS = function(text, type) {
        text = text.replace(/(url\s*\(\s*)("|'|)(.*?)\2(\s*\))/ig, function(match, prefix, quote, url, suffix) {
          return prefix + quote + options.minifyURLs(url) + quote + suffix;
        });
        var cleanCssOutput = new CleanCSS(value).minify(wrapCSS(text, type));
        if (cleanCssOutput.errors.length > 0) {
          cleanCssOutput.errors.forEach(options.log);
          return text;
        }
        return unwrapCSS(cleanCssOutput.styles, type);
      };
    } else if (key === "minifyJS" && typeof value !== "function") {
      if (!value) {
        return;
      }
      if (typeof value !== "object") {
        value = {};
      }
      (value.parse || (value.parse = {})).bare_returns = false;
      options.minifyJS = function(text, inline) {
        var start = text.match(/^\s*<!--.*/);
        var code = start ? text.slice(start[0].length).replace(/\n\s*-->\s*$/, "") : text;
        value.parse.bare_returns = inline;
        var result = UglifyJS.minify(code, value);
        if (result.error) {
          options.log(result.error);
          return text;
        }
        return result.code.replace(/;$/, "");
      };
    } else if (key === "minifyURLs" && typeof value !== "function") {
      if (!value) {
        return;
      }
      if (typeof value === "string") {
        value = { site: value };
      } else if (typeof value !== "object") {
        value = {};
      }
      options.minifyURLs = function(text) {
        try {
          return RelateUrl.relate(text, value);
        } catch (err) {
          options.log(err);
          return text;
        }
      };
    } else {
      options[key] = value;
    }
  });
  return options;
};
var uniqueId = function(value) {
  var id;
  do {
    id = Math.random().toString(36).replace(/^0\.[0-9]*/, "");
  } while (~value.indexOf(id));
  return id;
};
var createSortFns = function(value, options, uidIgnore, uidAttr) {
  var attrChains = options.sortAttributes && Object.create(null);
  var classChain = options.sortClassName && new TokenChain;
  function attrNames(attrs) {
    return attrs.map(function(attr) {
      return options.name(attr.name);
    });
  }
  function shouldSkipUID(token, uid) {
    return !uid || token.indexOf(uid) === -1;
  }
  function shouldSkipUIDs(token) {
    return shouldSkipUID(token, uidIgnore) && shouldSkipUID(token, uidAttr);
  }
  function scan(input) {
    var currentTag, currentType;
    new HTMLParser(input, {
      start: function(tag2, attrs) {
        if (attrChains) {
          if (!attrChains[tag2]) {
            attrChains[tag2] = new TokenChain;
          }
          attrChains[tag2].add(attrNames(attrs).filter(shouldSkipUIDs));
        }
        for (var i = 0, len = attrs.length;i < len; i++) {
          var attr = attrs[i];
          if (classChain && attr.value && options.name(attr.name) === "class") {
            classChain.add(trimWhitespace(attr.value).split(/[ \t\n\f\r]+/).filter(shouldSkipUIDs));
          } else if (options.processScripts && attr.name.toLowerCase() === "type") {
            currentTag = tag2;
            currentType = attr.value;
          }
        }
      },
      end: function() {
        currentTag = "";
      },
      chars: function(text) {
        if (options.processScripts && specialContentTags(currentTag) && options.processScripts.indexOf(currentType) > -1) {
          scan(text);
        }
      }
    });
  }
  var log = options.log;
  options.log = identity;
  options.sortAttributes = false;
  options.sortClassName = false;
  scan(minify2(value, options));
  options.log = log;
  if (attrChains) {
    var attrSorters = Object.create(null);
    for (var tag in attrChains) {
      attrSorters[tag] = attrChains[tag].createSorter();
    }
    options.sortAttributes = function(tag2, attrs) {
      var sorter2 = attrSorters[tag2];
      if (sorter2) {
        var attrMap = Object.create(null);
        var names = attrNames(attrs);
        names.forEach(function(name, index) {
          (attrMap[name] || (attrMap[name] = [])).push(attrs[index]);
        });
        sorter2.sort(names).forEach(function(name, index) {
          attrs[index] = attrMap[name].shift();
        });
      }
    };
  }
  if (classChain) {
    var sorter = classChain.createSorter();
    options.sortClassName = function(value2) {
      return sorter.sort(value2.split(/[ \n\f\r]+/)).join(" ");
    };
  }
};
var minify2 = function(value, options, partialMarkup) {
  if (options.collapseWhitespace) {
    value = collapseWhitespace(value, options, true, true);
  }
  var buffer = [], charsPrevTag, currentChars = "", hasChars, currentTag = "", currentAttrs = [], stackNoTrimWhitespace = [], stackNoCollapseWhitespace = [], optionalStartTag = "", optionalEndTag = "", ignoredMarkupChunks = [], ignoredCustomMarkupChunks = [], uidIgnore, uidAttr, uidPattern;
  value = value.replace(/<!-- htmlmin:ignore -->([\s\S]*?)<!-- htmlmin:ignore -->/g, function(match, group1) {
    if (!uidIgnore) {
      uidIgnore = uniqueId(value);
      var pattern = new RegExp("^" + uidIgnore + "([0-9]+)$");
      if (options.ignoreCustomComments) {
        options.ignoreCustomComments = options.ignoreCustomComments.slice();
      } else {
        options.ignoreCustomComments = [];
      }
      options.ignoreCustomComments.push(pattern);
    }
    var token = "<!--" + uidIgnore + ignoredMarkupChunks.length + "-->";
    ignoredMarkupChunks.push(group1);
    return token;
  });
  var customFragments = options.ignoreCustomFragments.map(function(re) {
    return re.source;
  });
  if (customFragments.length) {
    var reCustomIgnore = new RegExp("\\s*(?:" + customFragments.join("|") + ")+\\s*", "g");
    value = value.replace(reCustomIgnore, function(match) {
      if (!uidAttr) {
        uidAttr = uniqueId(value);
        uidPattern = new RegExp("(\\s*)" + uidAttr + "([0-9]+)" + uidAttr + "(\\s*)", "g");
        if (options.minifyCSS) {
          options.minifyCSS = function(fn) {
            return function(text, type) {
              text = text.replace(uidPattern, function(match2, prefix, index) {
                var chunks = ignoredCustomMarkupChunks[+index];
                return chunks[1] + uidAttr + index + uidAttr + chunks[2];
              });
              var ids = [];
              new CleanCSS().minify(wrapCSS(text, type)).warnings.forEach(function(warning) {
                var match2 = uidPattern.exec(warning);
                if (match2) {
                  var id = uidAttr + match2[2] + uidAttr;
                  text = text.replace(id, ignoreCSS(id));
                  ids.push(id);
                }
              });
              text = fn(text, type);
              ids.forEach(function(id) {
                text = text.replace(ignoreCSS(id), id);
              });
              return text;
            };
          }(options.minifyCSS);
        }
        if (options.minifyJS) {
          options.minifyJS = function(fn) {
            return function(text, type) {
              return fn(text.replace(uidPattern, function(match2, prefix, index) {
                var chunks = ignoredCustomMarkupChunks[+index];
                return chunks[1] + uidAttr + index + uidAttr + chunks[2];
              }), type);
            };
          }(options.minifyJS);
        }
      }
      var token = uidAttr + ignoredCustomMarkupChunks.length + uidAttr;
      ignoredCustomMarkupChunks.push(/^(\s*)[\s\S]*?(\s*)$/.exec(match));
      return "\t" + token + "\t";
    });
  }
  if (options.sortAttributes && typeof options.sortAttributes !== "function" || options.sortClassName && typeof options.sortClassName !== "function") {
    createSortFns(value, options, uidIgnore, uidAttr);
  }
  function _canCollapseWhitespace(tag, attrs) {
    return options.canCollapseWhitespace(tag, attrs, canCollapseWhitespace);
  }
  function _canTrimWhitespace(tag, attrs) {
    return options.canTrimWhitespace(tag, attrs, canTrimWhitespace);
  }
  function removeStartTag() {
    var index = buffer.length - 1;
    while (index > 0 && !/^<[^/!]/.test(buffer[index])) {
      index--;
    }
    buffer.length = Math.max(0, index);
  }
  function removeEndTag() {
    var index = buffer.length - 1;
    while (index > 0 && !/^<\//.test(buffer[index])) {
      index--;
    }
    buffer.length = Math.max(0, index);
  }
  function trimTrailingWhitespace(index, nextTag) {
    for (var endTag = null;index >= 0 && _canTrimWhitespace(endTag); index--) {
      var str = buffer[index];
      var match = str.match(/^<\/([\w:-]+)>$/);
      if (match) {
        endTag = match[1];
      } else if (/>$/.test(str) || (buffer[index] = collapseWhitespaceSmart(str, null, nextTag, options))) {
        break;
      }
    }
  }
  function squashTrailingWhitespace(nextTag) {
    var charsIndex = buffer.length - 1;
    if (buffer.length > 1) {
      var item = buffer[buffer.length - 1];
      if (/^(?:<!|$)/.test(item) && item.indexOf(uidIgnore) === -1) {
        charsIndex--;
      }
    }
    trimTrailingWhitespace(charsIndex, nextTag);
  }
  new HTMLParser(value, {
    partialMarkup,
    continueOnParseError: options.continueOnParseError,
    customAttrAssign: options.customAttrAssign,
    customAttrSurround: options.customAttrSurround,
    html5: options.html5,
    start: function(tag, attrs, unary, unarySlash, autoGenerated) {
      if (tag.toLowerCase() === "svg") {
        options = Object.create(options);
        options.caseSensitive = true;
        options.keepClosingSlash = true;
        options.name = identity;
      }
      tag = options.name(tag);
      currentTag = tag;
      charsPrevTag = tag;
      if (!inlineTextTags(tag)) {
        currentChars = "";
      }
      hasChars = false;
      currentAttrs = attrs;
      var optional = options.removeOptionalTags;
      if (optional) {
        var htmlTag = htmlTags(tag);
        if (htmlTag && canRemoveParentTag(optionalStartTag, tag)) {
          removeStartTag();
        }
        optionalStartTag = "";
        if (htmlTag && canRemovePrecedingTag(optionalEndTag, tag)) {
          removeEndTag();
          optional = !isStartTagMandatory(optionalEndTag, tag);
        }
        optionalEndTag = "";
      }
      if (options.collapseWhitespace) {
        if (!stackNoTrimWhitespace.length) {
          squashTrailingWhitespace(tag);
        }
        if (!unary) {
          if (!_canTrimWhitespace(tag, attrs) || stackNoTrimWhitespace.length) {
            stackNoTrimWhitespace.push(tag);
          }
          if (!_canCollapseWhitespace(tag, attrs) || stackNoCollapseWhitespace.length) {
            stackNoCollapseWhitespace.push(tag);
          }
        }
      }
      var openTag = "<" + tag;
      var hasUnarySlash = unarySlash && options.keepClosingSlash;
      buffer.push(openTag);
      if (options.sortAttributes) {
        options.sortAttributes(tag, attrs);
      }
      var parts = [];
      for (var i = attrs.length, isLast = true;--i >= 0; ) {
        var normalized = normalizeAttr(attrs[i], attrs, tag, options);
        if (normalized) {
          parts.unshift(buildAttr(normalized, hasUnarySlash, options, isLast, uidAttr));
          isLast = false;
        }
      }
      if (parts.length > 0) {
        buffer.push(" ");
        buffer.push.apply(buffer, parts);
      } else if (optional && optionalStartTags(tag)) {
        optionalStartTag = tag;
      }
      buffer.push(buffer.pop() + (hasUnarySlash ? "/" : "") + ">");
      if (autoGenerated && !options.includeAutoGeneratedTags) {
        removeStartTag();
        optionalStartTag = "";
      }
    },
    end: function(tag, attrs, autoGenerated) {
      if (tag.toLowerCase() === "svg") {
        options = Object.getPrototypeOf(options);
      }
      tag = options.name(tag);
      if (options.collapseWhitespace) {
        if (stackNoTrimWhitespace.length) {
          if (tag === stackNoTrimWhitespace[stackNoTrimWhitespace.length - 1]) {
            stackNoTrimWhitespace.pop();
          }
        } else {
          squashTrailingWhitespace("/" + tag);
        }
        if (stackNoCollapseWhitespace.length && tag === stackNoCollapseWhitespace[stackNoCollapseWhitespace.length - 1]) {
          stackNoCollapseWhitespace.pop();
        }
      }
      var isElementEmpty = false;
      if (tag === currentTag) {
        currentTag = "";
        isElementEmpty = !hasChars;
      }
      if (options.removeOptionalTags) {
        if (isElementEmpty && topLevelTags(optionalStartTag)) {
          removeStartTag();
        }
        optionalStartTag = "";
        if (htmlTags(tag) && optionalEndTag && !trailingTags(optionalEndTag) && (optionalEndTag !== "p" || !pInlineTags(tag))) {
          removeEndTag();
        }
        optionalEndTag = optionalEndTags(tag) ? tag : "";
      }
      if (options.removeEmptyElements && isElementEmpty && canRemoveElement(tag, attrs)) {
        removeStartTag();
        optionalStartTag = "";
        optionalEndTag = "";
      } else {
        if (autoGenerated && !options.includeAutoGeneratedTags) {
          optionalEndTag = "";
        } else {
          buffer.push("</" + tag + ">");
        }
        charsPrevTag = "/" + tag;
        if (!inlineTags(tag)) {
          currentChars = "";
        } else if (isElementEmpty) {
          currentChars += "|";
        }
      }
    },
    chars: function(text, prevTag, nextTag) {
      prevTag = prevTag === "" ? "comment" : prevTag;
      nextTag = nextTag === "" ? "comment" : nextTag;
      if (options.decodeEntities && text && !specialContentTags(currentTag)) {
        text = decode(text);
      }
      if (options.collapseWhitespace) {
        if (!stackNoTrimWhitespace.length) {
          if (prevTag === "comment") {
            var prevComment = buffer[buffer.length - 1];
            if (prevComment.indexOf(uidIgnore) === -1) {
              if (!prevComment) {
                prevTag = charsPrevTag;
              }
              if (buffer.length > 1 && (!prevComment || !options.conservativeCollapse && / $/.test(currentChars))) {
                var charsIndex = buffer.length - 2;
                buffer[charsIndex] = buffer[charsIndex].replace(/\s+$/, function(trailingSpaces) {
                  text = trailingSpaces + text;
                  return "";
                });
              }
            }
          }
          if (prevTag) {
            if (prevTag === "/nobr" || prevTag === "wbr") {
              if (/^\s/.test(text)) {
                var tagIndex = buffer.length - 1;
                while (tagIndex > 0 && buffer[tagIndex].lastIndexOf("<" + prevTag) !== 0) {
                  tagIndex--;
                }
                trimTrailingWhitespace(tagIndex - 1, "br");
              }
            } else if (inlineTextTags(prevTag.charAt(0) === "/" ? prevTag.slice(1) : prevTag)) {
              text = collapseWhitespace(text, options, /(?:^|\s)$/.test(currentChars));
            }
          }
          if (prevTag || nextTag) {
            text = collapseWhitespaceSmart(text, prevTag, nextTag, options);
          } else {
            text = collapseWhitespace(text, options, true, true);
          }
          if (!text && /\s$/.test(currentChars) && prevTag && prevTag.charAt(0) === "/") {
            trimTrailingWhitespace(buffer.length - 1, nextTag);
          }
        }
        if (!stackNoCollapseWhitespace.length && nextTag !== "html" && !(prevTag && nextTag)) {
          text = collapseWhitespace(text, options, false, false, true);
        }
      }
      if (options.processScripts && specialContentTags(currentTag)) {
        text = processScript(text, options, currentAttrs);
      }
      if (isExecutableScript(currentTag, currentAttrs)) {
        text = options.minifyJS(text);
      }
      if (isStyleSheet(currentTag, currentAttrs)) {
        text = options.minifyCSS(text);
      }
      if (options.removeOptionalTags && text) {
        if (optionalStartTag === "html" || optionalStartTag === "body" && !/^\s/.test(text)) {
          removeStartTag();
        }
        optionalStartTag = "";
        if (compactTags(optionalEndTag) || looseTags(optionalEndTag) && !/^\s/.test(text)) {
          removeEndTag();
        }
        optionalEndTag = "";
      }
      charsPrevTag = /^\s*$/.test(text) ? prevTag : "comment";
      if (options.decodeEntities && text && !specialContentTags(currentTag)) {
        text = text.replace(/&((?:Iacute|aacute|uacute|plusmn|Otilde|otilde|agrave|Agrave|Yacute|yacute|Oslash|oslash|atilde|Atilde|brvbar|ccedil|Ccedil|Ograve|curren|divide|eacute|Eacute|ograve|Oacute|egrave|Egrave|Ugrave|frac12|frac14|frac34|ugrave|oacute|iacute|Ntilde|ntilde|Uacute|middot|igrave|Igrave|iquest|Aacute|cedil|laquo|micro|iexcl|Icirc|icirc|acirc|Ucirc|Ecirc|ocirc|Ocirc|ecirc|ucirc|Aring|aring|AElig|aelig|acute|pound|raquo|Acirc|times|THORN|szlig|thorn|COPY|auml|ordf|ordm|Uuml|macr|uuml|Auml|ouml|Ouml|para|nbsp|euml|quot|QUOT|Euml|yuml|cent|sect|copy|sup1|sup2|sup3|iuml|Iuml|ETH|shy|reg|not|yen|amp|AMP|REG|uml|eth|deg|gt|GT|LT|lt)(?!;)|(?:#?[0-9a-zA-Z]+;))/g, "&amp$1").replace(/</g, "&lt;");
      }
      if (uidPattern && options.collapseWhitespace && stackNoTrimWhitespace.length) {
        text = text.replace(uidPattern, function(match, prefix, index) {
          return ignoredCustomMarkupChunks[+index][0];
        });
      }
      currentChars += text;
      if (text) {
        hasChars = true;
      }
      buffer.push(text);
    },
    comment: function(text, nonStandard) {
      var prefix = nonStandard ? "<!" : "<!--";
      var suffix = nonStandard ? ">" : "-->";
      if (isConditionalComment(text)) {
        text = prefix + cleanConditionalComment(text, options) + suffix;
      } else if (options.removeComments) {
        if (isIgnoredComment(text, options)) {
          text = "<!--" + text + "-->";
        } else {
          text = "";
        }
      } else {
        text = prefix + text + suffix;
      }
      if (options.removeOptionalTags && text) {
        optionalStartTag = "";
        optionalEndTag = "";
      }
      buffer.push(text);
    },
    doctype: function(doctype) {
      buffer.push(options.useShortDoctype ? "<!doctype" + (options.removeTagWhitespace ? "" : " ") + "html>" : collapseWhitespaceAll(doctype));
    }
  });
  if (options.removeOptionalTags) {
    if (topLevelTags(optionalStartTag)) {
      removeStartTag();
    }
    if (optionalEndTag && !trailingTags(optionalEndTag)) {
      removeEndTag();
    }
  }
  if (options.collapseWhitespace) {
    squashTrailingWhitespace("br");
  }
  return joinResultSegments(buffer, options, uidPattern ? function(str) {
    return str.replace(uidPattern, function(match, prefix, index, suffix) {
      var chunk = ignoredCustomMarkupChunks[+index][0];
      if (options.collapseWhitespace) {
        if (prefix !== "\t") {
          chunk = prefix + chunk;
        }
        if (suffix !== "\t") {
          chunk += suffix;
        }
        return collapseWhitespace(chunk, {
          preserveLineBreaks: options.preserveLineBreaks,
          conservativeCollapse: !options.trimCustomFragments
        }, /^[ \n\r\t\f]/.test(chunk), /[ \n\r\t\f]$/.test(chunk));
      }
      return chunk;
    });
  } : identity, uidIgnore ? function(str) {
    return str.replace(new RegExp("<!--" + uidIgnore + "([0-9]+)-->", "g"), function(match, index) {
      return ignoredMarkupChunks[+index];
    });
  } : identity);
};
var joinResultSegments = function(results, options, restoreCustom, restoreIgnore) {
  var str;
  var maxLineLength = options.maxLineLength;
  if (maxLineLength) {
    var line = "", lines = [];
    while (results.length) {
      var len = line.length;
      var end = results[0].indexOf("\n");
      if (end < 0) {
        line += restoreIgnore(restoreCustom(results.shift()));
      } else {
        line += restoreIgnore(restoreCustom(results[0].slice(0, end)));
        results[0] = results[0].slice(end + 1);
      }
      if (len > 0 && line.length > maxLineLength) {
        lines.push(line.slice(0, len));
        line = line.slice(len);
      } else if (end >= 0) {
        lines.push(line);
        line = "";
      }
    }
    if (line) {
      lines.push(line);
    }
    str = lines.join("\n");
  } else {
    str = restoreIgnore(restoreCustom(results.join("")));
  }
  return options.collapseWhitespace ? collapseWhitespace(str, options, true, true) : str;
};
var CleanCSS = require_clean();
var decode = require_he().decode;
var HTMLParser = require_htmlparser().HTMLParser;
var RelateUrl = require_lib();
var TokenChain = require_tokenchain();
var UglifyJS = require_node();
var utils = require_utils();
var createMapFromString = utils.createMapFromString;
var inlineTags = createMapFromString("a,abbr,acronym,b,bdi,bdo,big,button,cite,code,del,dfn,em,font,i,ins,kbd,label,mark,math,nobr,object,q,rp,rt,rtc,ruby,s,samp,select,small,span,strike,strong,sub,sup,svg,textarea,time,tt,u,var");
var inlineTextTags = createMapFromString("a,abbr,acronym,b,big,del,em,font,i,ins,kbd,mark,nobr,rp,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var");
var selfClosingInlineTags = createMapFromString("comment,img,input,wbr");
var executableScriptsMimetypes = utils.createMap([
  "text/javascript",
  "text/ecmascript",
  "text/jscript",
  "application/javascript",
  "application/x-javascript",
  "application/ecmascript"
]);
var isSimpleBoolean = createMapFromString("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible");
var isBooleanValue = createMapFromString("true,false");
var srcsetTags = createMapFromString("img,source");
var optionalStartTags = createMapFromString("html,head,body,colgroup,tbody");
var optionalEndTags = createMapFromString("html,head,body,li,dt,dd,p,rb,rt,rtc,rp,optgroup,option,colgroup,caption,thead,tbody,tfoot,tr,td,th");
var headerTags = createMapFromString("meta,link,script,style,template,noscript");
var descriptionTags = createMapFromString("dt,dd");
var pBlockTags = createMapFromString("address,article,aside,blockquote,details,div,dl,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,hr,main,menu,nav,ol,p,pre,section,table,ul");
var pInlineTags = createMapFromString("a,audio,del,ins,map,noscript,video");
var rubyTags = createMapFromString("rb,rt,rtc,rp");
var rtcTag = createMapFromString("rb,rtc,rp");
var optionTag = createMapFromString("option,optgroup");
var tableContentTags = createMapFromString("tbody,tfoot");
var tableSectionTags = createMapFromString("thead,tbody,tfoot");
var cellTags = createMapFromString("td,th");
var topLevelTags = createMapFromString("html,head,body");
var compactTags = createMapFromString("html,body");
var looseTags = createMapFromString("head,colgroup,caption");
var trailingTags = createMapFromString("dt,thead");
var htmlTags = createMapFromString("a,abbr,acronym,address,applet,area,article,aside,audio,b,base,basefont,bdi,bdo,bgsound,big,blink,blockquote,body,br,button,canvas,caption,center,cite,code,col,colgroup,command,content,data,datalist,dd,del,details,dfn,dialog,dir,div,dl,dt,element,em,embed,fieldset,figcaption,figure,font,footer,form,frame,frameset,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,i,iframe,image,img,input,ins,isindex,kbd,keygen,label,legend,li,link,listing,main,map,mark,marquee,menu,menuitem,meta,meter,multicol,nav,nobr,noembed,noframes,noscript,object,ol,optgroup,option,output,p,param,picture,plaintext,pre,progress,q,rb,rp,rt,rtc,ruby,s,samp,script,section,select,shadow,small,source,spacer,span,strike,strong,style,sub,summary,sup,table,tbody,td,template,textarea,tfoot,th,thead,time,title,tr,track,tt,u,ul,var,video,wbr,xmp");
var reEmptyAttribute = new RegExp("^(?:class|id|style|title|lang|dir|on(?:focus|blur|change|click|dblclick|mouse(?:down|up|over|move|out)|key(?:press|down|up)))$");
var specialContentTags = createMapFromString("script,style");
var $minify = function(value, options) {
  var start = Date.now();
  options = processOptions(options || {});
  var result = minify2(value, options);
  options.log("minified in: " + (Date.now() - start) + "ms");
  return result;
};

// index.ts
var result = $minify('<p title="blah" id="moo">foo</p>', {
  removeAttributeQuotes: true
});
console.log(result);
